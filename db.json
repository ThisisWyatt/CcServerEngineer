{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/ocean/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/ocean/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/ocean/source/robots.txt","path":"robots.txt","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/404.styl","path":"css/404.styl","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/hexo-inverted.svg","path":"images/hexo-inverted.svg","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/hexo.svg","path":"images/hexo.svg","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/jquery.justifiedGallery.min.js","path":"js/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/ocean.js","path":"js/ocean.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/pace.min.js","path":"js/pace.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.ttf","path":"css/feathericon/feathericon.ttf","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff","path":"css/feathericon/feathericon.woff","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff2","path":"css/feathericon/feathericon.woff2","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/ocean/overlay-hero.png","path":"images/ocean/overlay-hero.png","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.eot","path":"css/feathericon/feathericon.eot","modified":0,"renderable":1},{"_id":"themes/ocean/source/css/feathericon/feathericon.svg","path":"css/feathericon/feathericon.svg","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/forrestgump.png","path":"images/forrestgump.png","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.ogv","path":"images/ocean/ocean.ogv","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.png","path":"images/ocean/ocean.png","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.webm","path":"images/ocean/ocean.webm","modified":0,"renderable":1},{"_id":"themes/ocean/source/images/ocean/ocean.mp4","path":"images/ocean/ocean.mp4","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"2704eb662b43793a54c9cedc7759272b546c0547","modified":1587471596000},{"_id":"themes/ocean/package.json","hash":"b993176f8c35bc3ab9dbd8642ec6cd125fcb447e","modified":1586998020000},{"_id":"themes/ocean/README.md","hash":"28876fb36a83896ba0d54923b2ef17c2f9f183bf","modified":1586998020000},{"_id":"themes/ocean/_config.yml","hash":"70666aff24c528d2df42ca2980023f60c1c06d33","modified":1606538308000},{"_id":"source/about/index.md","hash":"c87152b63c7a804fc652c2a99627cb9bb9c1a9b4","modified":1606551560000},{"_id":"source/categories/index.md","hash":"339c4dee2ce86b010f0c2fe8c8434b0c3ed05374","modified":1588081636000},{"_id":"source/links/index.md","hash":"85c201e3ec20723388508f4de71da24eb7669f90","modified":1588137070000},{"_id":"source/tags/index.md","hash":"e85eecd56b736cc1419e3e15b3a3d5d9f71bf0b1","modified":1588081708000},{"_id":"themes/ocean/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1586998020000},{"_id":"themes/ocean/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1586998020000},{"_id":"source/gallery/index.md","hash":"c7a04bd6825cdf9d65a946051c4414db6aff9b0e","modified":1606145096000},{"_id":"themes/ocean/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1586998020000},{"_id":"themes/ocean/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1586998020000},{"_id":"themes/ocean/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1586998020000},{"_id":"themes/ocean/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1586998020000},{"_id":"themes/ocean/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1586998020000},{"_id":"themes/ocean/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1586998020000},{"_id":"themes/ocean/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1586998020000},{"_id":"themes/ocean/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1586998020000},{"_id":"themes/ocean/languages/zh-CN.yml","hash":"bdca02bd364280f1432fbfebfd4066ee13911ffb","modified":1588004808000},{"_id":"themes/ocean/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1586998020000},{"_id":"themes/ocean/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1586998020000},{"_id":"themes/ocean/layout/categories.ejs","hash":"5c341e56c38f30e610ab25c9026b4a21fe1127c8","modified":1586998020000},{"_id":"themes/ocean/layout/index.ejs","hash":"f8dbff295abb2a87bec1fb5f5feec2e408743693","modified":1586998020000},{"_id":"themes/ocean/layout/layout.ejs","hash":"a35490e7b61e924728c71c9aa4dfeaff421ba442","modified":1586998020000},{"_id":"themes/ocean/layout/page.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1586998020000},{"_id":"themes/ocean/layout/post.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1586998020000},{"_id":"themes/ocean/layout/tags.ejs","hash":"88b34dd8d7b1e64fa27aa6ed72af996cf6700809","modified":1586998020000},{"_id":"themes/ocean/source/404.html","hash":"788929fab7b99dd74575399f41cddae6f63ce1f4","modified":1586998020000},{"_id":"themes/ocean/source/favicon.ico","hash":"5c23ec874326c54a688dd0110aac25ab1bfa4162","modified":1586998020000},{"_id":"themes/ocean/source/robots.txt","hash":"066f2545f69113adbdac1b2fbc5fab43e9ba571e","modified":1586998020000},{"_id":"source/_posts/Arithmetic/KMP算法.md","hash":"ed04e08a6898e092fe135ba6d3d8c183338cb613","modified":1615438626000},{"_id":"source/_posts/Arithmetic/LeetCode 169th.md","hash":"94bf836b17ef80bf29cbff065e26eb2aabfe7c48","modified":1594808728000},{"_id":"source/_posts/Arithmetic/LeetCode 13th.md","hash":"a224ea37799f15633b00cc11ea357f1ad35519db","modified":1594808658000},{"_id":"source/_posts/Arithmetic/LeetCode 191th.md","hash":"89a91b7e1cd9d5351a6fb0686e738d82abcab1e4","modified":1594909324000},{"_id":"source/_posts/Arithmetic/LeetCode 26th.md","hash":"6f5b0cfd28aa8740993488450636a43b0cf9d727","modified":1594808692000},{"_id":"source/_posts/Arithmetic/LeetCode 20th.md","hash":"4593b50786c54758df282e722521ce07440ad375","modified":1594809060000},{"_id":"source/_posts/Arithmetic/LeetCode 27th.md","hash":"4e52de80413e483864212430886bd3b9c74d0872","modified":1595309250000},{"_id":"source/_posts/Arithmetic/LeetCode 53th.md","hash":"3cb7bcf2017a6df162bda7192010a6578741a0a4","modified":1594808710000},{"_id":"source/_posts/Arithmetic/LeetCode LCP06.md","hash":"a6f9ad622e52013aeb6781f35a755cd756e19d9d","modified":1594808822000},{"_id":"source/_posts/Arithmetic/LeetCode i0104.md","hash":"657a3052d42c548212c995a4e396186ed5dd2dbd","modified":1594808822000},{"_id":"source/_posts/Arithmetic/leetCode i48th.md","hash":"9745ecb9ba594fab5e2ab86b63461be8eb52e476","modified":1594808774000},{"_id":"source/_posts/Arithmetic/二分法.md","hash":"3b9d76c442a7957f18d093163ece9418d0a5c346","modified":1607733712000},{"_id":"source/_posts/Arithmetic/排序算法.md","hash":"8dba3216e52ebcf1b666db2decc39ea947cfa489","modified":1597418476000},{"_id":"source/_posts/Arithmetic/斐波那契数列.md","hash":"f38d8f8db6b897df3daf99a6848bd1ef53a34b31","modified":1597815026000},{"_id":"source/_posts/Arithmetic/红黑树.md","hash":"a4c77069dccd5ea308a81b8aa9a88f872523afa8","modified":1596293556000},{"_id":"source/_posts/code/Hexo+Ocean添加版权说明.md","hash":"52af77cb6854b8445ce07b67973ba9f7c050f898","modified":1588262336000},{"_id":"source/_posts/code/Hexo+Ocean添加字数统计.md","hash":"0108814d02fa86f187e16bfb3b94e65c8566a2d4","modified":1588262338000},{"_id":"source/_posts/code/Bookmarks for contruct the blog.md","hash":"8ed104f9b1a22bcaadadd62d4a4ee3b4fa741cf2","modified":1601981584000},{"_id":"source/_posts/essays/2020年4月30日.md","hash":"b8d5dca464a1f88553d1c39c164476a442e50612","modified":1588265172000},{"_id":"source/_posts/img/2020年4月.md","hash":"002794131347cef2608036bef247ae24929f8f1e","modified":1588261364000},{"_id":"source/_posts/img/2019年7月.md","hash":"1eda94907d394e5c516c5705e3648167d355ad17","modified":1588261360000},{"_id":"source/_posts/img/Hello.md","hash":"ee972ae98f8ad45b35c71cae4d3540e0a6c420cb","modified":1590119650000},{"_id":"source/_posts/lyrics/我有我爱我.md","hash":"2861e6af2644d88c7fe9a7c1684f06332fce7b09","modified":1588571850000},{"_id":"source/_posts/linux/Linux命令.md","hash":"1cd033e5ac43db503147fddbc8a98db9c53beede","modified":1627021050000},{"_id":"source/_posts/lyrics/平凡之路.md","hash":"622d08101f5ae1b67a71012340b9e4a6c66863d8","modified":1588329508000},{"_id":"source/_posts/linux/安装jdk.md","hash":"e88ae0f4e57fce5f13a30d6e1993696eccf30e60","modified":1595322416000},{"_id":"source/_posts/tools/cmd命令.md","hash":"16c0618e7129a1d70485cd0204549e14b9617649","modified":1588262290000},{"_id":"source/_posts/test/hello-world.md","hash":"aae9c0f69018257bba9342dfecdbfbb81bee4bf2","modified":1588262314000},{"_id":"source/_posts/tools/Git.md","hash":"a8b7611a871c182947283c3915d5f7e3bb75908f","modified":1608036414000},{"_id":"source/_posts/tools/Linux文件转码.md","hash":"d72ab2a851b4792019d0f49191478048651e564f","modified":1595242896000},{"_id":"source/_posts/tools/docker.md","hash":"bca5a9a59c7ea9806c59cbde7a1570972531186d","modified":1627009268000},{"_id":"source/_posts/tools/git命令.md","hash":"92a6c9da2c2e7f518782f5def77f97e06494b4b3","modified":1606665294000},{"_id":"source/_posts/tools/markdown0.md","hash":"a9691d0059447f68958d2f8e7ff81b9caf9ba612","modified":1588781144000},{"_id":"source/_posts/tools/vim命令.md","hash":"b6e2a96967d2cc4cd15dd326498a7654edfec947","modified":1588262300000},{"_id":"themes/ocean/layout/_partial/archive-post.ejs","hash":"9be7173badcca6582c1136204adb3aa432aada21","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/after-footer.ejs","hash":"85c14ce312f58c9a95b2ad6520e4a40e3f0b6585","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/footer.ejs","hash":"83629aa6b4a63104343c3e629dc9dddfda3352fe","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/article.ejs","hash":"c5a7ab94a77f48cecf8632c02e991e1fbb3387d4","modified":1588071764000},{"_id":"themes/ocean/layout/_partial/archive.ejs","hash":"fff2863c4b7af02a0b2fe332df91f639fc11036b","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/copyright.ejs","hash":"9114d28bd067ba896167dd0803f9647215aad5a7","modified":1588140432000},{"_id":"themes/ocean/layout/_partial/head.ejs","hash":"498b4cf5e94c50576d9362effe8d581e63142a62","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/ocean.ejs","hash":"be76e0cbc4ecd9171972fabed6830cb592b5b343","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/totop.ejs","hash":"72b960315983ee95363fa9cabe82f52916ac9ae3","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/sidebar.ejs","hash":"900394255046c3430d27fd2db083f905bbcfe90f","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/word-count.ejs","hash":"ae8af3aebfddd176e1b0966aee5997e0ba16868a","modified":1587900224000},{"_id":"themes/ocean/source/css/404.styl","hash":"14b2fec2da86081f0545732552aa5f07b545c19a","modified":1586998020000},{"_id":"themes/ocean/source/css/_extend.styl","hash":"deb6aca91c40516f5d638008a72f9def42e5d081","modified":1586998020000},{"_id":"themes/ocean/source/css/_mixins.styl","hash":"6959409df2dd0a1ca05be0c0e9b2a884efdfb82d","modified":1586998020000},{"_id":"themes/ocean/source/css/_feathericon.styl","hash":"8494f0e869411781264868f08eda62fd838e0cee","modified":1586998020000},{"_id":"themes/ocean/source/css/_normalize.styl","hash":"b3337320133b7a336db7033aa6bbe94b054c0b21","modified":1586998020000},{"_id":"themes/ocean/screenshots/hexo-theme-ocean.jpg","hash":"13b5045d2120cac2f68849757f5e0af08938b7c6","modified":1586998020000},{"_id":"themes/ocean/source/css/_variables.styl","hash":"363ebb84bf08ccf01d71c715d3d19e91811908bd","modified":1607933714000},{"_id":"themes/ocean/source/css/style.styl","hash":"8c6e3a37b18ee23ba295067b9e89ff7e61bdf369","modified":1607688302000},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.css","hash":"2e6a66987dbc7a57bbfd2655bce166739b4ba426","modified":1586998020000},{"_id":"themes/ocean/source/images/hexo-inverted.svg","hash":"525309ea3c7360f83d1d9df6d04c256d7171950d","modified":1586998020000},{"_id":"themes/ocean/source/images/hexo.svg","hash":"71e7204d04ccfe260f06ea5873484791cd5f404a","modified":1586998020000},{"_id":"themes/ocean/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1586998020000},{"_id":"themes/ocean/source/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1586998020000},{"_id":"themes/ocean/source/js/jquery.justifiedGallery.min.js","hash":"73b9373cd80bdbf77e711818095f3f120a019547","modified":1586998020000},{"_id":"themes/ocean/source/js/ocean.js","hash":"acac20176cf22a84f889894d7482dc9207076f12","modified":1586998020000},{"_id":"themes/ocean/source/js/pace.min.js","hash":"d32ab818e0f97d3b0c80f5631fc23d8a0cb52795","modified":1586998020000},{"_id":"themes/ocean/source/js/search.js","hash":"3e66ea259eff66e36e240b695c4753c5d4454bbb","modified":1586998020000},{"_id":"themes/ocean/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1586998020000},{"_id":"themes/ocean/source/fancybox/jquery.fancybox.min.js","hash":"600c86071c2b5198cfa2c052dd90b78920f62b45","modified":1586998020000},{"_id":"themes/ocean/source/js/jquery-2.0.3.min.js","hash":"ab131f0b13a89f24543fadbf496b1c813d417c02","modified":1586998020000},{"_id":"source/_posts/code/DesignMode/代理模式.md","hash":"86ff0d36b1ac1ae2ead333c55a6186adcb27b217","modified":1602004358000},{"_id":"source/_posts/code/DesignMode/单例模式.md","hash":"4807cca6cddbb40aaa09605031dabbd0bcbb4c7e","modified":1602004358000},{"_id":"source/_posts/code/DesignMode/模板模式.md","hash":"5eded965d3ab3c8f58b287afbc1698b1ff66e8dc","modified":1602004358000},{"_id":"source/_posts/code/DesignMode/观察者模式.md","hash":"6676ce71e50831a2b8cc1aa6ced295bfe75d1347","modified":1602004358000},{"_id":"source/_posts/code/JVM/JVM学习笔记(一) ——Java虚拟机内存结构.md","hash":"30e33cada614aea868e9d5967627119bf3d9cc2d","modified":1595416296000},{"_id":"source/_posts/code/JVM/JVM学习笔记(三)——类加载机制.md","hash":"3c2e200e08199d1e286a65a7510162e923e2ccd5","modified":1595508496000},{"_id":"source/_posts/code/JVM/JVM学习笔记(五)——Java的各种锁.md","hash":"f89e49354b4c19ffbe6ce7a8f85bfb579fb6c8ed","modified":1595640850000},{"_id":"source/_posts/code/JVM/JVM学习笔记(二) ——垃圾收集器和内存分配策略.md","hash":"0b0e349fa8604c7c2ba53756b73a5a74c1386832","modified":1593668202000},{"_id":"source/_posts/code/JVM/JVM学习笔记——推荐文章.md","hash":"11bd4ffe348f632cf0bcb6f579b683e1bbfd9a09","modified":1594102746000},{"_id":"source/_posts/code/JVM/JVM学习笔记(四) ——Java内存模型和线程安全.md","hash":"42d6cbcb519406cb602a23fd988b1c253b3a33a5","modified":1595604856000},{"_id":"source/_posts/code/JavaSE/BigDecimal.md","hash":"fc45405214667d64ad920dd8b4d0514cb5514ca8","modified":1605854524000},{"_id":"source/_posts/code/JavaSE/JavaSE基础.md","hash":"d0ec94169ddebc9914b1d5f001c0a3c0a3824567","modified":1594079034000},{"_id":"source/_posts/code/JavaSE/JavaSE容器.md","hash":"d1a54a6d7765e68041a6be61dd4ea125f96ec9b6","modified":1589814320000},{"_id":"source/_posts/code/JavaSE/Java计算文件大小.md","hash":"d70eff0d45b67ca757888fbbd3f848fbdfbbf62f","modified":1589892124000},{"_id":"source/_posts/code/JavaSE/JavaSE线程.md","hash":"a84ec0ce95f71289456b6fd4041c9bc0d7ad8ecc","modified":1588335070000},{"_id":"source/_posts/code/JavaSE/Java逐行读取文件.md","hash":"88aa45f89f057f4203e96af2076a2be0ae26340a","modified":1589801204000},{"_id":"source/_posts/code/JavaSE/Overwriter HashCode().md","hash":"46f695e22918c0818969685aab182f5c8fa8d168","modified":1602004744000},{"_id":"source/_posts/code/JavaSE/数组复制.md","hash":"fd6f7aeea95470522c5c5ae689386b1110aa7b14","modified":1607232474000},{"_id":"source/_posts/code/JavaSE/java按位与、按位或、异或、移位、按位非.md","hash":"f5fe0cfecb19388509f6c0e5af56a5c3c205a6c2","modified":1594909488000},{"_id":"source/_posts/code/JavaWeb/JavaWeb异常汇总.md","hash":"392b28c7e0309acbcf19b104c9d300be933251c0","modified":1588525370000},{"_id":"source/_posts/code/JavaSE/时间日期.md","hash":"c3bfdb04fdfa0f92bf4e01f1b1baf7ef89e807aa","modified":1620027068000},{"_id":"source/_posts/code/JavaSE/类型转换.md","hash":"bad729b1d93f9decd02bdfe1e56d8c5facbe41e9","modified":1606539236000},{"_id":"source/_posts/code/JavaWeb/Java Web框架.md","hash":"c6b66d03909624833794a609f9bbc129142fd60b","modified":1601981506000},{"_id":"source/_posts/code/JavaWeb/Spring Data Jpa模糊查询.md","hash":"61cbf0b58acd47faece53a20d30725558a457ab2","modified":1590119968000},{"_id":"source/_posts/code/JavaWeb/Spring Data JPA分页查询.md","hash":"65f817c598314041c4e8cbe8ab1087b84a42ea0d","modified":1590119968000},{"_id":"source/_posts/code/JavaWeb/Spring Boot集成Druid.md","hash":"1a5fd3e7f20ef463dc94999e7f6839c7e5ec0332","modified":1590035712000},{"_id":"source/_posts/code/JavaWeb/Spring Data Jpa设置联合主键.md","hash":"9d1413c58eabdb7832ed1d7f12714e600da4545d","modified":1601981514000},{"_id":"source/_posts/code/JavaWeb/SpringBoot基础.md","hash":"10d848a55d48aef037a282bc87e877b19e2cb798","modified":1615601594000},{"_id":"source/_posts/code/JavaWeb/集成log4j2.md","hash":"b072d6d74dafdb9d86caef488d354204b77336a8","modified":1590036442000},{"_id":"source/_posts/code/Multi-Thread/【转载】BlockingQueue.md","hash":"5c5079cb0a9ffe1faf9788e881c87ab0d963bce9","modified":1606665272000},{"_id":"source/_posts/code/Multi-Thread/生产者消费者模型.md","hash":"222d827e1021912c4b9d6cf988e688175f27fc7b","modified":1606064880000},{"_id":"source/_posts/code/OS/死锁.md","hash":"744c566a127161ddb60da0f21dc5e02ca3a73695","modified":1594820338000},{"_id":"source/_posts/code/MySql/MySql必知必会.md","hash":"5f07ffbc3cb1a66b3882d27e7889baae4b468432","modified":1607528446000},{"_id":"source/_posts/code/OS/进程同步与通信.md","hash":"80d98086d60b98af912bb0fa1f707a224f46381c","modified":1608466378000},{"_id":"source/_posts/code/NetWork/网络.md","hash":"b9a97ef899d3ef5455558d6f45d62392be0e6b89","modified":1596293598000},{"_id":"themes/ocean/layout/_partial/post/busuanzi.ejs","hash":"88462d160479cc3f0cc58efcd888fbaf22b0d4d8","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/category.ejs","hash":"85f0ebeceee1c32623bfa1e4170dbe1e34442fea","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/albums.ejs","hash":"acb6d9628b7a2de4f32a84c6f652ac7207d14517","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/gallery.ejs","hash":"5f8487fe7bed9a09001c6655244ff35f583cf1eb","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/justifiedGallery.ejs","hash":"17ccb9fc394d11412619a153997bb87650799c6e","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/search.ejs","hash":"2c9d19d1685e834aa2020998da2a2d259ce9b9ff","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/title.ejs","hash":"53ccbfc6f1c424fb4dd609c1a61ffb69841403cc","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/gitalk.ejs","hash":"457b94c819c318ffb49395c24ee005c74d0728e1","modified":1588184044000},{"_id":"themes/ocean/layout/_partial/post/tocbot.ejs","hash":"9898b0dd9237e21908ba40292a8a9f947bed44d2","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/topping.ejs","hash":"bacd7e1d09397cfb32d97b5f3296f3ac538e57ea","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/valine.ejs","hash":"3eaf4c0a8655bb42cd53ee427c3d06a3f90c1de7","modified":1586998020000},{"_id":"themes/ocean/layout/_partial/post/nav.ejs","hash":"6c7d36e8fab671d0133661f70cc4ed5a143e34e5","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/albums.styl","hash":"0659d5f7469f24a415354ff767d949926465d515","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/apple.styl","hash":"e06dce604cc58ec39d677e4e59910c2725684901","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/articles.styl","hash":"7bf289013d304505984b251be725b49165a694fd","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/archive.styl","hash":"8aefdcf2d542ad839018c2c58511e3318a38490d","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/article.styl","hash":"f4965330c5f737cb6d9532c084f6e3a35d519287","modified":1587892298000},{"_id":"themes/ocean/source/css/_partial/categories.styl","hash":"f0c898823a5ddc37ae6bf76cc34ce8e50dd30885","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/float.styl","hash":"d888df89a172e4c8119cb8740fc1eae1a9539157","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/footer.styl","hash":"24779cbce1012d4f35ffc6b3ec0830cbc2ea3b3f","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/gallery.styl","hash":"7bdc2c9fb4971dbd7511c5cbb69bd611f20db591","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/gitalk.styl","hash":"3706eef2e0541493f1679a30241d279e29dfdc17","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/lists.styl","hash":"6fd213c53027d42164bfc9f0e3b4ea02317bfb89","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/mobile.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/highlight.styl","hash":"c6e99fd23056fb01177aeefbc5dd4a8e88cf8f81","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/layou.styl","hash":"6b42ae12fec53e6ab0eb8a4bdd15824267403101","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/justifiedGallery.styl","hash":"e7b5784ffd501f98216a717f876f2adb23fa5cd9","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/pace.styl","hash":"e326918ba276ee332d0598d8193ccd8353e7d916","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/navbar.styl","hash":"7079bf8cb3b1e36cbd92eeaff5f3944d91ac3831","modified":1588092372000},{"_id":"themes/ocean/source/css/_partial/sidebar.styl","hash":"600c70f1de82da5223af290d47a583f9c379d188","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/ocean.styl","hash":"69ba351909c73eb1e04510facc9b35dd584198e0","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/search.styl","hash":"011aaf21942dfff514ed4e98ce20142efbdd1b71","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/tag.styl","hash":"925af8beede44ab53fe3cd0a5c472d2baa03baec","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/totop.styl","hash":"4bae031b6852384666cdf36e98c6bbbba1281453","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/valine.styl","hash":"b980d02c0d1aad4866c8173c20f5e6b53026cbd5","modified":1586998020000},{"_id":"themes/ocean/source/css/_partial/tocbot.styl","hash":"da8560a8f9718d3afb9760956f9f8e4bb88b3dd8","modified":1586998020000},{"_id":"themes/ocean/source/css/feathericon/feathericon.ttf","hash":"d0d80c3c960d7d45e6bd7fa428d8a6a8c8245b2d","modified":1586998020000},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff","hash":"d22fe861e47afd92969ab46c7cbb7ea9c225aaf8","modified":1586998020000},{"_id":"themes/ocean/source/css/feathericon/feathericon.woff2","hash":"2c11c45331d914ee38ad42ccf966132a508b5596","modified":1586998020000},{"_id":"themes/ocean/source/images/ocean/overlay-hero.png","hash":"92481a1848c35be96a693af11f77265323a7c189","modified":1586998020000},{"_id":"themes/ocean/source/css/feathericon/feathericon.eot","hash":"e2a01ae6f849841bc7a9fd21e5b7b450f1ded19b","modified":1586998020000},{"_id":"themes/ocean/source/css/feathericon/feathericon.svg","hash":"c113006c6822451802c8457128c352c0e4934453","modified":1586998020000},{"_id":"themes/ocean/source/images/forrestgump.png","hash":"18ad6a8ba815878e36a0d5562136dc4fb8920c12","modified":1586998020000},{"_id":"themes/ocean/source/images/ocean/ocean.ogv","hash":"9c6b5d6b0544472cee39f5eafac2d5cbba5fd86b","modified":1586998020000},{"_id":"themes/ocean/source/images/ocean/ocean.png","hash":"8245d07f812625d19b48ad2d00f8191f2aa4d304","modified":1586998020000},{"_id":"themes/ocean/source/images/ocean/ocean.webm","hash":"65aa2b6483e0151611899e31571057334c60d9e4","modified":1586998020000},{"_id":"themes/ocean/source/images/ocean/ocean.mp4","hash":"1e89cac2d652005d9dafd3ecb4dd460a8ff6d6af","modified":1586998020000},{"_id":"public/content.json","hash":"7c127deed2653033a55a80364c6179f5d6fbf523","modified":1628558940493},{"_id":"public/search.xml","hash":"995bd85a036e51d588d6e07e4ecbeaff7db36edd","modified":1628558940493},{"_id":"public/about/index.html","hash":"1945112d7a692de1a18b7b147e983bb46b9457d2","modified":1628558940493},{"_id":"public/categories/index.html","hash":"11e952708843b9d9816ce35aed732e8c1bb7a384","modified":1628558940493},{"_id":"public/tags/index.html","hash":"8e4555b8be6a6ebaea8d13e30230a5b47bd48154","modified":1628558940493},{"_id":"public/links/index.html","hash":"f195240787dee8e4de22f8049119c9449ce96949","modified":1628558940493},{"_id":"public/gallery/index.html","hash":"8f2d7b458886afbc26dfbb2888f95bab0712b501","modified":1628558940493},{"_id":"public/posts/16107.html","hash":"e6cad7ca622df4635cd7ee0928f946723ba8d4b9","modified":1628558940493},{"_id":"public/posts/2be0aa3a.html","hash":"7fc6e9775962254cf587aa2fb031ee3c151ae244","modified":1628558940493},{"_id":"public/posts/a7181215.html","hash":"3f8dd433085a06ca6be7a1c7f53956bfc0d8ca61","modified":1628558940493},{"_id":"public/posts/93780083.html","hash":"38f4cf5142d895cf36572f7f65d0b2f3fa67ee3c","modified":1628558940493},{"_id":"public/posts/d7b571bb.html","hash":"3b7724c45f05f445e5ebb99d9ba0905d27ff1a39","modified":1628558940493},{"_id":"public/posts/f89cb603.html","hash":"27af9a29a2f8794318d2e9a79350631293f39717","modified":1628558940493},{"_id":"public/posts/cc713db.html","hash":"95929f9ee31ed95453215704a579fe06e29b05c9","modified":1628558940493},{"_id":"public/posts/649c2087.html","hash":"dd0b62871e332abb5952b14133b8fb0c490ee9fa","modified":1628558940493},{"_id":"public/posts/d93986a2.html","hash":"7e484010575fb3d871506e7abafdde9eae9f9ecb","modified":1628558940493},{"_id":"public/posts/885418c8.html","hash":"4b92a28796947e884eec5870a7d201a9a24e1f89","modified":1628558940493},{"_id":"public/posts/a7a4385e.html","hash":"7b2ff8ac5de73a1e858b8c665eee57b120b08277","modified":1628558940493},{"_id":"public/posts/6fbce6f0.html","hash":"a908b93e6bff77378b7091074f2a59c2fa6cc078","modified":1628558940493},{"_id":"public/posts/8f5fd259.html","hash":"ef246e69ce4fc3c4572db9c7c0adc00594119888","modified":1628558940493},{"_id":"public/posts/51267ed9.html","hash":"78315fc35b34b690f8af76efa1eb575c47177d38","modified":1628558940493},{"_id":"public/posts/3ad27f93.html","hash":"41d1491f6c17f2c5ed0375a56dcb7d7f2bde6327","modified":1628558940493},{"_id":"public/posts/2d8953d4.html","hash":"5a5b4e3089f6c1ce05885e98f29da32d9a0688f4","modified":1628558940493},{"_id":"public/posts/af03e16b.html","hash":"d7a8935006dd60ebb81b9ea03ddf96d511908015","modified":1628558940493},{"_id":"public/posts/f48fda8c.html","hash":"cfdd0ead7e8ac28e871d72bf83bda64d857dd20a","modified":1628558940493},{"_id":"public/posts/989dd112.html","hash":"dcba85a34efec1b3087c01e109ac7823f3f9f61e","modified":1628558940493},{"_id":"public/posts/b1de1f1.html","hash":"a3604ee9cf75236ab1035e538c2c31e0f73639ea","modified":1628558940493},{"_id":"public/posts/c22157c3.html","hash":"7b350c6db54095647c102815ec41030efbf6f2fc","modified":1628558940493},{"_id":"public/posts/7de3426c.html","hash":"d7eb99962e2ec8bd88d1304ae1b3c7bb3b7d03ea","modified":1628558940493},{"_id":"public/posts/8d229e40.html","hash":"2f996113fcfeb0a99b80d422c2ac1cdf1534de15","modified":1628558940493},{"_id":"public/posts/335a5d78.html","hash":"60b3180a8930bda4f44392eb0ba2eec4e2132359","modified":1628558940493},{"_id":"public/posts/93d31219.html","hash":"5826a3a78559ca1308c928d241c2423448d287a2","modified":1628558940493},{"_id":"public/posts/a7a49a19.html","hash":"c3ac4727c7e0105f2f25b38b97dade680e245aa6","modified":1628558940493},{"_id":"public/posts/f7d18982.html","hash":"88516dc09e486706b7b791717f8b1ab66e30e9db","modified":1628558940493},{"_id":"public/categories/Airthmetic/index.html","hash":"a4e39e2fd072d463afb91253c7ea99b65fdc7a9a","modified":1628558940493},{"_id":"public/categories/Airthmetic/page/2/index.html","hash":"e020b7640b4fe3377efed072d0988398573f013a","modified":1628558940493},{"_id":"public/categories/Construct-Blog/index.html","hash":"26a1ba4349e93fec53faa539dec7444f5f7bd691","modified":1628558940493},{"_id":"public/categories/essays/index.html","hash":"0adf603fc51ec97c88ae648c956db4b31462aa31","modified":1628558940493},{"_id":"public/categories/Lyrics/index.html","hash":"5e5bb7cb51f4698e5f2ff6191663b72ab1cf7b4f","modified":1628558940493},{"_id":"public/categories/Code/index.html","hash":"58586dbcafae6671a7b0367ed426d8d42dffa5ec","modified":1628558940493},{"_id":"public/categories/Code/page/2/index.html","hash":"ec993185d3700913921f555981013a367317595a","modified":1628558940493},{"_id":"public/categories/Code/page/3/index.html","hash":"af41d3be916b5296873474707b31713774013c58","modified":1628558940493},{"_id":"public/categories/Code/page/4/index.html","hash":"4f7c0a701fbeefffa4e1a9c6a7615eafec09fbd3","modified":1628558940493},{"_id":"public/categories/Linux/index.html","hash":"b9b1f4cb631e6017cc10f0257237ffae6e3b5dce","modified":1628558940493},{"_id":"public/categories/Tools/index.html","hash":"cac894459d6ae55b3fba3c482506c6a22ce555ec","modified":1628558940493},{"_id":"public/archives/index.html","hash":"d70a2ad4a7e38074f8c48dc6a7f583a07d1cbe05","modified":1628558940493},{"_id":"public/archives/page/2/index.html","hash":"161cf277ad29cbf7831908acdfaad09d4c6cbb35","modified":1628558940493},{"_id":"public/archives/page/3/index.html","hash":"23b466a8ac4bd54e07f4fcf39577dc076b78a8d7","modified":1628558940493},{"_id":"public/archives/page/4/index.html","hash":"8e04737c02348ec1dd1cb4df971336ad65768cfc","modified":1628558940493},{"_id":"public/archives/page/5/index.html","hash":"707c5cf9102050f1b8d5b187dc75d5c4668d5556","modified":1628558940493},{"_id":"public/archives/page/6/index.html","hash":"80424f837d6fae1f2f8a1a42114700bb54debf8b","modified":1628558940493},{"_id":"public/archives/page/7/index.html","hash":"9f1786bd8b81f930f324e7e350546348bc04243a","modified":1628558940493},{"_id":"public/archives/2020/index.html","hash":"7f05e2c89b7a9f667afefa1c58dbd18496db8044","modified":1628558940493},{"_id":"public/archives/2020/page/2/index.html","hash":"a3a6e651cb540ba38c5593bf75e2c142e7e6da8c","modified":1628558940493},{"_id":"public/archives/2020/page/3/index.html","hash":"bb2b2441944c979689cfe6c18db5e65b7c8aa1bf","modified":1628558940493},{"_id":"public/archives/2020/page/4/index.html","hash":"0a172a8d28300a03d1766c77a72ca048cbae299a","modified":1628558940493},{"_id":"public/archives/2020/04/index.html","hash":"1ecc4f669ba4cca36e41daab5af3abb12785d3cd","modified":1628558940493},{"_id":"public/archives/2020/05/index.html","hash":"d748282149774053ebc722842db7c71048237050","modified":1628558940493},{"_id":"public/archives/2020/05/page/2/index.html","hash":"29cf5224418d11d227a4b885ecf2ff35388d4c08","modified":1628558940493},{"_id":"public/archives/2020/06/index.html","hash":"6045dfea0f0e16883d4f88bff3a1f7afe7b144f2","modified":1628558940493},{"_id":"public/archives/2020/07/index.html","hash":"481e8783469b759d78395a61ce02ffab0befff65","modified":1628558940493},{"_id":"public/archives/2020/08/index.html","hash":"858f8413f84d6c084911ed273c54454c0e845356","modified":1628558940493},{"_id":"public/archives/2020/10/index.html","hash":"f25c0eba0bb73794ac953c16ba62ea5ddea34bb5","modified":1628558940493},{"_id":"public/archives/2020/11/index.html","hash":"2feb7f303f16ce3743a0db65f0e02df3d7411c1c","modified":1628558940493},{"_id":"public/archives/2020/12/index.html","hash":"a290edd63fd91afab0c3ce43ed8273d570ecdcb4","modified":1628558940493},{"_id":"public/archives/2021/index.html","hash":"6e2fece5d2b9e5669e411c7d8d573106846b7bbe","modified":1628558940493},{"_id":"public/archives/2021/page/2/index.html","hash":"b24b3dff6b18e38126832ad5d66bc4e173bd767c","modified":1628558940493},{"_id":"public/archives/2021/page/3/index.html","hash":"611d382d3994b8fddb2b5251df6dd3c212ab13d4","modified":1628558940493},{"_id":"public/archives/2021/03/index.html","hash":"52d4e479d3ae64d67e5748ab7f03d17611c693d8","modified":1628558940493},{"_id":"public/archives/2021/08/index.html","hash":"a678b1406b2c481f53b43984cfc1464a8877cd43","modified":1628558940493},{"_id":"public/archives/2021/08/page/2/index.html","hash":"1864c135525bde65ac907242ec08749f445fd4a8","modified":1628558940493},{"_id":"public/archives/2021/08/page/3/index.html","hash":"90249c0c23eb1caac29c91fe67911339779256a8","modified":1628558940493},{"_id":"public/tags/Array/index.html","hash":"44e9f9c7d424565c1eb16f6a08508d7931a7d854","modified":1628558940493},{"_id":"public/tags/String/index.html","hash":"5250331c713f023248a891815c40a8adfae9dcfe","modified":1628558940493},{"_id":"public/tags/数据结构/index.html","hash":"9336b4ce1e2e63430c9e8ae3eed2e35cdd05a18d","modified":1628558940493},{"_id":"public/tags/Linux/index.html","hash":"c396f6ba9c82e92cdd0cfbf417bf50d10ecc7721","modified":1628558940493},{"_id":"public/tags/环境配置/index.html","hash":"e640fd12d5cbc99913f5fbf5599ff91b961e52be","modified":1628558940493},{"_id":"public/tags/windows/index.html","hash":"15c97b51a26fcc1b748577067c31717b32d6274c","modified":1628558940493},{"_id":"public/tags/SCM/index.html","hash":"a0613f4730aa9b3ac29c46a5d9d4240bcfec04ad","modified":1628558940493},{"_id":"public/tags/Cloud/index.html","hash":"cd747d82505c3362b924ffc3fe6bfe577324c278","modified":1628558940493},{"_id":"public/tags/linux工具/index.html","hash":"cb8dbebb0c7acece1baf5b65d39d7c7ac0feb342","modified":1628558940493},{"_id":"public/tags/git/index.html","hash":"7728a177649c2821860e152161dec353a3a14de0","modified":1628558940493},{"_id":"public/tags/DesignMode/index.html","hash":"ae6d51340e565580462396a02e0810fdcb92b4b3","modified":1628558940493},{"_id":"public/tags/JVM/index.html","hash":"450062351c8bdf14fccc9bf1ec7ecf035133c4e4","modified":1628558940493},{"_id":"public/tags/工具类/index.html","hash":"b074b89772d5471dd8941852ac93b0f912327992","modified":1628558940493},{"_id":"public/tags/JavaSE/index.html","hash":"4fc169bd2b9077ae6284b50637b77b5c91d15d84","modified":1628558940493},{"_id":"public/tags/JavaWeb-Exception/index.html","hash":"02f6f9e1d0b7abed8a2cb7fd7235391fcae15e01","modified":1628558940493},{"_id":"public/tags/JavaWeb/index.html","hash":"f1f9748996df4359e1cf9729c4ad48548886e9d0","modified":1628558940493},{"_id":"public/tags/ORM/index.html","hash":"b3dc4cba47f523b0aac5496879b3f5bc08219692","modified":1628558940493},{"_id":"public/tags/JPA/index.html","hash":"341843ed2268242f151b5b0854fd7e8b064ff2b2","modified":1628558940493},{"_id":"public/tags/Multi-Thread/index.html","hash":"b5a64737a8a344589dbccedf5fb34328ee092974","modified":1628558940493},{"_id":"public/tags/OS/index.html","hash":"df52a8efc8ab863eda611e5a61d41d367687896d","modified":1628558940493},{"_id":"public/tags/Mysql/index.html","hash":"4325c25663a563fbbf8ca640472ea5e4acc41245","modified":1628558940493},{"_id":"public/tags/NetWork/index.html","hash":"d543852e2a1503aa32f3a99fe139ccc5dcfe014f","modified":1628558940493},{"_id":"public/posts/57b3646e.html","hash":"ee69bf8274aa3af725220c9f1aefc2351c0ac7f0","modified":1628558940493},{"_id":"public/posts/181f0b61.html","hash":"83614052dd831084e54b802f43a81c179b22dcb3","modified":1628558940493},{"_id":"public/posts/25912.html","hash":"e7035f751c988517b7e55d6cac1387d5d0ee9c2f","modified":1628558940493},{"_id":"public/posts/b988190.html","hash":"df40a136c35a5ef89ac0ca3b9557cc7068a61f27","modified":1628558940493},{"_id":"public/posts/30225.html","hash":"e2e057b00f9bb84a6cb222e939d4fdc1b21be1d8","modified":1628558940493},{"_id":"public/posts/60908.html","hash":"c58210314f88134b02c157e1b25afe362cf06287","modified":1628558940493},{"_id":"public/posts/63423.html","hash":"8385a46bee7091c1492b85cd829e6195351816da","modified":1628558940493},{"_id":"public/posts/26565.html","hash":"061f3e5e5167e7717dcb28da1ea6551c22c09581","modified":1628558940493},{"_id":"public/posts/61237.html","hash":"a7541dba586ef68e6f25849e91c8b92c1711af3e","modified":1628558940493},{"_id":"public/posts/e2dceda6.html","hash":"03bb971d556803f8b762a1a1d6305c68bb5ea3aa","modified":1628558940493},{"_id":"public/posts/1e9266e0.html","hash":"861e1c8a663d78fe56f94631a7c4fa658f5915bd","modified":1628558940493},{"_id":"public/posts/3cb8c20c.html","hash":"ce726e0e3c1b8499c375312ad832d56d8198657a","modified":1628558940493},{"_id":"public/posts/8ce268b6.html","hash":"b26524475c2dc7b6591442aa2243844107847822","modified":1628558940493},{"_id":"public/posts/28c6af09.html","hash":"5ce9b1e2fb04a446497de3fd573288928f0ab92d","modified":1628558940493},{"_id":"public/posts/2da0528d.html","hash":"683f41a30aa994bff9b84237ce02d3a8b18c4bfd","modified":1628558940493},{"_id":"public/posts/341ecd43.html","hash":"3e18ebb5f56d3c4ca1b7208aeea1f8d12d85f502","modified":1628558940493},{"_id":"public/posts/f135954a.html","hash":"e73fe5fabe01f06fd6e63ff0ea4861fd8792e1ad","modified":1628558940493},{"_id":"public/posts/82734d8.html","hash":"e5e0e62f50facd4fff7f42d9abcf41f5c165842a","modified":1628558940493},{"_id":"public/posts/fe3b56f6.html","hash":"e99e992021e7fe20ae6257b07a958a665eace2df","modified":1628558940493},{"_id":"public/posts/161dcf21.html","hash":"3d0439dcc5996110e7ed64f6da4ead9619d3f7a9","modified":1628558940493},{"_id":"public/posts/8a529bb2.html","hash":"e6eddd2f383cc6ddb58d8e92f14568a1a4c859f9","modified":1628558940493},{"_id":"public/posts/64f4f5cc.html","hash":"ec21579461c8d7b57f9dfdcfcec9c7356f568996","modified":1628558940493},{"_id":"public/posts/907a70d0.html","hash":"a1c07bfd1cc42b864618278a3217107e351bf4c9","modified":1628558940493},{"_id":"public/posts/168b5985.html","hash":"9a14a05943023b02bcf0e35074191779ce465cd6","modified":1628558940493},{"_id":"public/posts/27b4eaba.html","hash":"a2f0e772fc451eefef9ac8b6a80bf110de38fa7a","modified":1628558940493},{"_id":"public/posts/eefe591f.html","hash":"8840328e33ed81620746dc611219ef4be9a6bdf7","modified":1628558940493},{"_id":"public/posts/86818cd5.html","hash":"940a9e13c09ee9dc817077e9b183aad80869ef2a","modified":1628558940493},{"_id":"public/posts/baafd636.html","hash":"c28dd7076db3ea92450693bd0abd1ebba263d0c7","modified":1628558940493},{"_id":"public/posts/1a4b62fe.html","hash":"d3731461a05a6b9acf4c6d4eace6503f351408b3","modified":1628558940493},{"_id":"public/posts/1e17e950.html","hash":"cff2f14eadff6e4ad6f6802fa927066cb8e3433a","modified":1628558940493},{"_id":"public/posts/1abadc07.html","hash":"9f4559d1bf6467ed0054a8bb5f76dbdad097290e","modified":1628558940493},{"_id":"public/posts/50daec4.html","hash":"672580eb45bc97df037a5f6adebc09bcd0fda076","modified":1628558940493},{"_id":"public/posts/6b344792.html","hash":"2f152fdc8ea5ee7b91a72c2ad0af1d1795ca8736","modified":1628558940493},{"_id":"public/posts/3570abc7.html","hash":"5468d09422ae8f412db00aa4a843ce17ad3c4b58","modified":1628558940493},{"_id":"public/posts/1862c94.html","hash":"6aba37b0a01387c71242076ab55b3cb295e64feb","modified":1628558940493},{"_id":"public/posts/1fd66a56.html","hash":"f00780a948acb034fe4426f33e2e0036f43006ac","modified":1628558940493},{"_id":"public/posts/5b0774c7.html","hash":"1aab2b394051ae5a38f725d92a0664e1084e6b45","modified":1628558940493},{"_id":"public/posts/e930d1ea.html","hash":"dbf6a67526bc2787ff4c3099f38da1f8c838c312","modified":1628558940493},{"_id":"public/posts/6ea65bec.html","hash":"a323da8623f61b85a12dd82277b5a463ae0d7945","modified":1628558940493},{"_id":"public/posts/dc174266.html","hash":"a4a8319b71682d566544d36af76e6d200cb4d11e","modified":1628558940493},{"_id":"public/index.html","hash":"f25fe78c4270944d6e5fa4f19b5efe76b27dd92d","modified":1628558940493},{"_id":"public/page/2/index.html","hash":"5a8d5fb8d52f25a1df2c1fe35152125d5e632604","modified":1628558940493},{"_id":"public/page/3/index.html","hash":"e617a9879a1ea9db060c5ed64cd4e25009946109","modified":1628558940493},{"_id":"public/page/4/index.html","hash":"f30da60b86a24297c9331a76bf3f4f05f4ee81e6","modified":1628558940493},{"_id":"public/page/5/index.html","hash":"d69a4edf2cbeef6c4c835ccc075d52c1ab52092e","modified":1628558940493},{"_id":"public/page/6/index.html","hash":"fff2de5d605e4f8186b189a586f3b232079f4a13","modified":1628558940493},{"_id":"public/page/7/index.html","hash":"636e0ad782009f67c7d4e8a001329a2341d24ed2","modified":1628558940493},{"_id":"public/page/8/index.html","hash":"b107524f1e54fbfa5986ed5e34cf045deab0c950","modified":1628558940493},{"_id":"public/page/9/index.html","hash":"2a0f92a8860b0d3093631a74d46cbdc135dc6d4b","modified":1628558940493},{"_id":"public/CNAME","hash":"2704eb662b43793a54c9cedc7759272b546c0547","modified":1628558940493},{"_id":"public/robots.txt","hash":"066f2545f69113adbdac1b2fbc5fab43e9ba571e","modified":1628558940493},{"_id":"public/favicon.ico","hash":"5c23ec874326c54a688dd0110aac25ab1bfa4162","modified":1628558940493},{"_id":"public/images/hexo-inverted.svg","hash":"525309ea3c7360f83d1d9df6d04c256d7171950d","modified":1628558940493},{"_id":"public/images/hexo.svg","hash":"71e7204d04ccfe260f06ea5873484791cd5f404a","modified":1628558940493},{"_id":"public/css/feathericon/feathericon.ttf","hash":"d0d80c3c960d7d45e6bd7fa428d8a6a8c8245b2d","modified":1628558940493},{"_id":"public/css/feathericon/feathericon.woff","hash":"d22fe861e47afd92969ab46c7cbb7ea9c225aaf8","modified":1628558940493},{"_id":"public/css/feathericon/feathericon.woff2","hash":"2c11c45331d914ee38ad42ccf966132a508b5596","modified":1628558940493},{"_id":"public/images/ocean/overlay-hero.png","hash":"92481a1848c35be96a693af11f77265323a7c189","modified":1628558940493},{"_id":"public/css/feathericon/feathericon.eot","hash":"e2a01ae6f849841bc7a9fd21e5b7b450f1ded19b","modified":1628558940493},{"_id":"public/css/prism-ghcolors.css","hash":"efa4a6e82e8063a811cdfd95f40ec78a387b79c1","modified":1628558940493},{"_id":"public/css/feathericon/feathericon.svg","hash":"c113006c6822451802c8457128c352c0e4934453","modified":1628558940493},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"2e6a66987dbc7a57bbfd2655bce166739b4ba426","modified":1628558940493},{"_id":"public/css/404.css","hash":"952f9d1b869886a2940768fb7d1fd891ccea29fa","modified":1628558940493},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1628558940493},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1628558940493},{"_id":"public/js/pace.min.js","hash":"d32ab818e0f97d3b0c80f5631fc23d8a0cb52795","modified":1628558940493},{"_id":"public/js/ocean.js","hash":"acac20176cf22a84f889894d7482dc9207076f12","modified":1628558940493},{"_id":"public/js/search.js","hash":"3e66ea259eff66e36e240b695c4753c5d4454bbb","modified":1628558940493},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1628558940493},{"_id":"public/404.html","hash":"68a4d7475513d70c0c101eb977358fbf96e5a6b1","modified":1628558940493},{"_id":"public/css/style.css","hash":"8ac8ae0ee33f51113e89e72b0d1604baa651b2d9","modified":1628558940493},{"_id":"public/js/jquery.justifiedGallery.min.js","hash":"73b9373cd80bdbf77e711818095f3f120a019547","modified":1628558940493},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"600c86071c2b5198cfa2c052dd90b78920f62b45","modified":1628558940493},{"_id":"public/js/jquery-2.0.3.min.js","hash":"ab131f0b13a89f24543fadbf496b1c813d417c02","modified":1628558940493},{"_id":"public/images/forrestgump.png","hash":"18ad6a8ba815878e36a0d5562136dc4fb8920c12","modified":1628558940493},{"_id":"public/images/ocean/ocean.ogv","hash":"9c6b5d6b0544472cee39f5eafac2d5cbba5fd86b","modified":1628558940493},{"_id":"public/images/ocean/ocean.png","hash":"8245d07f812625d19b48ad2d00f8191f2aa4d304","modified":1628558940493},{"_id":"public/images/ocean/ocean.webm","hash":"65aa2b6483e0151611899e31571057334c60d9e4","modified":1628558940493},{"_id":"public/images/ocean/ocean.mp4","hash":"1e89cac2d652005d9dafd3ecb4dd460a8ff6d6af","modified":1628558940493}],"Category":[{"name":"Airthmetic","_id":"cks5dy1el00070w7t6s8f4ez0"},{"name":"Construct Blog","_id":"cks5dy1ez001h0w7tagno0kuj"},{"name":"essays","_id":"cks5dy1f6001x0w7th3s41aoo"},{"name":"Lyrics","_id":"cks5dy1f800230w7tf2fq1qmv"},{"name":"Code","_id":"cks5dy1fb00280w7tgklvc4vu"},{"name":"Linux","_id":"cks5dy1fe002j0w7t8x4jahiu"},{"name":"Tools","_id":"cks5dy1fg002q0w7tgv7sdv1v"}],"Data":[],"Page":[{"title":"About","date":"2020-04-26T04:53:45.000Z","wordCount":false,"declare":false,"_content":"\n>因为你要做一朵花，才会觉得春天离开你；如果你是春天，就没有离开，就永远有花。\n\n\nEmail: cc7722@foxmail.com\nGitHub: <https://github.com/thisiswyatt> \n\n   \n\n\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n **2020年，依然相信现在的才是最好的。** \n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2020-04-26 12:53:45\nwordCount: false\ndeclare: false\n---\n\n>因为你要做一朵花，才会觉得春天离开你；如果你是春天，就没有离开，就永远有花。\n\n\nEmail: cc7722@foxmail.com\nGitHub: <https://github.com/thisiswyatt> \n\n   \n\n\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n **2020年，依然相信现在的才是最好的。** \n","updated":"2020-11-28T08:19:20.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cks5dy1dj00000w7thbuf6if3","content":"<blockquote>\n<p>因为你要做一朵花，才会觉得春天离开你；如果你是春天，就没有离开，就永远有花。</p>\n</blockquote>\n<p>Email: <a href=\"mailto:cc7722@foxmail.com\">cc7722@foxmail.com</a><br>GitHub: <a href=\"https://github.com/thisiswyatt\" target=\"_blank\" rel=\"noopener\">https://github.com/thisiswyatt</a> </p>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n<p> <strong>2020年，依然相信现在的才是最好的。</strong> </p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>因为你要做一朵花，才会觉得春天离开你；如果你是春天，就没有离开，就永远有花。</p>\n</blockquote>\n<p>Email: <a href=\"mailto:cc7722@foxmail.com\">cc7722@foxmail.com</a><br>GitHub: <a href=\"https://github.com/thisiswyatt\" target=\"_blank\" rel=\"noopener\">https://github.com/thisiswyatt</a> </p>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n<p> <strong>2020年，依然相信现在的才是最好的。</strong> </p>\n"},{"title":"categories","date":"2020-04-28T13:44:55.000Z","_content":"\n\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-04-28 21:44:55\n---\n\n\n","updated":"2020-04-28T13:47:16.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cks5dy1dm00010w7t3h1h1hwf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-04-28T13:48:27.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-04-28 21:48:27\n---\n","updated":"2020-04-28T13:48:28.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cks5dy1dn00020w7te42x9j1g","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"links","date":"2020-04-28T16:46:55.000Z","_content":"\n\n>➣ https://jinpen.top/\n","source":"links/index.md","raw":"---\ntitle: links\ndate: 2020-04-29 00:46:55\n---\n\n\n>➣ https://jinpen.top/\n","updated":"2020-04-29T05:11:10.000Z","path":"links/index.html","comments":1,"layout":"page","_id":"cks5dy1do00030w7tciwk7ipj","content":"<blockquote>\n<p>➣ <a href=\"https://jinpen.top/\" target=\"_blank\" rel=\"noopener\">https://jinpen.top/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>➣ <a href=\"https://jinpen.top/\" target=\"_blank\" rel=\"noopener\">https://jinpen.top/</a></p>\n</blockquote>\n"},{"title":"Gallery","albums":[["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20190704.jpg","2019年7月"],["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20190722.jpg","2019年7月"],["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20200429_103519.jpg","2019年6月"],["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20190709_213851.jpg","2019年7月"],["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20200429_015020.jpg","2020年4月"],["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200820.jpg","2020年8月"],["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20201016.jpg","2020年10月"],["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20201123.jpg","2020年11月"]],"abbrlink":"889641a6","date":"2020-04-27T13:44:55.000Z","_content":"","source":"gallery/index.md","raw":"---\ntitle: Gallery\nalbums: [\n        [\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20190704.jpg\",\"2019年7月\"],\n        [\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20190722.jpg\",\"2019年7月\"],\n        [\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20200429_103519.jpg\",\"2019年6月\"],\n        [\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20190709_213851.jpg\",\"2019年7月\"],\n        [\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20200429_015020.jpg\",\"2020年4月\"],\n        [\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200820.jpg\",\"2020年8月\"],\n        [\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20201016.jpg\",\"2020年10月\"],\n        [\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20201123.jpg\",\"2020年11月\"],\n        ]\nabbrlink: 889641a6\ndate: 2020-04-27 21:44:55\n---","updated":"2020-11-23T15:24:56.000Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"cks5dy1dp00040w7t2n06hh25","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"LeetCode 169th 多数元素","declare":true,"wordCount":true,"abbrlink":"a7a4385e","data":"2020-05-01T08:30:10.000Z","_content":"\n## 1.题目\n>寻找一个数组中出现次数最多的元素\n<!-- more -->\n## 2.解法\n\n### 2.1 思路\n\n    遍历数组并使用hashMap记录出现的次数\n\n### 2.1 code\n```java\npublic class multipleElement {\n\n\n    private static int Solution169(int[] a) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n\n        for (int m : a) {\n            map.put(m, map.getOrDefault(m, 0) + 1); //map.getOrDefault(a,b) 若map.get(a)存在则值为get(a)，否则为默认值b\n        }\n\n        int max = 0;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            System.out.println(entry.getValue());\n            if (max < entry.getValue())\n                max = entry.getValue();\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        int[] num = {3, 2, 3};\n        System.out.println(Solution169(num));\n    }\n}\n\n```","source":"_posts/Arithmetic/LeetCode 169th.md","raw":"---\ntitle: LeetCode 169th 多数元素\ncategories: Airthmetic\ntags: Array\ndeclare: true\nwordCount: true\nabbrlink: a7a4385e\ndata: 2020-05-01 16:30:10\n---\n\n## 1.题目\n>寻找一个数组中出现次数最多的元素\n<!-- more -->\n## 2.解法\n\n### 2.1 思路\n\n    遍历数组并使用hashMap记录出现的次数\n\n### 2.1 code\n```java\npublic class multipleElement {\n\n\n    private static int Solution169(int[] a) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n\n        for (int m : a) {\n            map.put(m, map.getOrDefault(m, 0) + 1); //map.getOrDefault(a,b) 若map.get(a)存在则值为get(a)，否则为默认值b\n        }\n\n        int max = 0;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            System.out.println(entry.getValue());\n            if (max < entry.getValue())\n                max = entry.getValue();\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        int[] num = {3, 2, 3};\n        System.out.println(Solution169(num));\n    }\n}\n\n```","slug":"Arithmetic/LeetCode 169th","published":1,"date":"2021-08-09T10:06:58.730Z","updated":"2020-07-15T10:25:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1eh00050w7t3sy37ehu","content":"<h2 id=\"1-题目\"><a href=\"#1-题目\" class=\"headerlink\" title=\"1.题目\"></a>1.题目</h2><blockquote>\n<p>寻找一个数组中出现次数最多的元素</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"2-解法\"><a href=\"#2-解法\" class=\"headerlink\" title=\"2.解法\"></a>2.解法</h2><h3 id=\"2-1-思路\"><a href=\"#2-1-思路\" class=\"headerlink\" title=\"2.1 思路\"></a>2.1 思路</h3><pre><code>遍历数组并使用hashMap记录出现的次数</code></pre><h3 id=\"2-1-code\"><a href=\"#2-1-code\" class=\"headerlink\" title=\"2.1 code\"></a>2.1 code</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">multipleElement</span> <span class=\"token punctuation\">{</span>\n\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">Solution169</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        HashMap<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> m <span class=\"token operator\">:</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">getOrDefault</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//map.getOrDefault(a,b) 若map.get(a)存在则值为get(a)，否则为默认值b</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> entry <span class=\"token operator\">:</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>max <span class=\"token operator\">&lt;</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                max <span class=\"token operator\">=</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> max<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> num <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">Solution169</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-题目\"><a href=\"#1-题目\" class=\"headerlink\" title=\"1.题目\"></a>1.题目</h2><blockquote>\n<p>寻找一个数组中出现次数最多的元素</p>\n</blockquote>","more":"<h2 id=\"2-解法\"><a href=\"#2-解法\" class=\"headerlink\" title=\"2.解法\"></a>2.解法</h2><h3 id=\"2-1-思路\"><a href=\"#2-1-思路\" class=\"headerlink\" title=\"2.1 思路\"></a>2.1 思路</h3><pre><code>遍历数组并使用hashMap记录出现的次数</code></pre><h3 id=\"2-1-code\"><a href=\"#2-1-code\" class=\"headerlink\" title=\"2.1 code\"></a>2.1 code</h3><pre><code class=\"java\">public class multipleElement {\n\n\n    private static int Solution169(int[] a) {\n        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n\n        for (int m : a) {\n            map.put(m, map.getOrDefault(m, 0) + 1); //map.getOrDefault(a,b) 若map.get(a)存在则值为get(a)，否则为默认值b\n        }\n\n        int max = 0;\n        for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {\n            System.out.println(entry.getValue());\n            if (max &lt; entry.getValue())\n                max = entry.getValue();\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        int[] num = {3, 2, 3};\n        System.out.println(Solution169(num));\n    }\n}\n</code></pre>"},{"title":"KMP算法","declare":true,"wordCount":true,"abbrlink":"2da0528d","data":"2020-07-21T05:35:10.000Z","_content":"\n![kmp算法思想.png](https://i.loli.net/2020/07/21/v6rbVX8UqOip12W.jpg)\n\n## 一、KMP算法简介\n当目标串txt与模式串pat进行匹配时，如果txt[i]遇到不匹配的pat[j]时，**不必像暴力匹配法那样每次只将pat后移一位，然后又从其第一位和txt[i+1]进行比较。**\n\n因为如果pat[0]~pat[j-1]有公共前后缀的话，那么txt[i]前的子串也必定存在一个公共前后缀\n\n那么，我们可以将pat右移，使得从  **pat的前缀匹配txt子串的前缀，pat的后缀匹配txt子串的后缀**  ，变为**pat的前缀匹配txt的后缀**，这样就不必每次都移动一位，然后重新开始匹配\n\n>上面提到的公共前后缀，**应该为最长公共前后缀**，因为公共前后缀越短，移动的越多，就有可能漏掉部分匹配，导致结果的出错。            \n> ababab的前缀为{'a','ab','aba','abab','ababa'}，后缀为{‘b’,'ab','bab','abab','babab'}（**不能是字符串本身**）       \n>它的最长公共字符串即为‘abab’.长度为4       \n\n<!-- more -->\n<br><br>\n***\n<br><br>\n\n## 二、PMT\nPMT即 partial match table(部分匹配表)，**当前子串（pat[0]~pat[j]）的最长公共前后缀**\n例如“ababab\"\n\nchar|a|b|a|b|a|b\n-|-|-|-|-|-|-\nindex|0|1|2|3|4|5\npmt|0|0|1|2|3|4\n\n```java\npublic static int[] getPMT(String s0) {\n        char[] s = s0.toCharArray();\n        int[] pmt = new int[s.length];\n\n        for (int flag = 0, i = 1; i < s.length; ) {\n            if (s[flag] != s[i] && flag == 0) { //如果s[i]和字符串的第一个不相同\n                pmt[i] = 0;\n                i++;\n            } else if (s[flag] == s[i]) {   //如果s[i]相匹配，pmt[i]为其pmt[j]+1 （j<i）\n                pmt[i] = flag + 1;\n                i++;\n                flag++;\n            } else if (s[flag] != s[i] && flag != 0) { //如果不匹配且flag也不为0，则将最长公共前后缀缩小一个范围\n                flag = pmt[flag - 1];\n            }\n        }\n\n        return pmt;\n    }\n```\n<br><br>\n***\n<br><br>\n\n## 三、Next数组\n在当前字符pat[j]**之前的子串(pat[0]~pat[j-1])的最长公共前后缀**，那么我们可以将PMT数组整体右移一位且Next[0]设为-1即可得到。\n\n例如“ababab\"\n\nchar|a|b|a|b|a|b\n-|-|-|-|-|-|-\nindex|0|1|2|3|4|5\npmt|0|0|1|2|3|4\nnext|-1|0|0|1|2|3\n\n<br>\n\n### 3.1如何求next数组\n**递归**得到   \n* 令next[0]=-1    \n\n* 如果**当前位置元素**s[i]的值与当前子串的最长公共前后缀（长度为K）的**下一个元素**s[k]相等，则最长公共前后缀长度加1，此时橙色长度+1（蓝色/绿色长度）作为**s[i+1]的next值**\n![kmp(s[i]==s[i]).png](https://i.loli.net/2020/07/21/4fhiX8OBC9WpFLQ.jpg)\n\n<br>\n\n* 如果不相等，则next值势必会缩小，由于长度为k的前缀、后缀（橙色部分）元素相同其相对位置也相同，那么**他们各自的最长公共前后缀（朱红色）也势必相同**。\n\n* 如此，那么如果s[i]与 **k缩小后的k\\`的下一个元素s[k`]** 相等，那么**m(s[i])就可以和n连起来**了成为最长公共前后缀。\n\n* 所以依次缩小k的范围，直至匹配     \n\n* 如果遇到next[k]=-1,则表名已经到了最后一个元素，,则表示无公共前后缀,停止匹配,next值为0\n![kmp(s[i]!=s[i]).jpg](https://i.loli.net/2020/07/21/FLOnwUIMYouVhSz.jpg)\n\n    ```java\n    public static int[] getNext(String s0) {\n        char[] s = s0.toCharArray();\n        int[] next = new int[s.length];\n\n        // 初始条件\n        int i = 0;\n        int k = -1;\n        next[0] = -1;\n\n        // 根据已知的前i位推测第i+1位\n        while (i < s.length - 1)  // 0 ~ i-2，next[i-1]是推出来的\n        {\n            //如果k=-1,则表示无公共前后缀，next值为0（-1++）\n            //如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1\n            if (k == -1 || s[i] == s[k]) {\n                //k(之前的最长公共前后缀长度)+1 赋给 next[i+1] \n                //(因为s[i]和前面的在一起，作为s[i+1]的子串的长公共前后缀长度即next[i+1])\n                next[++i] = ++k; \n            } else //不能匹配上\n            {\n                k = next[k];    //将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀\n            }\n        }\n        return next;\n    }\n    ```\n\n<br><br>\n***\n<br><br>\n\n## 四、KMP算法\n\n**如果txt[i]和pat[j]不匹配，则将txt[i]与pat[next[j]]进行匹配**\n\n>设next[j]的长度为length,则pat[length]为最长公共前后缀的**下一个元素**         \n>之前的元素pat[0]~pat[length-1] (一共length个元素)依然和之前的txt的后缀相匹配。\n\n\n\n```java\npackage array;\n\n/**\n * Description\n * Author cloudr\n * Date 2020/7/20 23:13\n * Version 1.0\n **/\npublic class KMP {\n    public static void main(String[] args) {\n        String haystack = \"mississippi\";\n        String needle = \"issip\";\n        System.out.println(KMPByNext(haystack, needle));\n    }\n\n    public static int KMPByNext(String txt, String pat) {\n        if (pat.length() == 0) return 0;\n        int[] next = getNext(pat);\n        int i = 0, j = 0;\n        while (i < txt.length() && j < pat.length()) {\n            //next值为-1，txt右移动一位,pat移动整个长度（j++=0）\n            //如果匹配成功,继续将txt,pat的下一个元素进行匹配\n            if (j == -1 || txt.charAt(i) == pat.charAt(j)) {\n                i++;\n                j++;\n            } else //匹配失败则回溯\n                j = next[j];\n        }\n        if (j == pat.length())\n            return i - j;\n        else\n            return -1;\n    }\n\n    public static int[] getNext(String ps) {\n        char[] strKey = ps.toCharArray();\n        int[] next = new int[strKey.length];\n\n        // 初始条件\n        int i = 0;\n        int k = -1;\n        next[0] = -1;\n\n        // 根据已知的前i位推测第j+1位\n        while (i < strKey.length - 1)  // 0~ i-2 因为要整体右移一位且0位置为-1\n        {\n            //如果k=-1,则表示无公共前后缀，next值为0\n            //如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1\n            if (k == -1 || strKey[i] == strKey[k]) {\n                next[++i] = ++k;    //k(之前的最长公共前后缀)+1 赋给 next[i+1] (因为next数组整体右移动一位)\n            } else //不能匹配上\n            {\n                k = next[k];    //将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀\n            }\n        }\n        return next;\n    }\n}\n\n```\n\n\n<br> \n\n*** \n\n<br>\n\n### 改进next数组\n有txt=\"aaaabcdef\"，pat=\"aaaaax\"\n\n![next数组改进.jpg](https://i.loli.net/2020/07/21/KRioSTgelI64J3c.jpg)\n\ns[i]和p[j]已经匹配失败，下一步会与p[ next[j] ]相匹配，但是如果p[j] == p[ next[j] ],那么后面s[i]和p[ next[j] ]的匹配**也必然会失败**，所以我们**将p[ next[j] ]之前的子串的最长公共前后缀** next[ next[j] ]赋值给next[j]\n```java\npublic static int[] getNext(String s0) {\n    char[] strKey = ps.toCharArray();\n    int[] next = new int[strKey.length];\n\n    // 初始条件\n    int i = 0;\n    int k = -1;\n    next[0] = -1;\n\n    // 根据已知的前i位推测第j+1位\n    while (i < strKey.length - 1)  // 0~ i-2 因为要整体右移一位且0位置为-1\n    {\n        //如果k=-1,则表示无公共前后缀，next值为0\n        //如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1\n        if (k == -1 || strKey[i] == strKey[k]) {\n            i++;    //赋给 next[i+1] (因为next数组整体右移动一位)\n            k++;    //k(之前的最长公共前后缀)+1\n            if (strKey[i] != strKey[k]) {\n                next[i] = k;\n            }\n            else {  //不能出现p[j] = p[ next[j] ]的情况，如果出现，则将next[j]的范围缩小\n                next[i] = next[k];      //  长度为k的pat[0]~pat[k-1]缩小一个范围 长度即为next[k]  k=next[i] , 则next[i] = next[k] = next [ next[i] ]\n            }\n        } else //不能匹配上\n        {\n            k = next[k];    //将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀\n        }\n\n    }\n    return next;\n}\n```\n\n<br> \n\n<br>\n\n\n\n\n~~基于PMT数组(未成功，对于某些子串符匹配会陷入死循环，待填坑)~~\n>String haystack = \"mississippi\";       \n>String needle = \"issip\";       \n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n       if (needle.length() == 0) return 0;\n        int[] pmt = getPMT(needle);\n        int i = 0, j = 0;\n        while (i < haystack.length() && j < needle.length()) {\n            if (j == 0 && haystack.charAt(i) != needle.charAt(j)) {\n                i++;\n                if (i == haystack.length())\n                    break;\n            }\n\n            if (haystack.charAt(i) == needle.charAt(j)) {\n\n                i++;\n                j++;\n            } else\n                j = j - pmt[j];\n        }\n        if (j == needle.length())\n            return i - j;\n        else\n            return -1;\n    }\n}\n```\n\n<br><br>\n***\n<br><br>\n\n\n**推荐阅读**     \n* [字符串匹配的KMP算法-阮一峰](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\n\n* [如何更好地理解和掌握 KMP 算法?——海纳的回答](https://www.zhihu.com/question/21923021)\n\n* [KMP算法 Next数组详解(【洛谷3375】KMP字符串匹配 )](https://blog.csdn.net/qq_30974369/article/details/74276186)\n\n* [KMP算法的优化与详解](https://www.cnblogs.com/cherryljr/p/6519748.html)\n\n<br><br>\n\n\n**参考**     \n[1]https://blog.csdn.net/qq_30974369/article/details/74276186\n[2]https://www.cnblogs.com/cherryljr/p/6519748.html\n\n\n\n<!-- shide -->","source":"_posts/Arithmetic/KMP算法.md","raw":"---\ntitle: KMP算法\ncategories: Airthmetic\ntags: Array\ndeclare: true\nwordCount: true\nabbrlink: 2da0528d\ndata: 2020-07-21 13:35:10\n---\n\n![kmp算法思想.png](https://i.loli.net/2020/07/21/v6rbVX8UqOip12W.jpg)\n\n## 一、KMP算法简介\n当目标串txt与模式串pat进行匹配时，如果txt[i]遇到不匹配的pat[j]时，**不必像暴力匹配法那样每次只将pat后移一位，然后又从其第一位和txt[i+1]进行比较。**\n\n因为如果pat[0]~pat[j-1]有公共前后缀的话，那么txt[i]前的子串也必定存在一个公共前后缀\n\n那么，我们可以将pat右移，使得从  **pat的前缀匹配txt子串的前缀，pat的后缀匹配txt子串的后缀**  ，变为**pat的前缀匹配txt的后缀**，这样就不必每次都移动一位，然后重新开始匹配\n\n>上面提到的公共前后缀，**应该为最长公共前后缀**，因为公共前后缀越短，移动的越多，就有可能漏掉部分匹配，导致结果的出错。            \n> ababab的前缀为{'a','ab','aba','abab','ababa'}，后缀为{‘b’,'ab','bab','abab','babab'}（**不能是字符串本身**）       \n>它的最长公共字符串即为‘abab’.长度为4       \n\n<!-- more -->\n<br><br>\n***\n<br><br>\n\n## 二、PMT\nPMT即 partial match table(部分匹配表)，**当前子串（pat[0]~pat[j]）的最长公共前后缀**\n例如“ababab\"\n\nchar|a|b|a|b|a|b\n-|-|-|-|-|-|-\nindex|0|1|2|3|4|5\npmt|0|0|1|2|3|4\n\n```java\npublic static int[] getPMT(String s0) {\n        char[] s = s0.toCharArray();\n        int[] pmt = new int[s.length];\n\n        for (int flag = 0, i = 1; i < s.length; ) {\n            if (s[flag] != s[i] && flag == 0) { //如果s[i]和字符串的第一个不相同\n                pmt[i] = 0;\n                i++;\n            } else if (s[flag] == s[i]) {   //如果s[i]相匹配，pmt[i]为其pmt[j]+1 （j<i）\n                pmt[i] = flag + 1;\n                i++;\n                flag++;\n            } else if (s[flag] != s[i] && flag != 0) { //如果不匹配且flag也不为0，则将最长公共前后缀缩小一个范围\n                flag = pmt[flag - 1];\n            }\n        }\n\n        return pmt;\n    }\n```\n<br><br>\n***\n<br><br>\n\n## 三、Next数组\n在当前字符pat[j]**之前的子串(pat[0]~pat[j-1])的最长公共前后缀**，那么我们可以将PMT数组整体右移一位且Next[0]设为-1即可得到。\n\n例如“ababab\"\n\nchar|a|b|a|b|a|b\n-|-|-|-|-|-|-\nindex|0|1|2|3|4|5\npmt|0|0|1|2|3|4\nnext|-1|0|0|1|2|3\n\n<br>\n\n### 3.1如何求next数组\n**递归**得到   \n* 令next[0]=-1    \n\n* 如果**当前位置元素**s[i]的值与当前子串的最长公共前后缀（长度为K）的**下一个元素**s[k]相等，则最长公共前后缀长度加1，此时橙色长度+1（蓝色/绿色长度）作为**s[i+1]的next值**\n![kmp(s[i]==s[i]).png](https://i.loli.net/2020/07/21/4fhiX8OBC9WpFLQ.jpg)\n\n<br>\n\n* 如果不相等，则next值势必会缩小，由于长度为k的前缀、后缀（橙色部分）元素相同其相对位置也相同，那么**他们各自的最长公共前后缀（朱红色）也势必相同**。\n\n* 如此，那么如果s[i]与 **k缩小后的k\\`的下一个元素s[k`]** 相等，那么**m(s[i])就可以和n连起来**了成为最长公共前后缀。\n\n* 所以依次缩小k的范围，直至匹配     \n\n* 如果遇到next[k]=-1,则表名已经到了最后一个元素，,则表示无公共前后缀,停止匹配,next值为0\n![kmp(s[i]!=s[i]).jpg](https://i.loli.net/2020/07/21/FLOnwUIMYouVhSz.jpg)\n\n    ```java\n    public static int[] getNext(String s0) {\n        char[] s = s0.toCharArray();\n        int[] next = new int[s.length];\n\n        // 初始条件\n        int i = 0;\n        int k = -1;\n        next[0] = -1;\n\n        // 根据已知的前i位推测第i+1位\n        while (i < s.length - 1)  // 0 ~ i-2，next[i-1]是推出来的\n        {\n            //如果k=-1,则表示无公共前后缀，next值为0（-1++）\n            //如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1\n            if (k == -1 || s[i] == s[k]) {\n                //k(之前的最长公共前后缀长度)+1 赋给 next[i+1] \n                //(因为s[i]和前面的在一起，作为s[i+1]的子串的长公共前后缀长度即next[i+1])\n                next[++i] = ++k; \n            } else //不能匹配上\n            {\n                k = next[k];    //将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀\n            }\n        }\n        return next;\n    }\n    ```\n\n<br><br>\n***\n<br><br>\n\n## 四、KMP算法\n\n**如果txt[i]和pat[j]不匹配，则将txt[i]与pat[next[j]]进行匹配**\n\n>设next[j]的长度为length,则pat[length]为最长公共前后缀的**下一个元素**         \n>之前的元素pat[0]~pat[length-1] (一共length个元素)依然和之前的txt的后缀相匹配。\n\n\n\n```java\npackage array;\n\n/**\n * Description\n * Author cloudr\n * Date 2020/7/20 23:13\n * Version 1.0\n **/\npublic class KMP {\n    public static void main(String[] args) {\n        String haystack = \"mississippi\";\n        String needle = \"issip\";\n        System.out.println(KMPByNext(haystack, needle));\n    }\n\n    public static int KMPByNext(String txt, String pat) {\n        if (pat.length() == 0) return 0;\n        int[] next = getNext(pat);\n        int i = 0, j = 0;\n        while (i < txt.length() && j < pat.length()) {\n            //next值为-1，txt右移动一位,pat移动整个长度（j++=0）\n            //如果匹配成功,继续将txt,pat的下一个元素进行匹配\n            if (j == -1 || txt.charAt(i) == pat.charAt(j)) {\n                i++;\n                j++;\n            } else //匹配失败则回溯\n                j = next[j];\n        }\n        if (j == pat.length())\n            return i - j;\n        else\n            return -1;\n    }\n\n    public static int[] getNext(String ps) {\n        char[] strKey = ps.toCharArray();\n        int[] next = new int[strKey.length];\n\n        // 初始条件\n        int i = 0;\n        int k = -1;\n        next[0] = -1;\n\n        // 根据已知的前i位推测第j+1位\n        while (i < strKey.length - 1)  // 0~ i-2 因为要整体右移一位且0位置为-1\n        {\n            //如果k=-1,则表示无公共前后缀，next值为0\n            //如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1\n            if (k == -1 || strKey[i] == strKey[k]) {\n                next[++i] = ++k;    //k(之前的最长公共前后缀)+1 赋给 next[i+1] (因为next数组整体右移动一位)\n            } else //不能匹配上\n            {\n                k = next[k];    //将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀\n            }\n        }\n        return next;\n    }\n}\n\n```\n\n\n<br> \n\n*** \n\n<br>\n\n### 改进next数组\n有txt=\"aaaabcdef\"，pat=\"aaaaax\"\n\n![next数组改进.jpg](https://i.loli.net/2020/07/21/KRioSTgelI64J3c.jpg)\n\ns[i]和p[j]已经匹配失败，下一步会与p[ next[j] ]相匹配，但是如果p[j] == p[ next[j] ],那么后面s[i]和p[ next[j] ]的匹配**也必然会失败**，所以我们**将p[ next[j] ]之前的子串的最长公共前后缀** next[ next[j] ]赋值给next[j]\n```java\npublic static int[] getNext(String s0) {\n    char[] strKey = ps.toCharArray();\n    int[] next = new int[strKey.length];\n\n    // 初始条件\n    int i = 0;\n    int k = -1;\n    next[0] = -1;\n\n    // 根据已知的前i位推测第j+1位\n    while (i < strKey.length - 1)  // 0~ i-2 因为要整体右移一位且0位置为-1\n    {\n        //如果k=-1,则表示无公共前后缀，next值为0\n        //如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1\n        if (k == -1 || strKey[i] == strKey[k]) {\n            i++;    //赋给 next[i+1] (因为next数组整体右移动一位)\n            k++;    //k(之前的最长公共前后缀)+1\n            if (strKey[i] != strKey[k]) {\n                next[i] = k;\n            }\n            else {  //不能出现p[j] = p[ next[j] ]的情况，如果出现，则将next[j]的范围缩小\n                next[i] = next[k];      //  长度为k的pat[0]~pat[k-1]缩小一个范围 长度即为next[k]  k=next[i] , 则next[i] = next[k] = next [ next[i] ]\n            }\n        } else //不能匹配上\n        {\n            k = next[k];    //将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀\n        }\n\n    }\n    return next;\n}\n```\n\n<br> \n\n<br>\n\n\n\n\n~~基于PMT数组(未成功，对于某些子串符匹配会陷入死循环，待填坑)~~\n>String haystack = \"mississippi\";       \n>String needle = \"issip\";       \n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n       if (needle.length() == 0) return 0;\n        int[] pmt = getPMT(needle);\n        int i = 0, j = 0;\n        while (i < haystack.length() && j < needle.length()) {\n            if (j == 0 && haystack.charAt(i) != needle.charAt(j)) {\n                i++;\n                if (i == haystack.length())\n                    break;\n            }\n\n            if (haystack.charAt(i) == needle.charAt(j)) {\n\n                i++;\n                j++;\n            } else\n                j = j - pmt[j];\n        }\n        if (j == needle.length())\n            return i - j;\n        else\n            return -1;\n    }\n}\n```\n\n<br><br>\n***\n<br><br>\n\n\n**推荐阅读**     \n* [字符串匹配的KMP算法-阮一峰](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\n\n* [如何更好地理解和掌握 KMP 算法?——海纳的回答](https://www.zhihu.com/question/21923021)\n\n* [KMP算法 Next数组详解(【洛谷3375】KMP字符串匹配 )](https://blog.csdn.net/qq_30974369/article/details/74276186)\n\n* [KMP算法的优化与详解](https://www.cnblogs.com/cherryljr/p/6519748.html)\n\n<br><br>\n\n\n**参考**     \n[1]https://blog.csdn.net/qq_30974369/article/details/74276186\n[2]https://www.cnblogs.com/cherryljr/p/6519748.html\n\n\n\n<!-- shide -->","slug":"Arithmetic/KMP算法","published":1,"date":"2021-08-09T10:06:58.723Z","updated":"2021-03-11T04:57:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1ek00060w7tcvz72s45","content":"<p><img src=\"https://i.loli.net/2020/07/21/v6rbVX8UqOip12W.jpg\" alt=\"kmp算法思想.png\"></p>\n<h2 id=\"一、KMP算法简介\"><a href=\"#一、KMP算法简介\" class=\"headerlink\" title=\"一、KMP算法简介\"></a>一、KMP算法简介</h2><p>当目标串txt与模式串pat进行匹配时，如果txt[i]遇到不匹配的pat[j]时，<strong>不必像暴力匹配法那样每次只将pat后移一位，然后又从其第一位和txt[i+1]进行比较。</strong></p>\n<p>因为如果pat[0]~pat[j-1]有公共前后缀的话，那么txt[i]前的子串也必定存在一个公共前后缀</p>\n<p>那么，我们可以将pat右移，使得从  <strong>pat的前缀匹配txt子串的前缀，pat的后缀匹配txt子串的后缀</strong>  ，变为<strong>pat的前缀匹配txt的后缀</strong>，这样就不必每次都移动一位，然后重新开始匹配</p>\n<blockquote>\n<p>上面提到的公共前后缀，<strong>应该为最长公共前后缀</strong>，因为公共前后缀越短，移动的越多，就有可能漏掉部分匹配，导致结果的出错。<br>ababab的前缀为{‘a’,’ab’,’aba’,’abab’,’ababa’}，后缀为{‘b’,’ab’,’bab’,’abab’,’babab’}（<strong>不能是字符串本身</strong>）<br>它的最长公共字符串即为‘abab’.长度为4       </p>\n</blockquote>\n<a id=\"more\"></a>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"二、PMT\"><a href=\"#二、PMT\" class=\"headerlink\" title=\"二、PMT\"></a>二、PMT</h2><p>PMT即 partial match table(部分匹配表)，<strong>当前子串（pat[0]~pat[j]）的最长公共前后缀</strong><br>例如“ababab”</p>\n<table>\n<thead>\n<tr>\n<th>char</th>\n<th>a</th>\n<th>b</th>\n<th>a</th>\n<th>b</th>\n<th>a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>index</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>5</td>\n</tr>\n<tr>\n<td>pmt</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getPMT</span><span class=\"token punctuation\">(</span>String s0<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> s <span class=\"token operator\">=</span> s0<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> pmt <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>flag<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> flag <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//如果s[i]和字符串的第一个不相同</span>\n                pmt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>flag<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>   <span class=\"token comment\" spellcheck=\"true\">//如果s[i]相匹配，pmt[i]为其pmt[j]+1 （j&lt;i）</span>\n                pmt<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> flag <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                flag<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>flag<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> flag <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//如果不匹配且flag也不为0，则将最长公共前后缀缩小一个范围</span>\n                flag <span class=\"token operator\">=</span> pmt<span class=\"token punctuation\">[</span>flag <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> pmt<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"三、Next数组\"><a href=\"#三、Next数组\" class=\"headerlink\" title=\"三、Next数组\"></a>三、Next数组</h2><p>在当前字符pat[j]<strong>之前的子串(pat[0]~pat[j-1])的最长公共前后缀</strong>，那么我们可以将PMT数组整体右移一位且Next[0]设为-1即可得到。</p>\n<p>例如“ababab”</p>\n<table>\n<thead>\n<tr>\n<th>char</th>\n<th>a</th>\n<th>b</th>\n<th>a</th>\n<th>b</th>\n<th>a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>index</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>5</td>\n</tr>\n<tr>\n<td>pmt</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>next</td>\n<td>-1</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n</tr>\n</tbody></table>\n<br>\n\n<h3 id=\"3-1如何求next数组\"><a href=\"#3-1如何求next数组\" class=\"headerlink\" title=\"3.1如何求next数组\"></a>3.1如何求next数组</h3><p><strong>递归</strong>得到   </p>\n<ul>\n<li><p>令next[0]=-1    </p>\n</li>\n<li><p>如果<strong>当前位置元素</strong>s[i]的值与当前子串的最长公共前后缀（长度为K）的<strong>下一个元素</strong>s[k]相等，则最长公共前后缀长度加1，此时橙色长度+1（蓝色/绿色长度）作为<strong>s[i+1]的next值</strong><br><img src=\"https://i.loli.net/2020/07/21/4fhiX8OBC9WpFLQ.jpg\" alt=\"kmp(s[i]==s[i]).png\"></p>\n</li>\n</ul>\n<br>\n\n<ul>\n<li><p>如果不相等，则next值势必会缩小，由于长度为k的前缀、后缀（橙色部分）元素相同其相对位置也相同，那么<strong>他们各自的最长公共前后缀（朱红色）也势必相同</strong>。</p>\n</li>\n<li><p>如此，那么如果s[i]与 <strong>k缩小后的k`的下一个元素s[k`]</strong> 相等，那么<strong>m(s[i])就可以和n连起来</strong>了成为最长公共前后缀。</p>\n</li>\n<li><p>所以依次缩小k的范围，直至匹配     </p>\n</li>\n<li><p>如果遇到next[k]=-1,则表名已经到了最后一个元素，,则表示无公共前后缀,停止匹配,next值为0<br><img src=\"https://i.loli.net/2020/07/21/FLOnwUIMYouVhSz.jpg\" alt=\"kmp(s[i]!=s[i]).jpg\"></p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getNext</span><span class=\"token punctuation\">(</span>String s0<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> s <span class=\"token operator\">=</span> s0<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> next <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 初始条件</span>\n      <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      next<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 根据已知的前i位推测第i+1位</span>\n      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 0 ~ i-2，next[i-1]是推出来的</span>\n      <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">//如果k=-1,则表示无公共前后缀，next值为0（-1++）</span>\n          <span class=\"token comment\" spellcheck=\"true\">//如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">||</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> s<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">//k(之前的最长公共前后缀长度)+1 赋给 next[i+1] </span>\n              <span class=\"token comment\" spellcheck=\"true\">//(因为s[i]和前面的在一起，作为s[i+1]的子串的长公共前后缀长度即next[i+1])</span>\n              next<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>k<span class=\"token punctuation\">;</span> \n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token comment\" spellcheck=\"true\">//不能匹配上</span>\n          <span class=\"token punctuation\">{</span>\n              k <span class=\"token operator\">=</span> next<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> next<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"四、KMP算法\"><a href=\"#四、KMP算法\" class=\"headerlink\" title=\"四、KMP算法\"></a>四、KMP算法</h2><p><strong>如果txt[i]和pat[j]不匹配，则将txt[i]与pat[next[j]]进行匹配</strong></p>\n<blockquote>\n<p>设next[j]的长度为length,则pat[length]为最长公共前后缀的<strong>下一个元素</strong><br>之前的元素pat[0]~pat[length-1] (一共length个元素)依然和之前的txt的后缀相匹配。</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> array<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * Description\n * Author cloudr\n * Date 2020/7/20 23:13\n * Version 1.0\n **/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">KMP</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        String haystack <span class=\"token operator\">=</span> <span class=\"token string\">\"mississippi\"</span><span class=\"token punctuation\">;</span>\n        String needle <span class=\"token operator\">=</span> <span class=\"token string\">\"issip\"</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">KMPByNext</span><span class=\"token punctuation\">(</span>haystack<span class=\"token punctuation\">,</span> needle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">KMPByNext</span><span class=\"token punctuation\">(</span>String txt<span class=\"token punctuation\">,</span> String pat<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pat<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> next <span class=\"token operator\">=</span> <span class=\"token function\">getNext</span><span class=\"token punctuation\">(</span>pat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> txt<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">&lt;</span> pat<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//next值为-1，txt右移动一位,pat移动整个长度（j++=0）</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果匹配成功,继续将txt,pat的下一个元素进行匹配</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">||</span> txt<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> pat<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                j<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token comment\" spellcheck=\"true\">//匹配失败则回溯</span>\n                j <span class=\"token operator\">=</span> next<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">==</span> pat<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> i <span class=\"token operator\">-</span> j<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getNext</span><span class=\"token punctuation\">(</span>String ps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> strKey <span class=\"token operator\">=</span> ps<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> next <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>strKey<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 初始条件</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        next<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 根据已知的前i位推测第j+1位</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> strKey<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 0~ i-2 因为要整体右移一位且0位置为-1</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果k=-1,则表示无公共前后缀，next值为0</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">||</span> strKey<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> strKey<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                next<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>k<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//k(之前的最长公共前后缀)+1 赋给 next[i+1] (因为next数组整体右移动一位)</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token comment\" spellcheck=\"true\">//不能匹配上</span>\n            <span class=\"token punctuation\">{</span>\n                k <span class=\"token operator\">=</span> next<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<br> \n\n<hr>\n<br>\n\n<h3 id=\"改进next数组\"><a href=\"#改进next数组\" class=\"headerlink\" title=\"改进next数组\"></a>改进next数组</h3><p>有txt=”aaaabcdef”，pat=”aaaaax”</p>\n<p><img src=\"https://i.loli.net/2020/07/21/KRioSTgelI64J3c.jpg\" alt=\"next数组改进.jpg\"></p>\n<p>s[i]和p[j]已经匹配失败，下一步会与p[ next[j] ]相匹配，但是如果p[j] == p[ next[j] ],那么后面s[i]和p[ next[j] ]的匹配<strong>也必然会失败</strong>，所以我们<strong>将p[ next[j] ]之前的子串的最长公共前后缀</strong> next[ next[j] ]赋值给next[j]</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getNext</span><span class=\"token punctuation\">(</span>String s0<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> strKey <span class=\"token operator\">=</span> ps<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> next <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>strKey<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 初始条件</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    next<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 根据已知的前i位推测第j+1位</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> strKey<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 0~ i-2 因为要整体右移一位且0位置为-1</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果k=-1,则表示无公共前后缀，next值为0</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">||</span> strKey<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> strKey<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//赋给 next[i+1] (因为next数组整体右移动一位)</span>\n            k<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//k(之前的最长公共前后缀)+1</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>strKey<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> strKey<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                next<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> k<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">//不能出现p[j] = p[ next[j] ]的情况，如果出现，则将next[j]的范围缩小</span>\n                next<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> next<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\" spellcheck=\"true\">//  长度为k的pat[0]~pat[k-1]缩小一个范围 长度即为next[k]  k=next[i] , 则next[i] = next[k] = next [ next[i] ]</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token comment\" spellcheck=\"true\">//不能匹配上</span>\n        <span class=\"token punctuation\">{</span>\n            k <span class=\"token operator\">=</span> next<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<br> \n\n<br>\n\n\n\n\n<p><del>基于PMT数组(未成功，对于某些子串符匹配会陷入死循环，待填坑)</del></p>\n<blockquote>\n<p>String haystack = “mississippi”;<br>String needle = “issip”;       </p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">strStr</span><span class=\"token punctuation\">(</span>String haystack<span class=\"token punctuation\">,</span> String needle<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>needle<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> pmt <span class=\"token operator\">=</span> <span class=\"token function\">getPMT</span><span class=\"token punctuation\">(</span>needle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> haystack<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">&lt;</span> needle<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> haystack<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> needle<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> haystack<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>haystack<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> needle<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                j<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span>\n                j <span class=\"token operator\">=</span> j <span class=\"token operator\">-</span> pmt<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">==</span> needle<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> i <span class=\"token operator\">-</span> j<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<p><strong>推荐阅读</strong>     </p>\n<ul>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\" target=\"_blank\" rel=\"noopener\">字符串匹配的KMP算法-阮一峰</a></p>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/21923021\" target=\"_blank\" rel=\"noopener\">如何更好地理解和掌握 KMP 算法?——海纳的回答</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_30974369/article/details/74276186\" target=\"_blank\" rel=\"noopener\">KMP算法 Next数组详解(【洛谷3375】KMP字符串匹配 )</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/cherryljr/p/6519748.html\" target=\"_blank\" rel=\"noopener\">KMP算法的优化与详解</a></p>\n</li>\n</ul>\n<p><br><br></p>\n<p><strong>参考</strong><br>[1]<a href=\"https://blog.csdn.net/qq_30974369/article/details/74276186\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_30974369/article/details/74276186</a><br>[2]<a href=\"https://www.cnblogs.com/cherryljr/p/6519748.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/cherryljr/p/6519748.html</a></p>\n<!-- shide -->","site":{"data":{}},"excerpt":"<p><img src=\"https://i.loli.net/2020/07/21/v6rbVX8UqOip12W.jpg\" alt=\"kmp算法思想.png\"></p>\n<h2 id=\"一、KMP算法简介\"><a href=\"#一、KMP算法简介\" class=\"headerlink\" title=\"一、KMP算法简介\"></a>一、KMP算法简介</h2><p>当目标串txt与模式串pat进行匹配时，如果txt[i]遇到不匹配的pat[j]时，<strong>不必像暴力匹配法那样每次只将pat后移一位，然后又从其第一位和txt[i+1]进行比较。</strong></p>\n<p>因为如果pat[0]~pat[j-1]有公共前后缀的话，那么txt[i]前的子串也必定存在一个公共前后缀</p>\n<p>那么，我们可以将pat右移，使得从  <strong>pat的前缀匹配txt子串的前缀，pat的后缀匹配txt子串的后缀</strong>  ，变为<strong>pat的前缀匹配txt的后缀</strong>，这样就不必每次都移动一位，然后重新开始匹配</p>\n<blockquote>\n<p>上面提到的公共前后缀，<strong>应该为最长公共前后缀</strong>，因为公共前后缀越短，移动的越多，就有可能漏掉部分匹配，导致结果的出错。<br>ababab的前缀为{‘a’,’ab’,’aba’,’abab’,’ababa’}，后缀为{‘b’,’ab’,’bab’,’abab’,’babab’}（<strong>不能是字符串本身</strong>）<br>它的最长公共字符串即为‘abab’.长度为4       </p>\n</blockquote>","more":"<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"二、PMT\"><a href=\"#二、PMT\" class=\"headerlink\" title=\"二、PMT\"></a>二、PMT</h2><p>PMT即 partial match table(部分匹配表)，<strong>当前子串（pat[0]~pat[j]）的最长公共前后缀</strong><br>例如“ababab”</p>\n<table>\n<thead>\n<tr>\n<th>char</th>\n<th>a</th>\n<th>b</th>\n<th>a</th>\n<th>b</th>\n<th>a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>index</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>5</td>\n</tr>\n<tr>\n<td>pmt</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">public static int[] getPMT(String s0) {\n        char[] s = s0.toCharArray();\n        int[] pmt = new int[s.length];\n\n        for (int flag = 0, i = 1; i &lt; s.length; ) {\n            if (s[flag] != s[i] &amp;&amp; flag == 0) { //如果s[i]和字符串的第一个不相同\n                pmt[i] = 0;\n                i++;\n            } else if (s[flag] == s[i]) {   //如果s[i]相匹配，pmt[i]为其pmt[j]+1 （j&lt;i）\n                pmt[i] = flag + 1;\n                i++;\n                flag++;\n            } else if (s[flag] != s[i] &amp;&amp; flag != 0) { //如果不匹配且flag也不为0，则将最长公共前后缀缩小一个范围\n                flag = pmt[flag - 1];\n            }\n        }\n\n        return pmt;\n    }</code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"三、Next数组\"><a href=\"#三、Next数组\" class=\"headerlink\" title=\"三、Next数组\"></a>三、Next数组</h2><p>在当前字符pat[j]<strong>之前的子串(pat[0]~pat[j-1])的最长公共前后缀</strong>，那么我们可以将PMT数组整体右移一位且Next[0]设为-1即可得到。</p>\n<p>例如“ababab”</p>\n<table>\n<thead>\n<tr>\n<th>char</th>\n<th>a</th>\n<th>b</th>\n<th>a</th>\n<th>b</th>\n<th>a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>index</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>5</td>\n</tr>\n<tr>\n<td>pmt</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>next</td>\n<td>-1</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n</tr>\n</tbody></table>\n<br>\n\n<h3 id=\"3-1如何求next数组\"><a href=\"#3-1如何求next数组\" class=\"headerlink\" title=\"3.1如何求next数组\"></a>3.1如何求next数组</h3><p><strong>递归</strong>得到   </p>\n<ul>\n<li><p>令next[0]=-1    </p>\n</li>\n<li><p>如果<strong>当前位置元素</strong>s[i]的值与当前子串的最长公共前后缀（长度为K）的<strong>下一个元素</strong>s[k]相等，则最长公共前后缀长度加1，此时橙色长度+1（蓝色/绿色长度）作为<strong>s[i+1]的next值</strong><br><img src=\"https://i.loli.net/2020/07/21/4fhiX8OBC9WpFLQ.jpg\" alt=\"kmp(s[i]==s[i]).png\"></p>\n</li>\n</ul>\n<br>\n\n<ul>\n<li><p>如果不相等，则next值势必会缩小，由于长度为k的前缀、后缀（橙色部分）元素相同其相对位置也相同，那么<strong>他们各自的最长公共前后缀（朱红色）也势必相同</strong>。</p>\n</li>\n<li><p>如此，那么如果s[i]与 <strong>k缩小后的k`的下一个元素s[k`]</strong> 相等，那么<strong>m(s[i])就可以和n连起来</strong>了成为最长公共前后缀。</p>\n</li>\n<li><p>所以依次缩小k的范围，直至匹配     </p>\n</li>\n<li><p>如果遇到next[k]=-1,则表名已经到了最后一个元素，,则表示无公共前后缀,停止匹配,next值为0<br><img src=\"https://i.loli.net/2020/07/21/FLOnwUIMYouVhSz.jpg\" alt=\"kmp(s[i]!=s[i]).jpg\"></p>\n<pre><code class=\"java\">  public static int[] getNext(String s0) {\n      char[] s = s0.toCharArray();\n      int[] next = new int[s.length];\n\n      // 初始条件\n      int i = 0;\n      int k = -1;\n      next[0] = -1;\n\n      // 根据已知的前i位推测第i+1位\n      while (i &lt; s.length - 1)  // 0 ~ i-2，next[i-1]是推出来的\n      {\n          //如果k=-1,则表示无公共前后缀，next值为0（-1++）\n          //如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1\n          if (k == -1 || s[i] == s[k]) {\n              //k(之前的最长公共前后缀长度)+1 赋给 next[i+1] \n              //(因为s[i]和前面的在一起，作为s[i+1]的子串的长公共前后缀长度即next[i+1])\n              next[++i] = ++k; \n          } else //不能匹配上\n          {\n              k = next[k];    //将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀\n          }\n      }\n      return next;\n  }</code></pre>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"四、KMP算法\"><a href=\"#四、KMP算法\" class=\"headerlink\" title=\"四、KMP算法\"></a>四、KMP算法</h2><p><strong>如果txt[i]和pat[j]不匹配，则将txt[i]与pat[next[j]]进行匹配</strong></p>\n<blockquote>\n<p>设next[j]的长度为length,则pat[length]为最长公共前后缀的<strong>下一个元素</strong><br>之前的元素pat[0]~pat[length-1] (一共length个元素)依然和之前的txt的后缀相匹配。</p>\n</blockquote>\n<pre><code class=\"java\">package array;\n\n/**\n * Description\n * Author cloudr\n * Date 2020/7/20 23:13\n * Version 1.0\n **/\npublic class KMP {\n    public static void main(String[] args) {\n        String haystack = &quot;mississippi&quot;;\n        String needle = &quot;issip&quot;;\n        System.out.println(KMPByNext(haystack, needle));\n    }\n\n    public static int KMPByNext(String txt, String pat) {\n        if (pat.length() == 0) return 0;\n        int[] next = getNext(pat);\n        int i = 0, j = 0;\n        while (i &lt; txt.length() &amp;&amp; j &lt; pat.length()) {\n            //next值为-1，txt右移动一位,pat移动整个长度（j++=0）\n            //如果匹配成功,继续将txt,pat的下一个元素进行匹配\n            if (j == -1 || txt.charAt(i) == pat.charAt(j)) {\n                i++;\n                j++;\n            } else //匹配失败则回溯\n                j = next[j];\n        }\n        if (j == pat.length())\n            return i - j;\n        else\n            return -1;\n    }\n\n    public static int[] getNext(String ps) {\n        char[] strKey = ps.toCharArray();\n        int[] next = new int[strKey.length];\n\n        // 初始条件\n        int i = 0;\n        int k = -1;\n        next[0] = -1;\n\n        // 根据已知的前i位推测第j+1位\n        while (i &lt; strKey.length - 1)  // 0~ i-2 因为要整体右移一位且0位置为-1\n        {\n            //如果k=-1,则表示无公共前后缀，next值为0\n            //如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1\n            if (k == -1 || strKey[i] == strKey[k]) {\n                next[++i] = ++k;    //k(之前的最长公共前后缀)+1 赋给 next[i+1] (因为next数组整体右移动一位)\n            } else //不能匹配上\n            {\n                k = next[k];    //将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀\n            }\n        }\n        return next;\n    }\n}\n</code></pre>\n<br> \n\n<hr>\n<br>\n\n<h3 id=\"改进next数组\"><a href=\"#改进next数组\" class=\"headerlink\" title=\"改进next数组\"></a>改进next数组</h3><p>有txt=”aaaabcdef”，pat=”aaaaax”</p>\n<p><img src=\"https://i.loli.net/2020/07/21/KRioSTgelI64J3c.jpg\" alt=\"next数组改进.jpg\"></p>\n<p>s[i]和p[j]已经匹配失败，下一步会与p[ next[j] ]相匹配，但是如果p[j] == p[ next[j] ],那么后面s[i]和p[ next[j] ]的匹配<strong>也必然会失败</strong>，所以我们<strong>将p[ next[j] ]之前的子串的最长公共前后缀</strong> next[ next[j] ]赋值给next[j]</p>\n<pre><code class=\"java\">public static int[] getNext(String s0) {\n    char[] strKey = ps.toCharArray();\n    int[] next = new int[strKey.length];\n\n    // 初始条件\n    int i = 0;\n    int k = -1;\n    next[0] = -1;\n\n    // 根据已知的前i位推测第j+1位\n    while (i &lt; strKey.length - 1)  // 0~ i-2 因为要整体右移一位且0位置为-1\n    {\n        //如果k=-1,则表示无公共前后缀，next值为0\n        //如果当前值和前一位的最大公共前后缀的下一位相等  例：如果s[i]=s[0] 则首位相等，next值：0+1=1\n        if (k == -1 || strKey[i] == strKey[k]) {\n            i++;    //赋给 next[i+1] (因为next数组整体右移动一位)\n            k++;    //k(之前的最长公共前后缀)+1\n            if (strKey[i] != strKey[k]) {\n                next[i] = k;\n            }\n            else {  //不能出现p[j] = p[ next[j] ]的情况，如果出现，则将next[j]的范围缩小\n                next[i] = next[k];      //  长度为k的pat[0]~pat[k-1]缩小一个范围 长度即为next[k]  k=next[i] , 则next[i] = next[k] = next [ next[i] ]\n            }\n        } else //不能匹配上\n        {\n            k = next[k];    //将k由 （0~S）的最长前后缀 改为  （0~S）的最长前后缀的最长前后缀\n        }\n\n    }\n    return next;\n}</code></pre>\n<br> \n\n<br>\n\n\n\n\n<p><del>基于PMT数组(未成功，对于某些子串符匹配会陷入死循环，待填坑)</del></p>\n<blockquote>\n<p>String haystack = “mississippi”;<br>String needle = “issip”;       </p>\n</blockquote>\n<pre><code class=\"java\">class Solution {\n    public int strStr(String haystack, String needle) {\n       if (needle.length() == 0) return 0;\n        int[] pmt = getPMT(needle);\n        int i = 0, j = 0;\n        while (i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) {\n            if (j == 0 &amp;&amp; haystack.charAt(i) != needle.charAt(j)) {\n                i++;\n                if (i == haystack.length())\n                    break;\n            }\n\n            if (haystack.charAt(i) == needle.charAt(j)) {\n\n                i++;\n                j++;\n            } else\n                j = j - pmt[j];\n        }\n        if (j == needle.length())\n            return i - j;\n        else\n            return -1;\n    }\n}</code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<p><strong>推荐阅读</strong>     </p>\n<ul>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\" target=\"_blank\" rel=\"noopener\">字符串匹配的KMP算法-阮一峰</a></p>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/21923021\" target=\"_blank\" rel=\"noopener\">如何更好地理解和掌握 KMP 算法?——海纳的回答</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_30974369/article/details/74276186\" target=\"_blank\" rel=\"noopener\">KMP算法 Next数组详解(【洛谷3375】KMP字符串匹配 )</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/cherryljr/p/6519748.html\" target=\"_blank\" rel=\"noopener\">KMP算法的优化与详解</a></p>\n</li>\n</ul>\n<p><br><br></p>\n<p><strong>参考</strong><br>[1]<a href=\"https://blog.csdn.net/qq_30974369/article/details/74276186\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_30974369/article/details/74276186</a><br>[2]<a href=\"https://www.cnblogs.com/cherryljr/p/6519748.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/cherryljr/p/6519748.html</a></p>\n<!-- shide -->"},{"title":"LeetCode 13th 罗马数字转整型","declare":true,"wordCount":true,"abbrlink":"28c6af09","data":"2020-07-15T08:45:10.000Z","_content":"\n# 1.Subject\n>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II\n\n>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。       \n>同样地，>数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\n    1. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n    2. X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \n    3. C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n<!-- more -->\n\n>输入: \"LVIII\"     \n>输出: 58      \n>解释: L = 50, V= 5, III = 3.   \n\n# 2.Solution\n\n## 2.1 全部HashMap\n### 2.1.1 思路\n\n1. 把规则全部存储在HashMap中\n2. 首先判断是否符合两字符规则\n3. 再判断是否符合单字符规则\n\n### 2.1.2 Code\n```java\npublic class cc13 {\n    public static void main(String[] args) {\n        String s = \"MCMXCIV\";\n        System.out.println(Solution2(s));\n    }\n\n    public static int Solution1(String s) {\n        HashMap<String, Integer> map = new HashMap<>();\n        map.put(\"I\", 1);\n        map.put(\"V\", 5);\n        map.put(\"X\", 10);\n        map.put(\"L\", 50);\n        map.put(\"C\", 100);\n        map.put(\"D\", 500);\n        map.put(\"M\", 1000);\n        map.put(\"IV\", 4);\n        map.put(\"IX\", 9);\n        map.put(\"XL\", 40);\n        map.put(\"XC\", 90);\n        map.put(\"CD\", 400);\n        map.put(\"CM\", 900);\n\n        int i = 0, sum = 0;\n        for (i = 0; i < s.length(); ) {\n            if (i + 2 <= s.length() && map.containsKey(s.substring(i, i + 2))) { //substring左开右闭\n                String ss = s.substring(i, i + 2);\n                sum += map.get(ss);\n                i += 2;\n            } else {\n                String ss = s.substring(i, i + 1);\n                sum += map.get(ss);\n                i++;\n            }\n        }\n        return sum;\n    }\n}\n```\n\n## 2.2 部分HashMap\n\n### 2.2.1 思路\n1. 直将单字符规则存储于HashMap中\n2. 判断前一个字符是否小于当前字符对于数值（正常情况下，小数值对应字符在大数值对应字符右边）\n3. 如果是则减去2倍前一数值\n\n### 2.2.2 Code\n```java\npublic static int Solution2(String s) {\n        HashMap<String, Integer> map = new HashMap<>();\n        map.put(\"I\", 1);\n        map.put(\"V\", 5);\n        map.put(\"X\", 10);\n        map.put(\"L\", 50);\n        map.put(\"C\", 100);\n        map.put(\"D\", 500);\n        map.put(\"M\", 1000);\n\n        String[] arrays = s.split(\"\");\n        int sum = map.get(arrays[0]);\n        for (int i = 1; i < arrays.length; i++) {\n            sum += map.get(arrays[i]);\n            if (map.get(arrays[i]) > map.get(arrays[i - 1]))\n                sum = sum - 2 * map.get(arrays[i - 1]); //注意减去2倍 因为之前多加了一次\n        }\n\n        return sum;\n    }\n```\n\n","source":"_posts/Arithmetic/LeetCode 13th.md","raw":"---\ntitle: LeetCode 13th 罗马数字转整型\ncategories: Airthmetic\ntags: Array\ndeclare: true\nwordCount: true\nabbrlink: 28c6af09\ndata: 2020-07-15 16:45:10\n---\n\n# 1.Subject\n>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M\n```\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II\n\n>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。       \n>同样地，>数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\n    1. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n    2. X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \n    3. C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n<!-- more -->\n\n>输入: \"LVIII\"     \n>输出: 58      \n>解释: L = 50, V= 5, III = 3.   \n\n# 2.Solution\n\n## 2.1 全部HashMap\n### 2.1.1 思路\n\n1. 把规则全部存储在HashMap中\n2. 首先判断是否符合两字符规则\n3. 再判断是否符合单字符规则\n\n### 2.1.2 Code\n```java\npublic class cc13 {\n    public static void main(String[] args) {\n        String s = \"MCMXCIV\";\n        System.out.println(Solution2(s));\n    }\n\n    public static int Solution1(String s) {\n        HashMap<String, Integer> map = new HashMap<>();\n        map.put(\"I\", 1);\n        map.put(\"V\", 5);\n        map.put(\"X\", 10);\n        map.put(\"L\", 50);\n        map.put(\"C\", 100);\n        map.put(\"D\", 500);\n        map.put(\"M\", 1000);\n        map.put(\"IV\", 4);\n        map.put(\"IX\", 9);\n        map.put(\"XL\", 40);\n        map.put(\"XC\", 90);\n        map.put(\"CD\", 400);\n        map.put(\"CM\", 900);\n\n        int i = 0, sum = 0;\n        for (i = 0; i < s.length(); ) {\n            if (i + 2 <= s.length() && map.containsKey(s.substring(i, i + 2))) { //substring左开右闭\n                String ss = s.substring(i, i + 2);\n                sum += map.get(ss);\n                i += 2;\n            } else {\n                String ss = s.substring(i, i + 1);\n                sum += map.get(ss);\n                i++;\n            }\n        }\n        return sum;\n    }\n}\n```\n\n## 2.2 部分HashMap\n\n### 2.2.1 思路\n1. 直将单字符规则存储于HashMap中\n2. 判断前一个字符是否小于当前字符对于数值（正常情况下，小数值对应字符在大数值对应字符右边）\n3. 如果是则减去2倍前一数值\n\n### 2.2.2 Code\n```java\npublic static int Solution2(String s) {\n        HashMap<String, Integer> map = new HashMap<>();\n        map.put(\"I\", 1);\n        map.put(\"V\", 5);\n        map.put(\"X\", 10);\n        map.put(\"L\", 50);\n        map.put(\"C\", 100);\n        map.put(\"D\", 500);\n        map.put(\"M\", 1000);\n\n        String[] arrays = s.split(\"\");\n        int sum = map.get(arrays[0]);\n        for (int i = 1; i < arrays.length; i++) {\n            sum += map.get(arrays[i]);\n            if (map.get(arrays[i]) > map.get(arrays[i - 1]))\n                sum = sum - 2 * map.get(arrays[i - 1]); //注意减去2倍 因为之前多加了一次\n        }\n\n        return sum;\n    }\n```\n\n","slug":"Arithmetic/LeetCode 13th","published":1,"date":"2021-08-09T10:06:58.726Z","updated":"2020-07-15T10:24:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1em00090w7tbzb0damr","content":"<h1 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h1><blockquote>\n<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M</p>\n</blockquote>\n<pre><code>字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</code></pre><blockquote>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II</p>\n</blockquote>\n<blockquote>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。<br>同样地，&gt;数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n</blockquote>\n<pre><code>1. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n2. X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \n3. C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</code></pre><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.   </p>\n</blockquote>\n<h1 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2.Solution\"></a>2.Solution</h1><h2 id=\"2-1-全部HashMap\"><a href=\"#2-1-全部HashMap\" class=\"headerlink\" title=\"2.1 全部HashMap\"></a>2.1 全部HashMap</h2><h3 id=\"2-1-1-思路\"><a href=\"#2-1-1-思路\" class=\"headerlink\" title=\"2.1.1 思路\"></a>2.1.1 思路</h3><ol>\n<li>把规则全部存储在HashMap中</li>\n<li>首先判断是否符合两字符规则</li>\n<li>再判断是否符合单字符规则</li>\n</ol>\n<h3 id=\"2-1-2-Code\"><a href=\"#2-1-2-Code\" class=\"headerlink\" title=\"2.1.2 Code\"></a>2.1.2 Code</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">cc13</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        String s <span class=\"token operator\">=</span> <span class=\"token string\">\"MCMXCIV\"</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">Solution2</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">Solution1</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        HashMap<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"V\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"X\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"L\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"C\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"M\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"IV\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"IX\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"XL\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"XC\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">90</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CD\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">400</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CM\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">900</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">2</span> <span class=\"token operator\">&lt;=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//substring左开右闭</span>\n                String ss <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                sum <span class=\"token operator\">+=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>ss<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                i <span class=\"token operator\">+=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                String ss <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                sum <span class=\"token operator\">+=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>ss<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"2-2-部分HashMap\"><a href=\"#2-2-部分HashMap\" class=\"headerlink\" title=\"2.2 部分HashMap\"></a>2.2 部分HashMap</h2><h3 id=\"2-2-1-思路\"><a href=\"#2-2-1-思路\" class=\"headerlink\" title=\"2.2.1 思路\"></a>2.2.1 思路</h3><ol>\n<li>直将单字符规则存储于HashMap中</li>\n<li>判断前一个字符是否小于当前字符对于数值（正常情况下，小数值对应字符在大数值对应字符右边）</li>\n<li>如果是则减去2倍前一数值</li>\n</ol>\n<h3 id=\"2-2-2-Code\"><a href=\"#2-2-2-Code\" class=\"headerlink\" title=\"2.2.2 Code\"></a>2.2.2 Code</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">Solution2</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        HashMap<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"V\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"X\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"L\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"C\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"M\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arrays <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>arrays<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrays<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            sum <span class=\"token operator\">+=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>arrays<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>arrays<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>arrays<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                sum <span class=\"token operator\">=</span> sum <span class=\"token operator\">-</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>arrays<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//注意减去2倍 因为之前多加了一次</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h1><blockquote>\n<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M</p>\n</blockquote>\n<pre><code>字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</code></pre><blockquote>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II</p>\n</blockquote>\n<blockquote>\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。<br>同样地，&gt;数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n</blockquote>\n<pre><code>1. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\n2. X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \n3. C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</code></pre><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>","more":"<blockquote>\n<p>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.   </p>\n</blockquote>\n<h1 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2.Solution\"></a>2.Solution</h1><h2 id=\"2-1-全部HashMap\"><a href=\"#2-1-全部HashMap\" class=\"headerlink\" title=\"2.1 全部HashMap\"></a>2.1 全部HashMap</h2><h3 id=\"2-1-1-思路\"><a href=\"#2-1-1-思路\" class=\"headerlink\" title=\"2.1.1 思路\"></a>2.1.1 思路</h3><ol>\n<li>把规则全部存储在HashMap中</li>\n<li>首先判断是否符合两字符规则</li>\n<li>再判断是否符合单字符规则</li>\n</ol>\n<h3 id=\"2-1-2-Code\"><a href=\"#2-1-2-Code\" class=\"headerlink\" title=\"2.1.2 Code\"></a>2.1.2 Code</h3><pre><code class=\"java\">public class cc13 {\n    public static void main(String[] args) {\n        String s = &quot;MCMXCIV&quot;;\n        System.out.println(Solution2(s));\n    }\n\n    public static int Solution1(String s) {\n        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n        map.put(&quot;I&quot;, 1);\n        map.put(&quot;V&quot;, 5);\n        map.put(&quot;X&quot;, 10);\n        map.put(&quot;L&quot;, 50);\n        map.put(&quot;C&quot;, 100);\n        map.put(&quot;D&quot;, 500);\n        map.put(&quot;M&quot;, 1000);\n        map.put(&quot;IV&quot;, 4);\n        map.put(&quot;IX&quot;, 9);\n        map.put(&quot;XL&quot;, 40);\n        map.put(&quot;XC&quot;, 90);\n        map.put(&quot;CD&quot;, 400);\n        map.put(&quot;CM&quot;, 900);\n\n        int i = 0, sum = 0;\n        for (i = 0; i &lt; s.length(); ) {\n            if (i + 2 &lt;= s.length() &amp;&amp; map.containsKey(s.substring(i, i + 2))) { //substring左开右闭\n                String ss = s.substring(i, i + 2);\n                sum += map.get(ss);\n                i += 2;\n            } else {\n                String ss = s.substring(i, i + 1);\n                sum += map.get(ss);\n                i++;\n            }\n        }\n        return sum;\n    }\n}</code></pre>\n<h2 id=\"2-2-部分HashMap\"><a href=\"#2-2-部分HashMap\" class=\"headerlink\" title=\"2.2 部分HashMap\"></a>2.2 部分HashMap</h2><h3 id=\"2-2-1-思路\"><a href=\"#2-2-1-思路\" class=\"headerlink\" title=\"2.2.1 思路\"></a>2.2.1 思路</h3><ol>\n<li>直将单字符规则存储于HashMap中</li>\n<li>判断前一个字符是否小于当前字符对于数值（正常情况下，小数值对应字符在大数值对应字符右边）</li>\n<li>如果是则减去2倍前一数值</li>\n</ol>\n<h3 id=\"2-2-2-Code\"><a href=\"#2-2-2-Code\" class=\"headerlink\" title=\"2.2.2 Code\"></a>2.2.2 Code</h3><pre><code class=\"java\">public static int Solution2(String s) {\n        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n        map.put(&quot;I&quot;, 1);\n        map.put(&quot;V&quot;, 5);\n        map.put(&quot;X&quot;, 10);\n        map.put(&quot;L&quot;, 50);\n        map.put(&quot;C&quot;, 100);\n        map.put(&quot;D&quot;, 500);\n        map.put(&quot;M&quot;, 1000);\n\n        String[] arrays = s.split(&quot;&quot;);\n        int sum = map.get(arrays[0]);\n        for (int i = 1; i &lt; arrays.length; i++) {\n            sum += map.get(arrays[i]);\n            if (map.get(arrays[i]) &gt; map.get(arrays[i - 1]))\n                sum = sum - 2 * map.get(arrays[i - 1]); //注意减去2倍 因为之前多加了一次\n        }\n\n        return sum;\n    }</code></pre>"},{"title":"LeetCode 191th 汉明重量","declare":true,"wordCount":true,"abbrlink":"6fbce6f0","data":"2020-07-16T14:10:10.000Z","_content":"\n# 1.Subject\n编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 \n>输入：11111111111111111111111111111101     \n>输出：31     \n>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。     \n\n<!-- more -->\n\n# 2.Solution\n## 2.1 思路\n* 将数值的每一位与1(000...001)进行按位与\n    * 如果此位为1则按位与结果为1\n    * 如果此位为0则按位与结果为0\n\n## 2.2 Code\n```java\npublic class cc191 {\n    public static void main(String[] args) {\n        int n = 110;\n        System.out.println(Solution(n));\n    }\n\n    public static int Solution(int n) {\n        int count = 0;\n        while (n != 0) {\n            System.out.println(\"n=\" + n);\n            count += n & 1; //最后一位和000...0001进行按位与\n            n = n >>> 1;    //无符号数右移动1位\n        }\n        return count;\n    }\n}\n```\n\n<br><br><br>\n***\n<br><br><br>\n\n**参考**    \n[1]https://leetcode-cn.com/problems/number-of-1-bits/solution/javade-17chong-jie-fa-by-sdwwld/\n\n","source":"_posts/Arithmetic/LeetCode 191th.md","raw":"---\ntitle: LeetCode 191th 汉明重量\ncategories: Airthmetic\ntags: Array\ndeclare: true\nwordCount: true\nabbrlink: 6fbce6f0\ndata: 2020-07-16 22:10:10\n---\n\n# 1.Subject\n编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 \n>输入：11111111111111111111111111111101     \n>输出：31     \n>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。     \n\n<!-- more -->\n\n# 2.Solution\n## 2.1 思路\n* 将数值的每一位与1(000...001)进行按位与\n    * 如果此位为1则按位与结果为1\n    * 如果此位为0则按位与结果为0\n\n## 2.2 Code\n```java\npublic class cc191 {\n    public static void main(String[] args) {\n        int n = 110;\n        System.out.println(Solution(n));\n    }\n\n    public static int Solution(int n) {\n        int count = 0;\n        while (n != 0) {\n            System.out.println(\"n=\" + n);\n            count += n & 1; //最后一位和000...0001进行按位与\n            n = n >>> 1;    //无符号数右移动1位\n        }\n        return count;\n    }\n}\n```\n\n<br><br><br>\n***\n<br><br><br>\n\n**参考**    \n[1]https://leetcode-cn.com/problems/number-of-1-bits/solution/javade-17chong-jie-fa-by-sdwwld/\n\n","slug":"Arithmetic/LeetCode 191th","published":1,"date":"2021-08-09T10:06:58.732Z","updated":"2020-07-16T14:22:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1en000a0w7t4e17bcw1","content":"<h1 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h1><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 </p>\n<blockquote>\n<p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。     </p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h1 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2.Solution\"></a>2.Solution</h1><h2 id=\"2-1-思路\"><a href=\"#2-1-思路\" class=\"headerlink\" title=\"2.1 思路\"></a>2.1 思路</h2><ul>\n<li>将数值的每一位与1(000…001)进行按位与<ul>\n<li>如果此位为1则按位与结果为1</li>\n<li>如果此位为0则按位与结果为0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-2-Code\"><a href=\"#2-2-Code\" class=\"headerlink\" title=\"2.2 Code\"></a>2.2 Code</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">cc191</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">110</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">Solution</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">Solution</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"n=\"</span> <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            count <span class=\"token operator\">+=</span> n <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//最后一位和000...0001进行按位与</span>\n            n <span class=\"token operator\">=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//无符号数右移动1位</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<p><strong>参考</strong><br>[1]<a href=\"https://leetcode-cn.com/problems/number-of-1-bits/solution/javade-17chong-jie-fa-by-sdwwld/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/number-of-1-bits/solution/javade-17chong-jie-fa-by-sdwwld/</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h1><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 </p>\n<blockquote>\n<p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。     </p>\n</blockquote>","more":"<h1 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2.Solution\"></a>2.Solution</h1><h2 id=\"2-1-思路\"><a href=\"#2-1-思路\" class=\"headerlink\" title=\"2.1 思路\"></a>2.1 思路</h2><ul>\n<li>将数值的每一位与1(000…001)进行按位与<ul>\n<li>如果此位为1则按位与结果为1</li>\n<li>如果此位为0则按位与结果为0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-2-Code\"><a href=\"#2-2-Code\" class=\"headerlink\" title=\"2.2 Code\"></a>2.2 Code</h2><pre><code class=\"java\">public class cc191 {\n    public static void main(String[] args) {\n        int n = 110;\n        System.out.println(Solution(n));\n    }\n\n    public static int Solution(int n) {\n        int count = 0;\n        while (n != 0) {\n            System.out.println(&quot;n=&quot; + n);\n            count += n &amp; 1; //最后一位和000...0001进行按位与\n            n = n &gt;&gt;&gt; 1;    //无符号数右移动1位\n        }\n        return count;\n    }\n}</code></pre>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<p><strong>参考</strong><br>[1]<a href=\"https://leetcode-cn.com/problems/number-of-1-bits/solution/javade-17chong-jie-fa-by-sdwwld/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/number-of-1-bits/solution/javade-17chong-jie-fa-by-sdwwld/</a></p>"},{"title":"LeetCode 26th 删除排序数组中的重复项","declare":true,"wordCount":true,"abbrlink":"3cb8c20c","data":"2020-07-14T10:25:10.000Z","_content":"# 1.Subject\n>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。      \n>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n<!-- more -->\n\n>给定 nums = [0,0,1,1,1,2,2,3,3,4],    \n>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。   \n>你不需要考虑数组中超出新长度后面的元素。\n\n# 2.Solution\n\n## 2.1 利用HashMap记录元素出现次数\n\n### 2.1.1 思路\n    1. 首先判定是否第一次出现\n    2. 如果是，则此后的元素整体向前移动一个位置\n    3. 如果不是，继续向后遍历\n\n## 2.1.2 Code\n```java\n    public class cc26 {\n        public static void main(String[] args) {\n            int[] a = {1, 1, 2};\n            System.out.println(Solution3(a));\n        }\n\n        public static int Solution1(int[] nums) {\n            if (nums == null || nums.length == 0)\n                return 0;\n            Map<Integer, Integer> map = new HashMap<>();\n            int length = nums.length;   //遍历的范围会变化\n\n            for (int i = 0; i < length; i++) {\n                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n                if (map.get(nums[i]) != 1) {\n                    for (int j = i + 1; j < length; j++) {\n                        nums[j - 1] = nums[j];      //此后的元素整体向前移动一个位置\n                    }\n                    length--;   //遍历范围减小\n                    i--;        //下次判定还是从此位置开始，所以先减1，后面遍历会加1\n                }\n            }\n            return length;\n        }\n    }\n```\n\n## 2.2 双指针法\n\n### 2.2.1 思路\n    首先注意数组是有序的，那么重复的元素一定会相邻。\n\n    要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。\n\n    考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：\n\n    比较 p 和 q 位置的元素是否相等。\n        如果相等，q 后移 1 位\n        如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位\n    重复上述过程，直到 q 等于数组长度。\n\n    返回 p + 1，即为新数组长度。\n\n### 2.2.2 Code\n```java\n    public static int Solution2(int[] nums) {\n        if (nums == null || nums.length == 0)\n            return 0;\n        int p = 0, q = 1;\n        while (q < nums.length) {\n            if (nums[p] != nums[q]) {\n                nums[p + 1] = nums[q];\n                p++;\n            }\n            q++;\n        }\n        return p + 1;\n    }\n\n    //优化版\n    public static int Solution3(int[] nums) {\n        if (nums == null || nums.length == 0)\n            return 0;\n        int p = 0, q = 1;\n        while (q < nums.length) {\n            if (nums[p] != nums[q]) {\n                if (q - p > 1) {      //排除由于没有重复元素，p、q一直紧挨着，但也会一直进行不必要的赋值\n                    nums[p + 1] = nums[q];\n                }\n                p++;\n            }\n            q++;\n        }\n        return p + 1;\n    }\n```\n\n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n### 参考\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/\n","source":"_posts/Arithmetic/LeetCode 26th.md","raw":"---\ntitle: LeetCode 26th 删除排序数组中的重复项\ncategories: Airthmetic\ntags: Array\ndeclare: true\nwordCount: true\nabbrlink: 3cb8c20c\ndata: 2020-07-14 18:25:10\n---\n# 1.Subject\n>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。      \n>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n<!-- more -->\n\n>给定 nums = [0,0,1,1,1,2,2,3,3,4],    \n>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。   \n>你不需要考虑数组中超出新长度后面的元素。\n\n# 2.Solution\n\n## 2.1 利用HashMap记录元素出现次数\n\n### 2.1.1 思路\n    1. 首先判定是否第一次出现\n    2. 如果是，则此后的元素整体向前移动一个位置\n    3. 如果不是，继续向后遍历\n\n## 2.1.2 Code\n```java\n    public class cc26 {\n        public static void main(String[] args) {\n            int[] a = {1, 1, 2};\n            System.out.println(Solution3(a));\n        }\n\n        public static int Solution1(int[] nums) {\n            if (nums == null || nums.length == 0)\n                return 0;\n            Map<Integer, Integer> map = new HashMap<>();\n            int length = nums.length;   //遍历的范围会变化\n\n            for (int i = 0; i < length; i++) {\n                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n                if (map.get(nums[i]) != 1) {\n                    for (int j = i + 1; j < length; j++) {\n                        nums[j - 1] = nums[j];      //此后的元素整体向前移动一个位置\n                    }\n                    length--;   //遍历范围减小\n                    i--;        //下次判定还是从此位置开始，所以先减1，后面遍历会加1\n                }\n            }\n            return length;\n        }\n    }\n```\n\n## 2.2 双指针法\n\n### 2.2.1 思路\n    首先注意数组是有序的，那么重复的元素一定会相邻。\n\n    要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。\n\n    考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：\n\n    比较 p 和 q 位置的元素是否相等。\n        如果相等，q 后移 1 位\n        如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位\n    重复上述过程，直到 q 等于数组长度。\n\n    返回 p + 1，即为新数组长度。\n\n### 2.2.2 Code\n```java\n    public static int Solution2(int[] nums) {\n        if (nums == null || nums.length == 0)\n            return 0;\n        int p = 0, q = 1;\n        while (q < nums.length) {\n            if (nums[p] != nums[q]) {\n                nums[p + 1] = nums[q];\n                p++;\n            }\n            q++;\n        }\n        return p + 1;\n    }\n\n    //优化版\n    public static int Solution3(int[] nums) {\n        if (nums == null || nums.length == 0)\n            return 0;\n        int p = 0, q = 1;\n        while (q < nums.length) {\n            if (nums[p] != nums[q]) {\n                if (q - p > 1) {      //排除由于没有重复元素，p、q一直紧挨着，但也会一直进行不必要的赋值\n                    nums[p + 1] = nums[q];\n                }\n                p++;\n            }\n            q++;\n        }\n        return p + 1;\n    }\n```\n\n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n### 参考\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/\n","slug":"Arithmetic/LeetCode 26th","published":1,"date":"2021-08-09T10:06:58.736Z","updated":"2020-07-15T10:24:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1eo000b0w7t4epwh35g","content":"<h1 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h1><blockquote>\n<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<h1 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2.Solution\"></a>2.Solution</h1><h2 id=\"2-1-利用HashMap记录元素出现次数\"><a href=\"#2-1-利用HashMap记录元素出现次数\" class=\"headerlink\" title=\"2.1 利用HashMap记录元素出现次数\"></a>2.1 利用HashMap记录元素出现次数</h2><h3 id=\"2-1-1-思路\"><a href=\"#2-1-1-思路\" class=\"headerlink\" title=\"2.1.1 思路\"></a>2.1.1 思路</h3><pre><code>1. 首先判定是否第一次出现\n2. 如果是，则此后的元素整体向前移动一个位置\n3. 如果不是，继续向后遍历</code></pre><h2 id=\"2-1-2-Code\"><a href=\"#2-1-2-Code\" class=\"headerlink\" title=\"2.1.2 Code\"></a>2.1.2 Code</h2><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">cc26</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">Solution3</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">Solution1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//遍历的范围会变化</span>\n\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">getOrDefault</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        nums<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\" spellcheck=\"true\">//此后的元素整体向前移动一个位置</span>\n                    <span class=\"token punctuation\">}</span>\n                    length<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//遍历范围减小</span>\n                    i<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">//下次判定还是从此位置开始，所以先减1，后面遍历会加1</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> length<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"2-2-双指针法\"><a href=\"#2-2-双指针法\" class=\"headerlink\" title=\"2.2 双指针法\"></a>2.2 双指针法</h2><h3 id=\"2-2-1-思路\"><a href=\"#2-2-1-思路\" class=\"headerlink\" title=\"2.2.1 思路\"></a>2.2.1 思路</h3><pre><code>首先注意数组是有序的，那么重复的元素一定会相邻。\n\n要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。\n\n考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：\n\n比较 p 和 q 位置的元素是否相等。\n    如果相等，q 后移 1 位\n    如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位\n重复上述过程，直到 q 等于数组长度。\n\n返回 p + 1，即为新数组长度。</code></pre><h3 id=\"2-2-2-Code\"><a href=\"#2-2-2-Code\" class=\"headerlink\" title=\"2.2.2 Code\"></a>2.2.2 Code</h3><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">Solution2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> q <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> nums<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                nums<span class=\"token punctuation\">[</span>p <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                p<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            q<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> p <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//优化版</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">Solution3</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> q <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> nums<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">-</span> p <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>      <span class=\"token comment\" spellcheck=\"true\">//排除由于没有重复元素，p、q一直紧挨着，但也会一直进行不必要的赋值</span>\n                    nums<span class=\"token punctuation\">[</span>p <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                p<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            q<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> p <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<br>\n<br>\n\n<hr>\n<br>\n<br>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h1><blockquote>\n<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>\n</blockquote>","more":"<blockquote>\n<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<h1 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2.Solution\"></a>2.Solution</h1><h2 id=\"2-1-利用HashMap记录元素出现次数\"><a href=\"#2-1-利用HashMap记录元素出现次数\" class=\"headerlink\" title=\"2.1 利用HashMap记录元素出现次数\"></a>2.1 利用HashMap记录元素出现次数</h2><h3 id=\"2-1-1-思路\"><a href=\"#2-1-1-思路\" class=\"headerlink\" title=\"2.1.1 思路\"></a>2.1.1 思路</h3><pre><code>1. 首先判定是否第一次出现\n2. 如果是，则此后的元素整体向前移动一个位置\n3. 如果不是，继续向后遍历</code></pre><h2 id=\"2-1-2-Code\"><a href=\"#2-1-2-Code\" class=\"headerlink\" title=\"2.1.2 Code\"></a>2.1.2 Code</h2><pre><code class=\"java\">    public class cc26 {\n        public static void main(String[] args) {\n            int[] a = {1, 1, 2};\n            System.out.println(Solution3(a));\n        }\n\n        public static int Solution1(int[] nums) {\n            if (nums == null || nums.length == 0)\n                return 0;\n            Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n            int length = nums.length;   //遍历的范围会变化\n\n            for (int i = 0; i &lt; length; i++) {\n                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n                if (map.get(nums[i]) != 1) {\n                    for (int j = i + 1; j &lt; length; j++) {\n                        nums[j - 1] = nums[j];      //此后的元素整体向前移动一个位置\n                    }\n                    length--;   //遍历范围减小\n                    i--;        //下次判定还是从此位置开始，所以先减1，后面遍历会加1\n                }\n            }\n            return length;\n        }\n    }</code></pre>\n<h2 id=\"2-2-双指针法\"><a href=\"#2-2-双指针法\" class=\"headerlink\" title=\"2.2 双指针法\"></a>2.2 双指针法</h2><h3 id=\"2-2-1-思路\"><a href=\"#2-2-1-思路\" class=\"headerlink\" title=\"2.2.1 思路\"></a>2.2.1 思路</h3><pre><code>首先注意数组是有序的，那么重复的元素一定会相邻。\n\n要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。\n\n考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：\n\n比较 p 和 q 位置的元素是否相等。\n    如果相等，q 后移 1 位\n    如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位\n重复上述过程，直到 q 等于数组长度。\n\n返回 p + 1，即为新数组长度。</code></pre><h3 id=\"2-2-2-Code\"><a href=\"#2-2-2-Code\" class=\"headerlink\" title=\"2.2.2 Code\"></a>2.2.2 Code</h3><pre><code class=\"java\">    public static int Solution2(int[] nums) {\n        if (nums == null || nums.length == 0)\n            return 0;\n        int p = 0, q = 1;\n        while (q &lt; nums.length) {\n            if (nums[p] != nums[q]) {\n                nums[p + 1] = nums[q];\n                p++;\n            }\n            q++;\n        }\n        return p + 1;\n    }\n\n    //优化版\n    public static int Solution3(int[] nums) {\n        if (nums == null || nums.length == 0)\n            return 0;\n        int p = 0, q = 1;\n        while (q &lt; nums.length) {\n            if (nums[p] != nums[q]) {\n                if (q - p &gt; 1) {      //排除由于没有重复元素，p、q一直紧挨着，但也会一直进行不必要的赋值\n                    nums[p + 1] = nums[q];\n                }\n                p++;\n            }\n            q++;\n        }\n        return p + 1;\n    }</code></pre>\n<br>\n<br>\n\n<hr>\n<br>\n<br>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/</a></p>"},{"title":"LeetCode 20th 有效的括号","declare":true,"wordCount":true,"abbrlink":"8ce268b6","data":"2020-07-15T10:45:10.000Z","_content":"\n# 1.Subject\n>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。     \n>有效字符串需满足：\n\n    左括号必须用相同类型的右括号闭合。\n    左括号必须以正确的顺序闭合。\n>注意空字符串可被认为是有效字符串。\n>输入: \"{[]}\"    \n>输出: true     \n\n>输入: \"()[]{}\"   \n>输出: true\n\n>输入: \"([)]\"     \n>输出: false     \n\n<!-- more -->\n\n# 2. Solution\n## 2.1 栈\n### 2.1.1 思路\n    1.遇到左括号时，存入右括号\n    2.遇到右括号时，判断是否是当前栈顶的元素\n        2.1 若是则弹出栈顶元素并继续\n        2.2 不是则返回false\n    3.若最终栈为空则全部匹配上，否则未全部匹配上\n\n### 2.2 Code\n```java\npublic class cc20 {\n    public static void main(String[] args) {\n        String s = \"{[]}\";\n        System.out.println(Solution(s));\n    }\n\n    public static boolean Solution(String s) {\n        HashMap<Character, Character> map = new HashMap<>();\n        map.put('(', ')');\n        map.put('{', '}');\n        map.put('[', ']');\n\n        LinkedList<Character> list = new LinkedList<>();\n\n        for (char c : s.toCharArray()) {\n            if (map.containsKey(c))\n                list.add(map.get(c)); //如果判断有左括号的时候，栈推入右括号\n            else if (list.isEmpty() || c != list.removeLast()) //list为空(没有匹配的) 或 c不等于list的最新的个元素(移除）\n                return false;\n        }\n        return list.isEmpty(); //无剩余则全部匹配上\n    }\n}\n```\n\n\n***\n\n<br>\n<br>\n\n### 参考\nhttps://leetcode-cn.com/problems/valid-parentheses/solution/java-you-xiao-gua-hao-si-lu-qing-xi-pan-duan-jian-/","source":"_posts/Arithmetic/LeetCode 20th.md","raw":"---\ntitle: LeetCode 20th 有效的括号\ncategories: Airthmetic\ntags: Array\ndeclare: true\nwordCount: true\nabbrlink: 8ce268b6\ndata: 2020-07-15 18:45:10\n---\n\n# 1.Subject\n>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。     \n>有效字符串需满足：\n\n    左括号必须用相同类型的右括号闭合。\n    左括号必须以正确的顺序闭合。\n>注意空字符串可被认为是有效字符串。\n>输入: \"{[]}\"    \n>输出: true     \n\n>输入: \"()[]{}\"   \n>输出: true\n\n>输入: \"([)]\"     \n>输出: false     \n\n<!-- more -->\n\n# 2. Solution\n## 2.1 栈\n### 2.1.1 思路\n    1.遇到左括号时，存入右括号\n    2.遇到右括号时，判断是否是当前栈顶的元素\n        2.1 若是则弹出栈顶元素并继续\n        2.2 不是则返回false\n    3.若最终栈为空则全部匹配上，否则未全部匹配上\n\n### 2.2 Code\n```java\npublic class cc20 {\n    public static void main(String[] args) {\n        String s = \"{[]}\";\n        System.out.println(Solution(s));\n    }\n\n    public static boolean Solution(String s) {\n        HashMap<Character, Character> map = new HashMap<>();\n        map.put('(', ')');\n        map.put('{', '}');\n        map.put('[', ']');\n\n        LinkedList<Character> list = new LinkedList<>();\n\n        for (char c : s.toCharArray()) {\n            if (map.containsKey(c))\n                list.add(map.get(c)); //如果判断有左括号的时候，栈推入右括号\n            else if (list.isEmpty() || c != list.removeLast()) //list为空(没有匹配的) 或 c不等于list的最新的个元素(移除）\n                return false;\n        }\n        return list.isEmpty(); //无剩余则全部匹配上\n    }\n}\n```\n\n\n***\n\n<br>\n<br>\n\n### 参考\nhttps://leetcode-cn.com/problems/valid-parentheses/solution/java-you-xiao-gua-hao-si-lu-qing-xi-pan-duan-jian-/","slug":"Arithmetic/LeetCode 20th","published":1,"date":"2021-08-09T10:06:58.734Z","updated":"2020-07-15T10:31:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1ep000f0w7t0pmg26ee","content":"<h1 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h1><blockquote>\n<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：</p>\n</blockquote>\n<pre><code>左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。</code></pre><blockquote>\n<p>注意空字符串可被认为是有效字符串。<br>输入: “{[]}”<br>输出: true     </p>\n</blockquote>\n<blockquote>\n<p>输入: “()[]{}”<br>输出: true</p>\n</blockquote>\n<blockquote>\n<p>输入: “([)]”<br>输出: false     </p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h1 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2. Solution\"></a>2. Solution</h1><h2 id=\"2-1-栈\"><a href=\"#2-1-栈\" class=\"headerlink\" title=\"2.1 栈\"></a>2.1 栈</h2><h3 id=\"2-1-1-思路\"><a href=\"#2-1-1-思路\" class=\"headerlink\" title=\"2.1.1 思路\"></a>2.1.1 思路</h3><pre><code>1.遇到左括号时，存入右括号\n2.遇到右括号时，判断是否是当前栈顶的元素\n    2.1 若是则弹出栈顶元素并继续\n    2.2 不是则返回false\n3.若最终栈为空则全部匹配上，否则未全部匹配上</code></pre><h3 id=\"2-2-Code\"><a href=\"#2-2-Code\" class=\"headerlink\" title=\"2.2 Code\"></a>2.2 Code</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">cc20</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        String s <span class=\"token operator\">=</span> <span class=\"token string\">\"{[]}\"</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">Solution</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">Solution</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        HashMap<span class=\"token operator\">&lt;</span>Character<span class=\"token punctuation\">,</span> Character<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">'('</span><span class=\"token punctuation\">,</span> <span class=\"token string\">')'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">'{'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'}'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">'['</span><span class=\"token punctuation\">,</span> <span class=\"token string\">']'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        LinkedList<span class=\"token operator\">&lt;</span>Character<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> c <span class=\"token operator\">:</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//如果判断有左括号的时候，栈推入右括号</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> c <span class=\"token operator\">!=</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">removeLast</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//list为空(没有匹配的) 或 c不等于list的最新的个元素(移除）</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//无剩余则全部匹配上</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<hr>\n<br>\n<br>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://leetcode-cn.com/problems/valid-parentheses/solution/java-you-xiao-gua-hao-si-lu-qing-xi-pan-duan-jian-/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/valid-parentheses/solution/java-you-xiao-gua-hao-si-lu-qing-xi-pan-duan-jian-/</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h1><blockquote>\n<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：</p>\n</blockquote>\n<pre><code>左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。</code></pre><blockquote>\n<p>注意空字符串可被认为是有效字符串。<br>输入: “{[]}”<br>输出: true     </p>\n</blockquote>\n<blockquote>\n<p>输入: “()[]{}”<br>输出: true</p>\n</blockquote>\n<blockquote>\n<p>输入: “([)]”<br>输出: false     </p>\n</blockquote>","more":"<h1 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2. Solution\"></a>2. Solution</h1><h2 id=\"2-1-栈\"><a href=\"#2-1-栈\" class=\"headerlink\" title=\"2.1 栈\"></a>2.1 栈</h2><h3 id=\"2-1-1-思路\"><a href=\"#2-1-1-思路\" class=\"headerlink\" title=\"2.1.1 思路\"></a>2.1.1 思路</h3><pre><code>1.遇到左括号时，存入右括号\n2.遇到右括号时，判断是否是当前栈顶的元素\n    2.1 若是则弹出栈顶元素并继续\n    2.2 不是则返回false\n3.若最终栈为空则全部匹配上，否则未全部匹配上</code></pre><h3 id=\"2-2-Code\"><a href=\"#2-2-Code\" class=\"headerlink\" title=\"2.2 Code\"></a>2.2 Code</h3><pre><code class=\"java\">public class cc20 {\n    public static void main(String[] args) {\n        String s = &quot;{[]}&quot;;\n        System.out.println(Solution(s));\n    }\n\n    public static boolean Solution(String s) {\n        HashMap&lt;Character, Character&gt; map = new HashMap&lt;&gt;();\n        map.put(&#39;(&#39;, &#39;)&#39;);\n        map.put(&#39;{&#39;, &#39;}&#39;);\n        map.put(&#39;[&#39;, &#39;]&#39;);\n\n        LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;();\n\n        for (char c : s.toCharArray()) {\n            if (map.containsKey(c))\n                list.add(map.get(c)); //如果判断有左括号的时候，栈推入右括号\n            else if (list.isEmpty() || c != list.removeLast()) //list为空(没有匹配的) 或 c不等于list的最新的个元素(移除）\n                return false;\n        }\n        return list.isEmpty(); //无剩余则全部匹配上\n    }\n}</code></pre>\n<hr>\n<br>\n<br>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://leetcode-cn.com/problems/valid-parentheses/solution/java-you-xiao-gua-hao-si-lu-qing-xi-pan-duan-jian-/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/valid-parentheses/solution/java-you-xiao-gua-hao-si-lu-qing-xi-pan-duan-jian-/</a></p>"},{"title":"LeetCode 27th 移除元素","declare":true,"wordCount":true,"abbrlink":"1e9266e0","data":"2020-07-18T14:25:10.000Z","_content":"# 1.Subject\n>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。       \n>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 **原地** 修改输入数组。       \n>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。       \n\n<!-- more -->\n\n\n>给定 nums = [3,2,2,3], val = 3,       \n>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。       \n>你不需要考虑数组中超出新长度后面的元素。\n\n# 2.Solution\n## 2.1 双指针\n### 2.1.1 思路\n* 两个指针p,q\n* 判断nums[q]的值是否与key值相等\n    * 不相等，将nums[q]的值赋给nums[p]，p++,q++\n    * 相等，q++\n\n### 2.1.2 Code\n```java\npublic static void main(String[] args) {\n        int[] nums = {3, 2, 3};\n        int n = 3;\n        System.out.println(removeElement(nums, n));\n    }\n\n    public static int removeElement(int[] nums, int val) {\n        int left = 0, length = nums.length, p = 0, q = 0;\n        while (q < nums.length) {\n            if (nums[q] != val) {\n                nums[p] = nums[q];\n                q++;\n                p++;\n            } else {\n                q++;\n                length--;\n            }\n        }\n        return length;\n    }\n}\n```\n\n## 2.2 前移数组（错误）\n### 2.2.1 思路（错误）\n遇到key值，就从下一位开始整体前移一位\n** **但是遇到key结尾的就很麻烦！！**\n### 2.2.2 Code（错误）\n```java\npublic static int removeElement(int[] nums, int val) {\n        int left = 0, length = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == val) {\n                for (int j = i + 1; j < nums.length; j++) {\n                    nums[j - 1] = nums[j];\n                }\n                length--;\n                i--;\n            }\n        }\n        return length;\n    }\n```\n\n\n\n","source":"_posts/Arithmetic/LeetCode 27th.md","raw":"---\ntitle: LeetCode 27th 移除元素\ncategories: Airthmetic\ntags: Array\ndeclare: true\nwordCount: true\nabbrlink: 1e9266e0\ndata: 2020-07-18 22:25:10\n---\n# 1.Subject\n>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。       \n>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 **原地** 修改输入数组。       \n>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。       \n\n<!-- more -->\n\n\n>给定 nums = [3,2,2,3], val = 3,       \n>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。       \n>你不需要考虑数组中超出新长度后面的元素。\n\n# 2.Solution\n## 2.1 双指针\n### 2.1.1 思路\n* 两个指针p,q\n* 判断nums[q]的值是否与key值相等\n    * 不相等，将nums[q]的值赋给nums[p]，p++,q++\n    * 相等，q++\n\n### 2.1.2 Code\n```java\npublic static void main(String[] args) {\n        int[] nums = {3, 2, 3};\n        int n = 3;\n        System.out.println(removeElement(nums, n));\n    }\n\n    public static int removeElement(int[] nums, int val) {\n        int left = 0, length = nums.length, p = 0, q = 0;\n        while (q < nums.length) {\n            if (nums[q] != val) {\n                nums[p] = nums[q];\n                q++;\n                p++;\n            } else {\n                q++;\n                length--;\n            }\n        }\n        return length;\n    }\n}\n```\n\n## 2.2 前移数组（错误）\n### 2.2.1 思路（错误）\n遇到key值，就从下一位开始整体前移一位\n** **但是遇到key结尾的就很麻烦！！**\n### 2.2.2 Code（错误）\n```java\npublic static int removeElement(int[] nums, int val) {\n        int left = 0, length = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == val) {\n                for (int j = i + 1; j < nums.length; j++) {\n                    nums[j - 1] = nums[j];\n                }\n                length--;\n                i--;\n            }\n        }\n        return length;\n    }\n```\n\n\n\n","slug":"Arithmetic/LeetCode 27th","published":1,"date":"2021-08-09T10:06:58.738Z","updated":"2020-07-21T05:27:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1eq000h0w7tegiz1ew5","content":"<h1 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h1><blockquote>\n<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 <strong>原地</strong> 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。       </p>\n</blockquote>\n<a id=\"more\"></a>\n\n\n<blockquote>\n<p>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<h1 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2.Solution\"></a>2.Solution</h1><h2 id=\"2-1-双指针\"><a href=\"#2-1-双指针\" class=\"headerlink\" title=\"2.1 双指针\"></a>2.1 双指针</h2><h3 id=\"2-1-1-思路\"><a href=\"#2-1-1-思路\" class=\"headerlink\" title=\"2.1.1 思路\"></a>2.1.1 思路</h3><ul>\n<li>两个指针p,q</li>\n<li>判断nums[q]的值是否与key值相等<ul>\n<li>不相等，将nums[q]的值赋给nums[p]，p++,q++</li>\n<li>相等，q++</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-2-Code\"><a href=\"#2-1-2-Code\" class=\"headerlink\" title=\"2.1.2 Code\"></a>2.1.2 Code</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">removeElement</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">removeElement</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> length <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> p <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> q <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                nums<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                q<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                p<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                q<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                length<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> length<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"2-2-前移数组（错误）\"><a href=\"#2-2-前移数组（错误）\" class=\"headerlink\" title=\"2.2 前移数组（错误）\"></a>2.2 前移数组（错误）</h2><h3 id=\"2-2-1-思路（错误）\"><a href=\"#2-2-1-思路（错误）\" class=\"headerlink\" title=\"2.2.1 思路（错误）\"></a>2.2.1 思路（错误）</h3><p>遇到key值，就从下一位开始整体前移一位<br>** <strong>但是遇到key结尾的就很麻烦！！</strong></p>\n<h3 id=\"2-2-2-Code（错误）\"><a href=\"#2-2-2-Code（错误）\" class=\"headerlink\" title=\"2.2.2 Code（错误）\"></a>2.2.2 Code（错误）</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">removeElement</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> length <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    nums<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                length<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n                i<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> length<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h1><blockquote>\n<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 <strong>原地</strong> 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。       </p>\n</blockquote>","more":"<blockquote>\n<p>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>\n</blockquote>\n<h1 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2.Solution\"></a>2.Solution</h1><h2 id=\"2-1-双指针\"><a href=\"#2-1-双指针\" class=\"headerlink\" title=\"2.1 双指针\"></a>2.1 双指针</h2><h3 id=\"2-1-1-思路\"><a href=\"#2-1-1-思路\" class=\"headerlink\" title=\"2.1.1 思路\"></a>2.1.1 思路</h3><ul>\n<li>两个指针p,q</li>\n<li>判断nums[q]的值是否与key值相等<ul>\n<li>不相等，将nums[q]的值赋给nums[p]，p++,q++</li>\n<li>相等，q++</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-2-Code\"><a href=\"#2-1-2-Code\" class=\"headerlink\" title=\"2.1.2 Code\"></a>2.1.2 Code</h3><pre><code class=\"java\">public static void main(String[] args) {\n        int[] nums = {3, 2, 3};\n        int n = 3;\n        System.out.println(removeElement(nums, n));\n    }\n\n    public static int removeElement(int[] nums, int val) {\n        int left = 0, length = nums.length, p = 0, q = 0;\n        while (q &lt; nums.length) {\n            if (nums[q] != val) {\n                nums[p] = nums[q];\n                q++;\n                p++;\n            } else {\n                q++;\n                length--;\n            }\n        }\n        return length;\n    }\n}</code></pre>\n<h2 id=\"2-2-前移数组（错误）\"><a href=\"#2-2-前移数组（错误）\" class=\"headerlink\" title=\"2.2 前移数组（错误）\"></a>2.2 前移数组（错误）</h2><h3 id=\"2-2-1-思路（错误）\"><a href=\"#2-2-1-思路（错误）\" class=\"headerlink\" title=\"2.2.1 思路（错误）\"></a>2.2.1 思路（错误）</h3><p>遇到key值，就从下一位开始整体前移一位<br>** <strong>但是遇到key结尾的就很麻烦！！</strong></p>\n<h3 id=\"2-2-2-Code（错误）\"><a href=\"#2-2-2-Code（错误）\" class=\"headerlink\" title=\"2.2.2 Code（错误）\"></a>2.2.2 Code（错误）</h3><pre><code class=\"java\">public static int removeElement(int[] nums, int val) {\n        int left = 0, length = nums.length;\n\n        for (int i = 0; i &lt; nums.length; i++) {\n            if (nums[i] == val) {\n                for (int j = i + 1; j &lt; nums.length; j++) {\n                    nums[j - 1] = nums[j];\n                }\n                length--;\n                i--;\n            }\n        }\n        return length;\n    }</code></pre>"},{"title":"LeetCode LCP 06 拿硬币","declare":true,"wordCount":true,"abbrlink":"d93986a2","data":"2020-05-01T15:25:10.000Z","_content":"\n## Subject\n>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。\n<!-- more -->\n```\n示例 1：\n    输入：[4,2,1]\n    输出：4\n    解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。\n```\n\n## Solution\n ```java\n    public class Lcp06 {\n        private static int solution(int[] coins) {\n            int time = 0;\n            for (int m : coins) {\n                int n = 0;\n                if (m % 2 == 0) {\n                    n = m / 2;\n                } else {\n                    n = m / 2 + 1;\n                }\n                time += n;\n            }\n            return time;\n        }\n\n        public static void main(String[] args) {\n            int[] a = {2, 3, 10};\n            System.out.println(solution(a));\n        }\n    }\n ```","source":"_posts/Arithmetic/LeetCode LCP06.md","raw":"---\ntitle: LeetCode LCP 06 拿硬币\ncategories: Airthmetic\ntags: String\ndeclare: true\nwordCount: true\nabbrlink: d93986a2\ndata: 2020-05-01 23:25:10\n---\n\n## Subject\n>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。\n<!-- more -->\n```\n示例 1：\n    输入：[4,2,1]\n    输出：4\n    解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。\n```\n\n## Solution\n ```java\n    public class Lcp06 {\n        private static int solution(int[] coins) {\n            int time = 0;\n            for (int m : coins) {\n                int n = 0;\n                if (m % 2 == 0) {\n                    n = m / 2;\n                } else {\n                    n = m / 2 + 1;\n                }\n                time += n;\n            }\n            return time;\n        }\n\n        public static void main(String[] args) {\n            int[] a = {2, 3, 10};\n            System.out.println(solution(a));\n        }\n    }\n ```","slug":"Arithmetic/LeetCode LCP06","published":1,"date":"2021-08-09T10:06:58.748Z","updated":"2020-07-15T10:27:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1er000m0w7t7xskgj49","content":"<h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><blockquote>\n<p>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p>\n</blockquote>\n<a id=\"more\"></a>\n<pre><code>示例 1：\n    输入：[4,2,1]\n    输出：4\n    解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</code></pre><h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Lcp06</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> coins<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> time <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> m <span class=\"token operator\">:</span> coins<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    n <span class=\"token operator\">=</span> m <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    n <span class=\"token operator\">=</span> m <span class=\"token operator\">/</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                time <span class=\"token operator\">+=</span> n<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> time<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">solution</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><blockquote>\n<p>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p>\n</blockquote>","more":"<pre><code>示例 1：\n    输入：[4,2,1]\n    输出：4\n    解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</code></pre><h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code class=\"java\">    public class Lcp06 {\n        private static int solution(int[] coins) {\n            int time = 0;\n            for (int m : coins) {\n                int n = 0;\n                if (m % 2 == 0) {\n                    n = m / 2;\n                } else {\n                    n = m / 2 + 1;\n                }\n                time += n;\n            }\n            return time;\n        }\n\n        public static void main(String[] args) {\n            int[] a = {2, 3, 10};\n            System.out.println(solution(a));\n        }\n    }</code></pre>"},{"title":"LeetCode 53th 最大子序和","declare":true,"wordCount":true,"abbrlink":"a7a4385e","data":"2020-05-01T07:53:10.000Z","_content":"## 1.Subject\n>* 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n>* 示例:\n>* 输入: [-2,1,-3,4,-1,2,1,-5,4],\n>* 输出: 6\n>* 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n<!-- more -->\n## 2.Solution\n\n### 2.1暴力法\n\n#### 2.1.1思路\n    1. 从第一个元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n    2. 从第二个元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n    3. 从第三元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n    4. ...\n    5. 第n个（最后一个）元素即为这个循环最大的元素和\n    6. 在所以循环的连续子数组和中找出最大的一个\n\n#### 2.1.2 code\n\n```java\npublic class maxSubArray {\n    private static int max(int[] a) {\n            int[] singleMsx = new int[a.length];\n            int start = 0;\n            for (int i = 0; i < a.length; ++i) {\n                singleMsx[i] = a[i];\n                start = a[i];\n                if (i != a.length - 1) {\n                    for (int j = i + 1; j < a.length; ++j) {\n                        start += a[j];\n                        singleMsx[i] = Math.max(start, singleMsx[i]);\n                    }\n                }\n            }\n\n            int max = 0;\n            for (int msx : singleMsx) {\n                if (max < msx)\n                    max = msx;\n            }\n            return max;\n    }\n\n    public static void main(String[] args) {\n\n        int[] array = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};\n        System.out.println(max1(array));\n\n    }\n}\n\n```\n\n### 2.2贪心算法\n\n#### 2.2.1 code\n```java\npublic class maxSubArray {\n    private static int max1(int[] a){\n        int currentSum=a[0];\n        int maxSum=a[0];\n        for(int i=0;i<a.length;i++){\n            currentSum=Math.max(a[i],currentSum+a[i]);  //如果之前的和加上nums[i]比直接用nums[i]重新开始还小则将nums[i]的值直接赋值给currentSum\n            maxSum=Math.max(maxSum,currentSum);\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n\n        int[] array = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};\n\n        System.out.println(max1(array));\n\n    }\n}\n```\n","source":"_posts/Arithmetic/LeetCode 53th.md","raw":"---\ntitle: LeetCode 53th 最大子序和\ncategories: Airthmetic\ntags: Array\ndeclare: true\nwordCount: true\nabbrlink: a7a4385e\ndata: 2020-05-01 15:53:10\n---\n## 1.Subject\n>* 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n>* 示例:\n>* 输入: [-2,1,-3,4,-1,2,1,-5,4],\n>* 输出: 6\n>* 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n<!-- more -->\n## 2.Solution\n\n### 2.1暴力法\n\n#### 2.1.1思路\n    1. 从第一个元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n    2. 从第二个元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n    3. 从第三元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n    4. ...\n    5. 第n个（最后一个）元素即为这个循环最大的元素和\n    6. 在所以循环的连续子数组和中找出最大的一个\n\n#### 2.1.2 code\n\n```java\npublic class maxSubArray {\n    private static int max(int[] a) {\n            int[] singleMsx = new int[a.length];\n            int start = 0;\n            for (int i = 0; i < a.length; ++i) {\n                singleMsx[i] = a[i];\n                start = a[i];\n                if (i != a.length - 1) {\n                    for (int j = i + 1; j < a.length; ++j) {\n                        start += a[j];\n                        singleMsx[i] = Math.max(start, singleMsx[i]);\n                    }\n                }\n            }\n\n            int max = 0;\n            for (int msx : singleMsx) {\n                if (max < msx)\n                    max = msx;\n            }\n            return max;\n    }\n\n    public static void main(String[] args) {\n\n        int[] array = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};\n        System.out.println(max1(array));\n\n    }\n}\n\n```\n\n### 2.2贪心算法\n\n#### 2.2.1 code\n```java\npublic class maxSubArray {\n    private static int max1(int[] a){\n        int currentSum=a[0];\n        int maxSum=a[0];\n        for(int i=0;i<a.length;i++){\n            currentSum=Math.max(a[i],currentSum+a[i]);  //如果之前的和加上nums[i]比直接用nums[i]重新开始还小则将nums[i]的值直接赋值给currentSum\n            maxSum=Math.max(maxSum,currentSum);\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n\n        int[] array = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};\n\n        System.out.println(max1(array));\n\n    }\n}\n```\n","slug":"Arithmetic/LeetCode 53th","published":1,"date":"2021-08-09T10:06:58.739Z","updated":"2020-07-15T10:25:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1es000p0w7t2a7lardg","content":"<h2 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h2><blockquote>\n<ul>\n<li>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</li>\n<li>示例:</li>\n<li>输入: [-2,1,-3,4,-1,2,1,-5,4],</li>\n<li>输出: 6</li>\n<li>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2.Solution\"></a>2.Solution</h2><h3 id=\"2-1暴力法\"><a href=\"#2-1暴力法\" class=\"headerlink\" title=\"2.1暴力法\"></a>2.1暴力法</h3><h4 id=\"2-1-1思路\"><a href=\"#2-1-1思路\" class=\"headerlink\" title=\"2.1.1思路\"></a>2.1.1思路</h4><pre><code>1. 从第一个元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n2. 从第二个元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n3. 从第三元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n4. ...\n5. 第n个（最后一个）元素即为这个循环最大的元素和\n6. 在所以循环的连续子数组和中找出最大的一个</code></pre><h4 id=\"2-1-2-code\"><a href=\"#2-1-2-code\" class=\"headerlink\" title=\"2.1.2 code\"></a>2.1.2 code</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">maxSubArray</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> singleMsx <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                singleMsx<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                start <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> a<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        start <span class=\"token operator\">+=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                        singleMsx<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> singleMsx<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> msx <span class=\"token operator\">:</span> singleMsx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>max <span class=\"token operator\">&lt;</span> msx<span class=\"token punctuation\">)</span>\n                    max <span class=\"token operator\">=</span> msx<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> max<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">max1</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"2-2贪心算法\"><a href=\"#2-2贪心算法\" class=\"headerlink\" title=\"2.2贪心算法\"></a>2.2贪心算法</h3><h4 id=\"2-2-1-code\"><a href=\"#2-2-1-code\" class=\"headerlink\" title=\"2.2.1 code\"></a>2.2.1 code</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">maxSubArray</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">max1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> currentSum<span class=\"token operator\">=</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> maxSum<span class=\"token operator\">=</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            currentSum<span class=\"token operator\">=</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>currentSum<span class=\"token operator\">+</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//如果之前的和加上nums[i]比直接用nums[i]重新开始还小则将nums[i]的值直接赋值给currentSum</span>\n            maxSum<span class=\"token operator\">=</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>maxSum<span class=\"token punctuation\">,</span>currentSum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> maxSum<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">max1</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-Subject\"><a href=\"#1-Subject\" class=\"headerlink\" title=\"1.Subject\"></a>1.Subject</h2><blockquote>\n<ul>\n<li>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</li>\n<li>示例:</li>\n<li>输入: [-2,1,-3,4,-1,2,1,-5,4],</li>\n<li>输出: 6</li>\n<li>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</li>\n</ul>\n</blockquote>","more":"<h2 id=\"2-Solution\"><a href=\"#2-Solution\" class=\"headerlink\" title=\"2.Solution\"></a>2.Solution</h2><h3 id=\"2-1暴力法\"><a href=\"#2-1暴力法\" class=\"headerlink\" title=\"2.1暴力法\"></a>2.1暴力法</h3><h4 id=\"2-1-1思路\"><a href=\"#2-1-1思路\" class=\"headerlink\" title=\"2.1.1思路\"></a>2.1.1思路</h4><pre><code>1. 从第一个元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n2. 从第二个元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n3. 从第三元素开始，逐渐向后加上一个后续元素，每加一次，并判断确定这一个循环最大的连续子数组和\n4. ...\n5. 第n个（最后一个）元素即为这个循环最大的元素和\n6. 在所以循环的连续子数组和中找出最大的一个</code></pre><h4 id=\"2-1-2-code\"><a href=\"#2-1-2-code\" class=\"headerlink\" title=\"2.1.2 code\"></a>2.1.2 code</h4><pre><code class=\"java\">public class maxSubArray {\n    private static int max(int[] a) {\n            int[] singleMsx = new int[a.length];\n            int start = 0;\n            for (int i = 0; i &lt; a.length; ++i) {\n                singleMsx[i] = a[i];\n                start = a[i];\n                if (i != a.length - 1) {\n                    for (int j = i + 1; j &lt; a.length; ++j) {\n                        start += a[j];\n                        singleMsx[i] = Math.max(start, singleMsx[i]);\n                    }\n                }\n            }\n\n            int max = 0;\n            for (int msx : singleMsx) {\n                if (max &lt; msx)\n                    max = msx;\n            }\n            return max;\n    }\n\n    public static void main(String[] args) {\n\n        int[] array = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};\n        System.out.println(max1(array));\n\n    }\n}\n</code></pre>\n<h3 id=\"2-2贪心算法\"><a href=\"#2-2贪心算法\" class=\"headerlink\" title=\"2.2贪心算法\"></a>2.2贪心算法</h3><h4 id=\"2-2-1-code\"><a href=\"#2-2-1-code\" class=\"headerlink\" title=\"2.2.1 code\"></a>2.2.1 code</h4><pre><code class=\"java\">public class maxSubArray {\n    private static int max1(int[] a){\n        int currentSum=a[0];\n        int maxSum=a[0];\n        for(int i=0;i&lt;a.length;i++){\n            currentSum=Math.max(a[i],currentSum+a[i]);  //如果之前的和加上nums[i]比直接用nums[i]重新开始还小则将nums[i]的值直接赋值给currentSum\n            maxSum=Math.max(maxSum,currentSum);\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n\n        int[] array = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};\n\n        System.out.println(max1(array));\n\n    }\n}</code></pre>"},{"title":"LeetCode i0104 回文排列","declare":true,"wordCount":true,"abbrlink":"885418c8","data":"2020-05-01T14:58:10.000Z","_content":"\n<!-- 面试题 01.04. 回文排列 -->\n\n## Subject\n>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列.回文串不一定是字典当中的单词。\n<!-- more -->\n```\n实例    \n    输入：\"tactcoa\"\n    输出：true（排列有\"tacocat\"、\"atcocta\"，等等）\n```\n## Solution\n\n    回文数的特征为只有一个字符的个数为奇数个。\n\n```java\n    public class i0104 {\n        private static boolean judge(String s) {\n            HashMap<Character, Integer> map = new HashMap<>();\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                map.put(c, map.getOrDefault(c, 0) + 1);\n            }\n            int n=0;\n            for(Map.Entry<Character,Integer> entry:map.entrySet()){\n                if(entry.getValue()% 2 == 1)\n                    n++;\n                if(n==2){\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static void main(String[] args) {\n            String s = \"tactcoa\";\n            System.out.println(judge(s));\n        }\n    }\n```","source":"_posts/Arithmetic/LeetCode i0104.md","raw":"---\ntitle: LeetCode i0104 回文排列\ncategories: Airthmetic\ntags: String\ndeclare: true\nwordCount: true\nabbrlink: 885418c8\ndata: 2020-05-01 22:58:10\n---\n\n<!-- 面试题 01.04. 回文排列 -->\n\n## Subject\n>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列.回文串不一定是字典当中的单词。\n<!-- more -->\n```\n实例    \n    输入：\"tactcoa\"\n    输出：true（排列有\"tacocat\"、\"atcocta\"，等等）\n```\n## Solution\n\n    回文数的特征为只有一个字符的个数为奇数个。\n\n```java\n    public class i0104 {\n        private static boolean judge(String s) {\n            HashMap<Character, Integer> map = new HashMap<>();\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                map.put(c, map.getOrDefault(c, 0) + 1);\n            }\n            int n=0;\n            for(Map.Entry<Character,Integer> entry:map.entrySet()){\n                if(entry.getValue()% 2 == 1)\n                    n++;\n                if(n==2){\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static void main(String[] args) {\n            String s = \"tactcoa\";\n            System.out.println(judge(s));\n        }\n    }\n```","slug":"Arithmetic/LeetCode i0104","published":1,"date":"2021-08-09T10:06:58.741Z","updated":"2020-07-15T10:27:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1et000t0w7tcslf5jv6","content":"<!-- 面试题 01.04. 回文排列 -->\n\n<h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><blockquote>\n<p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列.回文串不一定是字典当中的单词。</p>\n</blockquote>\n<a id=\"more\"></a>\n<pre><code>实例    \n    输入：&quot;tactcoa&quot;\n    输出：true（排列有&quot;tacocat&quot;、&quot;atcocta&quot;，等等）</code></pre><h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code>回文数的特征为只有一个字符的个数为奇数个。</code></pre><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">i0104</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">judge</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            HashMap<span class=\"token operator\">&lt;</span>Character<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">char</span> c <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">getOrDefault</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">int</span> n<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token operator\">&lt;</span>Character<span class=\"token punctuation\">,</span>Integer<span class=\"token operator\">></span> entry<span class=\"token operator\">:</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                    n<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            String s <span class=\"token operator\">=</span> <span class=\"token string\">\"tactcoa\"</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">judge</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<!-- 面试题 01.04. 回文排列 -->\n\n<h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><blockquote>\n<p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列.回文串不一定是字典当中的单词。</p>\n</blockquote>","more":"<pre><code>实例    \n    输入：&quot;tactcoa&quot;\n    输出：true（排列有&quot;tacocat&quot;、&quot;atcocta&quot;，等等）</code></pre><h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code>回文数的特征为只有一个字符的个数为奇数个。</code></pre><pre><code class=\"java\">    public class i0104 {\n        private static boolean judge(String s) {\n            HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();\n            for (int i = 0; i &lt; s.length(); i++) {\n                char c = s.charAt(i);\n                map.put(c, map.getOrDefault(c, 0) + 1);\n            }\n            int n=0;\n            for(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet()){\n                if(entry.getValue()% 2 == 1)\n                    n++;\n                if(n==2){\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static void main(String[] args) {\n            String s = &quot;tactcoa&quot;;\n            System.out.println(judge(s));\n        }\n    }</code></pre>"},{"title":"二分法","declare":true,"wordCount":true,"abbrlink":"649c2087","data":"2020-04-24T07:40:10.000Z","_content":"❄\n\n对于区间[a，b]上连续不断且f（a）·f（b）<0的函数y=f（x），通过不断地把函数f（x）的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值。\n<!-- more -->\n\n#### 1.适用场景\n\n* **有序**的数组，**没有重复**的数据元组\n* 使用场景：数据量较大<br>\n\n#### 2.算法简述\n\n  > 如果 value==arr[mid],中间值正好等于要查找的值，则返回下标，return mid;<br>\n  > 如果 value<arr[mid],要找的值小于中间的值，则再往数组的小端找，high=mid-1;<br>\n  > 如果 value>arr[mid],要找的值大于中间的值，则再往数组的大端找，low=mid+1;<br>\n\n#### 3. 代码\n\n  * ```java\n    public class dichotomySearch {\n        public static int search(int[] arr, int key) {\n            int start = 0;\n            int end = arr.length - 1;\n            while (start <= end) {\n                int mid = (start + end) / 2;\n                if (key < arr[mid])\n                    end = mid - 1;\n                else if (key > arr[mid]) {\n                    start = mid + 1;\n                } else\n                    return mid;\n            }\n            return -1;\n        }\n    \n        public static void main(String[] args) {\n            int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n            int key = 6;\n            int index = search(arr, key);\n            System.out.println(index);\n        }\n    }\n    \n    ```\n  \n","source":"_posts/Arithmetic/二分法.md","raw":"---\ntitle: 二分法\ncategories: Airthmetic\ndeclare: true\nwordCount: true\nabbrlink: 649c2087\ndata: 2020-04-24 15:40:10\n---\n❄\n\n对于区间[a，b]上连续不断且f（a）·f（b）<0的函数y=f（x），通过不断地把函数f（x）的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值。\n<!-- more -->\n\n#### 1.适用场景\n\n* **有序**的数组，**没有重复**的数据元组\n* 使用场景：数据量较大<br>\n\n#### 2.算法简述\n\n  > 如果 value==arr[mid],中间值正好等于要查找的值，则返回下标，return mid;<br>\n  > 如果 value<arr[mid],要找的值小于中间的值，则再往数组的小端找，high=mid-1;<br>\n  > 如果 value>arr[mid],要找的值大于中间的值，则再往数组的大端找，low=mid+1;<br>\n\n#### 3. 代码\n\n  * ```java\n    public class dichotomySearch {\n        public static int search(int[] arr, int key) {\n            int start = 0;\n            int end = arr.length - 1;\n            while (start <= end) {\n                int mid = (start + end) / 2;\n                if (key < arr[mid])\n                    end = mid - 1;\n                else if (key > arr[mid]) {\n                    start = mid + 1;\n                } else\n                    return mid;\n            }\n            return -1;\n        }\n    \n        public static void main(String[] args) {\n            int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n            int key = 6;\n            int index = search(arr, key);\n            System.out.println(index);\n        }\n    }\n    \n    ```\n  \n","slug":"Arithmetic/二分法","published":1,"date":"2021-08-09T10:06:58.750Z","updated":"2020-12-12T00:41:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1eu000w0w7t0kx7a1xq","content":"<p>❄</p>\n<p>对于区间[a，b]上连续不断且f（a）·f（b）&lt;0的函数y=f（x），通过不断地把函数f（x）的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"1-适用场景\"><a href=\"#1-适用场景\" class=\"headerlink\" title=\"1.适用场景\"></a>1.适用场景</h4><ul>\n<li><strong>有序</strong>的数组，<strong>没有重复</strong>的数据元组</li>\n<li>使用场景：数据量较大<br></li>\n</ul>\n<h4 id=\"2-算法简述\"><a href=\"#2-算法简述\" class=\"headerlink\" title=\"2.算法简述\"></a>2.算法简述</h4><blockquote>\n<p>如果 value==arr[mid],中间值正好等于要查找的值，则返回下标，return mid;<br><br>如果 value&lt;arr[mid],要找的值小于中间的值，则再往数组的小端找，high=mid-1;<br><br>如果 value&gt;arr[mid],要找的值大于中间的值，则再往数组的大端找，low=mid+1;<br></p>\n</blockquote>\n<h4 id=\"3-代码\"><a href=\"#3-代码\" class=\"headerlink\" title=\"3. 代码\"></a>3. 代码</h4><ul>\n<li><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">dichotomySearch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> end <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">&lt;=</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                end <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">></span> arr<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                start <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span>\n                <span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> key <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>❄</p>\n<p>对于区间[a，b]上连续不断且f（a）·f（b）&lt;0的函数y=f（x），通过不断地把函数f（x）的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值。</p>","more":"<h4 id=\"1-适用场景\"><a href=\"#1-适用场景\" class=\"headerlink\" title=\"1.适用场景\"></a>1.适用场景</h4><ul>\n<li><strong>有序</strong>的数组，<strong>没有重复</strong>的数据元组</li>\n<li>使用场景：数据量较大<br></li>\n</ul>\n<h4 id=\"2-算法简述\"><a href=\"#2-算法简述\" class=\"headerlink\" title=\"2.算法简述\"></a>2.算法简述</h4><blockquote>\n<p>如果 value==arr[mid],中间值正好等于要查找的值，则返回下标，return mid;<br><br>如果 value&lt;arr[mid],要找的值小于中间的值，则再往数组的小端找，high=mid-1;<br><br>如果 value&gt;arr[mid],要找的值大于中间的值，则再往数组的大端找，low=mid+1;<br></p>\n</blockquote>\n<h4 id=\"3-代码\"><a href=\"#3-代码\" class=\"headerlink\" title=\"3. 代码\"></a>3. 代码</h4><ul>\n<li><pre><code class=\"java\">public class dichotomySearch {\n    public static int search(int[] arr, int key) {\n        int start = 0;\n        int end = arr.length - 1;\n        while (start &lt;= end) {\n            int mid = (start + end) / 2;\n            if (key &lt; arr[mid])\n                end = mid - 1;\n            else if (key &gt; arr[mid]) {\n                start = mid + 1;\n            } else\n                return mid;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        int key = 6;\n        int index = search(arr, key);\n        System.out.println(index);\n    }\n}\n</code></pre>\n</li>\n</ul>"},{"title":"LeetCode i48th 最长不含重复字符的子字符串","declare":true,"wordCount":true,"abbrlink":"e2dceda6","data":"2020-05-01T09:56:10.000Z","_content":"\n## 1.题目\n>从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n<!-- more -->\n## 2.解法\n\n### 2.1 滑动窗口\n\n```java\n    private static int longest(String str) {\n        int length = str.length();\n        if (length == 0 || length == 1)\n            return length;\n        int left = 0;\n        int longest = 0;\n        for (int i = 1; i < length; ) {\n            if (judge(str, left, i - 1, str.charAt(i))) {\n                i++;\n                longest = Math.max(longest, i - left);\n            } else {\n                left++;\n            }\n        }\n        return longest;\n    }\n    private static boolean judge(String s, int left, int right, char c) {\n        for (int i = left; i <= right; i++) {\n            if (s.charAt(i) == c)\n                return false;\n        }\n        return true;\n    }\n```\n\n### 2.1HasHMap的滑动窗口\n```java\n    private static int LM(String s) {\n        if (s.length() == 0) {\n            return 0;\n        }\n        int longest = 0;\n        int head = 0;\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n\n            if (!map.containsKey(s.charAt(i))) {\n                map.put(s.charAt(i), i);\n                longest = Math.max(longest, i - head);\n            } else {\n                longest = Math.max(longest, i - head); //即使此次重复了 但是要算上前一个 每次i-head都是算的前面的\n                if (map.get(s.charAt(i)) + 1 > head) {\n                    head = map.get(s.charAt(i)) + 1;\n                }\n                map.remove(s.charAt(i));\n                map.put(s.charAt(i), i);\n            }\n        }\n        return Math.max(longest, s.length() - head); //判断最后一次的是否与之前最大的longest相同\n    }\n   \n```","source":"_posts/Arithmetic/leetCode i48th.md","raw":"---\ntitle: LeetCode i48th 最长不含重复字符的子字符串\ncategories: Airthmetic\ntags: String\ndeclare: true\nwordCount: true\nabbrlink: e2dceda6\ndata: 2020-05-01 17:56:10\n---\n\n## 1.题目\n>从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n<!-- more -->\n## 2.解法\n\n### 2.1 滑动窗口\n\n```java\n    private static int longest(String str) {\n        int length = str.length();\n        if (length == 0 || length == 1)\n            return length;\n        int left = 0;\n        int longest = 0;\n        for (int i = 1; i < length; ) {\n            if (judge(str, left, i - 1, str.charAt(i))) {\n                i++;\n                longest = Math.max(longest, i - left);\n            } else {\n                left++;\n            }\n        }\n        return longest;\n    }\n    private static boolean judge(String s, int left, int right, char c) {\n        for (int i = left; i <= right; i++) {\n            if (s.charAt(i) == c)\n                return false;\n        }\n        return true;\n    }\n```\n\n### 2.1HasHMap的滑动窗口\n```java\n    private static int LM(String s) {\n        if (s.length() == 0) {\n            return 0;\n        }\n        int longest = 0;\n        int head = 0;\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n\n            if (!map.containsKey(s.charAt(i))) {\n                map.put(s.charAt(i), i);\n                longest = Math.max(longest, i - head);\n            } else {\n                longest = Math.max(longest, i - head); //即使此次重复了 但是要算上前一个 每次i-head都是算的前面的\n                if (map.get(s.charAt(i)) + 1 > head) {\n                    head = map.get(s.charAt(i)) + 1;\n                }\n                map.remove(s.charAt(i));\n                map.put(s.charAt(i), i);\n            }\n        }\n        return Math.max(longest, s.length() - head); //判断最后一次的是否与之前最大的longest相同\n    }\n   \n```","slug":"Arithmetic/leetCode i48th","published":1,"date":"2021-08-09T10:06:58.745Z","updated":"2020-07-15T10:26:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1eu000z0w7thz0h6qmo","content":"<h2 id=\"1-题目\"><a href=\"#1-题目\" class=\"headerlink\" title=\"1.题目\"></a>1.题目</h2><blockquote>\n<p>从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"2-解法\"><a href=\"#2-解法\" class=\"headerlink\" title=\"2.解法\"></a>2.解法</h2><h3 id=\"2-1-滑动窗口\"><a href=\"#2-1-滑动窗口\" class=\"headerlink\" title=\"2.1 滑动窗口\"></a>2.1 滑动窗口</h3><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">longest</span><span class=\"token punctuation\">(</span>String str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> length <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> length<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> longest <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">judge</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                longest <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>longest<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> longest<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">judge</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> right<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> c<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"2-1HasHMap的滑动窗口\"><a href=\"#2-1HasHMap的滑动窗口\" class=\"headerlink\" title=\"2.1HasHMap的滑动窗口\"></a>2.1HasHMap的滑动窗口</h3><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">LM</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">int</span> longest <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> head <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        Map<span class=\"token operator\">&lt;</span>Character<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                longest <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>longest<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                longest <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>longest<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//即使此次重复了 但是要算上前一个 每次i-head都是算的前面的</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">></span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    head <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                map<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>longest<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//判断最后一次的是否与之前最大的longest相同</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-题目\"><a href=\"#1-题目\" class=\"headerlink\" title=\"1.题目\"></a>1.题目</h2><blockquote>\n<p>从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>\n</blockquote>","more":"<h2 id=\"2-解法\"><a href=\"#2-解法\" class=\"headerlink\" title=\"2.解法\"></a>2.解法</h2><h3 id=\"2-1-滑动窗口\"><a href=\"#2-1-滑动窗口\" class=\"headerlink\" title=\"2.1 滑动窗口\"></a>2.1 滑动窗口</h3><pre><code class=\"java\">    private static int longest(String str) {\n        int length = str.length();\n        if (length == 0 || length == 1)\n            return length;\n        int left = 0;\n        int longest = 0;\n        for (int i = 1; i &lt; length; ) {\n            if (judge(str, left, i - 1, str.charAt(i))) {\n                i++;\n                longest = Math.max(longest, i - left);\n            } else {\n                left++;\n            }\n        }\n        return longest;\n    }\n    private static boolean judge(String s, int left, int right, char c) {\n        for (int i = left; i &lt;= right; i++) {\n            if (s.charAt(i) == c)\n                return false;\n        }\n        return true;\n    }</code></pre>\n<h3 id=\"2-1HasHMap的滑动窗口\"><a href=\"#2-1HasHMap的滑动窗口\" class=\"headerlink\" title=\"2.1HasHMap的滑动窗口\"></a>2.1HasHMap的滑动窗口</h3><pre><code class=\"java\">    private static int LM(String s) {\n        if (s.length() == 0) {\n            return 0;\n        }\n        int longest = 0;\n        int head = 0;\n        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n\n            if (!map.containsKey(s.charAt(i))) {\n                map.put(s.charAt(i), i);\n                longest = Math.max(longest, i - head);\n            } else {\n                longest = Math.max(longest, i - head); //即使此次重复了 但是要算上前一个 每次i-head都是算的前面的\n                if (map.get(s.charAt(i)) + 1 &gt; head) {\n                    head = map.get(s.charAt(i)) + 1;\n                }\n                map.remove(s.charAt(i));\n                map.put(s.charAt(i), i);\n            }\n        }\n        return Math.max(longest, s.length() - head); //判断最后一次的是否与之前最大的longest相同\n    }\n</code></pre>"},{"title":"斐波那契数列","declare":true,"wordCount":true,"abbrlink":"cc713db","data":"2020-05-01T08:43:10.000Z","_content":"\n## 1.题目\n>F(0) = 0,   F(1) = 1<br>\n>F(N) = F(N - 1) + F(N - 2), 其中 N > 1.\n<!-- more -->\n## 2.解法\n\n### 2.1 普通递归\n```java\n    private int fib(int n){\n         if(n<2)\n             return n;\n         else\n             return fib(n-1)+fib(n-2);\n    }\n```\n### 2.2 字典记录\n \n    将每一次计算的值记录下来\n\n```java\n    private int fibs(int n){\n        int[] Results=new int[n+1];\n        for(int i=0;i<n+1;i++){\n            if(i<2)\n                Results[i]=i;\n            else\n                Results[i]=Results[i-1]+Results[i-2];\n        }\n        return Results[n];\n    }\n```\n\n## 2.3 动态规划\n    每一项的值为前两项的值之和\n```java\nclass Solution {\n    public int fib(int n) {\n        if(n == 0)\n            return 0;\n        if(n == 1)\n            return 1;\n        int prePre = 0, pre = 1, curr = 0;\n        for(int i = 2; i <= n; i++){\n            curr = (prePre + pre);\n            prePre = pre;\n            pre = curr;\n        }\n        return curr;\n    }\n}\n```\n","source":"_posts/Arithmetic/斐波那契数列.md","raw":"---\ntitle: 斐波那契数列\ncategories: Airthmetic\ndeclare: true\nwordCount: true\nabbrlink: cc713db\ndata: 2020-05-01 16:43:10\n---\n\n## 1.题目\n>F(0) = 0,   F(1) = 1<br>\n>F(N) = F(N - 1) + F(N - 2), 其中 N > 1.\n<!-- more -->\n## 2.解法\n\n### 2.1 普通递归\n```java\n    private int fib(int n){\n         if(n<2)\n             return n;\n         else\n             return fib(n-1)+fib(n-2);\n    }\n```\n### 2.2 字典记录\n \n    将每一次计算的值记录下来\n\n```java\n    private int fibs(int n){\n        int[] Results=new int[n+1];\n        for(int i=0;i<n+1;i++){\n            if(i<2)\n                Results[i]=i;\n            else\n                Results[i]=Results[i-1]+Results[i-2];\n        }\n        return Results[n];\n    }\n```\n\n## 2.3 动态规划\n    每一项的值为前两项的值之和\n```java\nclass Solution {\n    public int fib(int n) {\n        if(n == 0)\n            return 0;\n        if(n == 1)\n            return 1;\n        int prePre = 0, pre = 1, curr = 0;\n        for(int i = 2; i <= n; i++){\n            curr = (prePre + pre);\n            prePre = pre;\n            pre = curr;\n        }\n        return curr;\n    }\n}\n```\n","slug":"Arithmetic/斐波那契数列","published":1,"date":"2021-08-09T10:06:58.753Z","updated":"2020-08-19T05:30:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1ew00130w7t570k15k7","content":"<h2 id=\"1-题目\"><a href=\"#1-题目\" class=\"headerlink\" title=\"1.题目\"></a>1.题目</h2><blockquote>\n<p>F(0) = 0,   F(1) = 1<br><br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"2-解法\"><a href=\"#2-解法\" class=\"headerlink\" title=\"2.解法\"></a>2.解法</h2><h3 id=\"2-1-普通递归\"><a href=\"#2-1-普通递归\" class=\"headerlink\" title=\"2.1 普通递归\"></a>2.1 普通递归</h3><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">&lt;</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n             <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">else</span>\n             <span class=\"token keyword\">return</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"2-2-字典记录\"><a href=\"#2-2-字典记录\" class=\"headerlink\" title=\"2.2 字典记录\"></a>2.2 字典记录</h3><pre><code>将每一次计算的值记录下来</code></pre><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">fibs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> Results<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n                Results<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span>\n                Results<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>Results<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>Results<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> Results<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"2-3-动态规划\"><a href=\"#2-3-动态规划\" class=\"headerlink\" title=\"2.3 动态规划\"></a>2.3 动态规划</h2><pre><code>每一项的值为前两项的值之和</code></pre><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> prePre <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> pre <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> curr <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            curr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>prePre <span class=\"token operator\">+</span> pre<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            prePre <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span>\n            pre <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> curr<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-题目\"><a href=\"#1-题目\" class=\"headerlink\" title=\"1.题目\"></a>1.题目</h2><blockquote>\n<p>F(0) = 0,   F(1) = 1<br><br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p>\n</blockquote>","more":"<h2 id=\"2-解法\"><a href=\"#2-解法\" class=\"headerlink\" title=\"2.解法\"></a>2.解法</h2><h3 id=\"2-1-普通递归\"><a href=\"#2-1-普通递归\" class=\"headerlink\" title=\"2.1 普通递归\"></a>2.1 普通递归</h3><pre><code class=\"java\">    private int fib(int n){\n         if(n&lt;2)\n             return n;\n         else\n             return fib(n-1)+fib(n-2);\n    }</code></pre>\n<h3 id=\"2-2-字典记录\"><a href=\"#2-2-字典记录\" class=\"headerlink\" title=\"2.2 字典记录\"></a>2.2 字典记录</h3><pre><code>将每一次计算的值记录下来</code></pre><pre><code class=\"java\">    private int fibs(int n){\n        int[] Results=new int[n+1];\n        for(int i=0;i&lt;n+1;i++){\n            if(i&lt;2)\n                Results[i]=i;\n            else\n                Results[i]=Results[i-1]+Results[i-2];\n        }\n        return Results[n];\n    }</code></pre>\n<h2 id=\"2-3-动态规划\"><a href=\"#2-3-动态规划\" class=\"headerlink\" title=\"2.3 动态规划\"></a>2.3 动态规划</h2><pre><code>每一项的值为前两项的值之和</code></pre><pre><code class=\"java\">class Solution {\n    public int fib(int n) {\n        if(n == 0)\n            return 0;\n        if(n == 1)\n            return 1;\n        int prePre = 0, pre = 1, curr = 0;\n        for(int i = 2; i &lt;= n; i++){\n            curr = (prePre + pre);\n            prePre = pre;\n            pre = curr;\n        }\n        return curr;\n    }\n}</code></pre>"},{"title":"排序算法","abbrlink":61237,"data":"2020-04-21T18:40:10.000Z","declare":true,"wordCount":true,"_content":"* 冒泡排序\n* 插入排序\n* 快速排序\n* 选择排序\n* 希尔排序\n\n\n<!-- more -->\n### 1冒泡排序\n#### 1.1 原理 \n>每轮循环 多次两两比较选出一个最大的排在最后面\n\n![冒泡排序](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY)\n#### 1.2 原码 \n````java\n/**\n* Description TODO 冒泡排序\n* Author Cloudr\n* Date 2020/4/1 22:43\n**/\npublic class BubbleSort {\n    private static void bubbleSorts(int[] a) {\n\n        int i, j, temp;\n\n        for (i = 0; i < a.length - 1; i++) {       //每轮都是把最大的数排到最后 注意是 a.length-1 因为下文有一个j+1\n            for (j = 0; j < a.length - 1 - i; j++) { //每次需要排的个数减少i个\n                if (a[j] > a[j + 1]) {\n                    temp = a[j + 1];\n                    a[j + 1] = a[j];\n                    a[j] = temp;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] a = {1, 253, 56, 745, 342, 41, 654, 321432, 131, 324};\n        bubbleSorts(a);\n        for (int i : a) {\n            System.out.println(i);\n        }\n    }\n}\n````\n\n#### 1.3 复杂度\n    * 时间复杂度\n\n<br>\n\n***      \n\n<br>\n\n### 2直接插入排序\n\n#### 2.1 原理\n>直接插入排序是将未排序的数据插入至已排好序序列的合适位置。<br>\n>具体流程如下：<br>\n>1、首先比较数组的前两个数据，并排序；<br>\n>2、比较第三个元素与前两个排好序的数据，并将第三个元素放入适当的位置；<br>\n>3、比较第四个元素与前三个排好序的数据，并将第四个元素放入适当的位置；<br>\n>......<br>\n>4、直至把最后一个元素放入适当的位置。<br>\n\n![直接插入排序](https://upload-images.jianshu.io/upload_images/11016594-150b6c462e3ed809.png?imageMogr2/auto-orient/strip|imageView2/2/w/471)\n![直接插入排序](http://5b0988e595225.cdn.sohucs.com/images/20190306/4eb688dec144457ea32f03e247ce0678.gif)\n#### 2.2 代码\n````java\npublic class insertSort {\n    private static void insertSort(int[] a) {\n        int Temp;\n        for (int i = 1; i < a.length; i++) { //注意是从i=1开始的\n            Temp = a[i];                    //必须要用Temp 否则移动过程中会改变a[i]的值\n            int j;\n            for (j = i - 1; j >= 0; j--) {  //从已经排好的序列中的末尾（即最大的开始比较），即是从0~i-1与a[j]比较 \n                if (a[j] > Temp)\n                    a[j + 1] = a[j];\n                else {\n                    a[j + 1] = Temp; //因为之前j--了一次\n                    break;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] a = {1, 2, 4, 623, 1, 132, 634, 2, 3, 4};\n        insertSort(a);\n        for (int i : a) {\n            System.out.println(i);\n        }\n    }\n}\n````\n\n<br>\n\n***      \n\n<br>\n\n### 3快速排序\n* <https://www.bilibili.com/video/BV1at411T75o/>\n#### 3.1原理简述\n* 找一个基准数，将大于这个基准数的数放在右边，小于它的放在其左边\n* ![快速排序](https://images.xiaozhuanlan.com/photo/2018/b12fc88b3e00ae442d0d07f36eae73ee.gif)      \n#### 3.2源代码\n```java\n    public class QuickSort {\n\n        private static void quickSort(int[] a, int left, int right) {\n    //        将a分成一边大的，一边小的，重复执行这个过程\n            if (left < right) {\n                int index = getIndex(a, left, right);\n                quickSort(a, left, index - 1);\n                quickSort(a, index + 1, right);\n            }\n        }\n\n        private static int getIndex(int[] a, int left, int right) {\n\n            int standard = a[left]; // 基准数据\n            while (left < right) {\n                while (left < right && a[right] >= standard) { //必须要 >= 不然 =等于那个得不到处理 left也指不到这边\n                    right--;                                   // 当队尾的元素大于等于基准数据时,向前挪动high指针\n                }\n                a[left] = a[right];                            //将小于基准数据的值放到左边（小的一边）\n                while (left < right && a[left] <= standard) {\n                    left++;\n                }\n                a[right] = a[left];                           //将大于基准数据的值放到右边（大的一边）\n            }\n            a[left] = standard;                               //此时left==right 同时这个位置也是standard的位置\n            return left;\n        }\n\n        public static void main(String[] args) {\n            int[] a = {1, 2, 4, 2, 21, 563, 1, 6246, 13, 4331};\n            quickSort(a, 0, a.length - 1);\n            for (int i : a) {\n                System.out.println(i);\n            }\n        }\n    }\n```\n    \n<br>\n\n***      \n\n<br>\n\n### 4选择排序\n\n#### 4.1原理简述：\n    \n>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 \n\n* ![选择排序](![](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/1433219824.gif)\n    \n#### 4.2源代码\n````java\n    public class SelectSort {\n        private static void select(int[] a) {\n            for (int i = 0; i < a.length; ++i) {\n                int index = i;\n                for (int j = i + 1; j < a.length; j++) {\n                    if (a[index] > a[j]) {\n                        index = j; // 找到当前循环中最小的数的索引\n                    }\n                }\n                int temp = a[index];\n                a[index] = a[i];\n                a[i] = temp;\n            }\n        }\n\n        public static void main(String[] args) {\n\n            int[] a = {2, 1, 63, 2, 12, 7, 3, 12, 78, 6, 43};\n            select(a);\n            for (int i : a) {\n                System.out.println(i);\n            }\n\n        }\n    }\n\n````\n\n<br>\n\n***      \n\n<br>\n\n### 5希尔排序\n* [希尔排序](https://www.bilibili.com/video/BV1rE411g7rW/)\n#### 5.1原理简述\n\n>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n\n![希尔排序](![](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/1192699-20180319094116040-1638766271.png)\n    \n#### 5.2源代码\n````java\n    public class ShellSort {\n        private static void shell(int[] a) {\n            int gap = a.length / 2;  //增量，每隔gap为一组\n            while (gap >= 1) {\n                for (int i = gap; i < a.length; i++) { //依次遍历每一组 i=gap是因为后面的j-gap才有意义\n                    int j = i;\n                    while (j - gap >= 0 && a[j] < a[j - gap]) { //遍历每一组 如何发现后面的小于前面的则交换\n                        int temp = a[j];                        //这里不采用每次给j+gap是因为 会有gap个a[j]遍历不到 换种方法也会比较麻烦\n                        a[j] = a[j - gap];\n                    a[j - gap] = temp;\n\n                        j = j - gap;\n                    }\n                }\n                gap = gap / 2;\n            }\n    }\n\n        public static void main(String[] args) {\n            int[] a = {3, 2, 5, 7, 43, 12, 15, 33, 15, 2, 12, 14, 3};\n            shell(a);\n            for (int i : a) {\n                System.out.println(i);\n            }\n        }\n    }\n````\n\n\n> 图片来源于网络，如有侵权请联系我删除，谢谢。<br>\n>参考：<https://www.sohu.com/a/299382768_478315><br>\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<https://www.cnblogs.com/guoyaohua/p/8600214.html>\n>","source":"_posts/Arithmetic/排序算法.md","raw":"---\ntitle: 排序算法\ncategories: Airthmetic\n# photos:\n#   - - 'https://i.loli.net/2020/04/26/qpLaSN2XuCMcxrt.png'\nabbrlink: 61237\ndata: 2020-04-22 02:40:10\ndeclare: true\nwordCount: true\n---\n* 冒泡排序\n* 插入排序\n* 快速排序\n* 选择排序\n* 希尔排序\n\n\n<!-- more -->\n### 1冒泡排序\n#### 1.1 原理 \n>每轮循环 多次两两比较选出一个最大的排在最后面\n\n![冒泡排序](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY)\n#### 1.2 原码 \n````java\n/**\n* Description TODO 冒泡排序\n* Author Cloudr\n* Date 2020/4/1 22:43\n**/\npublic class BubbleSort {\n    private static void bubbleSorts(int[] a) {\n\n        int i, j, temp;\n\n        for (i = 0; i < a.length - 1; i++) {       //每轮都是把最大的数排到最后 注意是 a.length-1 因为下文有一个j+1\n            for (j = 0; j < a.length - 1 - i; j++) { //每次需要排的个数减少i个\n                if (a[j] > a[j + 1]) {\n                    temp = a[j + 1];\n                    a[j + 1] = a[j];\n                    a[j] = temp;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] a = {1, 253, 56, 745, 342, 41, 654, 321432, 131, 324};\n        bubbleSorts(a);\n        for (int i : a) {\n            System.out.println(i);\n        }\n    }\n}\n````\n\n#### 1.3 复杂度\n    * 时间复杂度\n\n<br>\n\n***      \n\n<br>\n\n### 2直接插入排序\n\n#### 2.1 原理\n>直接插入排序是将未排序的数据插入至已排好序序列的合适位置。<br>\n>具体流程如下：<br>\n>1、首先比较数组的前两个数据，并排序；<br>\n>2、比较第三个元素与前两个排好序的数据，并将第三个元素放入适当的位置；<br>\n>3、比较第四个元素与前三个排好序的数据，并将第四个元素放入适当的位置；<br>\n>......<br>\n>4、直至把最后一个元素放入适当的位置。<br>\n\n![直接插入排序](https://upload-images.jianshu.io/upload_images/11016594-150b6c462e3ed809.png?imageMogr2/auto-orient/strip|imageView2/2/w/471)\n![直接插入排序](http://5b0988e595225.cdn.sohucs.com/images/20190306/4eb688dec144457ea32f03e247ce0678.gif)\n#### 2.2 代码\n````java\npublic class insertSort {\n    private static void insertSort(int[] a) {\n        int Temp;\n        for (int i = 1; i < a.length; i++) { //注意是从i=1开始的\n            Temp = a[i];                    //必须要用Temp 否则移动过程中会改变a[i]的值\n            int j;\n            for (j = i - 1; j >= 0; j--) {  //从已经排好的序列中的末尾（即最大的开始比较），即是从0~i-1与a[j]比较 \n                if (a[j] > Temp)\n                    a[j + 1] = a[j];\n                else {\n                    a[j + 1] = Temp; //因为之前j--了一次\n                    break;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] a = {1, 2, 4, 623, 1, 132, 634, 2, 3, 4};\n        insertSort(a);\n        for (int i : a) {\n            System.out.println(i);\n        }\n    }\n}\n````\n\n<br>\n\n***      \n\n<br>\n\n### 3快速排序\n* <https://www.bilibili.com/video/BV1at411T75o/>\n#### 3.1原理简述\n* 找一个基准数，将大于这个基准数的数放在右边，小于它的放在其左边\n* ![快速排序](https://images.xiaozhuanlan.com/photo/2018/b12fc88b3e00ae442d0d07f36eae73ee.gif)      \n#### 3.2源代码\n```java\n    public class QuickSort {\n\n        private static void quickSort(int[] a, int left, int right) {\n    //        将a分成一边大的，一边小的，重复执行这个过程\n            if (left < right) {\n                int index = getIndex(a, left, right);\n                quickSort(a, left, index - 1);\n                quickSort(a, index + 1, right);\n            }\n        }\n\n        private static int getIndex(int[] a, int left, int right) {\n\n            int standard = a[left]; // 基准数据\n            while (left < right) {\n                while (left < right && a[right] >= standard) { //必须要 >= 不然 =等于那个得不到处理 left也指不到这边\n                    right--;                                   // 当队尾的元素大于等于基准数据时,向前挪动high指针\n                }\n                a[left] = a[right];                            //将小于基准数据的值放到左边（小的一边）\n                while (left < right && a[left] <= standard) {\n                    left++;\n                }\n                a[right] = a[left];                           //将大于基准数据的值放到右边（大的一边）\n            }\n            a[left] = standard;                               //此时left==right 同时这个位置也是standard的位置\n            return left;\n        }\n\n        public static void main(String[] args) {\n            int[] a = {1, 2, 4, 2, 21, 563, 1, 6246, 13, 4331};\n            quickSort(a, 0, a.length - 1);\n            for (int i : a) {\n                System.out.println(i);\n            }\n        }\n    }\n```\n    \n<br>\n\n***      \n\n<br>\n\n### 4选择排序\n\n#### 4.1原理简述：\n    \n>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 \n\n* ![选择排序](![](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/1433219824.gif)\n    \n#### 4.2源代码\n````java\n    public class SelectSort {\n        private static void select(int[] a) {\n            for (int i = 0; i < a.length; ++i) {\n                int index = i;\n                for (int j = i + 1; j < a.length; j++) {\n                    if (a[index] > a[j]) {\n                        index = j; // 找到当前循环中最小的数的索引\n                    }\n                }\n                int temp = a[index];\n                a[index] = a[i];\n                a[i] = temp;\n            }\n        }\n\n        public static void main(String[] args) {\n\n            int[] a = {2, 1, 63, 2, 12, 7, 3, 12, 78, 6, 43};\n            select(a);\n            for (int i : a) {\n                System.out.println(i);\n            }\n\n        }\n    }\n\n````\n\n<br>\n\n***      \n\n<br>\n\n### 5希尔排序\n* [希尔排序](https://www.bilibili.com/video/BV1rE411g7rW/)\n#### 5.1原理简述\n\n>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。\n\n![希尔排序](![](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/1192699-20180319094116040-1638766271.png)\n    \n#### 5.2源代码\n````java\n    public class ShellSort {\n        private static void shell(int[] a) {\n            int gap = a.length / 2;  //增量，每隔gap为一组\n            while (gap >= 1) {\n                for (int i = gap; i < a.length; i++) { //依次遍历每一组 i=gap是因为后面的j-gap才有意义\n                    int j = i;\n                    while (j - gap >= 0 && a[j] < a[j - gap]) { //遍历每一组 如何发现后面的小于前面的则交换\n                        int temp = a[j];                        //这里不采用每次给j+gap是因为 会有gap个a[j]遍历不到 换种方法也会比较麻烦\n                        a[j] = a[j - gap];\n                    a[j - gap] = temp;\n\n                        j = j - gap;\n                    }\n                }\n                gap = gap / 2;\n            }\n    }\n\n        public static void main(String[] args) {\n            int[] a = {3, 2, 5, 7, 43, 12, 15, 33, 15, 2, 12, 14, 3};\n            shell(a);\n            for (int i : a) {\n                System.out.println(i);\n            }\n        }\n    }\n````\n\n\n> 图片来源于网络，如有侵权请联系我删除，谢谢。<br>\n>参考：<https://www.sohu.com/a/299382768_478315><br>\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<https://www.cnblogs.com/guoyaohua/p/8600214.html>\n>","slug":"Arithmetic/排序算法","published":1,"date":"2021-08-09T10:06:58.752Z","updated":"2020-08-14T15:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1ew00160w7t4tztdkeg","content":"<ul>\n<li>冒泡排序</li>\n<li>插入排序</li>\n<li>快速排序</li>\n<li>选择排序</li>\n<li>希尔排序</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"1冒泡排序\"><a href=\"#1冒泡排序\" class=\"headerlink\" title=\"1冒泡排序\"></a>1冒泡排序</h3><h4 id=\"1-1-原理\"><a href=\"#1-1-原理\" class=\"headerlink\" title=\"1.1 原理\"></a>1.1 原理</h4><blockquote>\n<p>每轮循环 多次两两比较选出一个最大的排在最后面</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY\" alt=\"冒泡排序\"></p>\n<h4 id=\"1-2-原码\"><a href=\"#1-2-原码\" class=\"headerlink\" title=\"1.2 原码\"></a>1.2 原码</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n* Description TODO 冒泡排序\n* Author Cloudr\n* Date 2020/4/1 22:43\n**/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BubbleSort</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">bubbleSorts</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> temp<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>       <span class=\"token comment\" spellcheck=\"true\">//每轮都是把最大的数排到最后 注意是 a.length-1 因为下文有一个j+1</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">-</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//每次需要排的个数减少i个</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    temp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">253</span><span class=\"token punctuation\">,</span> <span class=\"token number\">56</span><span class=\"token punctuation\">,</span> <span class=\"token number\">745</span><span class=\"token punctuation\">,</span> <span class=\"token number\">342</span><span class=\"token punctuation\">,</span> <span class=\"token number\">41</span><span class=\"token punctuation\">,</span> <span class=\"token number\">654</span><span class=\"token punctuation\">,</span> <span class=\"token number\">321432</span><span class=\"token punctuation\">,</span> <span class=\"token number\">131</span><span class=\"token punctuation\">,</span> <span class=\"token number\">324</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">bubbleSorts</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">:</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"1-3-复杂度\"><a href=\"#1-3-复杂度\" class=\"headerlink\" title=\"1.3 复杂度\"></a>1.3 复杂度</h4><pre><code>* 时间复杂度</code></pre><br>\n\n<hr>\n<br>\n\n<h3 id=\"2直接插入排序\"><a href=\"#2直接插入排序\" class=\"headerlink\" title=\"2直接插入排序\"></a>2直接插入排序</h3><h4 id=\"2-1-原理\"><a href=\"#2-1-原理\" class=\"headerlink\" title=\"2.1 原理\"></a>2.1 原理</h4><blockquote>\n<p>直接插入排序是将未排序的数据插入至已排好序序列的合适位置。<br><br>具体流程如下：<br><br>1、首先比较数组的前两个数据，并排序；<br><br>2、比较第三个元素与前两个排好序的数据，并将第三个元素放入适当的位置；<br><br>3、比较第四个元素与前三个排好序的数据，并将第四个元素放入适当的位置；<br><br>……<br><br>4、直至把最后一个元素放入适当的位置。<br></p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11016594-150b6c462e3ed809.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/471\" alt=\"直接插入排序\"><br><img src=\"http://5b0988e595225.cdn.sohucs.com/images/20190306/4eb688dec144457ea32f03e247ce0678.gif\" alt=\"直接插入排序\"></p>\n<h4 id=\"2-2-代码\"><a href=\"#2-2-代码\" class=\"headerlink\" title=\"2.2 代码\"></a>2.2 代码</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">insertSort</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">insertSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> Temp<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//注意是从i=1开始的</span>\n            Temp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>                    <span class=\"token comment\" spellcheck=\"true\">//必须要用Temp 否则移动过程中会改变a[i]的值</span>\n            <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">//从已经排好的序列中的末尾（即最大的开始比较），即是从0~i-1与a[j]比较 </span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> Temp<span class=\"token punctuation\">)</span>\n                    a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Temp<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//因为之前j--了一次</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">623</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">132</span><span class=\"token punctuation\">,</span> <span class=\"token number\">634</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">insertSort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">:</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"3快速排序\"><a href=\"#3快速排序\" class=\"headerlink\" title=\"3快速排序\"></a>3快速排序</h3><ul>\n<li><p><a href=\"https://www.bilibili.com/video/BV1at411T75o/\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1at411T75o/</a></p>\n<h4 id=\"3-1原理简述\"><a href=\"#3-1原理简述\" class=\"headerlink\" title=\"3.1原理简述\"></a>3.1原理简述</h4></li>\n<li><p>找一个基准数，将大于这个基准数的数放在右边，小于它的放在其左边</p>\n</li>\n<li><p><img src=\"https://images.xiaozhuanlan.com/photo/2018/b12fc88b3e00ae442d0d07f36eae73ee.gif\" alt=\"快速排序\">      </p>\n<h4 id=\"3-2源代码\"><a href=\"#3-2源代码\" class=\"headerlink\" title=\"3.2源代码\"></a>3.2源代码</h4><pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">QuickSort</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">//        将a分成一边大的，一边小的，重复执行这个过程</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token function\">getIndex</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> index <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getIndex</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n          <span class=\"token keyword\">int</span> standard <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 基准数据</span>\n          <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> standard<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//必须要 >= 不然 =等于那个得不到处理 left也指不到这边</span>\n                  right<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>                                   <span class=\"token comment\" spellcheck=\"true\">// 当队尾的元素大于等于基准数据时,向前挪动high指针</span>\n              <span class=\"token punctuation\">}</span>\n              a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>                            <span class=\"token comment\" spellcheck=\"true\">//将小于基准数据的值放到左边（小的一边）</span>\n              <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> standard<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span>\n              a<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>                           <span class=\"token comment\" spellcheck=\"true\">//将大于基准数据的值放到右边（大的一边）</span>\n          <span class=\"token punctuation\">}</span>\n          a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> standard<span class=\"token punctuation\">;</span>                               <span class=\"token comment\" spellcheck=\"true\">//此时left==right 同时这个位置也是standard的位置</span>\n          <span class=\"token keyword\">return</span> left<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">21</span><span class=\"token punctuation\">,</span> <span class=\"token number\">563</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6246</span><span class=\"token punctuation\">,</span> <span class=\"token number\">13</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4331</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">:</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"4选择排序\"><a href=\"#4选择排序\" class=\"headerlink\" title=\"4选择排序\"></a>4选择排序</h3><h4 id=\"4-1原理简述：\"><a href=\"#4-1原理简述：\" class=\"headerlink\" title=\"4.1原理简述：\"></a>4.1原理简述：</h4><blockquote>\n<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>\n</blockquote>\n<ul>\n<li><img src=\"!%5B%5D(https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/1433219824.gif\" alt=\"选择排序\"></li>\n</ul>\n<h4 id=\"4-2源代码\"><a href=\"#4-2源代码\" class=\"headerlink\" title=\"4.2源代码\"></a>4.2源代码</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SelectSort</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        index <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 找到当前循环中最小的数的索引</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                a<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">63</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token number\">78</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">43</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">select</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">:</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"5希尔排序\"><a href=\"#5希尔排序\" class=\"headerlink\" title=\"5希尔排序\"></a>5希尔排序</h3><ul>\n<li><a href=\"https://www.bilibili.com/video/BV1rE411g7rW/\" target=\"_blank\" rel=\"noopener\">希尔排序</a><h4 id=\"5-1原理简述\"><a href=\"#5-1原理简述\" class=\"headerlink\" title=\"5.1原理简述\"></a>5.1原理简述</h4></li>\n</ul>\n<blockquote>\n<p>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>\n</blockquote>\n<p><img src=\"!%5B%5D(https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/1192699-20180319094116040-1638766271.png\" alt=\"希尔排序\"></p>\n<h4 id=\"5-2源代码\"><a href=\"#5-2源代码\" class=\"headerlink\" title=\"5.2源代码\"></a>5.2源代码</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ShellSort</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">shell</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> gap <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>length <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//增量，每隔gap为一组</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>gap <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> gap<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//依次遍历每一组 i=gap是因为后面的j-gap才有意义</span>\n                    <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> gap <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> gap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//遍历每一组 如何发现后面的小于前面的则交换</span>\n                        <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>                        <span class=\"token comment\" spellcheck=\"true\">//这里不采用每次给j+gap是因为 会有gap个a[j]遍历不到 换种方法也会比较麻烦</span>\n                        a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> gap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> gap<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n\n                        j <span class=\"token operator\">=</span> j <span class=\"token operator\">-</span> gap<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n                gap <span class=\"token operator\">=</span> gap <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">43</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">,</span> <span class=\"token number\">33</span><span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token number\">14</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">shell</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">:</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<blockquote>\n<p>图片来源于网络，如有侵权请联系我删除，谢谢。<br><br>参考：<a href=\"https://www.sohu.com/a/299382768_478315\" target=\"_blank\" rel=\"noopener\">https://www.sohu.com/a/299382768_478315</a><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://www.cnblogs.com/guoyaohua/p/8600214.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<ul>\n<li>冒泡排序</li>\n<li>插入排序</li>\n<li>快速排序</li>\n<li>选择排序</li>\n<li>希尔排序</li>\n</ul>","more":"<h3 id=\"1冒泡排序\"><a href=\"#1冒泡排序\" class=\"headerlink\" title=\"1冒泡排序\"></a>1冒泡排序</h3><h4 id=\"1-1-原理\"><a href=\"#1-1-原理\" class=\"headerlink\" title=\"1.1 原理\"></a>1.1 原理</h4><blockquote>\n<p>每轮循环 多次两两比较选出一个最大的排在最后面</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY\" alt=\"冒泡排序\"></p>\n<h4 id=\"1-2-原码\"><a href=\"#1-2-原码\" class=\"headerlink\" title=\"1.2 原码\"></a>1.2 原码</h4><pre><code class=\"java\">/**\n* Description TODO 冒泡排序\n* Author Cloudr\n* Date 2020/4/1 22:43\n**/\npublic class BubbleSort {\n    private static void bubbleSorts(int[] a) {\n\n        int i, j, temp;\n\n        for (i = 0; i &lt; a.length - 1; i++) {       //每轮都是把最大的数排到最后 注意是 a.length-1 因为下文有一个j+1\n            for (j = 0; j &lt; a.length - 1 - i; j++) { //每次需要排的个数减少i个\n                if (a[j] &gt; a[j + 1]) {\n                    temp = a[j + 1];\n                    a[j + 1] = a[j];\n                    a[j] = temp;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] a = {1, 253, 56, 745, 342, 41, 654, 321432, 131, 324};\n        bubbleSorts(a);\n        for (int i : a) {\n            System.out.println(i);\n        }\n    }\n}</code></pre>\n<h4 id=\"1-3-复杂度\"><a href=\"#1-3-复杂度\" class=\"headerlink\" title=\"1.3 复杂度\"></a>1.3 复杂度</h4><pre><code>* 时间复杂度</code></pre><br>\n\n<hr>\n<br>\n\n<h3 id=\"2直接插入排序\"><a href=\"#2直接插入排序\" class=\"headerlink\" title=\"2直接插入排序\"></a>2直接插入排序</h3><h4 id=\"2-1-原理\"><a href=\"#2-1-原理\" class=\"headerlink\" title=\"2.1 原理\"></a>2.1 原理</h4><blockquote>\n<p>直接插入排序是将未排序的数据插入至已排好序序列的合适位置。<br><br>具体流程如下：<br><br>1、首先比较数组的前两个数据，并排序；<br><br>2、比较第三个元素与前两个排好序的数据，并将第三个元素放入适当的位置；<br><br>3、比较第四个元素与前三个排好序的数据，并将第四个元素放入适当的位置；<br><br>……<br><br>4、直至把最后一个元素放入适当的位置。<br></p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11016594-150b6c462e3ed809.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/471\" alt=\"直接插入排序\"><br><img src=\"http://5b0988e595225.cdn.sohucs.com/images/20190306/4eb688dec144457ea32f03e247ce0678.gif\" alt=\"直接插入排序\"></p>\n<h4 id=\"2-2-代码\"><a href=\"#2-2-代码\" class=\"headerlink\" title=\"2.2 代码\"></a>2.2 代码</h4><pre><code class=\"java\">public class insertSort {\n    private static void insertSort(int[] a) {\n        int Temp;\n        for (int i = 1; i &lt; a.length; i++) { //注意是从i=1开始的\n            Temp = a[i];                    //必须要用Temp 否则移动过程中会改变a[i]的值\n            int j;\n            for (j = i - 1; j &gt;= 0; j--) {  //从已经排好的序列中的末尾（即最大的开始比较），即是从0~i-1与a[j]比较 \n                if (a[j] &gt; Temp)\n                    a[j + 1] = a[j];\n                else {\n                    a[j + 1] = Temp; //因为之前j--了一次\n                    break;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] a = {1, 2, 4, 623, 1, 132, 634, 2, 3, 4};\n        insertSort(a);\n        for (int i : a) {\n            System.out.println(i);\n        }\n    }\n}</code></pre>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"3快速排序\"><a href=\"#3快速排序\" class=\"headerlink\" title=\"3快速排序\"></a>3快速排序</h3><ul>\n<li><p><a href=\"https://www.bilibili.com/video/BV1at411T75o/\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1at411T75o/</a></p>\n<h4 id=\"3-1原理简述\"><a href=\"#3-1原理简述\" class=\"headerlink\" title=\"3.1原理简述\"></a>3.1原理简述</h4></li>\n<li><p>找一个基准数，将大于这个基准数的数放在右边，小于它的放在其左边</p>\n</li>\n<li><p><img src=\"https://images.xiaozhuanlan.com/photo/2018/b12fc88b3e00ae442d0d07f36eae73ee.gif\" alt=\"快速排序\">      </p>\n<h4 id=\"3-2源代码\"><a href=\"#3-2源代码\" class=\"headerlink\" title=\"3.2源代码\"></a>3.2源代码</h4><pre><code class=\"java\">  public class QuickSort {\n\n      private static void quickSort(int[] a, int left, int right) {\n  //        将a分成一边大的，一边小的，重复执行这个过程\n          if (left &lt; right) {\n              int index = getIndex(a, left, right);\n              quickSort(a, left, index - 1);\n              quickSort(a, index + 1, right);\n          }\n      }\n\n      private static int getIndex(int[] a, int left, int right) {\n\n          int standard = a[left]; // 基准数据\n          while (left &lt; right) {\n              while (left &lt; right &amp;&amp; a[right] &gt;= standard) { //必须要 &gt;= 不然 =等于那个得不到处理 left也指不到这边\n                  right--;                                   // 当队尾的元素大于等于基准数据时,向前挪动high指针\n              }\n              a[left] = a[right];                            //将小于基准数据的值放到左边（小的一边）\n              while (left &lt; right &amp;&amp; a[left] &lt;= standard) {\n                  left++;\n              }\n              a[right] = a[left];                           //将大于基准数据的值放到右边（大的一边）\n          }\n          a[left] = standard;                               //此时left==right 同时这个位置也是standard的位置\n          return left;\n      }\n\n      public static void main(String[] args) {\n          int[] a = {1, 2, 4, 2, 21, 563, 1, 6246, 13, 4331};\n          quickSort(a, 0, a.length - 1);\n          for (int i : a) {\n              System.out.println(i);\n          }\n      }\n  }</code></pre>\n</li>\n</ul>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"4选择排序\"><a href=\"#4选择排序\" class=\"headerlink\" title=\"4选择排序\"></a>4选择排序</h3><h4 id=\"4-1原理简述：\"><a href=\"#4-1原理简述：\" class=\"headerlink\" title=\"4.1原理简述：\"></a>4.1原理简述：</h4><blockquote>\n<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>\n</blockquote>\n<ul>\n<li><img src=\"!%5B%5D(https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/1433219824.gif\" alt=\"选择排序\"></li>\n</ul>\n<h4 id=\"4-2源代码\"><a href=\"#4-2源代码\" class=\"headerlink\" title=\"4.2源代码\"></a>4.2源代码</h4><pre><code class=\"java\">    public class SelectSort {\n        private static void select(int[] a) {\n            for (int i = 0; i &lt; a.length; ++i) {\n                int index = i;\n                for (int j = i + 1; j &lt; a.length; j++) {\n                    if (a[index] &gt; a[j]) {\n                        index = j; // 找到当前循环中最小的数的索引\n                    }\n                }\n                int temp = a[index];\n                a[index] = a[i];\n                a[i] = temp;\n            }\n        }\n\n        public static void main(String[] args) {\n\n            int[] a = {2, 1, 63, 2, 12, 7, 3, 12, 78, 6, 43};\n            select(a);\n            for (int i : a) {\n                System.out.println(i);\n            }\n\n        }\n    }\n</code></pre>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"5希尔排序\"><a href=\"#5希尔排序\" class=\"headerlink\" title=\"5希尔排序\"></a>5希尔排序</h3><ul>\n<li><a href=\"https://www.bilibili.com/video/BV1rE411g7rW/\" target=\"_blank\" rel=\"noopener\">希尔排序</a><h4 id=\"5-1原理简述\"><a href=\"#5-1原理简述\" class=\"headerlink\" title=\"5.1原理简述\"></a>5.1原理简述</h4></li>\n</ul>\n<blockquote>\n<p>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>\n</blockquote>\n<p><img src=\"!%5B%5D(https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/1192699-20180319094116040-1638766271.png\" alt=\"希尔排序\"></p>\n<h4 id=\"5-2源代码\"><a href=\"#5-2源代码\" class=\"headerlink\" title=\"5.2源代码\"></a>5.2源代码</h4><pre><code class=\"java\">    public class ShellSort {\n        private static void shell(int[] a) {\n            int gap = a.length / 2;  //增量，每隔gap为一组\n            while (gap &gt;= 1) {\n                for (int i = gap; i &lt; a.length; i++) { //依次遍历每一组 i=gap是因为后面的j-gap才有意义\n                    int j = i;\n                    while (j - gap &gt;= 0 &amp;&amp; a[j] &lt; a[j - gap]) { //遍历每一组 如何发现后面的小于前面的则交换\n                        int temp = a[j];                        //这里不采用每次给j+gap是因为 会有gap个a[j]遍历不到 换种方法也会比较麻烦\n                        a[j] = a[j - gap];\n                    a[j - gap] = temp;\n\n                        j = j - gap;\n                    }\n                }\n                gap = gap / 2;\n            }\n    }\n\n        public static void main(String[] args) {\n            int[] a = {3, 2, 5, 7, 43, 12, 15, 33, 15, 2, 12, 14, 3};\n            shell(a);\n            for (int i : a) {\n                System.out.println(i);\n            }\n        }\n    }</code></pre>\n<blockquote>\n<p>图片来源于网络，如有侵权请联系我删除，谢谢。<br><br>参考：<a href=\"https://www.sohu.com/a/299382768_478315\" target=\"_blank\" rel=\"noopener\">https://www.sohu.com/a/299382768_478315</a><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://www.cnblogs.com/guoyaohua/p/8600214.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></p>\n</blockquote>"},{"title":"红黑树","declare":true,"wordCount":true,"abbrlink":"f89cb603","data":"2020-08-01T14:55:10.000Z","_content":"<div style=\"width: 95%\">\n\n![左右旋转](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/左右旋.png)\n</div>\n<!-- more -->\n\n[程序员司马讲解二叉树(B站)](https://www.bilibili.com/video/BV1tE411f7tP?p=3)     \n**遍历->二分法->二叉树->二叉查找树->红黑树(自平衡的二叉查找树)->二叉平衡树(理想状态)**\n## 红黑树性质\n* 每一个结点不是红色就是黑色\n* 红色结点不能够连接在一起\n* 根节点必须为黑色\n* 叶子结点均为黑色\n>注意最后一个是NULL,所以表面上叶子结点为红色，但其实是没有问题的\n\n## 红黑树的变换规则\n所有插入的点默认都是红色，否则全黑色就是普通二叉树了，下一步也就无法按照规律变换以达到自平衡。\n\n1. 变色规则\n当前结点是红色，父结点是红色，且它的叔叔结点也是红色(**自红，父红，叔叔红**)\n\t1. 把父结点设为黑色    \n\t2. 把叔叔结点设为黑色   \n\t3. 把祖父结点设为红色         \n\t4. 把指针结点定义到祖父结点设为当前要操作的，分析的点变换的规则（此时可能是要左右旋）\n2. 左旋      \n* 当前结点是右子树，且是红色      \n* 父结点是红色     \n* 叔叔结点是黑色（**右红，父红，叔叔黑**）        \n以**父结点**左旋\n3. 右旋\n当前节结点是左子树，红色，父结点红色，叔叔黑色。（**左红，父红，叔叔黑**）    \n* 把父结点变为黑色    \n* 把祖父变为红色    \n* 以**祖父为结点**右旋\n\n## 参考\n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.bilibili.com/video/BV1tE411f7tP?p=3\">https://www.bilibili.com/video/BV1tE411f7tP?p=3</a><br>\n</div>\n\n","source":"_posts/Arithmetic/红黑树.md","raw":"---\ntitle: 红黑树\ncategories: Airthmetic\ntags: 数据结构\ndeclare: true\nwordCount: true\nabbrlink: f89cb603\ndata: 2020-08-01 22:55:10\n---\n<div style=\"width: 95%\">\n\n![左右旋转](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/左右旋.png)\n</div>\n<!-- more -->\n\n[程序员司马讲解二叉树(B站)](https://www.bilibili.com/video/BV1tE411f7tP?p=3)     \n**遍历->二分法->二叉树->二叉查找树->红黑树(自平衡的二叉查找树)->二叉平衡树(理想状态)**\n## 红黑树性质\n* 每一个结点不是红色就是黑色\n* 红色结点不能够连接在一起\n* 根节点必须为黑色\n* 叶子结点均为黑色\n>注意最后一个是NULL,所以表面上叶子结点为红色，但其实是没有问题的\n\n## 红黑树的变换规则\n所有插入的点默认都是红色，否则全黑色就是普通二叉树了，下一步也就无法按照规律变换以达到自平衡。\n\n1. 变色规则\n当前结点是红色，父结点是红色，且它的叔叔结点也是红色(**自红，父红，叔叔红**)\n\t1. 把父结点设为黑色    \n\t2. 把叔叔结点设为黑色   \n\t3. 把祖父结点设为红色         \n\t4. 把指针结点定义到祖父结点设为当前要操作的，分析的点变换的规则（此时可能是要左右旋）\n2. 左旋      \n* 当前结点是右子树，且是红色      \n* 父结点是红色     \n* 叔叔结点是黑色（**右红，父红，叔叔黑**）        \n以**父结点**左旋\n3. 右旋\n当前节结点是左子树，红色，父结点红色，叔叔黑色。（**左红，父红，叔叔黑**）    \n* 把父结点变为黑色    \n* 把祖父变为红色    \n* 以**祖父为结点**右旋\n\n## 参考\n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.bilibili.com/video/BV1tE411f7tP?p=3\">https://www.bilibili.com/video/BV1tE411f7tP?p=3</a><br>\n</div>\n\n","slug":"Arithmetic/红黑树","published":1,"date":"2021-08-09T10:06:58.755Z","updated":"2020-08-01T14:52:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1ex00190w7t3f5c05bl","content":"<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%B7%A6%E5%8F%B3%E6%97%8B.png\" alt=\"左右旋转\"></p>\n</div>\n<a id=\"more\"></a>\n\n<p><a href=\"https://www.bilibili.com/video/BV1tE411f7tP?p=3\" target=\"_blank\" rel=\"noopener\">程序员司马讲解二叉树(B站)</a><br><strong>遍历-&gt;二分法-&gt;二叉树-&gt;二叉查找树-&gt;红黑树(自平衡的二叉查找树)-&gt;二叉平衡树(理想状态)</strong></p>\n<h2 id=\"红黑树性质\"><a href=\"#红黑树性质\" class=\"headerlink\" title=\"红黑树性质\"></a>红黑树性质</h2><ul>\n<li>每一个结点不是红色就是黑色</li>\n<li>红色结点不能够连接在一起</li>\n<li>根节点必须为黑色</li>\n<li>叶子结点均为黑色<blockquote>\n<p>注意最后一个是NULL,所以表面上叶子结点为红色，但其实是没有问题的</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"红黑树的变换规则\"><a href=\"#红黑树的变换规则\" class=\"headerlink\" title=\"红黑树的变换规则\"></a>红黑树的变换规则</h2><p>所有插入的点默认都是红色，否则全黑色就是普通二叉树了，下一步也就无法按照规律变换以达到自平衡。</p>\n<ol>\n<li>变色规则<br>当前结点是红色，父结点是红色，且它的叔叔结点也是红色(<strong>自红，父红，叔叔红</strong>)<ol>\n<li>把父结点设为黑色    </li>\n<li>把叔叔结点设为黑色   </li>\n<li>把祖父结点设为红色         </li>\n<li>把指针结点定义到祖父结点设为当前要操作的，分析的点变换的规则（此时可能是要左右旋）</li>\n</ol>\n</li>\n<li>左旋      </li>\n</ol>\n<ul>\n<li>当前结点是右子树，且是红色      </li>\n<li>父结点是红色     </li>\n<li>叔叔结点是黑色（<strong>右红，父红，叔叔黑</strong>）<br>以<strong>父结点</strong>左旋</li>\n</ul>\n<ol start=\"3\">\n<li>右旋<br>当前节结点是左子树，红色，父结点红色，叔叔黑色。（<strong>左红，父红，叔叔黑</strong>）    </li>\n</ol>\n<ul>\n<li>把父结点变为黑色    </li>\n<li>把祖父变为红色    </li>\n<li>以<strong>祖父为结点</strong>右旋</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.bilibili.com/video/BV1tE411f7tP?p=3\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1tE411f7tP?p=3</a><br>\n</div>\n\n","site":{"data":{}},"excerpt":"<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%B7%A6%E5%8F%B3%E6%97%8B.png\" alt=\"左右旋转\"></p>\n</div>","more":"<p><a href=\"https://www.bilibili.com/video/BV1tE411f7tP?p=3\" target=\"_blank\" rel=\"noopener\">程序员司马讲解二叉树(B站)</a><br><strong>遍历-&gt;二分法-&gt;二叉树-&gt;二叉查找树-&gt;红黑树(自平衡的二叉查找树)-&gt;二叉平衡树(理想状态)</strong></p>\n<h2 id=\"红黑树性质\"><a href=\"#红黑树性质\" class=\"headerlink\" title=\"红黑树性质\"></a>红黑树性质</h2><ul>\n<li>每一个结点不是红色就是黑色</li>\n<li>红色结点不能够连接在一起</li>\n<li>根节点必须为黑色</li>\n<li>叶子结点均为黑色<blockquote>\n<p>注意最后一个是NULL,所以表面上叶子结点为红色，但其实是没有问题的</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"红黑树的变换规则\"><a href=\"#红黑树的变换规则\" class=\"headerlink\" title=\"红黑树的变换规则\"></a>红黑树的变换规则</h2><p>所有插入的点默认都是红色，否则全黑色就是普通二叉树了，下一步也就无法按照规律变换以达到自平衡。</p>\n<ol>\n<li>变色规则<br>当前结点是红色，父结点是红色，且它的叔叔结点也是红色(<strong>自红，父红，叔叔红</strong>)<ol>\n<li>把父结点设为黑色    </li>\n<li>把叔叔结点设为黑色   </li>\n<li>把祖父结点设为红色         </li>\n<li>把指针结点定义到祖父结点设为当前要操作的，分析的点变换的规则（此时可能是要左右旋）</li>\n</ol>\n</li>\n<li>左旋      </li>\n</ol>\n<ul>\n<li>当前结点是右子树，且是红色      </li>\n<li>父结点是红色     </li>\n<li>叔叔结点是黑色（<strong>右红，父红，叔叔黑</strong>）<br>以<strong>父结点</strong>左旋</li>\n</ul>\n<ol start=\"3\">\n<li>右旋<br>当前节结点是左子树，红色，父结点红色，叔叔黑色。（<strong>左红，父红，叔叔黑</strong>）    </li>\n</ol>\n<ul>\n<li>把父结点变为黑色    </li>\n<li>把祖父变为红色    </li>\n<li>以<strong>祖父为结点</strong>右旋</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.bilibili.com/video/BV1tE411f7tP?p=3\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1tE411f7tP?p=3</a><br>\n</div>"},{"title":"Hexo+Ocean添加字数统计","abbrlink":26565,"data":"2020-04-26T11:52:10.000Z","declare":true,"wordCount":true,"_content":"❄\n<!-- more -->\n\n### 1. `themes\\ocean\\layout\\_partial`路径下创建文件`word-count.ejs`,并输入以下代码：\n```javascript\n    <div style=\"margin-top:10px;\">\n        <span class=\"post-time\">\n            <span class=\"post-meta-item-icon\">\n                <i class=\"fa fa-keyboard-o\"></i>\n                <span class=\"post-meta-item-text\"> words count: </span>\n                <span class=\"post-count\"><%= wordcount(post.content) %></span>\n            </span>\n        </span>\n\n        <span class=\"post-time\">\n            &nbsp; | &nbsp;\n            <span class=\"post-meta-item-icon\">\n                <i class=\"fa fa-hourglass-half\"></i>\n                <span class=\"post-meta-item-text\"> expected cost: </span>\n                <span class=\"post-count\"><%= min2read(post.content) >1 ? min2read(post.content)+\" minutes\" : min2read(post.content)+\" minute\"%> </span>\n            </span>\n        </span>\n    </div>\n```\n### 2. 在`themes\\ocean\\layout\\_partial\\article.ejs`中添加以下代码\n```javascript\n    <!-- 开始添加字数统计-->\n    <% if(theme.word_count ){%>\n    <%- partial('word-count') %>\n    <% } %>\n    <!-- 结束 -->\n```\n* 具体位置是在`article-inner`的div中的header中，例如我的位置是\n    <img style=\"align:left\" src=\"https://i.loli.net/2020/04/26/MQ8jy37rkt5eLuD.png\" width=\"70%\">\n\n### 3. 在主题配置文件`themes\\ocean\\_config.yml`中添加    \n```javascript\n    word_count: true\n```\n\n### 4. `hexo clean & hexo g & hexo s`\n\n\n\n### 5. 总结：\n* 创建一个ejs用来渲染前端显示的具体内容\n* 设定ejs作用位置\n* 创建一个变量选择是否开启此功能\n    > 纯前端小白简单理解，期望与各路大佬多多交流\n\n<br>\n<br>\n<br>\n\n> 网络上都是以next的配置为主，但next很多是主题作者预先放置好的，所以作者找到了这篇为yilia添加此功能的，做了微小改动。    \n> 参考 <https://chocolate.blog.csdn.net/article/details/104262008>","source":"_posts/code/Hexo+Ocean添加字数统计.md","raw":"---\ntitle: Hexo+Ocean添加字数统计\ncategories: Construct Blog\n# photos:\n#   - - 'https://i.loli.net/2020/04/26/CJeY94S82GitImM.png'\nabbrlink: 26565\ndata: 2020-04-26 19:52:10\ndeclare: true\nwordCount: true\n---\n❄\n<!-- more -->\n\n### 1. `themes\\ocean\\layout\\_partial`路径下创建文件`word-count.ejs`,并输入以下代码：\n```javascript\n    <div style=\"margin-top:10px;\">\n        <span class=\"post-time\">\n            <span class=\"post-meta-item-icon\">\n                <i class=\"fa fa-keyboard-o\"></i>\n                <span class=\"post-meta-item-text\"> words count: </span>\n                <span class=\"post-count\"><%= wordcount(post.content) %></span>\n            </span>\n        </span>\n\n        <span class=\"post-time\">\n            &nbsp; | &nbsp;\n            <span class=\"post-meta-item-icon\">\n                <i class=\"fa fa-hourglass-half\"></i>\n                <span class=\"post-meta-item-text\"> expected cost: </span>\n                <span class=\"post-count\"><%= min2read(post.content) >1 ? min2read(post.content)+\" minutes\" : min2read(post.content)+\" minute\"%> </span>\n            </span>\n        </span>\n    </div>\n```\n### 2. 在`themes\\ocean\\layout\\_partial\\article.ejs`中添加以下代码\n```javascript\n    <!-- 开始添加字数统计-->\n    <% if(theme.word_count ){%>\n    <%- partial('word-count') %>\n    <% } %>\n    <!-- 结束 -->\n```\n* 具体位置是在`article-inner`的div中的header中，例如我的位置是\n    <img style=\"align:left\" src=\"https://i.loli.net/2020/04/26/MQ8jy37rkt5eLuD.png\" width=\"70%\">\n\n### 3. 在主题配置文件`themes\\ocean\\_config.yml`中添加    \n```javascript\n    word_count: true\n```\n\n### 4. `hexo clean & hexo g & hexo s`\n\n\n\n### 5. 总结：\n* 创建一个ejs用来渲染前端显示的具体内容\n* 设定ejs作用位置\n* 创建一个变量选择是否开启此功能\n    > 纯前端小白简单理解，期望与各路大佬多多交流\n\n<br>\n<br>\n<br>\n\n> 网络上都是以next的配置为主，但next很多是主题作者预先放置好的，所以作者找到了这篇为yilia添加此功能的，做了微小改动。    \n> 参考 <https://chocolate.blog.csdn.net/article/details/104262008>","slug":"code/Hexo+Ocean添加字数统计","published":1,"date":"2021-08-09T10:06:58.765Z","updated":"2020-04-30T15:58:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1ey001c0w7t8n4b2psk","content":"<p>❄</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-themes-ocean-layout-partial路径下创建文件word-count-ejs-并输入以下代码：\"><a href=\"#1-themes-ocean-layout-partial路径下创建文件word-count-ejs-并输入以下代码：\" class=\"headerlink\" title=\"1. themes\\ocean\\layout\\_partial路径下创建文件word-count.ejs,并输入以下代码：\"></a>1. <code>themes\\ocean\\layout\\_partial</code>路径下创建文件<code>word-count.ejs</code>,并输入以下代码：</h3><pre class=\" language-javascript\"><code class=\"language-javascript\">    <span class=\"token operator\">&lt;</span>div style<span class=\"token operator\">=</span><span class=\"token string\">\"margin-top:10px;\"</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>span <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"post-time\"</span><span class=\"token operator\">></span>\n            <span class=\"token operator\">&lt;</span>span <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"post-meta-item-icon\"</span><span class=\"token operator\">></span>\n                <span class=\"token operator\">&lt;</span>i <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"fa fa-keyboard-o\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>i<span class=\"token operator\">></span>\n                <span class=\"token operator\">&lt;</span>span <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"post-meta-item-text\"</span><span class=\"token operator\">></span> words count<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n                <span class=\"token operator\">&lt;</span>span <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"post-count\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">=</span> <span class=\"token function\">wordcount</span><span class=\"token punctuation\">(</span>post<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n            <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n\n        <span class=\"token operator\">&lt;</span>span <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"post-time\"</span><span class=\"token operator\">></span>\n            <span class=\"token operator\">&amp;</span>nbsp<span class=\"token punctuation\">;</span> <span class=\"token operator\">|</span> <span class=\"token operator\">&amp;</span>nbsp<span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">&lt;</span>span <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"post-meta-item-icon\"</span><span class=\"token operator\">></span>\n                <span class=\"token operator\">&lt;</span>i <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"fa fa-hourglass-half\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>i<span class=\"token operator\">></span>\n                <span class=\"token operator\">&lt;</span>span <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"post-meta-item-text\"</span><span class=\"token operator\">></span> expected cost<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n                <span class=\"token operator\">&lt;</span>span <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"post-count\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">=</span> <span class=\"token function\">min2read</span><span class=\"token punctuation\">(</span>post<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span><span class=\"token number\">1</span> <span class=\"token operator\">?</span> <span class=\"token function\">min2read</span><span class=\"token punctuation\">(</span>post<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" minutes\"</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">min2read</span><span class=\"token punctuation\">(</span>post<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" minute\"</span><span class=\"token operator\">%</span><span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n            <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span></code></pre>\n<h3 id=\"2-在themes-ocean-layout-partial-article-ejs中添加以下代码\"><a href=\"#2-在themes-ocean-layout-partial-article-ejs中添加以下代码\" class=\"headerlink\" title=\"2. 在themes\\ocean\\layout\\_partial\\article.ejs中添加以下代码\"></a>2. 在<code>themes\\ocean\\layout\\_partial\\article.ejs</code>中添加以下代码</h3><pre class=\" language-javascript\"><code class=\"language-javascript\">    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 开始添加字数统计<span class=\"token operator\">--</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>theme<span class=\"token punctuation\">.</span>word_count <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token operator\">%</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">-</span> <span class=\"token function\">partial</span><span class=\"token punctuation\">(</span><span class=\"token string\">'word-count'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 结束 <span class=\"token operator\">--</span><span class=\"token operator\">></span></code></pre>\n<ul>\n<li>具体位置是在<code>article-inner</code>的div中的header中，例如我的位置是  <img style=\"align:left\" src=\"https://i.loli.net/2020/04/26/MQ8jy37rkt5eLuD.png\" width=\"70%\">\n\n</li>\n</ul>\n<h3 id=\"3-在主题配置文件themes-ocean-config-yml中添加\"><a href=\"#3-在主题配置文件themes-ocean-config-yml中添加\" class=\"headerlink\" title=\"3. 在主题配置文件themes\\ocean\\_config.yml中添加\"></a>3. 在主题配置文件<code>themes\\ocean\\_config.yml</code>中添加</h3><pre class=\" language-javascript\"><code class=\"language-javascript\">    word_count<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span></code></pre>\n<h3 id=\"4-hexo-clean-amp-hexo-g-amp-hexo-s\"><a href=\"#4-hexo-clean-amp-hexo-g-amp-hexo-s\" class=\"headerlink\" title=\"4. hexo clean &amp; hexo g &amp; hexo s\"></a>4. <code>hexo clean &amp; hexo g &amp; hexo s</code></h3><h3 id=\"5-总结：\"><a href=\"#5-总结：\" class=\"headerlink\" title=\"5. 总结：\"></a>5. 总结：</h3><ul>\n<li>创建一个ejs用来渲染前端显示的具体内容</li>\n<li>设定ejs作用位置</li>\n<li>创建一个变量选择是否开启此功能<blockquote>\n<p>纯前端小白简单理解，期望与各路大佬多多交流</p>\n</blockquote>\n</li>\n</ul>\n<br>\n<br>\n<br>\n\n<blockquote>\n<p>网络上都是以next的配置为主，但next很多是主题作者预先放置好的，所以作者找到了这篇为yilia添加此功能的，做了微小改动。<br>参考 <a href=\"https://chocolate.blog.csdn.net/article/details/104262008\" target=\"_blank\" rel=\"noopener\">https://chocolate.blog.csdn.net/article/details/104262008</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>❄</p>","more":"<h3 id=\"1-themes-ocean-layout-partial路径下创建文件word-count-ejs-并输入以下代码：\"><a href=\"#1-themes-ocean-layout-partial路径下创建文件word-count-ejs-并输入以下代码：\" class=\"headerlink\" title=\"1. themes\\ocean\\layout\\_partial路径下创建文件word-count.ejs,并输入以下代码：\"></a>1. <code>themes\\ocean\\layout\\_partial</code>路径下创建文件<code>word-count.ejs</code>,并输入以下代码：</h3><pre><code class=\"javascript\">    &lt;div style=&quot;margin-top:10px;&quot;&gt;\n        &lt;span class=&quot;post-time&quot;&gt;\n            &lt;span class=&quot;post-meta-item-icon&quot;&gt;\n                &lt;i class=&quot;fa fa-keyboard-o&quot;&gt;&lt;/i&gt;\n                &lt;span class=&quot;post-meta-item-text&quot;&gt; words count: &lt;/span&gt;\n                &lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;&lt;/span&gt;\n            &lt;/span&gt;\n        &lt;/span&gt;\n\n        &lt;span class=&quot;post-time&quot;&gt;\n            &amp;nbsp; | &amp;nbsp;\n            &lt;span class=&quot;post-meta-item-icon&quot;&gt;\n                &lt;i class=&quot;fa fa-hourglass-half&quot;&gt;&lt;/i&gt;\n                &lt;span class=&quot;post-meta-item-text&quot;&gt; expected cost: &lt;/span&gt;\n                &lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) &gt;1 ? min2read(post.content)+&quot; minutes&quot; : min2read(post.content)+&quot; minute&quot;%&gt; &lt;/span&gt;\n            &lt;/span&gt;\n        &lt;/span&gt;\n    &lt;/div&gt;</code></pre>\n<h3 id=\"2-在themes-ocean-layout-partial-article-ejs中添加以下代码\"><a href=\"#2-在themes-ocean-layout-partial-article-ejs中添加以下代码\" class=\"headerlink\" title=\"2. 在themes\\ocean\\layout\\_partial\\article.ejs中添加以下代码\"></a>2. 在<code>themes\\ocean\\layout\\_partial\\article.ejs</code>中添加以下代码</h3><pre><code class=\"javascript\">    &lt;!-- 开始添加字数统计--&gt;\n    &lt;% if(theme.word_count ){%&gt;\n    &lt;%- partial(&#39;word-count&#39;) %&gt;\n    &lt;% } %&gt;\n    &lt;!-- 结束 --&gt;</code></pre>\n<ul>\n<li>具体位置是在<code>article-inner</code>的div中的header中，例如我的位置是  <img style=\"align:left\" src=\"https://i.loli.net/2020/04/26/MQ8jy37rkt5eLuD.png\" width=\"70%\">\n\n</li>\n</ul>\n<h3 id=\"3-在主题配置文件themes-ocean-config-yml中添加\"><a href=\"#3-在主题配置文件themes-ocean-config-yml中添加\" class=\"headerlink\" title=\"3. 在主题配置文件themes\\ocean\\_config.yml中添加\"></a>3. 在主题配置文件<code>themes\\ocean\\_config.yml</code>中添加</h3><pre><code class=\"javascript\">    word_count: true</code></pre>\n<h3 id=\"4-hexo-clean-amp-hexo-g-amp-hexo-s\"><a href=\"#4-hexo-clean-amp-hexo-g-amp-hexo-s\" class=\"headerlink\" title=\"4. hexo clean &amp; hexo g &amp; hexo s\"></a>4. <code>hexo clean &amp; hexo g &amp; hexo s</code></h3><h3 id=\"5-总结：\"><a href=\"#5-总结：\" class=\"headerlink\" title=\"5. 总结：\"></a>5. 总结：</h3><ul>\n<li>创建一个ejs用来渲染前端显示的具体内容</li>\n<li>设定ejs作用位置</li>\n<li>创建一个变量选择是否开启此功能<blockquote>\n<p>纯前端小白简单理解，期望与各路大佬多多交流</p>\n</blockquote>\n</li>\n</ul>\n<br>\n<br>\n<br>\n\n<blockquote>\n<p>网络上都是以next的配置为主，但next很多是主题作者预先放置好的，所以作者找到了这篇为yilia添加此功能的，做了微小改动。<br>参考 <a href=\"https://chocolate.blog.csdn.net/article/details/104262008\" target=\"_blank\" rel=\"noopener\">https://chocolate.blog.csdn.net/article/details/104262008</a></p>\n</blockquote>"},{"title":"Hexo+Ocean添加版权说明","abbrlink":63423,"data":"2020-04-26T12:56:10.000Z","declare":true,"wordCount":true,"_content":"❄\n<!-- more -->\n\n### 1. `themes\\ocean\\layout\\_partial`中创建`copyright.ejs`,并输入以下代码：\n```javascript\n    <!-- 《添加版权声明 -->\n    <!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->\n    <%\n    var sUrl = url.replace(/index\\.html$/, '');\n    sUrl = /^(http:|https:)\\/\\//.test(sUrl) ? sUrl : 'https:' + sUrl;\n    %>\n\n    <!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 且如果文章对应的md文件里有declare: false 则取消此篇文章的版权声明 -->\n    <% if ((theme.declare.declare_type === 2 || (theme.declare.declare_type === 1 && copyrighty)) && !index){ %>\n    <div class=\"declare\">\n        <strong class=\"author\">本文作者：</strong>\n        <% if(config.author != undefined){ %>\n        <%= config.author%>\n        <% }else{%>\n        <font color=\"red\">请在博客根目录“_config.yml”中填入正确的“author”</font>\n        <%}%>\n        <br>\n        <!-- <strong class=\"create-time\">发布时间：</strong>\n        <%- date(post.date, 'YYYY-MM-DD') %> \n        <br> -->\n        <!-- <strong class=\"update-time\">最后更新：</strong>\n        <%- date(post.updated, 'YYYY-MM-DD') %>\n        <br> -->\n        <!-- <strong class=\"article-titles\">本文标题：</strong>\n        <a href=\"<%= config.url %>/<%= post.path %>\" title=\"<%= post.title %>\" target=\"_blank\"><%= post.title %></a>\n        <br> -->\n        <strong class=\"article-url\">本文链接：</strong>\n        <a href=\"<%= config.url %>/<%= post.path %>\" title=\"<%= post.title %>\" target=\"_blank\"><%= config.url %>/<%= post.path %></a>\n        <br>\n        <strong class=\"copyright\">版权声明：</strong>\n        本作品采用\n        <a rel=\"license\" href=\"<%= theme.declare.licensee_url%>\" title=\"<%= theme.declare.licensee_alias %>\"><%= theme.declare.licensee_name%></a>\n        许可协议进行许可。转载请注明出处！\n        <% if(theme.declare.licensee_img != undefined){ %>\n        <br>\n        <% } %>\n    </div>\n    <% } else {%>\n    <div class=\"declare\" hidden=\"hidden\"></div>\n    <% } %>\n    <!-- 添加版权声明》 -->\n```\n### 2. 在`themes\\ocean\\layout\\_partial\\article.ejs`中添加以下代码\n```javascript\n    <!-- 《添加版权声明 -->\n        <% if(theme.declare){%>\n        <%- partial('copyright') %>\n        <% } %>\n    <!-- 添加版权声明》 -->\n```\n* 具体位置是在`article-inner`的div中的`article-entry`的div块中，例如我的位置是\n<img style=\"align:left\" src=\"https://i.loli.net/2020/04/26/8uFj4Td6xCnrBtf.png\" width=\"70%\">\n\n### 3. 在`themes\\ocean\\source\\css\\style.styl`中添加：\n```stylus\n    .declare\n        background-color #eaeaea\n        margin-top 5em\n        border-left 3px solid #ff1700\n        padding .5em 1em;\n```\n\n### 4. 在主题配置文件`themes\\ocean\\_config.yml`中添加：\n```\n    # 版权声明\n    #在需要进行版权声明的文章的md文件头部，设置属性declare: true。\n    #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明\n    declare:\n    declare_type: 2\n    licensee_url: https://creativecommons.org/licenses/by-nc-sa/4.0/        #当前应用的版权协议地址。\n    licensee_name: 'CC BY-NC-SA 4.0'                                        #版权协议的名称\n    licensee_alias: '知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议'       # alias别名\n    licensee_img: https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png    #版权协议的Logo\n```\n> 作者是直接设置的2,表示在所有的文章中都显示版权信息，当然也可全局设置1，然后在每篇文章中单独设置是否显示版权信息。\n\n* `hexo clean & hexo g & hexo s`\n\n### 5. 总结：\n    * 创建一个copyright.ejs用来渲染前端显示的具体内容\n    * 在article.ejs设定copyright.ejs作用位置\n    * 在style.styl中设置显示的心态\n    * 在`_config.yml`设置版权信息所需要的参数\n        > 纯前端小白简单理解，期望与各路大佬多多交流\n\n<br>\n<br>\n<br>\n\n> 网络上都是以next的配置为主，但next很多是主题作者预先放置好的，所以作者找到了这篇为yilia添加此功能的，做了微小改动。    \n> 参考 <https://blog.csdn.net/weixin_42429718/article/details/104262871>\n\n","source":"_posts/code/Hexo+Ocean添加版权说明.md","raw":"---\ntitle: Hexo+Ocean添加版权说明\ncategories: Construct Blog\n# photos:\n#   - - 'https://i.loli.net/2020/04/26/Y6Hp7yalX4fVnxC.png'\nabbrlink: 63423\ndata: 2020-04-26 20:56:10\ndeclare: true\nwordCount: true\n---\n❄\n<!-- more -->\n\n### 1. `themes\\ocean\\layout\\_partial`中创建`copyright.ejs`,并输入以下代码：\n```javascript\n    <!-- 《添加版权声明 -->\n    <!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3-->\n    <%\n    var sUrl = url.replace(/index\\.html$/, '');\n    sUrl = /^(http:|https:)\\/\\//.test(sUrl) ? sUrl : 'https:' + sUrl;\n    %>\n\n    <!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 且如果文章对应的md文件里有declare: false 则取消此篇文章的版权声明 -->\n    <% if ((theme.declare.declare_type === 2 || (theme.declare.declare_type === 1 && copyrighty)) && !index){ %>\n    <div class=\"declare\">\n        <strong class=\"author\">本文作者：</strong>\n        <% if(config.author != undefined){ %>\n        <%= config.author%>\n        <% }else{%>\n        <font color=\"red\">请在博客根目录“_config.yml”中填入正确的“author”</font>\n        <%}%>\n        <br>\n        <!-- <strong class=\"create-time\">发布时间：</strong>\n        <%- date(post.date, 'YYYY-MM-DD') %> \n        <br> -->\n        <!-- <strong class=\"update-time\">最后更新：</strong>\n        <%- date(post.updated, 'YYYY-MM-DD') %>\n        <br> -->\n        <!-- <strong class=\"article-titles\">本文标题：</strong>\n        <a href=\"<%= config.url %>/<%= post.path %>\" title=\"<%= post.title %>\" target=\"_blank\"><%= post.title %></a>\n        <br> -->\n        <strong class=\"article-url\">本文链接：</strong>\n        <a href=\"<%= config.url %>/<%= post.path %>\" title=\"<%= post.title %>\" target=\"_blank\"><%= config.url %>/<%= post.path %></a>\n        <br>\n        <strong class=\"copyright\">版权声明：</strong>\n        本作品采用\n        <a rel=\"license\" href=\"<%= theme.declare.licensee_url%>\" title=\"<%= theme.declare.licensee_alias %>\"><%= theme.declare.licensee_name%></a>\n        许可协议进行许可。转载请注明出处！\n        <% if(theme.declare.licensee_img != undefined){ %>\n        <br>\n        <% } %>\n    </div>\n    <% } else {%>\n    <div class=\"declare\" hidden=\"hidden\"></div>\n    <% } %>\n    <!-- 添加版权声明》 -->\n```\n### 2. 在`themes\\ocean\\layout\\_partial\\article.ejs`中添加以下代码\n```javascript\n    <!-- 《添加版权声明 -->\n        <% if(theme.declare){%>\n        <%- partial('copyright') %>\n        <% } %>\n    <!-- 添加版权声明》 -->\n```\n* 具体位置是在`article-inner`的div中的`article-entry`的div块中，例如我的位置是\n<img style=\"align:left\" src=\"https://i.loli.net/2020/04/26/8uFj4Td6xCnrBtf.png\" width=\"70%\">\n\n### 3. 在`themes\\ocean\\source\\css\\style.styl`中添加：\n```stylus\n    .declare\n        background-color #eaeaea\n        margin-top 5em\n        border-left 3px solid #ff1700\n        padding .5em 1em;\n```\n\n### 4. 在主题配置文件`themes\\ocean\\_config.yml`中添加：\n```\n    # 版权声明\n    #在需要进行版权声明的文章的md文件头部，设置属性declare: true。\n    #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明\n    declare:\n    declare_type: 2\n    licensee_url: https://creativecommons.org/licenses/by-nc-sa/4.0/        #当前应用的版权协议地址。\n    licensee_name: 'CC BY-NC-SA 4.0'                                        #版权协议的名称\n    licensee_alias: '知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议'       # alias别名\n    licensee_img: https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png    #版权协议的Logo\n```\n> 作者是直接设置的2,表示在所有的文章中都显示版权信息，当然也可全局设置1，然后在每篇文章中单独设置是否显示版权信息。\n\n* `hexo clean & hexo g & hexo s`\n\n### 5. 总结：\n    * 创建一个copyright.ejs用来渲染前端显示的具体内容\n    * 在article.ejs设定copyright.ejs作用位置\n    * 在style.styl中设置显示的心态\n    * 在`_config.yml`设置版权信息所需要的参数\n        > 纯前端小白简单理解，期望与各路大佬多多交流\n\n<br>\n<br>\n<br>\n\n> 网络上都是以next的配置为主，但next很多是主题作者预先放置好的，所以作者找到了这篇为yilia添加此功能的，做了微小改动。    \n> 参考 <https://blog.csdn.net/weixin_42429718/article/details/104262871>\n\n","slug":"code/Hexo+Ocean添加版权说明","published":1,"date":"2021-08-09T10:06:58.767Z","updated":"2020-04-30T15:58:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1ey001f0w7tb4zz4n0o","content":"<p>❄</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-themes-ocean-layout-partial中创建copyright-ejs-并输入以下代码：\"><a href=\"#1-themes-ocean-layout-partial中创建copyright-ejs-并输入以下代码：\" class=\"headerlink\" title=\"1. themes\\ocean\\layout\\_partial中创建copyright.ejs,并输入以下代码：\"></a>1. <code>themes\\ocean\\layout\\_partial</code>中创建<code>copyright.ejs</code>,并输入以下代码：</h3><pre class=\" language-javascript\"><code class=\"language-javascript\">    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 《添加版权声明 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>添加版权声明https<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>github<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>JoeyBling<span class=\"token operator\">/</span>hexo<span class=\"token operator\">-</span>theme<span class=\"token operator\">-</span>yilia<span class=\"token operator\">-</span>plus<span class=\"token operator\">/</span>commit<span class=\"token operator\">/</span>c1215e132f6d5621c5fea83d3c4f7ccbcca074a3<span class=\"token operator\">--</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span>\n    <span class=\"token keyword\">var</span> sUrl <span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/index\\.html$/</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    sUrl <span class=\"token operator\">=</span> <span class=\"token regex\">/^(http:|https:)\\/\\//</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>sUrl<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> sUrl <span class=\"token punctuation\">:</span> <span class=\"token string\">'https:'</span> <span class=\"token operator\">+</span> sUrl<span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> #版权基础设定：<span class=\"token number\">0</span><span class=\"token operator\">-</span>关闭声明； <span class=\"token number\">1</span><span class=\"token operator\">-</span>文章对应的md文件里有declare<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>属性，才有版权声明； <span class=\"token number\">2</span><span class=\"token operator\">-</span>所有文章均有版权声明 且如果文章对应的md文件里有declare<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> 则取消此篇文章的版权声明 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>theme<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">.</span>declare_type <span class=\"token operator\">===</span> <span class=\"token number\">2</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>theme<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">.</span>declare_type <span class=\"token operator\">===</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> copyrighty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>div <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"declare\"</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>strong <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"author\"</span><span class=\"token operator\">></span>本文作者：<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>strong<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">.</span>author <span class=\"token operator\">!=</span> undefined<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">=</span> config<span class=\"token punctuation\">.</span>author<span class=\"token operator\">%</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span><span class=\"token operator\">%</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>font color<span class=\"token operator\">=</span><span class=\"token string\">\"red\"</span><span class=\"token operator\">></span>请在博客根目录“_config<span class=\"token punctuation\">.</span>yml”中填入正确的“author”<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>font<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token punctuation\">}</span><span class=\"token operator\">%</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>br<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> <span class=\"token operator\">&lt;</span>strong <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"create-time\"</span><span class=\"token operator\">></span>发布时间：<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>strong<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">-</span> <span class=\"token function\">date</span><span class=\"token punctuation\">(</span>post<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">,</span> <span class=\"token string\">'YYYY-MM-DD'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span> \n        <span class=\"token operator\">&lt;</span>br<span class=\"token operator\">></span> <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> <span class=\"token operator\">&lt;</span>strong <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"update-time\"</span><span class=\"token operator\">></span>最后更新：<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>strong<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">-</span> <span class=\"token function\">date</span><span class=\"token punctuation\">(</span>post<span class=\"token punctuation\">.</span>updated<span class=\"token punctuation\">,</span> <span class=\"token string\">'YYYY-MM-DD'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>br<span class=\"token operator\">></span> <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> <span class=\"token operator\">&lt;</span>strong <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"article-titles\"</span><span class=\"token operator\">></span>本文标题：<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>strong<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>a href<span class=\"token operator\">=</span><span class=\"token string\">\"&lt;%= config.url %>/&lt;%= post.path %>\"</span> title<span class=\"token operator\">=</span><span class=\"token string\">\"&lt;%= post.title %>\"</span> target<span class=\"token operator\">=</span><span class=\"token string\">\"_blank\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">=</span> post<span class=\"token punctuation\">.</span>title <span class=\"token operator\">%</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>a<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>br<span class=\"token operator\">></span> <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>strong <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"article-url\"</span><span class=\"token operator\">></span>本文链接：<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>strong<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>a href<span class=\"token operator\">=</span><span class=\"token string\">\"&lt;%= config.url %>/&lt;%= post.path %>\"</span> title<span class=\"token operator\">=</span><span class=\"token string\">\"&lt;%= post.title %>\"</span> target<span class=\"token operator\">=</span><span class=\"token string\">\"_blank\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">=</span> config<span class=\"token punctuation\">.</span>url <span class=\"token operator\">%</span><span class=\"token operator\">></span><span class=\"token operator\">/</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">=</span> post<span class=\"token punctuation\">.</span>path <span class=\"token operator\">%</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>a<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>br<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>strong <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"copyright\"</span><span class=\"token operator\">></span>版权声明：<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>strong<span class=\"token operator\">></span>\n        本作品采用\n        <span class=\"token operator\">&lt;</span>a rel<span class=\"token operator\">=</span><span class=\"token string\">\"license\"</span> href<span class=\"token operator\">=</span><span class=\"token string\">\"&lt;%= theme.declare.licensee_url%>\"</span> title<span class=\"token operator\">=</span><span class=\"token string\">\"&lt;%= theme.declare.licensee_alias %>\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">=</span> theme<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">.</span>licensee_name<span class=\"token operator\">%</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>a<span class=\"token operator\">></span>\n        许可协议进行许可。转载请注明出处！\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>theme<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">.</span>licensee_img <span class=\"token operator\">!=</span> undefined<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>br<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">%</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>div <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"declare\"</span> hidden<span class=\"token operator\">=</span><span class=\"token string\">\"hidden\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 添加版权声明》 <span class=\"token operator\">--</span><span class=\"token operator\">></span></code></pre>\n<h3 id=\"2-在themes-ocean-layout-partial-article-ejs中添加以下代码\"><a href=\"#2-在themes-ocean-layout-partial-article-ejs中添加以下代码\" class=\"headerlink\" title=\"2. 在themes\\ocean\\layout\\_partial\\article.ejs中添加以下代码\"></a>2. 在<code>themes\\ocean\\layout\\_partial\\article.ejs</code>中添加以下代码</h3><pre class=\" language-javascript\"><code class=\"language-javascript\">    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 《添加版权声明 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>theme<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token operator\">%</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span><span class=\"token operator\">-</span> <span class=\"token function\">partial</span><span class=\"token punctuation\">(</span><span class=\"token string\">'copyright'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">%</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">%</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 添加版权声明》 <span class=\"token operator\">--</span><span class=\"token operator\">></span></code></pre>\n<ul>\n<li>具体位置是在<code>article-inner</code>的div中的<code>article-entry</code>的div块中，例如我的位置是<img style=\"align:left\" src=\"https://i.loli.net/2020/04/26/8uFj4Td6xCnrBtf.png\" width=\"70%\">\n\n</li>\n</ul>\n<h3 id=\"3-在themes-ocean-source-css-style-styl中添加：\"><a href=\"#3-在themes-ocean-source-css-style-styl中添加：\" class=\"headerlink\" title=\"3. 在themes\\ocean\\source\\css\\style.styl中添加：\"></a>3. 在<code>themes\\ocean\\source\\css\\style.styl</code>中添加：</h3><pre class=\" language-stylus\"><code class=\"language-stylus\">    <span class=\"token selector\">.declare</span>\n        <span class=\"token property-declaration\"><span class=\"token property\">background-color</span> <span class=\"token hexcode\">#eaeaea</span></span>\n        <span class=\"token property-declaration\"><span class=\"token property\">margin-top</span> <span class=\"token number\">5</span>em</span>\n        <span class=\"token property-declaration\"><span class=\"token property\">border-left</span> <span class=\"token number\">3</span>px solid <span class=\"token hexcode\">#ff1700</span></span>\n        <span class=\"token property-declaration\"><span class=\"token property\">padding</span> <span class=\"token operator\">.</span><span class=\"token number\">5</span>em <span class=\"token number\">1</span>em<span class=\"token punctuation\">;</span></span></code></pre>\n<h3 id=\"4-在主题配置文件themes-ocean-config-yml中添加：\"><a href=\"#4-在主题配置文件themes-ocean-config-yml中添加：\" class=\"headerlink\" title=\"4. 在主题配置文件themes\\ocean\\_config.yml中添加：\"></a>4. 在主题配置文件<code>themes\\ocean\\_config.yml</code>中添加：</h3><pre><code>    # 版权声明\n    #在需要进行版权声明的文章的md文件头部，设置属性declare: true。\n    #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明\n    declare:\n    declare_type: 2\n    licensee_url: https://creativecommons.org/licenses/by-nc-sa/4.0/        #当前应用的版权协议地址。\n    licensee_name: &#39;CC BY-NC-SA 4.0&#39;                                        #版权协议的名称\n    licensee_alias: &#39;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&#39;       # alias别名\n    licensee_img: https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png    #版权协议的Logo</code></pre><blockquote>\n<p>作者是直接设置的2,表示在所有的文章中都显示版权信息，当然也可全局设置1，然后在每篇文章中单独设置是否显示版权信息。</p>\n</blockquote>\n<ul>\n<li><code>hexo clean &amp; hexo g &amp; hexo s</code></li>\n</ul>\n<h3 id=\"5-总结：\"><a href=\"#5-总结：\" class=\"headerlink\" title=\"5. 总结：\"></a>5. 总结：</h3><pre><code>* 创建一个copyright.ejs用来渲染前端显示的具体内容\n* 在article.ejs设定copyright.ejs作用位置\n* 在style.styl中设置显示的心态\n* 在`_config.yml`设置版权信息所需要的参数\n    &gt; 纯前端小白简单理解，期望与各路大佬多多交流</code></pre><br>\n<br>\n<br>\n\n<blockquote>\n<p>网络上都是以next的配置为主，但next很多是主题作者预先放置好的，所以作者找到了这篇为yilia添加此功能的，做了微小改动。<br>参考 <a href=\"https://blog.csdn.net/weixin_42429718/article/details/104262871\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_42429718/article/details/104262871</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>❄</p>","more":"<h3 id=\"1-themes-ocean-layout-partial中创建copyright-ejs-并输入以下代码：\"><a href=\"#1-themes-ocean-layout-partial中创建copyright-ejs-并输入以下代码：\" class=\"headerlink\" title=\"1. themes\\ocean\\layout\\_partial中创建copyright.ejs,并输入以下代码：\"></a>1. <code>themes\\ocean\\layout\\_partial</code>中创建<code>copyright.ejs</code>,并输入以下代码：</h3><pre><code class=\"javascript\">    &lt;!-- 《添加版权声明 --&gt;\n    &lt;!--添加版权声明https://github.com/JoeyBling/hexo-theme-yilia-plus/commit/c1215e132f6d5621c5fea83d3c4f7ccbcca074a3--&gt;\n    &lt;%\n    var sUrl = url.replace(/index\\.html$/, &#39;&#39;);\n    sUrl = /^(http:|https:)\\/\\//.test(sUrl) ? sUrl : &#39;https:&#39; + sUrl;\n    %&gt;\n\n    &lt;!-- #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明 且如果文章对应的md文件里有declare: false 则取消此篇文章的版权声明 --&gt;\n    &lt;% if ((theme.declare.declare_type === 2 || (theme.declare.declare_type === 1 &amp;&amp; copyrighty)) &amp;&amp; !index){ %&gt;\n    &lt;div class=&quot;declare&quot;&gt;\n        &lt;strong class=&quot;author&quot;&gt;本文作者：&lt;/strong&gt;\n        &lt;% if(config.author != undefined){ %&gt;\n        &lt;%= config.author%&gt;\n        &lt;% }else{%>\n        <font color=\"red\">请在博客根目录“_config.yml”中填入正确的“author”</font>\n        <%}%&gt;\n        &lt;br&gt;\n        &lt;!-- &lt;strong class=&quot;create-time&quot;&gt;发布时间：&lt;/strong&gt;\n        &lt;%- date(post.date, &#39;YYYY-MM-DD&#39;) %&gt; \n        &lt;br&gt; --&gt;\n        &lt;!-- &lt;strong class=&quot;update-time&quot;&gt;最后更新：&lt;/strong&gt;\n        &lt;%- date(post.updated, &#39;YYYY-MM-DD&#39;) %&gt;\n        &lt;br&gt; --&gt;\n        &lt;!-- &lt;strong class=&quot;article-titles&quot;&gt;本文标题：&lt;/strong&gt;\n        &lt;a href=&quot;&lt;%= config.url %&gt;/&lt;%= post.path %&gt;&quot; title=&quot;&lt;%= post.title %&gt;&quot; target=&quot;_blank&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;\n        &lt;br&gt; --&gt;\n        &lt;strong class=&quot;article-url&quot;&gt;本文链接：&lt;/strong&gt;\n        &lt;a href=&quot;&lt;%= config.url %&gt;/&lt;%= post.path %&gt;&quot; title=&quot;&lt;%= post.title %&gt;&quot; target=&quot;_blank&quot;&gt;&lt;%= config.url %&gt;/&lt;%= post.path %&gt;&lt;/a&gt;\n        &lt;br&gt;\n        &lt;strong class=&quot;copyright&quot;&gt;版权声明：&lt;/strong&gt;\n        本作品采用\n        &lt;a rel=&quot;license&quot; href=&quot;&lt;%= theme.declare.licensee_url%&gt;&quot; title=&quot;&lt;%= theme.declare.licensee_alias %&gt;&quot;&gt;&lt;%= theme.declare.licensee_name%&gt;&lt;/a&gt;\n        许可协议进行许可。转载请注明出处！\n        &lt;% if(theme.declare.licensee_img != undefined){ %&gt;\n        &lt;br&gt;\n        &lt;% } %&gt;\n    &lt;/div&gt;\n    &lt;% } else {%&gt;\n    &lt;div class=&quot;declare&quot; hidden=&quot;hidden&quot;&gt;&lt;/div&gt;\n    &lt;% } %&gt;\n    &lt;!-- 添加版权声明》 --&gt;</code></pre>\n<h3 id=\"2-在themes-ocean-layout-partial-article-ejs中添加以下代码\"><a href=\"#2-在themes-ocean-layout-partial-article-ejs中添加以下代码\" class=\"headerlink\" title=\"2. 在themes\\ocean\\layout\\_partial\\article.ejs中添加以下代码\"></a>2. 在<code>themes\\ocean\\layout\\_partial\\article.ejs</code>中添加以下代码</h3><pre><code class=\"javascript\">    &lt;!-- 《添加版权声明 --&gt;\n        &lt;% if(theme.declare){%&gt;\n        &lt;%- partial(&#39;copyright&#39;) %&gt;\n        &lt;% } %&gt;\n    &lt;!-- 添加版权声明》 --&gt;</code></pre>\n<ul>\n<li>具体位置是在<code>article-inner</code>的div中的<code>article-entry</code>的div块中，例如我的位置是<img style=\"align:left\" src=\"https://i.loli.net/2020/04/26/8uFj4Td6xCnrBtf.png\" width=\"70%\">\n\n</li>\n</ul>\n<h3 id=\"3-在themes-ocean-source-css-style-styl中添加：\"><a href=\"#3-在themes-ocean-source-css-style-styl中添加：\" class=\"headerlink\" title=\"3. 在themes\\ocean\\source\\css\\style.styl中添加：\"></a>3. 在<code>themes\\ocean\\source\\css\\style.styl</code>中添加：</h3><pre><code class=\"stylus\">    .declare\n        background-color #eaeaea\n        margin-top 5em\n        border-left 3px solid #ff1700\n        padding .5em 1em;</code></pre>\n<h3 id=\"4-在主题配置文件themes-ocean-config-yml中添加：\"><a href=\"#4-在主题配置文件themes-ocean-config-yml中添加：\" class=\"headerlink\" title=\"4. 在主题配置文件themes\\ocean\\_config.yml中添加：\"></a>4. 在主题配置文件<code>themes\\ocean\\_config.yml</code>中添加：</h3><pre><code>    # 版权声明\n    #在需要进行版权声明的文章的md文件头部，设置属性declare: true。\n    #版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明\n    declare:\n    declare_type: 2\n    licensee_url: https://creativecommons.org/licenses/by-nc-sa/4.0/        #当前应用的版权协议地址。\n    licensee_name: &#39;CC BY-NC-SA 4.0&#39;                                        #版权协议的名称\n    licensee_alias: &#39;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&#39;       # alias别名\n    licensee_img: https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png    #版权协议的Logo</code></pre><blockquote>\n<p>作者是直接设置的2,表示在所有的文章中都显示版权信息，当然也可全局设置1，然后在每篇文章中单独设置是否显示版权信息。</p>\n</blockquote>\n<ul>\n<li><code>hexo clean &amp; hexo g &amp; hexo s</code></li>\n</ul>\n<h3 id=\"5-总结：\"><a href=\"#5-总结：\" class=\"headerlink\" title=\"5. 总结：\"></a>5. 总结：</h3><pre><code>* 创建一个copyright.ejs用来渲染前端显示的具体内容\n* 在article.ejs设定copyright.ejs作用位置\n* 在style.styl中设置显示的心态\n* 在`_config.yml`设置版权信息所需要的参数\n    &gt; 纯前端小白简单理解，期望与各路大佬多多交流</code></pre><br>\n<br>\n<br>\n\n<blockquote>\n<p>网络上都是以next的配置为主，但next很多是主题作者预先放置好的，所以作者找到了这篇为yilia添加此功能的，做了微小改动。<br>参考 <a href=\"https://blog.csdn.net/weixin_42429718/article/details/104262871\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_42429718/article/details/104262871</a></p>\n</blockquote>"},{"title":"Bookmarks for contruct the blog","abbrlink":"d7b571bb","data":"2020-04-26T13:38:10.000Z","_content":"❄\n<!-- more -->\n\n>➱[Ocean文档](https://zhwangart.github.io/2018/11/30/Ocean/)➲ <br>\n\n>➯[Hexo - 修改永久链接的默认格式](https://www.cnblogs.com/yulinlewis/p/9114178.html)➲","source":"_posts/code/Bookmarks for contruct the blog.md","raw":"---\ntitle: Bookmarks for contruct the blog\ncategories: Construct Blog\n# photos:\n#   - - 'https://i.loli.net/2020/04/26/egWJwAcjBkX81qb.png'\nabbrlink: d7b571bb\ndata: 2020-04-26 21:38:10\n---\n❄\n<!-- more -->\n\n>➱[Ocean文档](https://zhwangart.github.io/2018/11/30/Ocean/)➲ <br>\n\n>➯[Hexo - 修改永久链接的默认格式](https://www.cnblogs.com/yulinlewis/p/9114178.html)➲","slug":"code/Bookmarks for contruct the blog","published":1,"date":"2021-08-09T10:06:58.762Z","updated":"2020-10-06T10:53:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1f2001i0w7t4tt92rva","content":"<p>❄</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>➱<a href=\"https://zhwangart.github.io/2018/11/30/Ocean/\" target=\"_blank\" rel=\"noopener\">Ocean文档</a>➲ <br></p>\n</blockquote>\n<blockquote>\n<p>➯<a href=\"https://www.cnblogs.com/yulinlewis/p/9114178.html\" target=\"_blank\" rel=\"noopener\">Hexo - 修改永久链接的默认格式</a>➲</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>❄</p>","more":"<blockquote>\n<p>➱<a href=\"https://zhwangart.github.io/2018/11/30/Ocean/\" target=\"_blank\" rel=\"noopener\">Ocean文档</a>➲ <br></p>\n</blockquote>\n<blockquote>\n<p>➯<a href=\"https://www.cnblogs.com/yulinlewis/p/9114178.html\" target=\"_blank\" rel=\"noopener\">Hexo - 修改永久链接的默认格式</a>➲</p>\n</blockquote>"},{"title":"04.30","data":"2020-04-30T13:56:10.000Z","abbrlink":"a7181215","_content":"\n下午到外面去理发店，发现Tony小哥们都穿的是短袖，我还是两件加起来比较厚的衣服。<br>\n\n今天是4月30日。小学的时候，春季刚刚开学的时候就开始期待五一之前的那几个周，还有初中同样期待操场边的水杉树发芽，因为都是那时对运动会的期待，运动会上都穿着短袖，差不多同时也是一年里在学校最开心的日子。<br>\n\n希望疫情寒冬早日过去，春天早点到来。\n","source":"_posts/essays/2020年4月30日.md","raw":"---\ntitle: 04.30 \ncategories: essays\ndata: 2020-04-30 21:56:10\nabbrlink: a7181215\n---\n\n下午到外面去理发店，发现Tony小哥们都穿的是短袖，我还是两件加起来比较厚的衣服。<br>\n\n今天是4月30日。小学的时候，春季刚刚开学的时候就开始期待五一之前的那几个周，还有初中同样期待操场边的水杉树发芽，因为都是那时对运动会的期待，运动会上都穿着短袖，差不多同时也是一年里在学校最开心的日子。<br>\n\n希望疫情寒冬早日过去，春天早点到来。\n","slug":"essays/2020年4月30日","published":1,"date":"2021-08-09T10:06:58.884Z","updated":"2020-04-30T16:46:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1f2001k0w7tbvu2hads","content":"<p>下午到外面去理发店，发现Tony小哥们都穿的是短袖，我还是两件加起来比较厚的衣服。<br></p>\n<p>今天是4月30日。小学的时候，春季刚刚开学的时候就开始期待五一之前的那几个周，还有初中同样期待操场边的水杉树发芽，因为都是那时对运动会的期待，运动会上都穿着短袖，差不多同时也是一年里在学校最开心的日子。<br></p>\n<p>希望疫情寒冬早日过去，春天早点到来。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>下午到外面去理发店，发现Tony小哥们都穿的是短袖，我还是两件加起来比较厚的衣服。<br></p>\n<p>今天是4月30日。小学的时候，春季刚刚开学的时候就开始期待五一之前的那几个周，还有初中同样期待操场边的水杉树发芽，因为都是那时对运动会的期待，运动会上都穿着短袖，差不多同时也是一年里在学校最开心的日子。<br></p>\n<p>希望疫情寒冬早日过去，春天早点到来。</p>\n"},{"title":"2020年4月","abbrlink":"93d31219","date":"2020-04-28T15:44:55.000Z","_content":"","source":"_posts/img/2020年4月.md","raw":"---\ntitle: 2020年4月\nphoto:\n  - - >-\n      https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20200429_015020.jpg\nabbrlink: 93d31219\ndate: 2020-04-28 23:44:55\n---\n","slug":"img/2020年4月","published":1,"updated":"2020-04-30T15:42:44.000Z","photos":["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20200429_015020.jpg"],"comments":1,"layout":"post","link":"","_id":"cks5dy1f3001n0w7thhet1uzq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"2019年7月","abbrlink":"a7a49a19","date":"2020-04-21T14:10:10.000Z","_content":"","source":"_posts/img/2019年7月.md","raw":"---\ntitle: 2019年7月\nphoto:\n  - - >-\n      https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20190709_213851.jpg\nabbrlink: a7a49a19\ndate: 2020-04-21 22:10:10\n---\n","slug":"img/2019年7月","published":1,"updated":"2020-04-30T15:42:40.000Z","photos":["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20190709_213851.jpg"],"comments":1,"layout":"post","link":"","_id":"cks5dy1f4001q0w7tdeqh70g0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"喜欢美好事物","top":true,"abbrlink":"f7d18982","date":"2020-04-21T10:02:10.000Z","_content":"\n<!-- > <b style=\"font-size:18px;color:#262626\">喜欢美好事物</b> -->","source":"_posts/img/Hello.md","raw":"---\ntitle: 喜欢美好事物\nphoto: [\n  [https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20200429_103519.jpg]\n]\ntop: true\nabbrlink: f7d18982\ndate: 2020-04-21 18:02:10\n---\n\n<!-- > <b style=\"font-size:18px;color:#262626\">喜欢美好事物</b> -->","slug":"img/Hello","published":1,"updated":"2020-05-22T03:54:10.000Z","photos":["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IMG_20200429_103519.jpg"],"comments":1,"layout":"post","link":"","_id":"cks5dy1f5001s0w7t54ni297q","content":"<!-- > <b style=\"font-size:18px;color:#262626\">喜欢美好事物</b> -->","site":{"data":{}},"excerpt":"","more":"<!-- > <b style=\"font-size:18px;color:#262626\">喜欢美好事物</b> -->"},{"title":"我有我爱我","abbrlink":"989dd112","date":"2020-05-04T05:45:10.000Z","_content":"\n\n<div style=\"margin-left:30px\">\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=421885447&auto=0&height=66\"></iframe>\n</div>","source":"_posts/lyrics/我有我爱我.md","raw":"---\ntitle: 我有我爱我\ncategories: Lyrics\nphoto: [https://i.loli.net/2020/05/04/pgk9PZ6aNiRESMz.jpg]\nabbrlink: 989dd112\ndate: 2020-05-04 13:45:10\n---\n\n\n<div style=\"margin-left:30px\">\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=421885447&auto=0&height=66\"></iframe>\n</div>","slug":"lyrics/我有我爱我","published":1,"updated":"2020-05-04T05:57:30.000Z","photos":["https://i.loli.net/2020/05/04/pgk9PZ6aNiRESMz.jpg"],"comments":1,"layout":"post","link":"","_id":"cks5dy1f6001v0w7tc76b0jqa","content":"<div style=\"margin-left:30px\">\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=421885447&auto=0&height=66\"></iframe>\n</div>","site":{"data":{}},"excerpt":"","more":"<div style=\"margin-left:30px\">\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=421885447&auto=0&height=66\"></iframe>\n</div>"},{"title":"Linux命令","declare":true,"wordCount":true,"abbrlink":"82734d8","date":"2020-11-24T15:04:33.000Z","_content":"\n基础Linux命令\n<!-- more -->\n\n\n## 1.使用命令\n1. 详细信息 `ls -l`\n2. 删除 rm(remove)\n\t* 删除文件 `rm test.txt`\n\t* 删除文件夹  `rm -r dictory`\n3. 移动 mv(move)\n\t* 改名 `mv file1.txt file2.txt`\n\t* 移动 `mv workspace/space2/helloworld.txt workspace/space1/helloworld.txt`\n4. 复制 cp(copy)\n\t* cp `workspace/space2/helloworld.txt workspace/space1/helloworld.txt`\n5. 显示文件信息\n\t* 显示全部 `cat file.txt`\n\t* 查看开头部分`head file.txt -n 4`\n\t* 查看结尾部分`tail file.txt -n 4`\n\t* 循环读取(每隔10s)动态改变的日志文件`tail -f -s 10 file.log`,\n\t* 暂时少量查看`less file.txt `\n\n6. 文件权限     \n\n|u(author)|g(group)|o(other)|\n|-|-|-|\n|rw\\-(可读可写)|r\\-x(可读可运行)|r\\-\\-(可读)|\n<!-- gaodafeng shegnxia shegnxiashegnxi youshoushizhi -->\n> r : 可读      \n> w : 修改、删除      \n> x : execute可执行\n\n* author限制可读 `chmod u-r file.txt`\n* author增加可读 `chmod u+r file.txt`\n* group、other限制读`chmod go-r file.txt`\n* 为所有用户增加可读 `chmod a-r file.txt`\n* 为所有用户添加所有权限 `chmod 777 file.txt`\n\t> `rwx rwx rwx`二进制 `111 111 111`, 可利用二进制添加相应的权限\n\n6. 设置目录权限\n* 为user添加/user/local/的权限 chown -R user /usr/local/ \n\n7. 检索grep\n\n* `grep keyWord file.txt`\n* 配合正则表达式\n\t* `grep ^KeyWord file.txt`\n8. 统计wc\n\t* 统计行数、单词数、字符数`wc file.txt`\n\t* 统计byte数`wc -c file.txt`\n\t* 统计字符数`wc -m file.txt`\n\t* 统计最新的一行的长度`wc -l file.txt`\n\t* 统计最长的一行的长度`wc -L file.txt`\n\t* 统计单词个数 `wc -w file.txt`\n\n9. [查看系统信息](https://www.linuxprobe.com/linux-cat-system.html)\n\t* lsb_release -a \n\t\t> Linux Standard Base\n\t* cat /etc/os-release\n\n10. [查看是否安装某个软件]\n\t* Ubuntu `dpkg -s \"软件或包的名字\"`\n\t* CentOS `rpm -qa | grep \"软件或者包的名字\"`\n\t\t> `rpm: redhat package manager; -q: query; a: all` \n\n11. 查看网络活动相关信息\n\t* `netstat -nptl` \n\t\t> connetction、tcp、programs、listening \n\t```ini\n\t\t[root@cloudr etc]# netstat -h\n        -r, --route              display routing table\n        -I, --interfaces=<Iface> display interface table for <Iface>\n        -i, --interfaces         display interface table\n        -s, --statistics         display networking statistics (like SNMP)\n        -M, --masquerade         display masqueraded connections\n\n        -v, --verbose            be verbose //详细的\n        -e, --extend             display other/more information\n        -p, --programs           display PID/Program name for sockets\t//PID、程序名\n        -o, --timers             display timers\n        -c, --continuous         continuous listing\n\n        -l, --listening          display listening server sockets //监听中的套接口\n        -a, --all                display all sockets (default: connected)\n        -F, --fib                display Forwarding Information Base (default)\n        -C, --cache              display routing cache instead of FIB\n        -Z, --context            display SELinux security context for sockets\n\n\t\t-t, --tcp\t//tcp相关\n\t\t-u, --udp\t//udp相关\n\t\t-U, --udplite\n\t\t-w, --raw \t//原始\n\t\t-x, --unix\t//unix相关\n\t```\n\n\n## 2.用户和工作组管理类命令\n### 2.1 查看用户\n* 查看用户信息命令 `id`\n* 显示用户名称命令 `logname`\n* 查看用户操作命令 `history`\n\t* 执行第几条命令 `!数字` \n* 查看用户所属用户组 `groups`\n### 2.2 用户组管理\n* 查看所有用户组命令 `cat /etc/group`\n* 创建一个用户组命令 `groupadd 用户组名` \n* 删除一个用户组命令 `groupdel 用户名`\n* 更改用户组名命令 `groupmod 新用户组名 旧用户组名`\n* 添加用户到用户组 `usermode -a -G groupName userName`\n\t> -a : appened，不能直接-G，否则会离开原有用户组\n### 2.3 用户管理\n* 查看当前登录用户名命令 `w、who、users、whoami`\n* 切换用户 `su [选项] 目标用户`\n* 新增用户账号 `useradd 用户名`\n* 删除用户账号 `userdel 用户名`\n\t* 强制删除`userdel -f 用户名` \n\t* 删除用户的同时，删除与用户相关的所有文件 `userdel -r 用户名`\n* 为用户设置口令 `passwd 用户名`\n* 查看用户所属组命令 `groups 用户名`\n* 变更用户账号信息命令 `usermod [选项] 用户名`\n\n### 2.4 用户权限管理\n普通用户如何获得root权限\n* 用户使用sudo命令并输入口令          \n在文件/etc/sudoers第100行后添加`username  ALL=(ALL)   ALL`后保存修改，执行命令时输入当前用户口令，即可执行root权限\n* 用户组使用sudo命令并输入口令          \n在文件/etc/sudoers第100行后添加`%groupname  ALL=(ALL)   ALL`后保存修改，执行命令时输入当前用户口令，即可执行root权限\n* 用户使用sudo命令并（不需要输入口令）\n在文件/etc/sudoers第100行后添加`username  ALL=(ALL)   NOPASSWD: ALL`后保存修改，执行命令时输入当前用户口令，即可执行root权限\n* 用户组使用sudo命令并（不需要输入口令）\n在文件/etc/sudoers第100行后添加`%groupname  ALL=(ALL)   NOPASSWD: ALL`后保存修改，执行命令时输入当前用户口令，即可执行root权限\n\n\n* 显示当前挂载在Linux系统的每个分区 df\n\t* `df -h` 将分区小转换为用户可读的形式\n\n* 查看文件大小\n\t* `ll -h` h: human-readable\n\n\n\n* 归档命令`tar`\n\t* `tar -cvf testTar.tar * `\n\t\t* c --create: 创建一个新的归档文件\n\t\t* v --verbose: 显示已处理文件\n\t\t* f --file=ARCHIVE: 指向归档文件的名字\n\t* `tar -cvzf testTar.tar.gz *`\n\t\t* z --zip: 压缩归档文件 \n\n\t* `tar -xvzf testTar.tar.gz`\n\t\t* x --extract : 提取（解压）\n\n\t* `tar czvf - importantstuff/ | ssh useranme@10.0.0.123  \"cat > /home/username/myfiles.tar.gz` ： 归档importantstuff目录下的文件至10.0.0.123主机的/home/username/myfile.tar.gz文件\n\t\t* \\- : 该连接符表示将数据输出到标准标准的输出设备上，这允许将归档文件文件名的详细信息推后至该命令的末尾。\n\t\t* | : 管道，将这个未命名的、压缩的归档文件传输至远程服务器的ssh登陆\t\n\t\t* \"cat > /home/username/myfiles.tar.gz\" : 键入内容至myfiles.tar.gz(覆盖)\n\n\n* 文件分割 split\n\t* `split -4 README.md`: 将README.md文件每4行分割为以x开头的文件,例如xaa、xab、xac；\n\t* `split 2KB README.md REAME.md.part`: 将README.md分割为以REAMD.md.part开头的文件，例如REAME.md.part.aa、REAME.md.part.ab\n\n* 搜索文件命令locate\n\t* `locate *.mp4`\n\t\t> locate命令并非真正地文件系统本身，而是在一个已存在的索引中进行简单的搜索，但是该索引**并不是实时性的**，默认是在系统每次启动时自动更新，所以会因为索引过时时搜索不到文件，使用`updatedb`命令更新.<br>\n\n\t\t> centos安装命令`sudo yum install mlocate`\n\n* 指定目录下查找文件find\n\t* `find readme.md` : 在当前目录下查找文件名为readme.md的文件（默认为当前目录下查找）\n\t* `find /home/cc1/dd/ -iname \"*.java\" -exec tar -rvf javaZip.tar {} \\;`\n\t\t* -exec: shell的内建命令，在当前shell下用exec后面的命令替换掉当前执行的进程，并将老进程的环境清除掉。\n\t\t* -iname: 忽略名字字母大小写查找\n\t\t* {}: 告诉find命令，对于每个查找到的文件执行官exec后面的命令\n\t\t* \\\\;: 格式，必须 \n\n\n\n\n\n\n\n\n\n\nhttps://www.cnblogs.com/zox2011/archive/2013/05/28/3103824.html\n","source":"_posts/linux/Linux命令.md","raw":"---\ntitle: Linux命令\ncategories: Code\ntags: Linux\ndeclare: true\nwordCount: true\nabbrlink: 82734d8\ndate: 2020-11-24 23:04:33\n---\n\n基础Linux命令\n<!-- more -->\n\n\n## 1.使用命令\n1. 详细信息 `ls -l`\n2. 删除 rm(remove)\n\t* 删除文件 `rm test.txt`\n\t* 删除文件夹  `rm -r dictory`\n3. 移动 mv(move)\n\t* 改名 `mv file1.txt file2.txt`\n\t* 移动 `mv workspace/space2/helloworld.txt workspace/space1/helloworld.txt`\n4. 复制 cp(copy)\n\t* cp `workspace/space2/helloworld.txt workspace/space1/helloworld.txt`\n5. 显示文件信息\n\t* 显示全部 `cat file.txt`\n\t* 查看开头部分`head file.txt -n 4`\n\t* 查看结尾部分`tail file.txt -n 4`\n\t* 循环读取(每隔10s)动态改变的日志文件`tail -f -s 10 file.log`,\n\t* 暂时少量查看`less file.txt `\n\n6. 文件权限     \n\n|u(author)|g(group)|o(other)|\n|-|-|-|\n|rw\\-(可读可写)|r\\-x(可读可运行)|r\\-\\-(可读)|\n<!-- gaodafeng shegnxia shegnxiashegnxi youshoushizhi -->\n> r : 可读      \n> w : 修改、删除      \n> x : execute可执行\n\n* author限制可读 `chmod u-r file.txt`\n* author增加可读 `chmod u+r file.txt`\n* group、other限制读`chmod go-r file.txt`\n* 为所有用户增加可读 `chmod a-r file.txt`\n* 为所有用户添加所有权限 `chmod 777 file.txt`\n\t> `rwx rwx rwx`二进制 `111 111 111`, 可利用二进制添加相应的权限\n\n6. 设置目录权限\n* 为user添加/user/local/的权限 chown -R user /usr/local/ \n\n7. 检索grep\n\n* `grep keyWord file.txt`\n* 配合正则表达式\n\t* `grep ^KeyWord file.txt`\n8. 统计wc\n\t* 统计行数、单词数、字符数`wc file.txt`\n\t* 统计byte数`wc -c file.txt`\n\t* 统计字符数`wc -m file.txt`\n\t* 统计最新的一行的长度`wc -l file.txt`\n\t* 统计最长的一行的长度`wc -L file.txt`\n\t* 统计单词个数 `wc -w file.txt`\n\n9. [查看系统信息](https://www.linuxprobe.com/linux-cat-system.html)\n\t* lsb_release -a \n\t\t> Linux Standard Base\n\t* cat /etc/os-release\n\n10. [查看是否安装某个软件]\n\t* Ubuntu `dpkg -s \"软件或包的名字\"`\n\t* CentOS `rpm -qa | grep \"软件或者包的名字\"`\n\t\t> `rpm: redhat package manager; -q: query; a: all` \n\n11. 查看网络活动相关信息\n\t* `netstat -nptl` \n\t\t> connetction、tcp、programs、listening \n\t```ini\n\t\t[root@cloudr etc]# netstat -h\n        -r, --route              display routing table\n        -I, --interfaces=<Iface> display interface table for <Iface>\n        -i, --interfaces         display interface table\n        -s, --statistics         display networking statistics (like SNMP)\n        -M, --masquerade         display masqueraded connections\n\n        -v, --verbose            be verbose //详细的\n        -e, --extend             display other/more information\n        -p, --programs           display PID/Program name for sockets\t//PID、程序名\n        -o, --timers             display timers\n        -c, --continuous         continuous listing\n\n        -l, --listening          display listening server sockets //监听中的套接口\n        -a, --all                display all sockets (default: connected)\n        -F, --fib                display Forwarding Information Base (default)\n        -C, --cache              display routing cache instead of FIB\n        -Z, --context            display SELinux security context for sockets\n\n\t\t-t, --tcp\t//tcp相关\n\t\t-u, --udp\t//udp相关\n\t\t-U, --udplite\n\t\t-w, --raw \t//原始\n\t\t-x, --unix\t//unix相关\n\t```\n\n\n## 2.用户和工作组管理类命令\n### 2.1 查看用户\n* 查看用户信息命令 `id`\n* 显示用户名称命令 `logname`\n* 查看用户操作命令 `history`\n\t* 执行第几条命令 `!数字` \n* 查看用户所属用户组 `groups`\n### 2.2 用户组管理\n* 查看所有用户组命令 `cat /etc/group`\n* 创建一个用户组命令 `groupadd 用户组名` \n* 删除一个用户组命令 `groupdel 用户名`\n* 更改用户组名命令 `groupmod 新用户组名 旧用户组名`\n* 添加用户到用户组 `usermode -a -G groupName userName`\n\t> -a : appened，不能直接-G，否则会离开原有用户组\n### 2.3 用户管理\n* 查看当前登录用户名命令 `w、who、users、whoami`\n* 切换用户 `su [选项] 目标用户`\n* 新增用户账号 `useradd 用户名`\n* 删除用户账号 `userdel 用户名`\n\t* 强制删除`userdel -f 用户名` \n\t* 删除用户的同时，删除与用户相关的所有文件 `userdel -r 用户名`\n* 为用户设置口令 `passwd 用户名`\n* 查看用户所属组命令 `groups 用户名`\n* 变更用户账号信息命令 `usermod [选项] 用户名`\n\n### 2.4 用户权限管理\n普通用户如何获得root权限\n* 用户使用sudo命令并输入口令          \n在文件/etc/sudoers第100行后添加`username  ALL=(ALL)   ALL`后保存修改，执行命令时输入当前用户口令，即可执行root权限\n* 用户组使用sudo命令并输入口令          \n在文件/etc/sudoers第100行后添加`%groupname  ALL=(ALL)   ALL`后保存修改，执行命令时输入当前用户口令，即可执行root权限\n* 用户使用sudo命令并（不需要输入口令）\n在文件/etc/sudoers第100行后添加`username  ALL=(ALL)   NOPASSWD: ALL`后保存修改，执行命令时输入当前用户口令，即可执行root权限\n* 用户组使用sudo命令并（不需要输入口令）\n在文件/etc/sudoers第100行后添加`%groupname  ALL=(ALL)   NOPASSWD: ALL`后保存修改，执行命令时输入当前用户口令，即可执行root权限\n\n\n* 显示当前挂载在Linux系统的每个分区 df\n\t* `df -h` 将分区小转换为用户可读的形式\n\n* 查看文件大小\n\t* `ll -h` h: human-readable\n\n\n\n* 归档命令`tar`\n\t* `tar -cvf testTar.tar * `\n\t\t* c --create: 创建一个新的归档文件\n\t\t* v --verbose: 显示已处理文件\n\t\t* f --file=ARCHIVE: 指向归档文件的名字\n\t* `tar -cvzf testTar.tar.gz *`\n\t\t* z --zip: 压缩归档文件 \n\n\t* `tar -xvzf testTar.tar.gz`\n\t\t* x --extract : 提取（解压）\n\n\t* `tar czvf - importantstuff/ | ssh useranme@10.0.0.123  \"cat > /home/username/myfiles.tar.gz` ： 归档importantstuff目录下的文件至10.0.0.123主机的/home/username/myfile.tar.gz文件\n\t\t* \\- : 该连接符表示将数据输出到标准标准的输出设备上，这允许将归档文件文件名的详细信息推后至该命令的末尾。\n\t\t* | : 管道，将这个未命名的、压缩的归档文件传输至远程服务器的ssh登陆\t\n\t\t* \"cat > /home/username/myfiles.tar.gz\" : 键入内容至myfiles.tar.gz(覆盖)\n\n\n* 文件分割 split\n\t* `split -4 README.md`: 将README.md文件每4行分割为以x开头的文件,例如xaa、xab、xac；\n\t* `split 2KB README.md REAME.md.part`: 将README.md分割为以REAMD.md.part开头的文件，例如REAME.md.part.aa、REAME.md.part.ab\n\n* 搜索文件命令locate\n\t* `locate *.mp4`\n\t\t> locate命令并非真正地文件系统本身，而是在一个已存在的索引中进行简单的搜索，但是该索引**并不是实时性的**，默认是在系统每次启动时自动更新，所以会因为索引过时时搜索不到文件，使用`updatedb`命令更新.<br>\n\n\t\t> centos安装命令`sudo yum install mlocate`\n\n* 指定目录下查找文件find\n\t* `find readme.md` : 在当前目录下查找文件名为readme.md的文件（默认为当前目录下查找）\n\t* `find /home/cc1/dd/ -iname \"*.java\" -exec tar -rvf javaZip.tar {} \\;`\n\t\t* -exec: shell的内建命令，在当前shell下用exec后面的命令替换掉当前执行的进程，并将老进程的环境清除掉。\n\t\t* -iname: 忽略名字字母大小写查找\n\t\t* {}: 告诉find命令，对于每个查找到的文件执行官exec后面的命令\n\t\t* \\\\;: 格式，必须 \n\n\n\n\n\n\n\n\n\n\nhttps://www.cnblogs.com/zox2011/archive/2013/05/28/3103824.html\n","slug":"linux/Linux命令","published":1,"updated":"2021-07-23T06:17:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1f6001w0w7t0jk1828w","content":"<p>基础Linux命令</p>\n<a id=\"more\"></a>\n\n\n<h2 id=\"1-使用命令\"><a href=\"#1-使用命令\" class=\"headerlink\" title=\"1.使用命令\"></a>1.使用命令</h2><ol>\n<li><p>详细信息 <code>ls -l</code></p>\n</li>\n<li><p>删除 rm(remove)</p>\n<ul>\n<li>删除文件 <code>rm test.txt</code></li>\n<li>删除文件夹  <code>rm -r dictory</code></li>\n</ul>\n</li>\n<li><p>移动 mv(move)</p>\n<ul>\n<li>改名 <code>mv file1.txt file2.txt</code></li>\n<li>移动 <code>mv workspace/space2/helloworld.txt workspace/space1/helloworld.txt</code></li>\n</ul>\n</li>\n<li><p>复制 cp(copy)</p>\n<ul>\n<li>cp <code>workspace/space2/helloworld.txt workspace/space1/helloworld.txt</code></li>\n</ul>\n</li>\n<li><p>显示文件信息</p>\n<ul>\n<li>显示全部 <code>cat file.txt</code></li>\n<li>查看开头部分<code>head file.txt -n 4</code></li>\n<li>查看结尾部分<code>tail file.txt -n 4</code></li>\n<li>循环读取(每隔10s)动态改变的日志文件<code>tail -f -s 10 file.log</code>,</li>\n<li>暂时少量查看<code>less file.txt</code></li>\n</ul>\n</li>\n<li><p>文件权限     </p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>u(author)</th>\n<th>g(group)</th>\n<th>o(other)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rw-(可读可写)</td>\n<td>r-x(可读可运行)</td>\n<td>r--(可读)</td>\n</tr>\n<tr>\n<td><!-- gaodafeng shegnxia shegnxiashegnxi youshoushizhi --></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>r : 可读<br>w : 修改、删除<br>x : execute可执行</p>\n</blockquote>\n<ul>\n<li>author限制可读 <code>chmod u-r file.txt</code></li>\n<li>author增加可读 <code>chmod u+r file.txt</code></li>\n<li>group、other限制读<code>chmod go-r file.txt</code></li>\n<li>为所有用户增加可读 <code>chmod a-r file.txt</code></li>\n<li>为所有用户添加所有权限 <code>chmod 777 file.txt</code><blockquote>\n<p><code>rwx rwx rwx</code>二进制 <code>111 111 111</code>, 可利用二进制添加相应的权限</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"6\">\n<li>设置目录权限</li>\n</ol>\n<ul>\n<li>为user添加/user/local/的权限 chown -R user /usr/local/ </li>\n</ul>\n<ol start=\"7\">\n<li>检索grep</li>\n</ol>\n<ul>\n<li><code>grep keyWord file.txt</code></li>\n<li>配合正则表达式<ul>\n<li><code>grep ^KeyWord file.txt</code></li>\n</ul>\n</li>\n</ul>\n<ol start=\"8\">\n<li><p>统计wc</p>\n<ul>\n<li>统计行数、单词数、字符数<code>wc file.txt</code></li>\n<li>统计byte数<code>wc -c file.txt</code></li>\n<li>统计字符数<code>wc -m file.txt</code></li>\n<li>统计最新的一行的长度<code>wc -l file.txt</code></li>\n<li>统计最长的一行的长度<code>wc -L file.txt</code></li>\n<li>统计单词个数 <code>wc -w file.txt</code></li>\n</ul>\n</li>\n<li><p><a href=\"https://www.linuxprobe.com/linux-cat-system.html\" target=\"_blank\" rel=\"noopener\">查看系统信息</a></p>\n<ul>\n<li>lsb_release -a <blockquote>\n<p>Linux Standard Base</p>\n</blockquote>\n</li>\n<li>cat /etc/os-release</li>\n</ul>\n</li>\n<li><p>[查看是否安装某个软件]</p>\n<ul>\n<li>Ubuntu <code>dpkg -s &quot;软件或包的名字&quot;</code></li>\n<li>CentOS <code>rpm -qa | grep &quot;软件或者包的名字&quot;</code><blockquote>\n<p><code>rpm: redhat package manager; -q: query; a: all</code> </p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>查看网络活动相关信息</p>\n<ul>\n<li><p><code>netstat -nptl</code> </p>\n<blockquote>\n<p>connetction、tcp、programs、listening </p>\n</blockquote>\n<pre class=\" language-ini\"><code class=\"language-ini\"><span class=\"token selector\">  [root@cloudr etc]</span># netstat -h\n  -r, --route              display routing table\n  -I, --interfaces<span class=\"token attr-value\"><span class=\"token punctuation\">=</span>&lt;Iface> display interface table for &lt;Iface></span>\n  -i, --interfaces         display interface table\n  -s, --statistics         display networking statistics (like SNMP)\n  -M, --masquerade         display masqueraded connections\n\n  -v, --verbose            be verbose //详细的\n  -e, --extend             display other/more information\n  -p, --programs           display PID/Program name for sockets    //PID、程序名\n  -o, --timers             display timers\n  -c, --continuous         continuous listing\n\n  -l, --listening          display listening server sockets //监听中的套接口\n  -a, --all                display all sockets (default: connected)\n  -F, --fib                display Forwarding Information Base (default)\n  -C, --cache              display routing cache instead of FIB\n  -Z, --context            display SELinux security context for sockets\n\n  -t, --tcp    //tcp相关\n  -u, --udp    //udp相关\n  -U, --udplite\n  -w, --raw     //原始\n  -x, --unix    //unix相关</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-用户和工作组管理类命令\"><a href=\"#2-用户和工作组管理类命令\" class=\"headerlink\" title=\"2.用户和工作组管理类命令\"></a>2.用户和工作组管理类命令</h2><h3 id=\"2-1-查看用户\"><a href=\"#2-1-查看用户\" class=\"headerlink\" title=\"2.1 查看用户\"></a>2.1 查看用户</h3><ul>\n<li>查看用户信息命令 <code>id</code></li>\n<li>显示用户名称命令 <code>logname</code></li>\n<li>查看用户操作命令 <code>history</code><ul>\n<li>执行第几条命令 <code>!数字</code> </li>\n</ul>\n</li>\n<li>查看用户所属用户组 <code>groups</code><h3 id=\"2-2-用户组管理\"><a href=\"#2-2-用户组管理\" class=\"headerlink\" title=\"2.2 用户组管理\"></a>2.2 用户组管理</h3></li>\n<li>查看所有用户组命令 <code>cat /etc/group</code></li>\n<li>创建一个用户组命令 <code>groupadd 用户组名</code> </li>\n<li>删除一个用户组命令 <code>groupdel 用户名</code></li>\n<li>更改用户组名命令 <code>groupmod 新用户组名 旧用户组名</code></li>\n<li>添加用户到用户组 <code>usermode -a -G groupName userName</code><blockquote>\n<p>-a : appened，不能直接-G，否则会离开原有用户组</p>\n</blockquote>\n<h3 id=\"2-3-用户管理\"><a href=\"#2-3-用户管理\" class=\"headerlink\" title=\"2.3 用户管理\"></a>2.3 用户管理</h3></li>\n<li>查看当前登录用户名命令 <code>w、who、users、whoami</code></li>\n<li>切换用户 <code>su [选项] 目标用户</code></li>\n<li>新增用户账号 <code>useradd 用户名</code></li>\n<li>删除用户账号 <code>userdel 用户名</code><ul>\n<li>强制删除<code>userdel -f 用户名</code> </li>\n<li>删除用户的同时，删除与用户相关的所有文件 <code>userdel -r 用户名</code></li>\n</ul>\n</li>\n<li>为用户设置口令 <code>passwd 用户名</code></li>\n<li>查看用户所属组命令 <code>groups 用户名</code></li>\n<li>变更用户账号信息命令 <code>usermod [选项] 用户名</code></li>\n</ul>\n<h3 id=\"2-4-用户权限管理\"><a href=\"#2-4-用户权限管理\" class=\"headerlink\" title=\"2.4 用户权限管理\"></a>2.4 用户权限管理</h3><p>普通用户如何获得root权限</p>\n<ul>\n<li>用户使用sudo命令并输入口令<br>在文件/etc/sudoers第100行后添加<code>username  ALL=(ALL)   ALL</code>后保存修改，执行命令时输入当前用户口令，即可执行root权限</li>\n<li>用户组使用sudo命令并输入口令<br>在文件/etc/sudoers第100行后添加<code>%groupname  ALL=(ALL)   ALL</code>后保存修改，执行命令时输入当前用户口令，即可执行root权限</li>\n<li>用户使用sudo命令并（不需要输入口令）<br>在文件/etc/sudoers第100行后添加<code>username  ALL=(ALL)   NOPASSWD: ALL</code>后保存修改，执行命令时输入当前用户口令，即可执行root权限</li>\n<li>用户组使用sudo命令并（不需要输入口令）<br>在文件/etc/sudoers第100行后添加<code>%groupname  ALL=(ALL)   NOPASSWD: ALL</code>后保存修改，执行命令时输入当前用户口令，即可执行root权限</li>\n</ul>\n<ul>\n<li><p>显示当前挂载在Linux系统的每个分区 df</p>\n<ul>\n<li><code>df -h</code> 将分区小转换为用户可读的形式</li>\n</ul>\n</li>\n<li><p>查看文件大小</p>\n<ul>\n<li><code>ll -h</code> h: human-readable</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>归档命令<code>tar</code></p>\n<ul>\n<li><p><code>tar -cvf testTar.tar *</code></p>\n<ul>\n<li>c –create: 创建一个新的归档文件</li>\n<li>v –verbose: 显示已处理文件</li>\n<li>f –file=ARCHIVE: 指向归档文件的名字</li>\n</ul>\n</li>\n<li><p><code>tar -cvzf testTar.tar.gz *</code></p>\n<ul>\n<li>z –zip: 压缩归档文件 </li>\n</ul>\n</li>\n<li><p><code>tar -xvzf testTar.tar.gz</code></p>\n<ul>\n<li>x –extract : 提取（解压）</li>\n</ul>\n</li>\n<li><p><code>tar czvf - importantstuff/ | ssh useranme@10.0.0.123  &quot;cat &gt; /home/username/myfiles.tar.gz</code> ： 归档importantstuff目录下的文件至10.0.0.123主机的/home/username/myfile.tar.gz文件</p>\n<ul>\n<li>- : 该连接符表示将数据输出到标准标准的输出设备上，这允许将归档文件文件名的详细信息推后至该命令的末尾。</li>\n<li>| : 管道，将这个未命名的、压缩的归档文件传输至远程服务器的ssh登陆    </li>\n<li>“cat &gt; /home/username/myfiles.tar.gz” : 键入内容至myfiles.tar.gz(覆盖)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>文件分割 split</p>\n<ul>\n<li><code>split -4 README.md</code>: 将README.md文件每4行分割为以x开头的文件,例如xaa、xab、xac；</li>\n<li><code>split 2KB README.md REAME.md.part</code>: 将README.md分割为以REAMD.md.part开头的文件，例如REAME.md.part.aa、REAME.md.part.ab</li>\n</ul>\n</li>\n<li><p>搜索文件命令locate</p>\n<ul>\n<li><p><code>locate *.mp4</code></p>\n<blockquote>\n<p>locate命令并非真正地文件系统本身，而是在一个已存在的索引中进行简单的搜索，但是该索引<strong>并不是实时性的</strong>，默认是在系统每次启动时自动更新，所以会因为索引过时时搜索不到文件，使用<code>updatedb</code>命令更新.<br></p>\n</blockquote>\n<blockquote>\n<p>centos安装命令<code>sudo yum install mlocate</code></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>指定目录下查找文件find</p>\n<ul>\n<li><code>find readme.md</code> : 在当前目录下查找文件名为readme.md的文件（默认为当前目录下查找）</li>\n<li><code>find /home/cc1/dd/ -iname &quot;*.java&quot; -exec tar -rvf javaZip.tar {} \\;</code><ul>\n<li>-exec: shell的内建命令，在当前shell下用exec后面的命令替换掉当前执行的进程，并将老进程的环境清除掉。</li>\n<li>-iname: 忽略名字字母大小写查找</li>\n<li>{}: 告诉find命令，对于每个查找到的文件执行官exec后面的命令</li>\n<li>\\;: 格式，必须 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/zox2011/archive/2013/05/28/3103824.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zox2011/archive/2013/05/28/3103824.html</a></p>\n","site":{"data":{}},"excerpt":"<p>基础Linux命令</p>","more":"<h2 id=\"1-使用命令\"><a href=\"#1-使用命令\" class=\"headerlink\" title=\"1.使用命令\"></a>1.使用命令</h2><ol>\n<li><p>详细信息 <code>ls -l</code></p>\n</li>\n<li><p>删除 rm(remove)</p>\n<ul>\n<li>删除文件 <code>rm test.txt</code></li>\n<li>删除文件夹  <code>rm -r dictory</code></li>\n</ul>\n</li>\n<li><p>移动 mv(move)</p>\n<ul>\n<li>改名 <code>mv file1.txt file2.txt</code></li>\n<li>移动 <code>mv workspace/space2/helloworld.txt workspace/space1/helloworld.txt</code></li>\n</ul>\n</li>\n<li><p>复制 cp(copy)</p>\n<ul>\n<li>cp <code>workspace/space2/helloworld.txt workspace/space1/helloworld.txt</code></li>\n</ul>\n</li>\n<li><p>显示文件信息</p>\n<ul>\n<li>显示全部 <code>cat file.txt</code></li>\n<li>查看开头部分<code>head file.txt -n 4</code></li>\n<li>查看结尾部分<code>tail file.txt -n 4</code></li>\n<li>循环读取(每隔10s)动态改变的日志文件<code>tail -f -s 10 file.log</code>,</li>\n<li>暂时少量查看<code>less file.txt</code></li>\n</ul>\n</li>\n<li><p>文件权限     </p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>u(author)</th>\n<th>g(group)</th>\n<th>o(other)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rw-(可读可写)</td>\n<td>r-x(可读可运行)</td>\n<td>r--(可读)</td>\n</tr>\n<tr>\n<td><!-- gaodafeng shegnxia shegnxiashegnxi youshoushizhi --></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>r : 可读<br>w : 修改、删除<br>x : execute可执行</p>\n</blockquote>\n<ul>\n<li>author限制可读 <code>chmod u-r file.txt</code></li>\n<li>author增加可读 <code>chmod u+r file.txt</code></li>\n<li>group、other限制读<code>chmod go-r file.txt</code></li>\n<li>为所有用户增加可读 <code>chmod a-r file.txt</code></li>\n<li>为所有用户添加所有权限 <code>chmod 777 file.txt</code><blockquote>\n<p><code>rwx rwx rwx</code>二进制 <code>111 111 111</code>, 可利用二进制添加相应的权限</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"6\">\n<li>设置目录权限</li>\n</ol>\n<ul>\n<li>为user添加/user/local/的权限 chown -R user /usr/local/ </li>\n</ul>\n<ol start=\"7\">\n<li>检索grep</li>\n</ol>\n<ul>\n<li><code>grep keyWord file.txt</code></li>\n<li>配合正则表达式<ul>\n<li><code>grep ^KeyWord file.txt</code></li>\n</ul>\n</li>\n</ul>\n<ol start=\"8\">\n<li><p>统计wc</p>\n<ul>\n<li>统计行数、单词数、字符数<code>wc file.txt</code></li>\n<li>统计byte数<code>wc -c file.txt</code></li>\n<li>统计字符数<code>wc -m file.txt</code></li>\n<li>统计最新的一行的长度<code>wc -l file.txt</code></li>\n<li>统计最长的一行的长度<code>wc -L file.txt</code></li>\n<li>统计单词个数 <code>wc -w file.txt</code></li>\n</ul>\n</li>\n<li><p><a href=\"https://www.linuxprobe.com/linux-cat-system.html\" target=\"_blank\" rel=\"noopener\">查看系统信息</a></p>\n<ul>\n<li>lsb_release -a <blockquote>\n<p>Linux Standard Base</p>\n</blockquote>\n</li>\n<li>cat /etc/os-release</li>\n</ul>\n</li>\n<li><p>[查看是否安装某个软件]</p>\n<ul>\n<li>Ubuntu <code>dpkg -s &quot;软件或包的名字&quot;</code></li>\n<li>CentOS <code>rpm -qa | grep &quot;软件或者包的名字&quot;</code><blockquote>\n<p><code>rpm: redhat package manager; -q: query; a: all</code> </p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>查看网络活动相关信息</p>\n<ul>\n<li><p><code>netstat -nptl</code> </p>\n<blockquote>\n<p>connetction、tcp、programs、listening </p>\n</blockquote>\n<pre><code class=\"ini\">  [root@cloudr etc]# netstat -h\n  -r, --route              display routing table\n  -I, --interfaces=&lt;Iface&gt; display interface table for &lt;Iface&gt;\n  -i, --interfaces         display interface table\n  -s, --statistics         display networking statistics (like SNMP)\n  -M, --masquerade         display masqueraded connections\n\n  -v, --verbose            be verbose //详细的\n  -e, --extend             display other/more information\n  -p, --programs           display PID/Program name for sockets    //PID、程序名\n  -o, --timers             display timers\n  -c, --continuous         continuous listing\n\n  -l, --listening          display listening server sockets //监听中的套接口\n  -a, --all                display all sockets (default: connected)\n  -F, --fib                display Forwarding Information Base (default)\n  -C, --cache              display routing cache instead of FIB\n  -Z, --context            display SELinux security context for sockets\n\n  -t, --tcp    //tcp相关\n  -u, --udp    //udp相关\n  -U, --udplite\n  -w, --raw     //原始\n  -x, --unix    //unix相关</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-用户和工作组管理类命令\"><a href=\"#2-用户和工作组管理类命令\" class=\"headerlink\" title=\"2.用户和工作组管理类命令\"></a>2.用户和工作组管理类命令</h2><h3 id=\"2-1-查看用户\"><a href=\"#2-1-查看用户\" class=\"headerlink\" title=\"2.1 查看用户\"></a>2.1 查看用户</h3><ul>\n<li>查看用户信息命令 <code>id</code></li>\n<li>显示用户名称命令 <code>logname</code></li>\n<li>查看用户操作命令 <code>history</code><ul>\n<li>执行第几条命令 <code>!数字</code> </li>\n</ul>\n</li>\n<li>查看用户所属用户组 <code>groups</code><h3 id=\"2-2-用户组管理\"><a href=\"#2-2-用户组管理\" class=\"headerlink\" title=\"2.2 用户组管理\"></a>2.2 用户组管理</h3></li>\n<li>查看所有用户组命令 <code>cat /etc/group</code></li>\n<li>创建一个用户组命令 <code>groupadd 用户组名</code> </li>\n<li>删除一个用户组命令 <code>groupdel 用户名</code></li>\n<li>更改用户组名命令 <code>groupmod 新用户组名 旧用户组名</code></li>\n<li>添加用户到用户组 <code>usermode -a -G groupName userName</code><blockquote>\n<p>-a : appened，不能直接-G，否则会离开原有用户组</p>\n</blockquote>\n<h3 id=\"2-3-用户管理\"><a href=\"#2-3-用户管理\" class=\"headerlink\" title=\"2.3 用户管理\"></a>2.3 用户管理</h3></li>\n<li>查看当前登录用户名命令 <code>w、who、users、whoami</code></li>\n<li>切换用户 <code>su [选项] 目标用户</code></li>\n<li>新增用户账号 <code>useradd 用户名</code></li>\n<li>删除用户账号 <code>userdel 用户名</code><ul>\n<li>强制删除<code>userdel -f 用户名</code> </li>\n<li>删除用户的同时，删除与用户相关的所有文件 <code>userdel -r 用户名</code></li>\n</ul>\n</li>\n<li>为用户设置口令 <code>passwd 用户名</code></li>\n<li>查看用户所属组命令 <code>groups 用户名</code></li>\n<li>变更用户账号信息命令 <code>usermod [选项] 用户名</code></li>\n</ul>\n<h3 id=\"2-4-用户权限管理\"><a href=\"#2-4-用户权限管理\" class=\"headerlink\" title=\"2.4 用户权限管理\"></a>2.4 用户权限管理</h3><p>普通用户如何获得root权限</p>\n<ul>\n<li>用户使用sudo命令并输入口令<br>在文件/etc/sudoers第100行后添加<code>username  ALL=(ALL)   ALL</code>后保存修改，执行命令时输入当前用户口令，即可执行root权限</li>\n<li>用户组使用sudo命令并输入口令<br>在文件/etc/sudoers第100行后添加<code>%groupname  ALL=(ALL)   ALL</code>后保存修改，执行命令时输入当前用户口令，即可执行root权限</li>\n<li>用户使用sudo命令并（不需要输入口令）<br>在文件/etc/sudoers第100行后添加<code>username  ALL=(ALL)   NOPASSWD: ALL</code>后保存修改，执行命令时输入当前用户口令，即可执行root权限</li>\n<li>用户组使用sudo命令并（不需要输入口令）<br>在文件/etc/sudoers第100行后添加<code>%groupname  ALL=(ALL)   NOPASSWD: ALL</code>后保存修改，执行命令时输入当前用户口令，即可执行root权限</li>\n</ul>\n<ul>\n<li><p>显示当前挂载在Linux系统的每个分区 df</p>\n<ul>\n<li><code>df -h</code> 将分区小转换为用户可读的形式</li>\n</ul>\n</li>\n<li><p>查看文件大小</p>\n<ul>\n<li><code>ll -h</code> h: human-readable</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>归档命令<code>tar</code></p>\n<ul>\n<li><p><code>tar -cvf testTar.tar *</code></p>\n<ul>\n<li>c –create: 创建一个新的归档文件</li>\n<li>v –verbose: 显示已处理文件</li>\n<li>f –file=ARCHIVE: 指向归档文件的名字</li>\n</ul>\n</li>\n<li><p><code>tar -cvzf testTar.tar.gz *</code></p>\n<ul>\n<li>z –zip: 压缩归档文件 </li>\n</ul>\n</li>\n<li><p><code>tar -xvzf testTar.tar.gz</code></p>\n<ul>\n<li>x –extract : 提取（解压）</li>\n</ul>\n</li>\n<li><p><code>tar czvf - importantstuff/ | ssh useranme@10.0.0.123  &quot;cat &gt; /home/username/myfiles.tar.gz</code> ： 归档importantstuff目录下的文件至10.0.0.123主机的/home/username/myfile.tar.gz文件</p>\n<ul>\n<li>- : 该连接符表示将数据输出到标准标准的输出设备上，这允许将归档文件文件名的详细信息推后至该命令的末尾。</li>\n<li>| : 管道，将这个未命名的、压缩的归档文件传输至远程服务器的ssh登陆    </li>\n<li>“cat &gt; /home/username/myfiles.tar.gz” : 键入内容至myfiles.tar.gz(覆盖)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>文件分割 split</p>\n<ul>\n<li><code>split -4 README.md</code>: 将README.md文件每4行分割为以x开头的文件,例如xaa、xab、xac；</li>\n<li><code>split 2KB README.md REAME.md.part</code>: 将README.md分割为以REAMD.md.part开头的文件，例如REAME.md.part.aa、REAME.md.part.ab</li>\n</ul>\n</li>\n<li><p>搜索文件命令locate</p>\n<ul>\n<li><p><code>locate *.mp4</code></p>\n<blockquote>\n<p>locate命令并非真正地文件系统本身，而是在一个已存在的索引中进行简单的搜索，但是该索引<strong>并不是实时性的</strong>，默认是在系统每次启动时自动更新，所以会因为索引过时时搜索不到文件，使用<code>updatedb</code>命令更新.<br></p>\n</blockquote>\n<blockquote>\n<p>centos安装命令<code>sudo yum install mlocate</code></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>指定目录下查找文件find</p>\n<ul>\n<li><code>find readme.md</code> : 在当前目录下查找文件名为readme.md的文件（默认为当前目录下查找）</li>\n<li><code>find /home/cc1/dd/ -iname &quot;*.java&quot; -exec tar -rvf javaZip.tar {} \\;</code><ul>\n<li>-exec: shell的内建命令，在当前shell下用exec后面的命令替换掉当前执行的进程，并将老进程的环境清除掉。</li>\n<li>-iname: 忽略名字字母大小写查找</li>\n<li>{}: 告诉find命令，对于每个查找到的文件执行官exec后面的命令</li>\n<li>\\;: 格式，必须 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/zox2011/archive/2013/05/28/3103824.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zox2011/archive/2013/05/28/3103824.html</a></p>"},{"title":"平凡之路","abbrlink":"c22157c3","date":"2020-05-01T10:27:10.000Z","_content":"\n**我曾经跨过山和大海**     \n**也曾拥有着一切**   \n**转眼都飘散如烟**      \n**我曾经失落失望失掉所有方向**    \n**直到看见平凡才是唯一的答案**     \n\n\n\n<!-- more -->\n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n徘徊着的 在路上的   \n你要走吗 Via Via    \n易碎的 骄傲着     \n那也曾是我的模样   \n沸腾着的  不安者的     \n你要去哪 Via Via    \n迷一样的 沉默着的      \n故事你真的在听吗    \n**我曾经跨过山和大海**     \n**也曾拥有着一切**   \n**转眼都飘散如烟**      \n**我曾经失落失望失掉所有方向**    \n**直到看见平凡才是唯一的答案**  \n当你仍然 还在幻想     \n你的明天 Via Via     \n她会好吗 还是更烂    \n对我而言是另一天    \n我曾经毁了我的一切     \n只想永远离开    \n我曾堕入无边黑暗      \n想挣扎无法自拔     \n我曾经像你像他像那野草野花    \n绝望着 也渴望着     \n也哭也笑也平凡着    \n向前走 就这么走     \n就算你被给过什么    \n向前走 就这么走    \n就算你夺走什么   \n向前走 就这么走    \n就算你会    \n我曾经跨过山河大海   \n也穿过人山人海   \n我曾经拥有着的一切\n转眼都飘散如烟   \n我曾经失落失望失掉所有方向    \n直到看见平凡才是唯一的答案     \n我曾经毁了我的一切   \n只想永远德离开    \n我曾经堕入黑暗     \n想挣扎无法自拔    \n我曾经像你像他像那野草野花   \n绝望着 也渴望着    \n也哭也笑平凡着    \n我曾经跨过山和大海   \n也穿过人山人海    \n我曾经问遍整个世界   \n从来没得到答案    \n我不过像你像他像那野草野花    \n冥冥中这是我 唯一要走的路啊   \n**时间无言 如此这般**    \n明天已在 Hia Hia    \n风吹过的 路依然远\n你的故事讲到哪了\n\n\n","source":"_posts/lyrics/平凡之路.md","raw":"---\ntitle: 平凡之路\ncategories: Lyrics\nabbrlink: c22157c3\ndate: 2020-05-01 18:27:10\n---\n\n**我曾经跨过山和大海**     \n**也曾拥有着一切**   \n**转眼都飘散如烟**      \n**我曾经失落失望失掉所有方向**    \n**直到看见平凡才是唯一的答案**     \n\n\n\n<!-- more -->\n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n徘徊着的 在路上的   \n你要走吗 Via Via    \n易碎的 骄傲着     \n那也曾是我的模样   \n沸腾着的  不安者的     \n你要去哪 Via Via    \n迷一样的 沉默着的      \n故事你真的在听吗    \n**我曾经跨过山和大海**     \n**也曾拥有着一切**   \n**转眼都飘散如烟**      \n**我曾经失落失望失掉所有方向**    \n**直到看见平凡才是唯一的答案**  \n当你仍然 还在幻想     \n你的明天 Via Via     \n她会好吗 还是更烂    \n对我而言是另一天    \n我曾经毁了我的一切     \n只想永远离开    \n我曾堕入无边黑暗      \n想挣扎无法自拔     \n我曾经像你像他像那野草野花    \n绝望着 也渴望着     \n也哭也笑也平凡着    \n向前走 就这么走     \n就算你被给过什么    \n向前走 就这么走    \n就算你夺走什么   \n向前走 就这么走    \n就算你会    \n我曾经跨过山河大海   \n也穿过人山人海   \n我曾经拥有着的一切\n转眼都飘散如烟   \n我曾经失落失望失掉所有方向    \n直到看见平凡才是唯一的答案     \n我曾经毁了我的一切   \n只想永远德离开    \n我曾经堕入黑暗     \n想挣扎无法自拔    \n我曾经像你像他像那野草野花   \n绝望着 也渴望着    \n也哭也笑平凡着    \n我曾经跨过山和大海   \n也穿过人山人海    \n我曾经问遍整个世界   \n从来没得到答案    \n我不过像你像他像那野草野花    \n冥冥中这是我 唯一要走的路啊   \n**时间无言 如此这般**    \n明天已在 Hia Hia    \n风吹过的 路依然远\n你的故事讲到哪了\n\n\n","slug":"lyrics/平凡之路","published":1,"updated":"2020-05-01T10:38:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1f7001z0w7t9afc9otq","content":"<p><strong>我曾经跨过山和大海</strong><br><strong>也曾拥有着一切</strong><br><strong>转眼都飘散如烟</strong><br><strong>我曾经失落失望失掉所有方向</strong><br><strong>直到看见平凡才是唯一的答案</strong>     </p>\n<a id=\"more\"></a>\n<br>\n<br>\n\n<hr>\n<br>\n<br>\n\n<p>徘徊着的 在路上的<br>你要走吗 Via Via<br>易碎的 骄傲着<br>那也曾是我的模样<br>沸腾着的  不安者的<br>你要去哪 Via Via<br>迷一样的 沉默着的<br>故事你真的在听吗<br><strong>我曾经跨过山和大海</strong><br><strong>也曾拥有着一切</strong><br><strong>转眼都飘散如烟</strong><br><strong>我曾经失落失望失掉所有方向</strong><br><strong>直到看见平凡才是唯一的答案</strong><br>当你仍然 还在幻想<br>你的明天 Via Via<br>她会好吗 还是更烂<br>对我而言是另一天<br>我曾经毁了我的一切<br>只想永远离开<br>我曾堕入无边黑暗<br>想挣扎无法自拔<br>我曾经像你像他像那野草野花<br>绝望着 也渴望着<br>也哭也笑也平凡着<br>向前走 就这么走<br>就算你被给过什么<br>向前走 就这么走<br>就算你夺走什么<br>向前走 就这么走<br>就算你会<br>我曾经跨过山河大海<br>也穿过人山人海<br>我曾经拥有着的一切<br>转眼都飘散如烟<br>我曾经失落失望失掉所有方向<br>直到看见平凡才是唯一的答案<br>我曾经毁了我的一切<br>只想永远德离开<br>我曾经堕入黑暗<br>想挣扎无法自拔<br>我曾经像你像他像那野草野花<br>绝望着 也渴望着<br>也哭也笑平凡着<br>我曾经跨过山和大海<br>也穿过人山人海<br>我曾经问遍整个世界<br>从来没得到答案<br>我不过像你像他像那野草野花<br>冥冥中这是我 唯一要走的路啊<br><strong>时间无言 如此这般</strong><br>明天已在 Hia Hia<br>风吹过的 路依然远<br>你的故事讲到哪了</p>\n","site":{"data":{}},"excerpt":"<p><strong>我曾经跨过山和大海</strong><br><strong>也曾拥有着一切</strong><br><strong>转眼都飘散如烟</strong><br><strong>我曾经失落失望失掉所有方向</strong><br><strong>直到看见平凡才是唯一的答案</strong>     </p>","more":"<br>\n<br>\n\n<hr>\n<br>\n<br>\n\n<p>徘徊着的 在路上的<br>你要走吗 Via Via<br>易碎的 骄傲着<br>那也曾是我的模样<br>沸腾着的  不安者的<br>你要去哪 Via Via<br>迷一样的 沉默着的<br>故事你真的在听吗<br><strong>我曾经跨过山和大海</strong><br><strong>也曾拥有着一切</strong><br><strong>转眼都飘散如烟</strong><br><strong>我曾经失落失望失掉所有方向</strong><br><strong>直到看见平凡才是唯一的答案</strong><br>当你仍然 还在幻想<br>你的明天 Via Via<br>她会好吗 还是更烂<br>对我而言是另一天<br>我曾经毁了我的一切<br>只想永远离开<br>我曾堕入无边黑暗<br>想挣扎无法自拔<br>我曾经像你像他像那野草野花<br>绝望着 也渴望着<br>也哭也笑也平凡着<br>向前走 就这么走<br>就算你被给过什么<br>向前走 就这么走<br>就算你夺走什么<br>向前走 就这么走<br>就算你会<br>我曾经跨过山河大海<br>也穿过人山人海<br>我曾经拥有着的一切<br>转眼都飘散如烟<br>我曾经失落失望失掉所有方向<br>直到看见平凡才是唯一的答案<br>我曾经毁了我的一切<br>只想永远德离开<br>我曾经堕入黑暗<br>想挣扎无法自拔<br>我曾经像你像他像那野草野花<br>绝望着 也渴望着<br>也哭也笑平凡着<br>我曾经跨过山和大海<br>也穿过人山人海<br>我曾经问遍整个世界<br>从来没得到答案<br>我不过像你像他像那野草野花<br>冥冥中这是我 唯一要走的路啊<br><strong>时间无言 如此这般</strong><br>明天已在 Hia Hia<br>风吹过的 路依然远<br>你的故事讲到哪了</p>"},{"title":"Liunx下安装JDK","declare":true,"wordCount":true,"abbrlink":"2be0aa3a","data":"2020-07-20T11:02:10.000Z","_content":"\n* 解压\n* 创建储存位置\n* 移动jdk到指定位置\n* 配置环境变量\n* 更新环境变量\n* 更新环境变量\n* 测试\n\n<!-- more -->\n\n\n## 1.解压\n```ini\n[root@cc resource]# tar -zxvf jdk-8u161-linux-x64.tar.gz \n```\n\n## 2.创建储存位置\n```ini\n[root@cc resource]# cd /usr\n[root@cc resource]# mkdir java\n[root@cc resource]# cd java\n```\n\n## 3.移动jdk到指定位置\n```ini\n[root@cc resource]# mv  jdk1.8.0_161/ /usr/java\n```\n\n## 4.配置环境变量\n```ini\n[root@cc resource]# vim /etc/profile\n\n添加如下代码：\n\nexport JAVA_HOME=/usr/java/jdk1.8.0_161\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH\nexport JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin\nexport PATH=$PATH:${JAVA_PATH}\n\n```\n\n## 5.更新环境变量\n```ini\n[root@cc resource]# source /etc/profile\n```\n\n## 6.测试\n```ini\n[root@cc resource]# java -version\n```","source":"_posts/linux/安装jdk.md","raw":"---\ntitle: Liunx下安装JDK\ncategories: Linux\ntags: 环境配置\ndeclare: true\nwordCount: true\nabbrlink: 2be0aa3a\ndata: 2020-07-20 19:02:10\n---\n\n* 解压\n* 创建储存位置\n* 移动jdk到指定位置\n* 配置环境变量\n* 更新环境变量\n* 更新环境变量\n* 测试\n\n<!-- more -->\n\n\n## 1.解压\n```ini\n[root@cc resource]# tar -zxvf jdk-8u161-linux-x64.tar.gz \n```\n\n## 2.创建储存位置\n```ini\n[root@cc resource]# cd /usr\n[root@cc resource]# mkdir java\n[root@cc resource]# cd java\n```\n\n## 3.移动jdk到指定位置\n```ini\n[root@cc resource]# mv  jdk1.8.0_161/ /usr/java\n```\n\n## 4.配置环境变量\n```ini\n[root@cc resource]# vim /etc/profile\n\n添加如下代码：\n\nexport JAVA_HOME=/usr/java/jdk1.8.0_161\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH\nexport JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin\nexport PATH=$PATH:${JAVA_PATH}\n\n```\n\n## 5.更新环境变量\n```ini\n[root@cc resource]# source /etc/profile\n```\n\n## 6.测试\n```ini\n[root@cc resource]# java -version\n```","slug":"linux/安装jdk","published":1,"date":"2021-08-09T10:06:58.901Z","updated":"2020-07-21T09:06:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1f700210w7t5y52f03a","content":"<ul>\n<li>解压</li>\n<li>创建储存位置</li>\n<li>移动jdk到指定位置</li>\n<li>配置环境变量</li>\n<li>更新环境变量</li>\n<li>更新环境变量</li>\n<li>测试</li>\n</ul>\n<a id=\"more\"></a>\n\n\n<h2 id=\"1-解压\"><a href=\"#1-解压\" class=\"headerlink\" title=\"1.解压\"></a>1.解压</h2><pre class=\" language-ini\"><code class=\"language-ini\"><span class=\"token selector\">[root@cc resource]</span># tar -zxvf jdk-8u161-linux-x64.tar.gz </code></pre>\n<h2 id=\"2-创建储存位置\"><a href=\"#2-创建储存位置\" class=\"headerlink\" title=\"2.创建储存位置\"></a>2.创建储存位置</h2><pre class=\" language-ini\"><code class=\"language-ini\"><span class=\"token selector\">[root@cc resource]</span># cd /usr\n<span class=\"token selector\">[root@cc resource]</span># mkdir java\n<span class=\"token selector\">[root@cc resource]</span># cd java</code></pre>\n<h2 id=\"3-移动jdk到指定位置\"><a href=\"#3-移动jdk到指定位置\" class=\"headerlink\" title=\"3.移动jdk到指定位置\"></a>3.移动jdk到指定位置</h2><pre class=\" language-ini\"><code class=\"language-ini\"><span class=\"token selector\">[root@cc resource]</span># mv  jdk1.8.0_161/ /usr/java</code></pre>\n<h2 id=\"4-配置环境变量\"><a href=\"#4-配置环境变量\" class=\"headerlink\" title=\"4.配置环境变量\"></a>4.配置环境变量</h2><pre class=\" language-ini\"><code class=\"language-ini\"><span class=\"token selector\">[root@cc resource]</span># vim /etc/profile\n\n添加如下代码：\n\nexport JAVA_HOME<span class=\"token attr-value\"><span class=\"token punctuation\">=</span>/usr/java/jdk1.8.0_161</span>\nexport JRE_HOME<span class=\"token attr-value\"><span class=\"token punctuation\">=</span>${JAVA_HOME}/jre</span>\nexport CLASSPATH<span class=\"token attr-value\"><span class=\"token punctuation\">=</span>.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH</span>\nexport JAVA_PATH<span class=\"token attr-value\"><span class=\"token punctuation\">=</span>${JAVA_HOME}/bin:${JRE_HOME}/bin</span>\nexport PATH<span class=\"token attr-value\"><span class=\"token punctuation\">=</span>$PATH:${JAVA_PATH}</span>\n</code></pre>\n<h2 id=\"5-更新环境变量\"><a href=\"#5-更新环境变量\" class=\"headerlink\" title=\"5.更新环境变量\"></a>5.更新环境变量</h2><pre class=\" language-ini\"><code class=\"language-ini\"><span class=\"token selector\">[root@cc resource]</span># source /etc/profile</code></pre>\n<h2 id=\"6-测试\"><a href=\"#6-测试\" class=\"headerlink\" title=\"6.测试\"></a>6.测试</h2><pre class=\" language-ini\"><code class=\"language-ini\"><span class=\"token selector\">[root@cc resource]</span># java -version</code></pre>\n","site":{"data":{}},"excerpt":"<ul>\n<li>解压</li>\n<li>创建储存位置</li>\n<li>移动jdk到指定位置</li>\n<li>配置环境变量</li>\n<li>更新环境变量</li>\n<li>更新环境变量</li>\n<li>测试</li>\n</ul>","more":"<h2 id=\"1-解压\"><a href=\"#1-解压\" class=\"headerlink\" title=\"1.解压\"></a>1.解压</h2><pre><code class=\"ini\">[root@cc resource]# tar -zxvf jdk-8u161-linux-x64.tar.gz </code></pre>\n<h2 id=\"2-创建储存位置\"><a href=\"#2-创建储存位置\" class=\"headerlink\" title=\"2.创建储存位置\"></a>2.创建储存位置</h2><pre><code class=\"ini\">[root@cc resource]# cd /usr\n[root@cc resource]# mkdir java\n[root@cc resource]# cd java</code></pre>\n<h2 id=\"3-移动jdk到指定位置\"><a href=\"#3-移动jdk到指定位置\" class=\"headerlink\" title=\"3.移动jdk到指定位置\"></a>3.移动jdk到指定位置</h2><pre><code class=\"ini\">[root@cc resource]# mv  jdk1.8.0_161/ /usr/java</code></pre>\n<h2 id=\"4-配置环境变量\"><a href=\"#4-配置环境变量\" class=\"headerlink\" title=\"4.配置环境变量\"></a>4.配置环境变量</h2><pre><code class=\"ini\">[root@cc resource]# vim /etc/profile\n\n添加如下代码：\n\nexport JAVA_HOME=/usr/java/jdk1.8.0_161\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH\nexport JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin\nexport PATH=$PATH:${JAVA_PATH}\n</code></pre>\n<h2 id=\"5-更新环境变量\"><a href=\"#5-更新环境变量\" class=\"headerlink\" title=\"5.更新环境变量\"></a>5.更新环境变量</h2><pre><code class=\"ini\">[root@cc resource]# source /etc/profile</code></pre>\n<h2 id=\"6-测试\"><a href=\"#6-测试\" class=\"headerlink\" title=\"6.测试\"></a>6.测试</h2><pre><code class=\"ini\">[root@cc resource]# java -version</code></pre>"},{"title":"cmd命令","declare":true,"wordCount":true,"abbrlink":"8d229e40","date":"2020-04-29T08:57:10.000Z","_content":"❄\n<!-- more -->\n\n\n### 进程操作\n#### 进程\n* 查找占用4000端口的进程\n    * `netstat -aon|findstr \"1024\"`\n* 关闭PID为 1024的进程\n    * `taskkill /pid 1024 /f`","source":"_posts/tools/cmd命令.md","raw":"---\ntitle: cmd命令\ncategories: Tools\ntags: windows\ndeclare: true\nwordCount: true\nabbrlink: 8d229e40\ndate: 2020-04-29 16:57:10\n---\n❄\n<!-- more -->\n\n\n### 进程操作\n#### 进程\n* 查找占用4000端口的进程\n    * `netstat -aon|findstr \"1024\"`\n* 关闭PID为 1024的进程\n    * `taskkill /pid 1024 /f`","slug":"tools/cmd命令","published":1,"updated":"2020-04-30T15:58:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1f800240w7t4x9tdexq","content":"<p>❄</p>\n<a id=\"more\"></a>\n\n\n<h3 id=\"进程操作\"><a href=\"#进程操作\" class=\"headerlink\" title=\"进程操作\"></a>进程操作</h3><h4 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h4><ul>\n<li>查找占用4000端口的进程<ul>\n<li><code>netstat -aon|findstr &quot;1024&quot;</code></li>\n</ul>\n</li>\n<li>关闭PID为 1024的进程<ul>\n<li><code>taskkill /pid 1024 /f</code></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>❄</p>","more":"<h3 id=\"进程操作\"><a href=\"#进程操作\" class=\"headerlink\" title=\"进程操作\"></a>进程操作</h3><h4 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h4><ul>\n<li>查找占用4000端口的进程<ul>\n<li><code>netstat -aon|findstr &quot;1024&quot;</code></li>\n</ul>\n</li>\n<li>关闭PID为 1024的进程<ul>\n<li><code>taskkill /pid 1024 /f</code></li>\n</ul>\n</li>\n</ul>"},{"title":"Hello World","abbrlink":16107,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/test/hello-world.md","raw":"---\ntitle: Hello World\nabbrlink: 16107\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"test/hello-world","published":1,"date":"2021-08-09T10:06:58.911Z","updated":"2020-04-30T15:58:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1fa00250w7t0wngauz1","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo new <span class=\"token string\">\"My New Post\"</span></code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"Git","declare":true,"wordCount":true,"abbrlink":"341ecd43","date":"2020-11-29T15:54:34.000Z","_content":"<!-- git:\n    --- : 未修改（提交过的）\n    +++ : 修改过的  （未提交过的）\n-->\n\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/30/3YAsCch1igVaWyU.png\" alt=\"Git组成\" width=\"66%\"/>\n</div>\n\n\nGit是一个免费、开源的开源分布式版本控制系统，它可以高效快速地处理大小项目。它易于学习、占用空间极小性能而又极为出色，超越了像Subversion、CVS、Perforce和ClearCase这样的SCM(soft configuration management)工具，具有像便宜的本地分支、方便的存储区域和多个工作流这样的特性。\n<!-- more -->\n\n## 一、Git简介\nGit是一个**分布式系统**，即不同于集中式系统将所有的版本存放在中央服务器里，而是每一个设备上都是一个完整的版本库，这样做的好处不但使你不必依赖于互联网与中央服务器进行版本控制，而且即使一个设备损坏，只要在其他设备中存在你的项目，也不会造成你的数据丢失事故。\n> 当然在实际使用过程中，会选择一台设备作为“中央服务器”（例如github服务器），但这样只是为了有利于你的数据存储、携带以及团队之间的合作开发，并不是真正的中央服务器。\n\n### 1.1 Git的构成\n\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/29/aphYo63R7glfOQM.png\" alt=\"Git结构\" width=\"80%\"/>\n</div>\n\n> **workspace:工作区**      \n> **index/stage:暂存区**      \n> **repository:本地仓库**     \n> **remote:远程仓库**     \n\n1. **add**:将文件从工作区添加到暂存区；\n2. **commit**:将文件从暂存区提交到本地仓库；\n3. **push**:将文件本地仓库同步到远程仓库；\n4. **pull**: `git fetch` 和 `git merge` 的简写，从远程仓库获取代码并合并本地的版本；\n5. **fetch/clone**:`clone`将项目克隆到本地，`fetch`更新远程仓库文件到本地仓库；\n6. **checkout**:从版本库中恢复文件到工作区\n\nindex和repository共同组成版本库（本地）\n\n### 1.2 简单使用\n* 在当前目录下新建git仓库\n```ini\n    git init\n```\n* 添加文件到暂存区中\n```ini \n    git add fileName\n```\n* 提交文件到本地仓库中\n```ini\n    git commit -m \"commit information\"\n```\n* 推送本地仓库内容至远程仓库\n```ini\n    git push origin master\n```\n\n## 二、版本控制      \n利用Git我们可以对项目的文件进行存储、对文件的修改进行控制，是软件开发过程中必备的开发工具。   \n\n\n### 2.1 差异比较\n**Git管理的是修改，而并非文件本身**，我们可以利用`git status`我们可以比较workspace和index文件的差异，但是如何比较具体文件的差异时，我们需要用到`git diff` 命令\n\n* `git status`：比较workspace和index中的差异\n* `git diff (filename)`：比较workspace和index中文件的差异\n* `git diff --cached (filename)`、`git diff --staged (filename)`：比较index和上一次提交的差异\n* `git diff HEAD (filename)`：比较workspace和repository的差别\n    > HEAD指向repository中最新的提交的版本\n* `git diff --stat`：统计各个文件的具体变化情况worksapce和index\n* `git diff --numstat`：统计各个文件中变化的行数\n\n**git diff输出格式分析**     \n例如这里有一个文件gitDiffDemo.txt,有内容如下：\n```txt\nDragonBall1\nDragonBall2\nDragonBall3\nDragonBall4\nDragonBall5\nDragonBall6\nDragonBall7\nDragonBall8\nDragonBall9\n```\n\n将此文件提交至暂存区`$ git add gitDiffDemo.txt`后，将内容修改如下：\n```txt\nDragonBall1\nDragonBall2\nDragonBall3\nDragonBall4\nDragonBall5s \nDragonBall6\nDragonBall7\nDragonBall8\nDragonBall9 \n```\n此时使用`$ git diff gitDiffDemo.txt`查看异同：\n```ini\n$ git diff gitDiffDemo.txt \ndiff --git a/gitDiffDemo.txt b/gitDiffDemo.txt\nindex 9da8892..fa04dee 100644\n--- a/gitDiffDemo.txt\n+++ b/gitDiffDemo.txt\n@@ -2,7 +2,7 @@ DragonBall1\n DragonBall2\n DragonBall3\n DragonBall4\n-DragonBall5 \n+DragonBall5s \n DragonBall6\n DragonBall7\n DragonBall8\n```\n\n让我们来逐行来看输出内容\n```ini\nindex 9da8892..fa04dee 100644\n```\n9da8892..fa04dee表示暂存区具体文件（此处指当前文件夹下的gitDiffDemo.txt）的哈希值，100644表示对象模式，100表示普通文件(regular file)，644表示文件操作权限，即`rw-r--r--`\n> 101: symbolic link 110: git link \n\n```ini\n--- a/gitDiffDemo.txt\n+++ b/gitDiffDemo.txt\n```\n\\-\\-\\-表示变化前的版本（提交过的）    \n+++表示变化后的版本（修改过的）\n\n```ini\n@@ -2,7 +2,7 @@ DragonBall1\n```\n一对`@@`表示一个差异小结，一个差异小结的范围为**变更位置上下3行**，即一般为7行，上下行内容不足或两个差异点距离过近这个范围可能会缩小或变大。     \n`-2,7`: 表示变化前的文件中，差异小结范围为第2行开始连续7行        \n`+2,7`: 表示变化后的文件中，差异小结范围为第2行开始连续7行        \n\n\"DragonBall1\"内容为差异小结范围上一行，不用理会。 \n\n\n### 2.2 快照Id\n在Git中，针对每一次commit都会生成相应的快照，即在Git系统中我们可以选择恢复某一个时间点上的版本快照以此达到版本控制的目的，使用`git log`命令查看commit历史\n```ini\ncommit 7361c5145897d215c7bd9e9cf5a13c59f5908e7d\nAuthor: WyattWang <cc7722@foxmail.com>\nDate:   Sun Nov 29 20:14:41 2020 +0800\n\n    git tracks changes\n\ncommit 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9\nAuthor: WyattWang <cc7722@foxmail.com>\nDate:   Sun Nov 29 16:38:14 2020 +0800\n\n    append GPL\n\ncommit 1076977642fedc84ef89be1a840850b991e434c7\nAuthor: WyattWang <cc7722@foxmail.com>\nDate:   Sun Nov 29 16:17:24 2020 +0800\n\n    add distributed\n\ncommit a2fdd707b60ff78bada28410dc0ca8b6dd027e43\nAuthor: WyattWang <cc7722@foxmail.com>\nDate:   Sun Nov 29 14:11:51 2020 +0800\n\n    wrote a readme file\n\n```\n如上所示，每一小段commit信息从上往下包含了commit id、提交者信息、commit时间和commit信息。       \n如果只是想查看commit id和commit信息，加上`--pretty=oneline`参数即可\n```ini\n$ git log --pretty=oneline\n7361c5145897d215c7bd9e9cf5a13c59f5908e7d git tracks changes\n4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9 append GPL\n1076977642fedc84ef89be1a840850b991e434c7 add distributed\na2fdd707b60ff78bada28410dc0ca8b6dd027e43 wrote a readme file\n```\n\n### 2.3 版本回退\n在Git中，`HEAD`表示当前版本，上一个版本为`HEAD^`或`HEAD~1`，上上一个版本为`HEAD^^`或`HEAD~2`，上上个版本为`HEAD^^^`或`HEAD~3`......\n\n使用`git reset`命令可以让版本进行回退, 例如回退到上一版本\n```ini\n$ git reset --hard HEAD^ \n$ git reset --hard HEAD~1 \n```\n回退到指定commit id的版本\n```ini\n$ git reset --hard 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9\n```\n如果从版本B回退到之前的版本A，在A之后的提交信息将会在git log中**查询不到**commit id,但是如果在当前命令行窗口还可以看到版本B的commit id，或者使用`git reflog`可以看到版本变动的过程及其id\n```ini\n$ git reflog\ncde5cd3 HEAD@{0}: reset: moving to cde5cd3cf18629fbc9d9f033447478b90355224c\n4dbe0ff HEAD@{1}: reset: moving to HEAD^^\nd5c7d80 HEAD@{2}: reset: moving to HEAD~1\ncde5cd3 HEAD@{3}: commit: 提交2\nd5c7d80 HEAD@{4}: commit: 提交\n7361c51 HEAD@{5}: commit: git tracks changes\n4dbe0ff HEAD@{6}: reset: moving to 4dbe0ff\na2fdd70 HEAD@{7}: reset: moving to a2fdd70\n4dbe0ff HEAD@{8}: reset: moving to 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9\n1076977 HEAD@{9}: reset: moving to HEAD^\n4dbe0ff HEAD@{10}: commit: append GPL\n1076977 HEAD@{11}: commit: add distributed\na2fdd70 HEAD@{12}: commit (initial): wrote a readme file\n```\n\n\n在Git中除了使用`git reset`命令以外，还可以使用`git revert`命令来达到类似的的效果，但这两者还是有所区别：         \n* `git reset`是将版本**回退**到之前的版本，但那个版本之后的版本将不会被保留\n* `git revert`是将指定版本**反做**，例如按照时间线的版本为a->b->c, 当HEAD为版本c时反做版本b，即在提交版本b时，添加了file1.txt，则反做就是执行相反操作，删除file1.txt\n    > 如果**在一个文件中**多次修改内容并且进行提交，反做**非最后一次提交**时，会提示发生冲突，需要手动解决\n\n➦[Git恢复之前版本的两种方法reset、revert（图文详解）](https://blog.csdn.net/yxlshk/article/details/79944535)\n\n### 2.4 撤销修改\n如果需要**撤销在workspace中的修改**，可以使用`git checkout -- filename`命令(注意文件名前的空格)\n```ini\n$ git checkout -- readme.md \n```\n* 如果readme.md自修改后第一次放进index中，则git checkout后版本和repository中的版本是一致的\n* 如果readme.md之前放进过index中，则git checkout后版本和前一次添加到index中的版本保持一致       \n \n即`git checkout`后的版本和最新的`git add`或`git commit`的文件保持一致 \n<br>\n\n\n如果需要**撤销workspace添加到index中的修改**，则可已使用`git reset HEAD filename`命令\n```ini\n$ git reset HEAD readme.md\n```\n`git reset`不仅可以回退版本，还可以回退index中的修改，即将repository中最新的版本`HEAD`替换掉index中修改过的文件。\n\n\n### 2.5 删除文件\n如果工作区中的文件和版本库中的**版本一致**，使用`git rm <filename>`命令删除工作区文件，并且将这次删除放入暂存区\n```ini\n$ git rm readme.md\n$ git commit -m \"rm readme.md\"\n```\n\n如果在workspace中修改过文件，无论有没有添加到index中，即**工作区和版本库中文件版本不一致**，单纯使用`git rm`命令会出现错误，此时需要加上参数`-f`，即使用`git rm -f <filename>`进行删除\n```ini\n$ git rm -f readme.md\n```\n\n如果只是想删除版本库中的文件，**但保留工作区文件**，则使用`git rm --cached <filename>`可以删除暂存区文件，并将这次删除的操作添加到暂存区中，即此时该文件处于*untracked*状态\n```ini\n$ git rm --cached readme.md\n$ git commit -m \"untrack reame.md\"\n```\n\n\n## 三、远程仓库\n虽然Git是一个**分布式**的版本控制工具，并不存在着中央服务器，但是在实际使用中还是存在一个远程仓库，方便用于同步代码或协同开发的。    \n\n### 3.1 添加远程仓库\n使用`git remote add <仓库名称> <仓库地址>`命令可以建立本地仓库和远程仓库的连接\n```ini\n$ git remote add origin git@github.com:server-name/learn-git.git\n```\n添加完成后可以使用`git remote -v`查看已关联的远程仓库信息\n```ini\n$ git remote -v\norigin\tgit@gitee.com:server-name/learn-git.git (fetch)\norigin\tgit@gitee.com:server-name/learn-git.git (push)\n```\n以及可以使用`git remote rename <old name> <new name>`来更新远程仓库名称和使用`git remote remove <name>`来移除远程仓库名称\n\n### 3.2 推送文件\n使用`git push <远程主机名> <本地分支名>:<远程分支名>`命令可以推送本地仓库文件至远程仓库，特别的使用加上参数`-u`，可以给推送的分支加上（跟踪）引用，即使当前分子和多个远程主机存在关联，后面也可以不加任何参数使用git push推送到和本次相同的远程仓库中。\n```ini\n$ git push -u origin master #第一次\n$ git push                  #后续可简写\n```\n> 如果远程仓库地址为ssh url，则需要提前配置当前主机和远程主机的ssh公私钥\n\n特别的，使用`git push -f origin master`命令将本地文件推送到远程，并**强制覆盖**，使用时需要特别小心，**谨慎使用**。\n\n### 3.3 代码克隆\n使用`git clone <远程仓库地址>`命令可以将远程仓库的文件克隆到本地\n```ini\n$ git clone git@gitee.com:server-name/learn-git.git\n```\n\n\n\n\n\n## 参考\nhttps://www.cnblogs.com/ims-/p/9747333.html\n\nhttps://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n\nhttps://blog.csdn.net/qq_42780289/article/details/98353792\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/tools/Git.md","raw":"---\ntitle: Git\ncategories: Tools\ntags: SCM\ndeclare: true\nwordCount: true\nabbrlink: 341ecd43\ndate: 2020-11-29 23:54:34\n---\n<!-- git:\n    --- : 未修改（提交过的）\n    +++ : 修改过的  （未提交过的）\n-->\n\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/30/3YAsCch1igVaWyU.png\" alt=\"Git组成\" width=\"66%\"/>\n</div>\n\n\nGit是一个免费、开源的开源分布式版本控制系统，它可以高效快速地处理大小项目。它易于学习、占用空间极小性能而又极为出色，超越了像Subversion、CVS、Perforce和ClearCase这样的SCM(soft configuration management)工具，具有像便宜的本地分支、方便的存储区域和多个工作流这样的特性。\n<!-- more -->\n\n## 一、Git简介\nGit是一个**分布式系统**，即不同于集中式系统将所有的版本存放在中央服务器里，而是每一个设备上都是一个完整的版本库，这样做的好处不但使你不必依赖于互联网与中央服务器进行版本控制，而且即使一个设备损坏，只要在其他设备中存在你的项目，也不会造成你的数据丢失事故。\n> 当然在实际使用过程中，会选择一台设备作为“中央服务器”（例如github服务器），但这样只是为了有利于你的数据存储、携带以及团队之间的合作开发，并不是真正的中央服务器。\n\n### 1.1 Git的构成\n\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/29/aphYo63R7glfOQM.png\" alt=\"Git结构\" width=\"80%\"/>\n</div>\n\n> **workspace:工作区**      \n> **index/stage:暂存区**      \n> **repository:本地仓库**     \n> **remote:远程仓库**     \n\n1. **add**:将文件从工作区添加到暂存区；\n2. **commit**:将文件从暂存区提交到本地仓库；\n3. **push**:将文件本地仓库同步到远程仓库；\n4. **pull**: `git fetch` 和 `git merge` 的简写，从远程仓库获取代码并合并本地的版本；\n5. **fetch/clone**:`clone`将项目克隆到本地，`fetch`更新远程仓库文件到本地仓库；\n6. **checkout**:从版本库中恢复文件到工作区\n\nindex和repository共同组成版本库（本地）\n\n### 1.2 简单使用\n* 在当前目录下新建git仓库\n```ini\n    git init\n```\n* 添加文件到暂存区中\n```ini \n    git add fileName\n```\n* 提交文件到本地仓库中\n```ini\n    git commit -m \"commit information\"\n```\n* 推送本地仓库内容至远程仓库\n```ini\n    git push origin master\n```\n\n## 二、版本控制      \n利用Git我们可以对项目的文件进行存储、对文件的修改进行控制，是软件开发过程中必备的开发工具。   \n\n\n### 2.1 差异比较\n**Git管理的是修改，而并非文件本身**，我们可以利用`git status`我们可以比较workspace和index文件的差异，但是如何比较具体文件的差异时，我们需要用到`git diff` 命令\n\n* `git status`：比较workspace和index中的差异\n* `git diff (filename)`：比较workspace和index中文件的差异\n* `git diff --cached (filename)`、`git diff --staged (filename)`：比较index和上一次提交的差异\n* `git diff HEAD (filename)`：比较workspace和repository的差别\n    > HEAD指向repository中最新的提交的版本\n* `git diff --stat`：统计各个文件的具体变化情况worksapce和index\n* `git diff --numstat`：统计各个文件中变化的行数\n\n**git diff输出格式分析**     \n例如这里有一个文件gitDiffDemo.txt,有内容如下：\n```txt\nDragonBall1\nDragonBall2\nDragonBall3\nDragonBall4\nDragonBall5\nDragonBall6\nDragonBall7\nDragonBall8\nDragonBall9\n```\n\n将此文件提交至暂存区`$ git add gitDiffDemo.txt`后，将内容修改如下：\n```txt\nDragonBall1\nDragonBall2\nDragonBall3\nDragonBall4\nDragonBall5s \nDragonBall6\nDragonBall7\nDragonBall8\nDragonBall9 \n```\n此时使用`$ git diff gitDiffDemo.txt`查看异同：\n```ini\n$ git diff gitDiffDemo.txt \ndiff --git a/gitDiffDemo.txt b/gitDiffDemo.txt\nindex 9da8892..fa04dee 100644\n--- a/gitDiffDemo.txt\n+++ b/gitDiffDemo.txt\n@@ -2,7 +2,7 @@ DragonBall1\n DragonBall2\n DragonBall3\n DragonBall4\n-DragonBall5 \n+DragonBall5s \n DragonBall6\n DragonBall7\n DragonBall8\n```\n\n让我们来逐行来看输出内容\n```ini\nindex 9da8892..fa04dee 100644\n```\n9da8892..fa04dee表示暂存区具体文件（此处指当前文件夹下的gitDiffDemo.txt）的哈希值，100644表示对象模式，100表示普通文件(regular file)，644表示文件操作权限，即`rw-r--r--`\n> 101: symbolic link 110: git link \n\n```ini\n--- a/gitDiffDemo.txt\n+++ b/gitDiffDemo.txt\n```\n\\-\\-\\-表示变化前的版本（提交过的）    \n+++表示变化后的版本（修改过的）\n\n```ini\n@@ -2,7 +2,7 @@ DragonBall1\n```\n一对`@@`表示一个差异小结，一个差异小结的范围为**变更位置上下3行**，即一般为7行，上下行内容不足或两个差异点距离过近这个范围可能会缩小或变大。     \n`-2,7`: 表示变化前的文件中，差异小结范围为第2行开始连续7行        \n`+2,7`: 表示变化后的文件中，差异小结范围为第2行开始连续7行        \n\n\"DragonBall1\"内容为差异小结范围上一行，不用理会。 \n\n\n### 2.2 快照Id\n在Git中，针对每一次commit都会生成相应的快照，即在Git系统中我们可以选择恢复某一个时间点上的版本快照以此达到版本控制的目的，使用`git log`命令查看commit历史\n```ini\ncommit 7361c5145897d215c7bd9e9cf5a13c59f5908e7d\nAuthor: WyattWang <cc7722@foxmail.com>\nDate:   Sun Nov 29 20:14:41 2020 +0800\n\n    git tracks changes\n\ncommit 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9\nAuthor: WyattWang <cc7722@foxmail.com>\nDate:   Sun Nov 29 16:38:14 2020 +0800\n\n    append GPL\n\ncommit 1076977642fedc84ef89be1a840850b991e434c7\nAuthor: WyattWang <cc7722@foxmail.com>\nDate:   Sun Nov 29 16:17:24 2020 +0800\n\n    add distributed\n\ncommit a2fdd707b60ff78bada28410dc0ca8b6dd027e43\nAuthor: WyattWang <cc7722@foxmail.com>\nDate:   Sun Nov 29 14:11:51 2020 +0800\n\n    wrote a readme file\n\n```\n如上所示，每一小段commit信息从上往下包含了commit id、提交者信息、commit时间和commit信息。       \n如果只是想查看commit id和commit信息，加上`--pretty=oneline`参数即可\n```ini\n$ git log --pretty=oneline\n7361c5145897d215c7bd9e9cf5a13c59f5908e7d git tracks changes\n4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9 append GPL\n1076977642fedc84ef89be1a840850b991e434c7 add distributed\na2fdd707b60ff78bada28410dc0ca8b6dd027e43 wrote a readme file\n```\n\n### 2.3 版本回退\n在Git中，`HEAD`表示当前版本，上一个版本为`HEAD^`或`HEAD~1`，上上一个版本为`HEAD^^`或`HEAD~2`，上上个版本为`HEAD^^^`或`HEAD~3`......\n\n使用`git reset`命令可以让版本进行回退, 例如回退到上一版本\n```ini\n$ git reset --hard HEAD^ \n$ git reset --hard HEAD~1 \n```\n回退到指定commit id的版本\n```ini\n$ git reset --hard 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9\n```\n如果从版本B回退到之前的版本A，在A之后的提交信息将会在git log中**查询不到**commit id,但是如果在当前命令行窗口还可以看到版本B的commit id，或者使用`git reflog`可以看到版本变动的过程及其id\n```ini\n$ git reflog\ncde5cd3 HEAD@{0}: reset: moving to cde5cd3cf18629fbc9d9f033447478b90355224c\n4dbe0ff HEAD@{1}: reset: moving to HEAD^^\nd5c7d80 HEAD@{2}: reset: moving to HEAD~1\ncde5cd3 HEAD@{3}: commit: 提交2\nd5c7d80 HEAD@{4}: commit: 提交\n7361c51 HEAD@{5}: commit: git tracks changes\n4dbe0ff HEAD@{6}: reset: moving to 4dbe0ff\na2fdd70 HEAD@{7}: reset: moving to a2fdd70\n4dbe0ff HEAD@{8}: reset: moving to 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9\n1076977 HEAD@{9}: reset: moving to HEAD^\n4dbe0ff HEAD@{10}: commit: append GPL\n1076977 HEAD@{11}: commit: add distributed\na2fdd70 HEAD@{12}: commit (initial): wrote a readme file\n```\n\n\n在Git中除了使用`git reset`命令以外，还可以使用`git revert`命令来达到类似的的效果，但这两者还是有所区别：         \n* `git reset`是将版本**回退**到之前的版本，但那个版本之后的版本将不会被保留\n* `git revert`是将指定版本**反做**，例如按照时间线的版本为a->b->c, 当HEAD为版本c时反做版本b，即在提交版本b时，添加了file1.txt，则反做就是执行相反操作，删除file1.txt\n    > 如果**在一个文件中**多次修改内容并且进行提交，反做**非最后一次提交**时，会提示发生冲突，需要手动解决\n\n➦[Git恢复之前版本的两种方法reset、revert（图文详解）](https://blog.csdn.net/yxlshk/article/details/79944535)\n\n### 2.4 撤销修改\n如果需要**撤销在workspace中的修改**，可以使用`git checkout -- filename`命令(注意文件名前的空格)\n```ini\n$ git checkout -- readme.md \n```\n* 如果readme.md自修改后第一次放进index中，则git checkout后版本和repository中的版本是一致的\n* 如果readme.md之前放进过index中，则git checkout后版本和前一次添加到index中的版本保持一致       \n \n即`git checkout`后的版本和最新的`git add`或`git commit`的文件保持一致 \n<br>\n\n\n如果需要**撤销workspace添加到index中的修改**，则可已使用`git reset HEAD filename`命令\n```ini\n$ git reset HEAD readme.md\n```\n`git reset`不仅可以回退版本，还可以回退index中的修改，即将repository中最新的版本`HEAD`替换掉index中修改过的文件。\n\n\n### 2.5 删除文件\n如果工作区中的文件和版本库中的**版本一致**，使用`git rm <filename>`命令删除工作区文件，并且将这次删除放入暂存区\n```ini\n$ git rm readme.md\n$ git commit -m \"rm readme.md\"\n```\n\n如果在workspace中修改过文件，无论有没有添加到index中，即**工作区和版本库中文件版本不一致**，单纯使用`git rm`命令会出现错误，此时需要加上参数`-f`，即使用`git rm -f <filename>`进行删除\n```ini\n$ git rm -f readme.md\n```\n\n如果只是想删除版本库中的文件，**但保留工作区文件**，则使用`git rm --cached <filename>`可以删除暂存区文件，并将这次删除的操作添加到暂存区中，即此时该文件处于*untracked*状态\n```ini\n$ git rm --cached readme.md\n$ git commit -m \"untrack reame.md\"\n```\n\n\n## 三、远程仓库\n虽然Git是一个**分布式**的版本控制工具，并不存在着中央服务器，但是在实际使用中还是存在一个远程仓库，方便用于同步代码或协同开发的。    \n\n### 3.1 添加远程仓库\n使用`git remote add <仓库名称> <仓库地址>`命令可以建立本地仓库和远程仓库的连接\n```ini\n$ git remote add origin git@github.com:server-name/learn-git.git\n```\n添加完成后可以使用`git remote -v`查看已关联的远程仓库信息\n```ini\n$ git remote -v\norigin\tgit@gitee.com:server-name/learn-git.git (fetch)\norigin\tgit@gitee.com:server-name/learn-git.git (push)\n```\n以及可以使用`git remote rename <old name> <new name>`来更新远程仓库名称和使用`git remote remove <name>`来移除远程仓库名称\n\n### 3.2 推送文件\n使用`git push <远程主机名> <本地分支名>:<远程分支名>`命令可以推送本地仓库文件至远程仓库，特别的使用加上参数`-u`，可以给推送的分支加上（跟踪）引用，即使当前分子和多个远程主机存在关联，后面也可以不加任何参数使用git push推送到和本次相同的远程仓库中。\n```ini\n$ git push -u origin master #第一次\n$ git push                  #后续可简写\n```\n> 如果远程仓库地址为ssh url，则需要提前配置当前主机和远程主机的ssh公私钥\n\n特别的，使用`git push -f origin master`命令将本地文件推送到远程，并**强制覆盖**，使用时需要特别小心，**谨慎使用**。\n\n### 3.3 代码克隆\n使用`git clone <远程仓库地址>`命令可以将远程仓库的文件克隆到本地\n```ini\n$ git clone git@gitee.com:server-name/learn-git.git\n```\n\n\n\n\n\n## 参考\nhttps://www.cnblogs.com/ims-/p/9747333.html\n\nhttps://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n\nhttps://blog.csdn.net/qq_42780289/article/details/98353792\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"tools/Git","published":1,"updated":"2020-12-15T12:46:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1fb002a0w7t9hygghpn","content":"<!-- git:\n    --- : 未修改（提交过的）\n    +++ : 修改过的  （未提交过的）\n-->\n\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/30/3YAsCch1igVaWyU.png\" alt=\"Git组成\" width=\"66%\"/>\n</div>\n\n\n<p>Git是一个免费、开源的开源分布式版本控制系统，它可以高效快速地处理大小项目。它易于学习、占用空间极小性能而又极为出色，超越了像Subversion、CVS、Perforce和ClearCase这样的SCM(soft configuration management)工具，具有像便宜的本地分支、方便的存储区域和多个工作流这样的特性。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"一、Git简介\"><a href=\"#一、Git简介\" class=\"headerlink\" title=\"一、Git简介\"></a>一、Git简介</h2><p>Git是一个<strong>分布式系统</strong>，即不同于集中式系统将所有的版本存放在中央服务器里，而是每一个设备上都是一个完整的版本库，这样做的好处不但使你不必依赖于互联网与中央服务器进行版本控制，而且即使一个设备损坏，只要在其他设备中存在你的项目，也不会造成你的数据丢失事故。</p>\n<blockquote>\n<p>当然在实际使用过程中，会选择一台设备作为“中央服务器”（例如github服务器），但这样只是为了有利于你的数据存储、携带以及团队之间的合作开发，并不是真正的中央服务器。</p>\n</blockquote>\n<h3 id=\"1-1-Git的构成\"><a href=\"#1-1-Git的构成\" class=\"headerlink\" title=\"1.1 Git的构成\"></a>1.1 Git的构成</h3><div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/29/aphYo63R7glfOQM.png\" alt=\"Git结构\" width=\"80%\"/>\n</div>\n\n<blockquote>\n<p><strong>workspace:工作区</strong><br><strong>index/stage:暂存区</strong><br><strong>repository:本地仓库</strong><br><strong>remote:远程仓库</strong>     </p>\n</blockquote>\n<ol>\n<li><strong>add</strong>:将文件从工作区添加到暂存区；</li>\n<li><strong>commit</strong>:将文件从暂存区提交到本地仓库；</li>\n<li><strong>push</strong>:将文件本地仓库同步到远程仓库；</li>\n<li><strong>pull</strong>: <code>git fetch</code> 和 <code>git merge</code> 的简写，从远程仓库获取代码并合并本地的版本；</li>\n<li><strong>fetch/clone</strong>:<code>clone</code>将项目克隆到本地，<code>fetch</code>更新远程仓库文件到本地仓库；</li>\n<li><strong>checkout</strong>:从版本库中恢复文件到工作区</li>\n</ol>\n<p>index和repository共同组成版本库（本地）</p>\n<h3 id=\"1-2-简单使用\"><a href=\"#1-2-简单使用\" class=\"headerlink\" title=\"1.2 简单使用\"></a>1.2 简单使用</h3><ul>\n<li>在当前目录下新建git仓库<pre class=\" language-ini\"><code class=\"language-ini\">  git init</code></pre>\n</li>\n<li>添加文件到暂存区中<pre class=\" language-ini\"><code class=\"language-ini\">  git add fileName</code></pre>\n</li>\n<li>提交文件到本地仓库中<pre class=\" language-ini\"><code class=\"language-ini\">  git commit -m \"commit information\"</code></pre>\n</li>\n<li>推送本地仓库内容至远程仓库<pre class=\" language-ini\"><code class=\"language-ini\">  git push origin master</code></pre>\n</li>\n</ul>\n<h2 id=\"二、版本控制\"><a href=\"#二、版本控制\" class=\"headerlink\" title=\"二、版本控制\"></a>二、版本控制</h2><p>利用Git我们可以对项目的文件进行存储、对文件的修改进行控制，是软件开发过程中必备的开发工具。   </p>\n<h3 id=\"2-1-差异比较\"><a href=\"#2-1-差异比较\" class=\"headerlink\" title=\"2.1 差异比较\"></a>2.1 差异比较</h3><p><strong>Git管理的是修改，而并非文件本身</strong>，我们可以利用<code>git status</code>我们可以比较workspace和index文件的差异，但是如何比较具体文件的差异时，我们需要用到<code>git diff</code> 命令</p>\n<ul>\n<li><code>git status</code>：比较workspace和index中的差异</li>\n<li><code>git diff (filename)</code>：比较workspace和index中文件的差异</li>\n<li><code>git diff --cached (filename)</code>、<code>git diff --staged (filename)</code>：比较index和上一次提交的差异</li>\n<li><code>git diff HEAD (filename)</code>：比较workspace和repository的差别<blockquote>\n<p>HEAD指向repository中最新的提交的版本</p>\n</blockquote>\n</li>\n<li><code>git diff --stat</code>：统计各个文件的具体变化情况worksapce和index</li>\n<li><code>git diff --numstat</code>：统计各个文件中变化的行数</li>\n</ul>\n<p><strong>git diff输出格式分析</strong><br>例如这里有一个文件gitDiffDemo.txt,有内容如下：</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">DragonBall1\nDragonBall2\nDragonBall3\nDragonBall4\nDragonBall5\nDragonBall6\nDragonBall7\nDragonBall8\nDragonBall9</code></pre>\n<p>将此文件提交至暂存区<code>$ git add gitDiffDemo.txt</code>后，将内容修改如下：</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">DragonBall1\nDragonBall2\nDragonBall3\nDragonBall4\nDragonBall5s \nDragonBall6\nDragonBall7\nDragonBall8\nDragonBall9 </code></pre>\n<p>此时使用<code>$ git diff gitDiffDemo.txt</code>查看异同：</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git diff gitDiffDemo.txt \ndiff --git a/gitDiffDemo.txt b/gitDiffDemo.txt\nindex 9da8892..fa04dee 100644\n--- a/gitDiffDemo.txt\n+++ b/gitDiffDemo.txt\n@@ -2,7 +2,7 @@ DragonBall1\n DragonBall2\n DragonBall3\n DragonBall4\n-DragonBall5 \n+DragonBall5s \n DragonBall6\n DragonBall7\n DragonBall8</code></pre>\n<p>让我们来逐行来看输出内容</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">index 9da8892..fa04dee 100644</code></pre>\n<p>9da8892..fa04dee表示暂存区具体文件（此处指当前文件夹下的gitDiffDemo.txt）的哈希值，100644表示对象模式，100表示普通文件(regular file)，644表示文件操作权限，即<code>rw-r--r--</code></p>\n<blockquote>\n<p>101: symbolic link 110: git link </p>\n</blockquote>\n<pre class=\" language-ini\"><code class=\"language-ini\">--- a/gitDiffDemo.txt\n+++ b/gitDiffDemo.txt</code></pre>\n<p>---表示变化前的版本（提交过的）<br>+++表示变化后的版本（修改过的）</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">@@ -2,7 +2,7 @@ DragonBall1</code></pre>\n<p>一对<code>@@</code>表示一个差异小结，一个差异小结的范围为<strong>变更位置上下3行</strong>，即一般为7行，上下行内容不足或两个差异点距离过近这个范围可能会缩小或变大。<br><code>-2,7</code>: 表示变化前的文件中，差异小结范围为第2行开始连续7行<br><code>+2,7</code>: 表示变化后的文件中，差异小结范围为第2行开始连续7行        </p>\n<p>“DragonBall1”内容为差异小结范围上一行，不用理会。 </p>\n<h3 id=\"2-2-快照Id\"><a href=\"#2-2-快照Id\" class=\"headerlink\" title=\"2.2 快照Id\"></a>2.2 快照Id</h3><p>在Git中，针对每一次commit都会生成相应的快照，即在Git系统中我们可以选择恢复某一个时间点上的版本快照以此达到版本控制的目的，使用<code>git log</code>命令查看commit历史</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">commit 7361c5145897d215c7bd9e9cf5a13c59f5908e7d\nAuthor: WyattWang &lt;cc7722@foxmail.com>\nDate:   Sun Nov 29 20:14:41 2020 +0800\n\n    git tracks changes\n\ncommit 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9\nAuthor: WyattWang &lt;cc7722@foxmail.com>\nDate:   Sun Nov 29 16:38:14 2020 +0800\n\n    append GPL\n\ncommit 1076977642fedc84ef89be1a840850b991e434c7\nAuthor: WyattWang &lt;cc7722@foxmail.com>\nDate:   Sun Nov 29 16:17:24 2020 +0800\n\n    add distributed\n\ncommit a2fdd707b60ff78bada28410dc0ca8b6dd027e43\nAuthor: WyattWang &lt;cc7722@foxmail.com>\nDate:   Sun Nov 29 14:11:51 2020 +0800\n\n    wrote a readme file\n</code></pre>\n<p>如上所示，每一小段commit信息从上往下包含了commit id、提交者信息、commit时间和commit信息。<br>如果只是想查看commit id和commit信息，加上<code>--pretty=oneline</code>参数即可</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git log --pretty<span class=\"token attr-value\"><span class=\"token punctuation\">=</span>oneline</span>\n7361c5145897d215c7bd9e9cf5a13c59f5908e7d git tracks changes\n4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9 append GPL\n1076977642fedc84ef89be1a840850b991e434c7 add distributed\na2fdd707b60ff78bada28410dc0ca8b6dd027e43 wrote a readme file</code></pre>\n<h3 id=\"2-3-版本回退\"><a href=\"#2-3-版本回退\" class=\"headerlink\" title=\"2.3 版本回退\"></a>2.3 版本回退</h3><p>在Git中，<code>HEAD</code>表示当前版本，上一个版本为<code>HEAD^</code>或<code>HEAD~1</code>，上上一个版本为<code>HEAD^^</code>或<code>HEAD~2</code>，上上个版本为<code>HEAD^^^</code>或<code>HEAD~3</code>……</p>\n<p>使用<code>git reset</code>命令可以让版本进行回退, 例如回退到上一版本</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git reset --hard HEAD^ \n$ git reset --hard HEAD~1 </code></pre>\n<p>回退到指定commit id的版本</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git reset --hard 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9</code></pre>\n<p>如果从版本B回退到之前的版本A，在A之后的提交信息将会在git log中<strong>查询不到</strong>commit id,但是如果在当前命令行窗口还可以看到版本B的commit id，或者使用<code>git reflog</code>可以看到版本变动的过程及其id</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git reflog\ncde5cd3 HEAD@{0}: reset: moving to cde5cd3cf18629fbc9d9f033447478b90355224c\n4dbe0ff HEAD@{1}: reset: moving to HEAD^^\nd5c7d80 HEAD@{2}: reset: moving to HEAD~1\ncde5cd3 HEAD@{3}: commit: 提交2\nd5c7d80 HEAD@{4}: commit: 提交\n7361c51 HEAD@{5}: commit: git tracks changes\n4dbe0ff HEAD@{6}: reset: moving to 4dbe0ff\na2fdd70 HEAD@{7}: reset: moving to a2fdd70\n4dbe0ff HEAD@{8}: reset: moving to 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9\n1076977 HEAD@{9}: reset: moving to HEAD^\n4dbe0ff HEAD@{10}: commit: append GPL\n1076977 HEAD@{11}: commit: add distributed\na2fdd70 HEAD@{12}: commit (initial): wrote a readme file</code></pre>\n<p>在Git中除了使用<code>git reset</code>命令以外，还可以使用<code>git revert</code>命令来达到类似的的效果，但这两者还是有所区别：         </p>\n<ul>\n<li><code>git reset</code>是将版本<strong>回退</strong>到之前的版本，但那个版本之后的版本将不会被保留</li>\n<li><code>git revert</code>是将指定版本<strong>反做</strong>，例如按照时间线的版本为a-&gt;b-&gt;c, 当HEAD为版本c时反做版本b，即在提交版本b时，添加了file1.txt，则反做就是执行相反操作，删除file1.txt<blockquote>\n<p>如果<strong>在一个文件中</strong>多次修改内容并且进行提交，反做<strong>非最后一次提交</strong>时，会提示发生冲突，需要手动解决</p>\n</blockquote>\n</li>\n</ul>\n<p>➦<a href=\"https://blog.csdn.net/yxlshk/article/details/79944535\" target=\"_blank\" rel=\"noopener\">Git恢复之前版本的两种方法reset、revert（图文详解）</a></p>\n<h3 id=\"2-4-撤销修改\"><a href=\"#2-4-撤销修改\" class=\"headerlink\" title=\"2.4 撤销修改\"></a>2.4 撤销修改</h3><p>如果需要<strong>撤销在workspace中的修改</strong>，可以使用<code>git checkout -- filename</code>命令(注意文件名前的空格)</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git checkout -- readme.md </code></pre>\n<ul>\n<li>如果readme.md自修改后第一次放进index中，则git checkout后版本和repository中的版本是一致的</li>\n<li>如果readme.md之前放进过index中，则git checkout后版本和前一次添加到index中的版本保持一致       </li>\n</ul>\n<p>即<code>git checkout</code>后的版本和最新的<code>git add</code>或<code>git commit</code>的文件保持一致<br><br></p>\n<p>如果需要<strong>撤销workspace添加到index中的修改</strong>，则可已使用<code>git reset HEAD filename</code>命令</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git reset HEAD readme.md</code></pre>\n<p><code>git reset</code>不仅可以回退版本，还可以回退index中的修改，即将repository中最新的版本<code>HEAD</code>替换掉index中修改过的文件。</p>\n<h3 id=\"2-5-删除文件\"><a href=\"#2-5-删除文件\" class=\"headerlink\" title=\"2.5 删除文件\"></a>2.5 删除文件</h3><p>如果工作区中的文件和版本库中的<strong>版本一致</strong>，使用<code>git rm &lt;filename&gt;</code>命令删除工作区文件，并且将这次删除放入暂存区</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git rm readme.md\n$ git commit -m \"rm readme.md\"</code></pre>\n<p>如果在workspace中修改过文件，无论有没有添加到index中，即<strong>工作区和版本库中文件版本不一致</strong>，单纯使用<code>git rm</code>命令会出现错误，此时需要加上参数<code>-f</code>，即使用<code>git rm -f &lt;filename&gt;</code>进行删除</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git rm -f readme.md</code></pre>\n<p>如果只是想删除版本库中的文件，<strong>但保留工作区文件</strong>，则使用<code>git rm --cached &lt;filename&gt;</code>可以删除暂存区文件，并将这次删除的操作添加到暂存区中，即此时该文件处于<em>untracked</em>状态</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git rm --cached readme.md\n$ git commit -m \"untrack reame.md\"</code></pre>\n<h2 id=\"三、远程仓库\"><a href=\"#三、远程仓库\" class=\"headerlink\" title=\"三、远程仓库\"></a>三、远程仓库</h2><p>虽然Git是一个<strong>分布式</strong>的版本控制工具，并不存在着中央服务器，但是在实际使用中还是存在一个远程仓库，方便用于同步代码或协同开发的。    </p>\n<h3 id=\"3-1-添加远程仓库\"><a href=\"#3-1-添加远程仓库\" class=\"headerlink\" title=\"3.1 添加远程仓库\"></a>3.1 添加远程仓库</h3><p>使用<code>git remote add &lt;仓库名称&gt; &lt;仓库地址&gt;</code>命令可以建立本地仓库和远程仓库的连接</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git remote add origin git@github.com:server-name/learn-git.git</code></pre>\n<p>添加完成后可以使用<code>git remote -v</code>查看已关联的远程仓库信息</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git remote -v\norigin    git@gitee.com:server-name/learn-git.git (fetch)\norigin    git@gitee.com:server-name/learn-git.git (push)</code></pre>\n<p>以及可以使用<code>git remote rename &lt;old name&gt; &lt;new name&gt;</code>来更新远程仓库名称和使用<code>git remote remove &lt;name&gt;</code>来移除远程仓库名称</p>\n<h3 id=\"3-2-推送文件\"><a href=\"#3-2-推送文件\" class=\"headerlink\" title=\"3.2 推送文件\"></a>3.2 推送文件</h3><p>使用<code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>命令可以推送本地仓库文件至远程仓库，特别的使用加上参数<code>-u</code>，可以给推送的分支加上（跟踪）引用，即使当前分子和多个远程主机存在关联，后面也可以不加任何参数使用git push推送到和本次相同的远程仓库中。</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git push -u origin master #第一次\n$ git push                  #后续可简写</code></pre>\n<blockquote>\n<p>如果远程仓库地址为ssh url，则需要提前配置当前主机和远程主机的ssh公私钥</p>\n</blockquote>\n<p>特别的，使用<code>git push -f origin master</code>命令将本地文件推送到远程，并<strong>强制覆盖</strong>，使用时需要特别小心，<strong>谨慎使用</strong>。</p>\n<h3 id=\"3-3-代码克隆\"><a href=\"#3-3-代码克隆\" class=\"headerlink\" title=\"3.3 代码克隆\"></a>3.3 代码克隆</h3><p>使用<code>git clone &lt;远程仓库地址&gt;</code>命令可以将远程仓库的文件克隆到本地</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">$ git clone git@gitee.com:server-name/learn-git.git</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/ims-/p/9747333.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ims-/p/9747333.html</a></p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p>\n<p><a href=\"https://blog.csdn.net/qq_42780289/article/details/98353792\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_42780289/article/details/98353792</a></p>\n","site":{"data":{}},"excerpt":"<!-- git:\n    --- : 未修改（提交过的）\n    +++ : 修改过的  （未提交过的）\n-->\n\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/30/3YAsCch1igVaWyU.png\" alt=\"Git组成\" width=\"66%\"/>\n</div>\n\n\n<p>Git是一个免费、开源的开源分布式版本控制系统，它可以高效快速地处理大小项目。它易于学习、占用空间极小性能而又极为出色，超越了像Subversion、CVS、Perforce和ClearCase这样的SCM(soft configuration management)工具，具有像便宜的本地分支、方便的存储区域和多个工作流这样的特性。</p>","more":"<h2 id=\"一、Git简介\"><a href=\"#一、Git简介\" class=\"headerlink\" title=\"一、Git简介\"></a>一、Git简介</h2><p>Git是一个<strong>分布式系统</strong>，即不同于集中式系统将所有的版本存放在中央服务器里，而是每一个设备上都是一个完整的版本库，这样做的好处不但使你不必依赖于互联网与中央服务器进行版本控制，而且即使一个设备损坏，只要在其他设备中存在你的项目，也不会造成你的数据丢失事故。</p>\n<blockquote>\n<p>当然在实际使用过程中，会选择一台设备作为“中央服务器”（例如github服务器），但这样只是为了有利于你的数据存储、携带以及团队之间的合作开发，并不是真正的中央服务器。</p>\n</blockquote>\n<h3 id=\"1-1-Git的构成\"><a href=\"#1-1-Git的构成\" class=\"headerlink\" title=\"1.1 Git的构成\"></a>1.1 Git的构成</h3><div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/29/aphYo63R7glfOQM.png\" alt=\"Git结构\" width=\"80%\"/>\n</div>\n\n<blockquote>\n<p><strong>workspace:工作区</strong><br><strong>index/stage:暂存区</strong><br><strong>repository:本地仓库</strong><br><strong>remote:远程仓库</strong>     </p>\n</blockquote>\n<ol>\n<li><strong>add</strong>:将文件从工作区添加到暂存区；</li>\n<li><strong>commit</strong>:将文件从暂存区提交到本地仓库；</li>\n<li><strong>push</strong>:将文件本地仓库同步到远程仓库；</li>\n<li><strong>pull</strong>: <code>git fetch</code> 和 <code>git merge</code> 的简写，从远程仓库获取代码并合并本地的版本；</li>\n<li><strong>fetch/clone</strong>:<code>clone</code>将项目克隆到本地，<code>fetch</code>更新远程仓库文件到本地仓库；</li>\n<li><strong>checkout</strong>:从版本库中恢复文件到工作区</li>\n</ol>\n<p>index和repository共同组成版本库（本地）</p>\n<h3 id=\"1-2-简单使用\"><a href=\"#1-2-简单使用\" class=\"headerlink\" title=\"1.2 简单使用\"></a>1.2 简单使用</h3><ul>\n<li>在当前目录下新建git仓库<pre><code class=\"ini\">  git init</code></pre>\n</li>\n<li>添加文件到暂存区中<pre><code class=\"ini\">  git add fileName</code></pre>\n</li>\n<li>提交文件到本地仓库中<pre><code class=\"ini\">  git commit -m &quot;commit information&quot;</code></pre>\n</li>\n<li>推送本地仓库内容至远程仓库<pre><code class=\"ini\">  git push origin master</code></pre>\n</li>\n</ul>\n<h2 id=\"二、版本控制\"><a href=\"#二、版本控制\" class=\"headerlink\" title=\"二、版本控制\"></a>二、版本控制</h2><p>利用Git我们可以对项目的文件进行存储、对文件的修改进行控制，是软件开发过程中必备的开发工具。   </p>\n<h3 id=\"2-1-差异比较\"><a href=\"#2-1-差异比较\" class=\"headerlink\" title=\"2.1 差异比较\"></a>2.1 差异比较</h3><p><strong>Git管理的是修改，而并非文件本身</strong>，我们可以利用<code>git status</code>我们可以比较workspace和index文件的差异，但是如何比较具体文件的差异时，我们需要用到<code>git diff</code> 命令</p>\n<ul>\n<li><code>git status</code>：比较workspace和index中的差异</li>\n<li><code>git diff (filename)</code>：比较workspace和index中文件的差异</li>\n<li><code>git diff --cached (filename)</code>、<code>git diff --staged (filename)</code>：比较index和上一次提交的差异</li>\n<li><code>git diff HEAD (filename)</code>：比较workspace和repository的差别<blockquote>\n<p>HEAD指向repository中最新的提交的版本</p>\n</blockquote>\n</li>\n<li><code>git diff --stat</code>：统计各个文件的具体变化情况worksapce和index</li>\n<li><code>git diff --numstat</code>：统计各个文件中变化的行数</li>\n</ul>\n<p><strong>git diff输出格式分析</strong><br>例如这里有一个文件gitDiffDemo.txt,有内容如下：</p>\n<pre><code class=\"txt\">DragonBall1\nDragonBall2\nDragonBall3\nDragonBall4\nDragonBall5\nDragonBall6\nDragonBall7\nDragonBall8\nDragonBall9</code></pre>\n<p>将此文件提交至暂存区<code>$ git add gitDiffDemo.txt</code>后，将内容修改如下：</p>\n<pre><code class=\"txt\">DragonBall1\nDragonBall2\nDragonBall3\nDragonBall4\nDragonBall5s \nDragonBall6\nDragonBall7\nDragonBall8\nDragonBall9 </code></pre>\n<p>此时使用<code>$ git diff gitDiffDemo.txt</code>查看异同：</p>\n<pre><code class=\"ini\">$ git diff gitDiffDemo.txt \ndiff --git a/gitDiffDemo.txt b/gitDiffDemo.txt\nindex 9da8892..fa04dee 100644\n--- a/gitDiffDemo.txt\n+++ b/gitDiffDemo.txt\n@@ -2,7 +2,7 @@ DragonBall1\n DragonBall2\n DragonBall3\n DragonBall4\n-DragonBall5 \n+DragonBall5s \n DragonBall6\n DragonBall7\n DragonBall8</code></pre>\n<p>让我们来逐行来看输出内容</p>\n<pre><code class=\"ini\">index 9da8892..fa04dee 100644</code></pre>\n<p>9da8892..fa04dee表示暂存区具体文件（此处指当前文件夹下的gitDiffDemo.txt）的哈希值，100644表示对象模式，100表示普通文件(regular file)，644表示文件操作权限，即<code>rw-r--r--</code></p>\n<blockquote>\n<p>101: symbolic link 110: git link </p>\n</blockquote>\n<pre><code class=\"ini\">--- a/gitDiffDemo.txt\n+++ b/gitDiffDemo.txt</code></pre>\n<p>---表示变化前的版本（提交过的）<br>+++表示变化后的版本（修改过的）</p>\n<pre><code class=\"ini\">@@ -2,7 +2,7 @@ DragonBall1</code></pre>\n<p>一对<code>@@</code>表示一个差异小结，一个差异小结的范围为<strong>变更位置上下3行</strong>，即一般为7行，上下行内容不足或两个差异点距离过近这个范围可能会缩小或变大。<br><code>-2,7</code>: 表示变化前的文件中，差异小结范围为第2行开始连续7行<br><code>+2,7</code>: 表示变化后的文件中，差异小结范围为第2行开始连续7行        </p>\n<p>“DragonBall1”内容为差异小结范围上一行，不用理会。 </p>\n<h3 id=\"2-2-快照Id\"><a href=\"#2-2-快照Id\" class=\"headerlink\" title=\"2.2 快照Id\"></a>2.2 快照Id</h3><p>在Git中，针对每一次commit都会生成相应的快照，即在Git系统中我们可以选择恢复某一个时间点上的版本快照以此达到版本控制的目的，使用<code>git log</code>命令查看commit历史</p>\n<pre><code class=\"ini\">commit 7361c5145897d215c7bd9e9cf5a13c59f5908e7d\nAuthor: WyattWang &lt;cc7722@foxmail.com&gt;\nDate:   Sun Nov 29 20:14:41 2020 +0800\n\n    git tracks changes\n\ncommit 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9\nAuthor: WyattWang &lt;cc7722@foxmail.com&gt;\nDate:   Sun Nov 29 16:38:14 2020 +0800\n\n    append GPL\n\ncommit 1076977642fedc84ef89be1a840850b991e434c7\nAuthor: WyattWang &lt;cc7722@foxmail.com&gt;\nDate:   Sun Nov 29 16:17:24 2020 +0800\n\n    add distributed\n\ncommit a2fdd707b60ff78bada28410dc0ca8b6dd027e43\nAuthor: WyattWang &lt;cc7722@foxmail.com&gt;\nDate:   Sun Nov 29 14:11:51 2020 +0800\n\n    wrote a readme file\n</code></pre>\n<p>如上所示，每一小段commit信息从上往下包含了commit id、提交者信息、commit时间和commit信息。<br>如果只是想查看commit id和commit信息，加上<code>--pretty=oneline</code>参数即可</p>\n<pre><code class=\"ini\">$ git log --pretty=oneline\n7361c5145897d215c7bd9e9cf5a13c59f5908e7d git tracks changes\n4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9 append GPL\n1076977642fedc84ef89be1a840850b991e434c7 add distributed\na2fdd707b60ff78bada28410dc0ca8b6dd027e43 wrote a readme file</code></pre>\n<h3 id=\"2-3-版本回退\"><a href=\"#2-3-版本回退\" class=\"headerlink\" title=\"2.3 版本回退\"></a>2.3 版本回退</h3><p>在Git中，<code>HEAD</code>表示当前版本，上一个版本为<code>HEAD^</code>或<code>HEAD~1</code>，上上一个版本为<code>HEAD^^</code>或<code>HEAD~2</code>，上上个版本为<code>HEAD^^^</code>或<code>HEAD~3</code>……</p>\n<p>使用<code>git reset</code>命令可以让版本进行回退, 例如回退到上一版本</p>\n<pre><code class=\"ini\">$ git reset --hard HEAD^ \n$ git reset --hard HEAD~1 </code></pre>\n<p>回退到指定commit id的版本</p>\n<pre><code class=\"ini\">$ git reset --hard 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9</code></pre>\n<p>如果从版本B回退到之前的版本A，在A之后的提交信息将会在git log中<strong>查询不到</strong>commit id,但是如果在当前命令行窗口还可以看到版本B的commit id，或者使用<code>git reflog</code>可以看到版本变动的过程及其id</p>\n<pre><code class=\"ini\">$ git reflog\ncde5cd3 HEAD@{0}: reset: moving to cde5cd3cf18629fbc9d9f033447478b90355224c\n4dbe0ff HEAD@{1}: reset: moving to HEAD^^\nd5c7d80 HEAD@{2}: reset: moving to HEAD~1\ncde5cd3 HEAD@{3}: commit: 提交2\nd5c7d80 HEAD@{4}: commit: 提交\n7361c51 HEAD@{5}: commit: git tracks changes\n4dbe0ff HEAD@{6}: reset: moving to 4dbe0ff\na2fdd70 HEAD@{7}: reset: moving to a2fdd70\n4dbe0ff HEAD@{8}: reset: moving to 4dbe0ff1cd9ade95b0ca83e22ac6dc27619b1cd9\n1076977 HEAD@{9}: reset: moving to HEAD^\n4dbe0ff HEAD@{10}: commit: append GPL\n1076977 HEAD@{11}: commit: add distributed\na2fdd70 HEAD@{12}: commit (initial): wrote a readme file</code></pre>\n<p>在Git中除了使用<code>git reset</code>命令以外，还可以使用<code>git revert</code>命令来达到类似的的效果，但这两者还是有所区别：         </p>\n<ul>\n<li><code>git reset</code>是将版本<strong>回退</strong>到之前的版本，但那个版本之后的版本将不会被保留</li>\n<li><code>git revert</code>是将指定版本<strong>反做</strong>，例如按照时间线的版本为a-&gt;b-&gt;c, 当HEAD为版本c时反做版本b，即在提交版本b时，添加了file1.txt，则反做就是执行相反操作，删除file1.txt<blockquote>\n<p>如果<strong>在一个文件中</strong>多次修改内容并且进行提交，反做<strong>非最后一次提交</strong>时，会提示发生冲突，需要手动解决</p>\n</blockquote>\n</li>\n</ul>\n<p>➦<a href=\"https://blog.csdn.net/yxlshk/article/details/79944535\" target=\"_blank\" rel=\"noopener\">Git恢复之前版本的两种方法reset、revert（图文详解）</a></p>\n<h3 id=\"2-4-撤销修改\"><a href=\"#2-4-撤销修改\" class=\"headerlink\" title=\"2.4 撤销修改\"></a>2.4 撤销修改</h3><p>如果需要<strong>撤销在workspace中的修改</strong>，可以使用<code>git checkout -- filename</code>命令(注意文件名前的空格)</p>\n<pre><code class=\"ini\">$ git checkout -- readme.md </code></pre>\n<ul>\n<li>如果readme.md自修改后第一次放进index中，则git checkout后版本和repository中的版本是一致的</li>\n<li>如果readme.md之前放进过index中，则git checkout后版本和前一次添加到index中的版本保持一致       </li>\n</ul>\n<p>即<code>git checkout</code>后的版本和最新的<code>git add</code>或<code>git commit</code>的文件保持一致<br><br></p>\n<p>如果需要<strong>撤销workspace添加到index中的修改</strong>，则可已使用<code>git reset HEAD filename</code>命令</p>\n<pre><code class=\"ini\">$ git reset HEAD readme.md</code></pre>\n<p><code>git reset</code>不仅可以回退版本，还可以回退index中的修改，即将repository中最新的版本<code>HEAD</code>替换掉index中修改过的文件。</p>\n<h3 id=\"2-5-删除文件\"><a href=\"#2-5-删除文件\" class=\"headerlink\" title=\"2.5 删除文件\"></a>2.5 删除文件</h3><p>如果工作区中的文件和版本库中的<strong>版本一致</strong>，使用<code>git rm &lt;filename&gt;</code>命令删除工作区文件，并且将这次删除放入暂存区</p>\n<pre><code class=\"ini\">$ git rm readme.md\n$ git commit -m &quot;rm readme.md&quot;</code></pre>\n<p>如果在workspace中修改过文件，无论有没有添加到index中，即<strong>工作区和版本库中文件版本不一致</strong>，单纯使用<code>git rm</code>命令会出现错误，此时需要加上参数<code>-f</code>，即使用<code>git rm -f &lt;filename&gt;</code>进行删除</p>\n<pre><code class=\"ini\">$ git rm -f readme.md</code></pre>\n<p>如果只是想删除版本库中的文件，<strong>但保留工作区文件</strong>，则使用<code>git rm --cached &lt;filename&gt;</code>可以删除暂存区文件，并将这次删除的操作添加到暂存区中，即此时该文件处于<em>untracked</em>状态</p>\n<pre><code class=\"ini\">$ git rm --cached readme.md\n$ git commit -m &quot;untrack reame.md&quot;</code></pre>\n<h2 id=\"三、远程仓库\"><a href=\"#三、远程仓库\" class=\"headerlink\" title=\"三、远程仓库\"></a>三、远程仓库</h2><p>虽然Git是一个<strong>分布式</strong>的版本控制工具，并不存在着中央服务器，但是在实际使用中还是存在一个远程仓库，方便用于同步代码或协同开发的。    </p>\n<h3 id=\"3-1-添加远程仓库\"><a href=\"#3-1-添加远程仓库\" class=\"headerlink\" title=\"3.1 添加远程仓库\"></a>3.1 添加远程仓库</h3><p>使用<code>git remote add &lt;仓库名称&gt; &lt;仓库地址&gt;</code>命令可以建立本地仓库和远程仓库的连接</p>\n<pre><code class=\"ini\">$ git remote add origin git@github.com:server-name/learn-git.git</code></pre>\n<p>添加完成后可以使用<code>git remote -v</code>查看已关联的远程仓库信息</p>\n<pre><code class=\"ini\">$ git remote -v\norigin    git@gitee.com:server-name/learn-git.git (fetch)\norigin    git@gitee.com:server-name/learn-git.git (push)</code></pre>\n<p>以及可以使用<code>git remote rename &lt;old name&gt; &lt;new name&gt;</code>来更新远程仓库名称和使用<code>git remote remove &lt;name&gt;</code>来移除远程仓库名称</p>\n<h3 id=\"3-2-推送文件\"><a href=\"#3-2-推送文件\" class=\"headerlink\" title=\"3.2 推送文件\"></a>3.2 推送文件</h3><p>使用<code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>命令可以推送本地仓库文件至远程仓库，特别的使用加上参数<code>-u</code>，可以给推送的分支加上（跟踪）引用，即使当前分子和多个远程主机存在关联，后面也可以不加任何参数使用git push推送到和本次相同的远程仓库中。</p>\n<pre><code class=\"ini\">$ git push -u origin master #第一次\n$ git push                  #后续可简写</code></pre>\n<blockquote>\n<p>如果远程仓库地址为ssh url，则需要提前配置当前主机和远程主机的ssh公私钥</p>\n</blockquote>\n<p>特别的，使用<code>git push -f origin master</code>命令将本地文件推送到远程，并<strong>强制覆盖</strong>，使用时需要特别小心，<strong>谨慎使用</strong>。</p>\n<h3 id=\"3-3-代码克隆\"><a href=\"#3-3-代码克隆\" class=\"headerlink\" title=\"3.3 代码克隆\"></a>3.3 代码克隆</h3><p>使用<code>git clone &lt;远程仓库地址&gt;</code>命令可以将远程仓库的文件克隆到本地</p>\n<pre><code class=\"ini\">$ git clone git@gitee.com:server-name/learn-git.git</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/ims-/p/9747333.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ims-/p/9747333.html</a></p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p>\n<p><a href=\"https://blog.csdn.net/qq_42780289/article/details/98353792\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_42780289/article/details/98353792</a></p>"},{"title":"Docker command","declare":true,"wordCount":true,"abbrlink":"8f5fd259","date":"2021-03-20T03:54:34.000Z","_content":"\n## 一、Docker的基本使用和管理\n### 1. Docker配置\n* centos安装docker `yum install docker`\n* 设置普通用户使用docker\n    * 创建`docker`用户组 `groupadd docker`\n    * 添加用户到`docker`用户组 `usermod -a -G docker userName`\n    * 重启docker `systemctl restart docker`\n\n<!-- more -->\n\n/usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n### 2. Docker镜像操作\n* 搜索镜像 `docker search keyword`\n* 获取镜像 `docker pull imageName`\n* 查看镜像信息 `docker iamges`\n    * REPOSITORY：镜像所属的仓库\n    * TAG：镜像的标签信息，用于标记同一仓库的不同镜像\n        > 为了后续工作中方便使用镜像，可以使用`docker tag 名称:[标签] 新名称:[新标签]`\n    * IMAGE ID：镜像的唯一ID号\n        > 可通过ID号来获取对应镜像信息：`docker inspect id`\n* 删除镜像 `docker rmi 仓库名称:标签 | ID号`\n* 存出镜像 `docker save -o 存出文件名 存出的镜像`\n* 载入镜像 `docker load < | -i 目标镜像文件`\n* 上传镜像 \n    * 打上私有的标签 `docker tag 名称:[标签] 新名称:[新标签]`\n    * 上传 `docker push 仓库名称:标签`\n\n### 3. Docker容器操作\n* 创建 `docker create [OPTIONS] 镜像 运行的程序`\n    > `docker crate -it hivemq/hivemq4 /bin/bash`\n    * -i：让容器的输入保持打开状态\n    * -t：让Docker分配一个伪终端\n* 查看容器运行状态 `docker ps -a`\n* 启动容器 `docker start 容器ID | 名称`\n* 创建并运行容器 `docker [OPTIONS] run 仓库名称:标签`\n    * -d 后台运行\n    * --name：自定义一个名称\n    * -p：指定端口映射，指定容器端口映射到主机端口，`主机端口:容器端口`\n    * -P：随机端口映射，容器内部端口映射到主机的一个随机端口\n    * -e：设置相关环境变量\n    * TZ:设置容器内时区，例如`TZ=\"Asia/Shanghai\"`\n    * -v：设置数据卷       \n        * 创建数据卷：`-v 目录`\n        * 创建数据卷并挂载到主机目录： `-v 宿主机目录:容器数据卷目录`\n        * 挂载数据卷容器：`--volumes-from 容器名`\n* 容器的进入 `docker exec -it 容器ID | 名称 /bin/bash`\n> 容器是一个与其中运行的shell命令共存亡的众安，shell命令运行则容器运行，shell命令停止则容器停止，使用exit命令会在退出容器的同时关闭容器（但可以docker ps、docker restart恢复），所以使用`ctrl+P & ctrl + Q`可以退出容器\n* 容器终止运行 `docker stop 容器ID | 名称`\n* 容器导出 `docker export 容器ID | 名称 > 文件名`\n* 容器导入 `cat 文件名 | docker import - 生成镜像名称:标签`\n* 容器的删除 `docker rm 容器ID | 名称`\n\n<br><br>\n\n***\n<br><br>\n\n\n## 二、Docker镜像管理\n### 2.1 Docker的镜像结构\n镜像不是一个单一的文件，而是由多层构成的。可以由`docker history`命令来查看镜像中各层的内容及大小，**每一层对应着Dockerfile中的一条指令**，并且有如下特点：    \n* Dockerfile中的每个指令都会创建一个新的镜像层\n* 镜像层可以被缓存和复用\n* 当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量灵不同了，对应的镜像层缓存就会失效\n* 当某一层的镜像缓存失效，它之后的镜像层缓存都会失效\n* 镜像层是不可变的，如果在某一层添加一个文件，然后在下一层删除它，则镜像中依然会包含该文件，只是这个文件在Docker容器中不可见了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<br><br><br><br>\n<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>\n\n***\n<br><br>\n<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/var/lib/docker/containers/3141e6fc8b6f094abf1e4887cffd5a1e256d2f6107cc2d38800a169c36dbf970\n\n\"PortBindings\":{\"1883/tcp\":[{\"HostIp\":\"\",\"HostPort\":\"1884444\"}],\"8080/tcp\":[{\"HostIp\":\"\",\"HostPort\":\"8081\"}]},","source":"_posts/tools/docker.md","raw":"---\ntitle: Docker command\ncategories: Tools\ntags: Cloud\ndeclare: true\nwordCount: true\nabbrlink: 8f5fd259\ndate: 2021-03-20 11:54:34\n---\n\n## 一、Docker的基本使用和管理\n### 1. Docker配置\n* centos安装docker `yum install docker`\n* 设置普通用户使用docker\n    * 创建`docker`用户组 `groupadd docker`\n    * 添加用户到`docker`用户组 `usermod -a -G docker userName`\n    * 重启docker `systemctl restart docker`\n\n<!-- more -->\n\n/usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n### 2. Docker镜像操作\n* 搜索镜像 `docker search keyword`\n* 获取镜像 `docker pull imageName`\n* 查看镜像信息 `docker iamges`\n    * REPOSITORY：镜像所属的仓库\n    * TAG：镜像的标签信息，用于标记同一仓库的不同镜像\n        > 为了后续工作中方便使用镜像，可以使用`docker tag 名称:[标签] 新名称:[新标签]`\n    * IMAGE ID：镜像的唯一ID号\n        > 可通过ID号来获取对应镜像信息：`docker inspect id`\n* 删除镜像 `docker rmi 仓库名称:标签 | ID号`\n* 存出镜像 `docker save -o 存出文件名 存出的镜像`\n* 载入镜像 `docker load < | -i 目标镜像文件`\n* 上传镜像 \n    * 打上私有的标签 `docker tag 名称:[标签] 新名称:[新标签]`\n    * 上传 `docker push 仓库名称:标签`\n\n### 3. Docker容器操作\n* 创建 `docker create [OPTIONS] 镜像 运行的程序`\n    > `docker crate -it hivemq/hivemq4 /bin/bash`\n    * -i：让容器的输入保持打开状态\n    * -t：让Docker分配一个伪终端\n* 查看容器运行状态 `docker ps -a`\n* 启动容器 `docker start 容器ID | 名称`\n* 创建并运行容器 `docker [OPTIONS] run 仓库名称:标签`\n    * -d 后台运行\n    * --name：自定义一个名称\n    * -p：指定端口映射，指定容器端口映射到主机端口，`主机端口:容器端口`\n    * -P：随机端口映射，容器内部端口映射到主机的一个随机端口\n    * -e：设置相关环境变量\n    * TZ:设置容器内时区，例如`TZ=\"Asia/Shanghai\"`\n    * -v：设置数据卷       \n        * 创建数据卷：`-v 目录`\n        * 创建数据卷并挂载到主机目录： `-v 宿主机目录:容器数据卷目录`\n        * 挂载数据卷容器：`--volumes-from 容器名`\n* 容器的进入 `docker exec -it 容器ID | 名称 /bin/bash`\n> 容器是一个与其中运行的shell命令共存亡的众安，shell命令运行则容器运行，shell命令停止则容器停止，使用exit命令会在退出容器的同时关闭容器（但可以docker ps、docker restart恢复），所以使用`ctrl+P & ctrl + Q`可以退出容器\n* 容器终止运行 `docker stop 容器ID | 名称`\n* 容器导出 `docker export 容器ID | 名称 > 文件名`\n* 容器导入 `cat 文件名 | docker import - 生成镜像名称:标签`\n* 容器的删除 `docker rm 容器ID | 名称`\n\n<br><br>\n\n***\n<br><br>\n\n\n## 二、Docker镜像管理\n### 2.1 Docker的镜像结构\n镜像不是一个单一的文件，而是由多层构成的。可以由`docker history`命令来查看镜像中各层的内容及大小，**每一层对应着Dockerfile中的一条指令**，并且有如下特点：    \n* Dockerfile中的每个指令都会创建一个新的镜像层\n* 镜像层可以被缓存和复用\n* 当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量灵不同了，对应的镜像层缓存就会失效\n* 当某一层的镜像缓存失效，它之后的镜像层缓存都会失效\n* 镜像层是不可变的，如果在某一层添加一个文件，然后在下一层删除它，则镜像中依然会包含该文件，只是这个文件在Docker容器中不可见了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<br><br><br><br>\n<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>\n\n***\n<br><br>\n<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/var/lib/docker/containers/3141e6fc8b6f094abf1e4887cffd5a1e256d2f6107cc2d38800a169c36dbf970\n\n\"PortBindings\":{\"1883/tcp\":[{\"HostIp\":\"\",\"HostPort\":\"1884444\"}],\"8080/tcp\":[{\"HostIp\":\"\",\"HostPort\":\"8081\"}]},","slug":"tools/docker","published":1,"updated":"2021-07-23T03:01:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1fb002b0w7t5krj6c9a","content":"<h2 id=\"一、Docker的基本使用和管理\"><a href=\"#一、Docker的基本使用和管理\" class=\"headerlink\" title=\"一、Docker的基本使用和管理\"></a>一、Docker的基本使用和管理</h2><h3 id=\"1-Docker配置\"><a href=\"#1-Docker配置\" class=\"headerlink\" title=\"1. Docker配置\"></a>1. Docker配置</h3><ul>\n<li>centos安装docker <code>yum install docker</code></li>\n<li>设置普通用户使用docker<ul>\n<li>创建<code>docker</code>用户组 <code>groupadd docker</code></li>\n<li>添加用户到<code>docker</code>用户组 <code>usermod -a -G docker userName</code></li>\n<li>重启docker <code>systemctl restart docker</code></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<p>/usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>\n<h3 id=\"2-Docker镜像操作\"><a href=\"#2-Docker镜像操作\" class=\"headerlink\" title=\"2. Docker镜像操作\"></a>2. Docker镜像操作</h3><ul>\n<li>搜索镜像 <code>docker search keyword</code></li>\n<li>获取镜像 <code>docker pull imageName</code></li>\n<li>查看镜像信息 <code>docker iamges</code><ul>\n<li>REPOSITORY：镜像所属的仓库</li>\n<li>TAG：镜像的标签信息，用于标记同一仓库的不同镜像<blockquote>\n<p>为了后续工作中方便使用镜像，可以使用<code>docker tag 名称:[标签] 新名称:[新标签]</code></p>\n</blockquote>\n</li>\n<li>IMAGE ID：镜像的唯一ID号<blockquote>\n<p>可通过ID号来获取对应镜像信息：<code>docker inspect id</code></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>删除镜像 <code>docker rmi 仓库名称:标签 | ID号</code></li>\n<li>存出镜像 <code>docker save -o 存出文件名 存出的镜像</code></li>\n<li>载入镜像 <code>docker load &lt; | -i 目标镜像文件</code></li>\n<li>上传镜像 <ul>\n<li>打上私有的标签 <code>docker tag 名称:[标签] 新名称:[新标签]</code></li>\n<li>上传 <code>docker push 仓库名称:标签</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-Docker容器操作\"><a href=\"#3-Docker容器操作\" class=\"headerlink\" title=\"3. Docker容器操作\"></a>3. Docker容器操作</h3><ul>\n<li>创建 <code>docker create [OPTIONS] 镜像 运行的程序</code><blockquote>\n<p><code>docker crate -it hivemq/hivemq4 /bin/bash</code></p>\n</blockquote>\n<ul>\n<li>-i：让容器的输入保持打开状态</li>\n<li>-t：让Docker分配一个伪终端</li>\n</ul>\n</li>\n<li>查看容器运行状态 <code>docker ps -a</code></li>\n<li>启动容器 <code>docker start 容器ID | 名称</code></li>\n<li>创建并运行容器 <code>docker [OPTIONS] run 仓库名称:标签</code><ul>\n<li>-d 后台运行</li>\n<li>–name：自定义一个名称</li>\n<li>-p：指定端口映射，指定容器端口映射到主机端口，<code>主机端口:容器端口</code></li>\n<li>-P：随机端口映射，容器内部端口映射到主机的一个随机端口</li>\n<li>-e：设置相关环境变量</li>\n<li>TZ:设置容器内时区，例如<code>TZ=&quot;Asia/Shanghai&quot;</code></li>\n<li>-v：设置数据卷       <ul>\n<li>创建数据卷：<code>-v 目录</code></li>\n<li>创建数据卷并挂载到主机目录： <code>-v 宿主机目录:容器数据卷目录</code></li>\n<li>挂载数据卷容器：<code>--volumes-from 容器名</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>容器的进入 <code>docker exec -it 容器ID | 名称 /bin/bash</code><blockquote>\n<p>容器是一个与其中运行的shell命令共存亡的众安，shell命令运行则容器运行，shell命令停止则容器停止，使用exit命令会在退出容器的同时关闭容器（但可以docker ps、docker restart恢复），所以使用<code>ctrl+P &amp; ctrl + Q</code>可以退出容器</p>\n</blockquote>\n</li>\n<li>容器终止运行 <code>docker stop 容器ID | 名称</code></li>\n<li>容器导出 <code>docker export 容器ID | 名称 &gt; 文件名</code></li>\n<li>容器导入 <code>cat 文件名 | docker import - 生成镜像名称:标签</code></li>\n<li>容器的删除 <code>docker rm 容器ID | 名称</code></li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"二、Docker镜像管理\"><a href=\"#二、Docker镜像管理\" class=\"headerlink\" title=\"二、Docker镜像管理\"></a>二、Docker镜像管理</h2><h3 id=\"2-1-Docker的镜像结构\"><a href=\"#2-1-Docker的镜像结构\" class=\"headerlink\" title=\"2.1 Docker的镜像结构\"></a>2.1 Docker的镜像结构</h3><p>镜像不是一个单一的文件，而是由多层构成的。可以由<code>docker history</code>命令来查看镜像中各层的内容及大小，<strong>每一层对应着Dockerfile中的一条指令</strong>，并且有如下特点：    </p>\n<ul>\n<li>Dockerfile中的每个指令都会创建一个新的镜像层</li>\n<li>镜像层可以被缓存和复用</li>\n<li>当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量灵不同了，对应的镜像层缓存就会失效</li>\n<li>当某一层的镜像缓存失效，它之后的镜像层缓存都会失效</li>\n<li>镜像层是不可变的，如果在某一层添加一个文件，然后在下一层删除它，则镜像中依然会包含该文件，只是这个文件在Docker容器中不可见了。</li>\n</ul>\n<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>\n<hr>\n<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>\n<p>/var/lib/docker/containers/3141e6fc8b6f094abf1e4887cffd5a1e256d2f6107cc2d38800a169c36dbf970</p>\n<p>“PortBindings”:{“1883/tcp”:[{“HostIp”:””,”HostPort”:”1884444”}],”8080/tcp”:[{“HostIp”:””,”HostPort”:”8081”}]},</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、Docker的基本使用和管理\"><a href=\"#一、Docker的基本使用和管理\" class=\"headerlink\" title=\"一、Docker的基本使用和管理\"></a>一、Docker的基本使用和管理</h2><h3 id=\"1-Docker配置\"><a href=\"#1-Docker配置\" class=\"headerlink\" title=\"1. Docker配置\"></a>1. Docker配置</h3><ul>\n<li>centos安装docker <code>yum install docker</code></li>\n<li>设置普通用户使用docker<ul>\n<li>创建<code>docker</code>用户组 <code>groupadd docker</code></li>\n<li>添加用户到<code>docker</code>用户组 <code>usermod -a -G docker userName</code></li>\n<li>重启docker <code>systemctl restart docker</code></li>\n</ul>\n</li>\n</ul>","more":"<p>/usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>\n<h3 id=\"2-Docker镜像操作\"><a href=\"#2-Docker镜像操作\" class=\"headerlink\" title=\"2. Docker镜像操作\"></a>2. Docker镜像操作</h3><ul>\n<li>搜索镜像 <code>docker search keyword</code></li>\n<li>获取镜像 <code>docker pull imageName</code></li>\n<li>查看镜像信息 <code>docker iamges</code><ul>\n<li>REPOSITORY：镜像所属的仓库</li>\n<li>TAG：镜像的标签信息，用于标记同一仓库的不同镜像<blockquote>\n<p>为了后续工作中方便使用镜像，可以使用<code>docker tag 名称:[标签] 新名称:[新标签]</code></p>\n</blockquote>\n</li>\n<li>IMAGE ID：镜像的唯一ID号<blockquote>\n<p>可通过ID号来获取对应镜像信息：<code>docker inspect id</code></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>删除镜像 <code>docker rmi 仓库名称:标签 | ID号</code></li>\n<li>存出镜像 <code>docker save -o 存出文件名 存出的镜像</code></li>\n<li>载入镜像 <code>docker load &lt; | -i 目标镜像文件</code></li>\n<li>上传镜像 <ul>\n<li>打上私有的标签 <code>docker tag 名称:[标签] 新名称:[新标签]</code></li>\n<li>上传 <code>docker push 仓库名称:标签</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-Docker容器操作\"><a href=\"#3-Docker容器操作\" class=\"headerlink\" title=\"3. Docker容器操作\"></a>3. Docker容器操作</h3><ul>\n<li>创建 <code>docker create [OPTIONS] 镜像 运行的程序</code><blockquote>\n<p><code>docker crate -it hivemq/hivemq4 /bin/bash</code></p>\n</blockquote>\n<ul>\n<li>-i：让容器的输入保持打开状态</li>\n<li>-t：让Docker分配一个伪终端</li>\n</ul>\n</li>\n<li>查看容器运行状态 <code>docker ps -a</code></li>\n<li>启动容器 <code>docker start 容器ID | 名称</code></li>\n<li>创建并运行容器 <code>docker [OPTIONS] run 仓库名称:标签</code><ul>\n<li>-d 后台运行</li>\n<li>–name：自定义一个名称</li>\n<li>-p：指定端口映射，指定容器端口映射到主机端口，<code>主机端口:容器端口</code></li>\n<li>-P：随机端口映射，容器内部端口映射到主机的一个随机端口</li>\n<li>-e：设置相关环境变量</li>\n<li>TZ:设置容器内时区，例如<code>TZ=&quot;Asia/Shanghai&quot;</code></li>\n<li>-v：设置数据卷       <ul>\n<li>创建数据卷：<code>-v 目录</code></li>\n<li>创建数据卷并挂载到主机目录： <code>-v 宿主机目录:容器数据卷目录</code></li>\n<li>挂载数据卷容器：<code>--volumes-from 容器名</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>容器的进入 <code>docker exec -it 容器ID | 名称 /bin/bash</code><blockquote>\n<p>容器是一个与其中运行的shell命令共存亡的众安，shell命令运行则容器运行，shell命令停止则容器停止，使用exit命令会在退出容器的同时关闭容器（但可以docker ps、docker restart恢复），所以使用<code>ctrl+P &amp; ctrl + Q</code>可以退出容器</p>\n</blockquote>\n</li>\n<li>容器终止运行 <code>docker stop 容器ID | 名称</code></li>\n<li>容器导出 <code>docker export 容器ID | 名称 &gt; 文件名</code></li>\n<li>容器导入 <code>cat 文件名 | docker import - 生成镜像名称:标签</code></li>\n<li>容器的删除 <code>docker rm 容器ID | 名称</code></li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"二、Docker镜像管理\"><a href=\"#二、Docker镜像管理\" class=\"headerlink\" title=\"二、Docker镜像管理\"></a>二、Docker镜像管理</h2><h3 id=\"2-1-Docker的镜像结构\"><a href=\"#2-1-Docker的镜像结构\" class=\"headerlink\" title=\"2.1 Docker的镜像结构\"></a>2.1 Docker的镜像结构</h3><p>镜像不是一个单一的文件，而是由多层构成的。可以由<code>docker history</code>命令来查看镜像中各层的内容及大小，<strong>每一层对应着Dockerfile中的一条指令</strong>，并且有如下特点：    </p>\n<ul>\n<li>Dockerfile中的每个指令都会创建一个新的镜像层</li>\n<li>镜像层可以被缓存和复用</li>\n<li>当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量灵不同了，对应的镜像层缓存就会失效</li>\n<li>当某一层的镜像缓存失效，它之后的镜像层缓存都会失效</li>\n<li>镜像层是不可变的，如果在某一层添加一个文件，然后在下一层删除它，则镜像中依然会包含该文件，只是这个文件在Docker容器中不可见了。</li>\n</ul>\n<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>\n<hr>\n<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>\n<p>/var/lib/docker/containers/3141e6fc8b6f094abf1e4887cffd5a1e256d2f6107cc2d38800a169c36dbf970</p>\n<p>“PortBindings”:{“1883/tcp”:[{“HostIp”:””,”HostPort”:”1884444”}],”8080/tcp”:[{“HostIp”:””,”HostPort”:”8081”}]},</p>"},{"title":"linux下文件转码","declare":true,"wordCount":true,"abbrlink":"f48fda8c","date":"2020-05-18T10:00:10.000Z","_content":"\n最近两天因为项目中的原始文件编码格式为cp936，而程序处理的是utf-8，所以需要对其转换，想来也不是很麻烦，但是还是遇到了很多坑，所以记下，可能会帮到别人。\nlinux下有多种转换文件编码格式的方法，但最常用的转换工具是vim和`iconv`。\n<!-- more -->\n在很多地方都看了使用vim编辑器转码，但是我对其表示怀疑，因为测试过多次都不咋成功，可能还需要手动添加支持的编码格式，总之还是比较麻烦。而且打开vim转码也只是适用于少量非生产环境中，总之我只推荐使用vim查看编码格式，**不推荐使用vim转码**。\n## 一、VIM\n### 1.1 查看文件编码格式\n```ini\nset fileencoding\n```\n### 1.2 格式转换\n```\nset fileencoing= encoding  //加上自己需要的编码格式即可\n```\n> 我在ubuntu和centos上都测试过，都没能转换成功。。。。 **所以对此方法表示怀疑**\n\n## 二、iconv\n官方文档\n```ini\n[root@master test]# iconv -?\n用法： iconv [选项...] [文件...]\n转换给定文件的编码。\n\n 输入/输出格式规范：\n  -f, --from-code=名称     原始文本编码\n  -t, --to-code=名称       输出编码\n\n 信息：\n  -l, --list                 列举所有已知的字符集\n\n 输出控制：\n  -c                         从输出中忽略无效的字符\n  -o, --output=FILE          输出文件\n  -s, --silent               关闭警告\n      --verbose              打印进度信息\n\n  -?, --help                 给出该系统求助列表\n      --usage                给出简要的用法信息\n  -V, --version              打印程序版本号\n\n长选项的强制或可选参数对对应的短选项也是强制或可选的。\n\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/libc/bugs.html>.\n\n\n```\n### 2.1 查看支持的编码格式\n```ini\niconv -l\n```\n### 2.2 转换\n```ini\niconv -f encoding1 -t encoding2 filename1 -o filename2\n```    \n\n> -f : 原编码格式 &nbsp; -t: 转换后格式    \n> **一定要输出到文件中**，否则只会标准输出到显示器中 \n\n> 我这边无法将utf-8转换为cp936 ,gbk ,gb2312    \n> 但可以将cp936转换为utf-8，对于日常也够了\n\n### 2.3 常见问题\n* 首次使用可能需要安装\n```ini\nubuntu等：apt-get install iconv\ncentos等：yum install iconv\n```\n\n* `iconv: 未知 *** 处的非法输入序列`,加`-c`\n```ini\niconv -c -f encoding1 -t encoding2 filename1 -o filename2\n```\n\n* 转换后乱码。建议转码输出到另外一个文件中，猜测输出到源文件中即直接转码可能会引起文件内容紊乱。。。\n\n","source":"_posts/tools/Linux文件转码.md","raw":"---\ntitle: linux下文件转码\ncategories: Linux\ntags: linux工具\ndeclare: true\nwordCount: true\nabbrlink: f48fda8c\ndate: 2020-05-18 18:00:10\n---\n\n最近两天因为项目中的原始文件编码格式为cp936，而程序处理的是utf-8，所以需要对其转换，想来也不是很麻烦，但是还是遇到了很多坑，所以记下，可能会帮到别人。\nlinux下有多种转换文件编码格式的方法，但最常用的转换工具是vim和`iconv`。\n<!-- more -->\n在很多地方都看了使用vim编辑器转码，但是我对其表示怀疑，因为测试过多次都不咋成功，可能还需要手动添加支持的编码格式，总之还是比较麻烦。而且打开vim转码也只是适用于少量非生产环境中，总之我只推荐使用vim查看编码格式，**不推荐使用vim转码**。\n## 一、VIM\n### 1.1 查看文件编码格式\n```ini\nset fileencoding\n```\n### 1.2 格式转换\n```\nset fileencoing= encoding  //加上自己需要的编码格式即可\n```\n> 我在ubuntu和centos上都测试过，都没能转换成功。。。。 **所以对此方法表示怀疑**\n\n## 二、iconv\n官方文档\n```ini\n[root@master test]# iconv -?\n用法： iconv [选项...] [文件...]\n转换给定文件的编码。\n\n 输入/输出格式规范：\n  -f, --from-code=名称     原始文本编码\n  -t, --to-code=名称       输出编码\n\n 信息：\n  -l, --list                 列举所有已知的字符集\n\n 输出控制：\n  -c                         从输出中忽略无效的字符\n  -o, --output=FILE          输出文件\n  -s, --silent               关闭警告\n      --verbose              打印进度信息\n\n  -?, --help                 给出该系统求助列表\n      --usage                给出简要的用法信息\n  -V, --version              打印程序版本号\n\n长选项的强制或可选参数对对应的短选项也是强制或可选的。\n\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/libc/bugs.html>.\n\n\n```\n### 2.1 查看支持的编码格式\n```ini\niconv -l\n```\n### 2.2 转换\n```ini\niconv -f encoding1 -t encoding2 filename1 -o filename2\n```    \n\n> -f : 原编码格式 &nbsp; -t: 转换后格式    \n> **一定要输出到文件中**，否则只会标准输出到显示器中 \n\n> 我这边无法将utf-8转换为cp936 ,gbk ,gb2312    \n> 但可以将cp936转换为utf-8，对于日常也够了\n\n### 2.3 常见问题\n* 首次使用可能需要安装\n```ini\nubuntu等：apt-get install iconv\ncentos等：yum install iconv\n```\n\n* `iconv: 未知 *** 处的非法输入序列`,加`-c`\n```ini\niconv -c -f encoding1 -t encoding2 filename1 -o filename2\n```\n\n* 转换后乱码。建议转码输出到另外一个文件中，猜测输出到源文件中即直接转码可能会引起文件内容紊乱。。。\n\n","slug":"tools/Linux文件转码","published":1,"updated":"2020-07-20T11:01:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1fc002f0w7t5doneoxu","content":"<p>最近两天因为项目中的原始文件编码格式为cp936，而程序处理的是utf-8，所以需要对其转换，想来也不是很麻烦，但是还是遇到了很多坑，所以记下，可能会帮到别人。<br>linux下有多种转换文件编码格式的方法，但最常用的转换工具是vim和<code>iconv</code>。</p>\n<a id=\"more\"></a>\n<p>在很多地方都看了使用vim编辑器转码，但是我对其表示怀疑，因为测试过多次都不咋成功，可能还需要手动添加支持的编码格式，总之还是比较麻烦。而且打开vim转码也只是适用于少量非生产环境中，总之我只推荐使用vim查看编码格式，<strong>不推荐使用vim转码</strong>。</p>\n<h2 id=\"一、VIM\"><a href=\"#一、VIM\" class=\"headerlink\" title=\"一、VIM\"></a>一、VIM</h2><h3 id=\"1-1-查看文件编码格式\"><a href=\"#1-1-查看文件编码格式\" class=\"headerlink\" title=\"1.1 查看文件编码格式\"></a>1.1 查看文件编码格式</h3><pre class=\" language-ini\"><code class=\"language-ini\">set fileencoding</code></pre>\n<h3 id=\"1-2-格式转换\"><a href=\"#1-2-格式转换\" class=\"headerlink\" title=\"1.2 格式转换\"></a>1.2 格式转换</h3><pre><code>set fileencoing= encoding  //加上自己需要的编码格式即可</code></pre><blockquote>\n<p>我在ubuntu和centos上都测试过，都没能转换成功。。。。 <strong>所以对此方法表示怀疑</strong></p>\n</blockquote>\n<h2 id=\"二、iconv\"><a href=\"#二、iconv\" class=\"headerlink\" title=\"二、iconv\"></a>二、iconv</h2><p>官方文档</p>\n<pre class=\" language-ini\"><code class=\"language-ini\"><span class=\"token selector\">[root@master test]</span># iconv -?\n用法： iconv [选项...] [文件...]\n转换给定文件的编码。\n\n 输入/输出格式规范：\n  -f, --from-code<span class=\"token attr-value\"><span class=\"token punctuation\">=</span>名称     原始文本编码</span>\n  -t, --to-code<span class=\"token attr-value\"><span class=\"token punctuation\">=</span>名称       输出编码</span>\n\n 信息：\n  -l, --list                 列举所有已知的字符集\n\n 输出控制：\n  -c                         从输出中忽略无效的字符\n  -o, --output<span class=\"token attr-value\"><span class=\"token punctuation\">=</span>FILE          输出文件</span>\n  -s, --silent               关闭警告\n      --verbose              打印进度信息\n\n  -?, --help                 给出该系统求助列表\n      --usage                给出简要的用法信息\n  -V, --version              打印程序版本号\n\n长选项的强制或可选参数对对应的短选项也是强制或可选的。\n\nFor bug reporting instructions, please see:\n&lt;http://www.gnu.org/software/libc/bugs.html>.\n\n</code></pre>\n<h3 id=\"2-1-查看支持的编码格式\"><a href=\"#2-1-查看支持的编码格式\" class=\"headerlink\" title=\"2.1 查看支持的编码格式\"></a>2.1 查看支持的编码格式</h3><pre class=\" language-ini\"><code class=\"language-ini\">iconv -l</code></pre>\n<h3 id=\"2-2-转换\"><a href=\"#2-2-转换\" class=\"headerlink\" title=\"2.2 转换\"></a>2.2 转换</h3><pre class=\" language-ini\"><code class=\"language-ini\">iconv -f encoding1 -t encoding2 filename1 -o filename2</code></pre>\n<blockquote>\n<p>-f : 原编码格式 &nbsp; -t: 转换后格式<br><strong>一定要输出到文件中</strong>，否则只会标准输出到显示器中 </p>\n</blockquote>\n<blockquote>\n<p>我这边无法将utf-8转换为cp936 ,gbk ,gb2312<br>但可以将cp936转换为utf-8，对于日常也够了</p>\n</blockquote>\n<h3 id=\"2-3-常见问题\"><a href=\"#2-3-常见问题\" class=\"headerlink\" title=\"2.3 常见问题\"></a>2.3 常见问题</h3><ul>\n<li><p>首次使用可能需要安装</p>\n<pre class=\" language-ini\"><code class=\"language-ini\">ubuntu等：apt-get install iconv\ncentos等：yum install iconv</code></pre>\n</li>\n<li><p><code>iconv: 未知 *** 处的非法输入序列</code>,加<code>-c</code></p>\n<pre class=\" language-ini\"><code class=\"language-ini\">iconv -c -f encoding1 -t encoding2 filename1 -o filename2</code></pre>\n</li>\n<li><p>转换后乱码。建议转码输出到另外一个文件中，猜测输出到源文件中即直接转码可能会引起文件内容紊乱。。。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近两天因为项目中的原始文件编码格式为cp936，而程序处理的是utf-8，所以需要对其转换，想来也不是很麻烦，但是还是遇到了很多坑，所以记下，可能会帮到别人。<br>linux下有多种转换文件编码格式的方法，但最常用的转换工具是vim和<code>iconv</code>。</p>","more":"<p>在很多地方都看了使用vim编辑器转码，但是我对其表示怀疑，因为测试过多次都不咋成功，可能还需要手动添加支持的编码格式，总之还是比较麻烦。而且打开vim转码也只是适用于少量非生产环境中，总之我只推荐使用vim查看编码格式，<strong>不推荐使用vim转码</strong>。</p>\n<h2 id=\"一、VIM\"><a href=\"#一、VIM\" class=\"headerlink\" title=\"一、VIM\"></a>一、VIM</h2><h3 id=\"1-1-查看文件编码格式\"><a href=\"#1-1-查看文件编码格式\" class=\"headerlink\" title=\"1.1 查看文件编码格式\"></a>1.1 查看文件编码格式</h3><pre><code class=\"ini\">set fileencoding</code></pre>\n<h3 id=\"1-2-格式转换\"><a href=\"#1-2-格式转换\" class=\"headerlink\" title=\"1.2 格式转换\"></a>1.2 格式转换</h3><pre><code>set fileencoing= encoding  //加上自己需要的编码格式即可</code></pre><blockquote>\n<p>我在ubuntu和centos上都测试过，都没能转换成功。。。。 <strong>所以对此方法表示怀疑</strong></p>\n</blockquote>\n<h2 id=\"二、iconv\"><a href=\"#二、iconv\" class=\"headerlink\" title=\"二、iconv\"></a>二、iconv</h2><p>官方文档</p>\n<pre><code class=\"ini\">[root@master test]# iconv -?\n用法： iconv [选项...] [文件...]\n转换给定文件的编码。\n\n 输入/输出格式规范：\n  -f, --from-code=名称     原始文本编码\n  -t, --to-code=名称       输出编码\n\n 信息：\n  -l, --list                 列举所有已知的字符集\n\n 输出控制：\n  -c                         从输出中忽略无效的字符\n  -o, --output=FILE          输出文件\n  -s, --silent               关闭警告\n      --verbose              打印进度信息\n\n  -?, --help                 给出该系统求助列表\n      --usage                给出简要的用法信息\n  -V, --version              打印程序版本号\n\n长选项的强制或可选参数对对应的短选项也是强制或可选的。\n\nFor bug reporting instructions, please see:\n&lt;http://www.gnu.org/software/libc/bugs.html&gt;.\n\n</code></pre>\n<h3 id=\"2-1-查看支持的编码格式\"><a href=\"#2-1-查看支持的编码格式\" class=\"headerlink\" title=\"2.1 查看支持的编码格式\"></a>2.1 查看支持的编码格式</h3><pre><code class=\"ini\">iconv -l</code></pre>\n<h3 id=\"2-2-转换\"><a href=\"#2-2-转换\" class=\"headerlink\" title=\"2.2 转换\"></a>2.2 转换</h3><pre><code class=\"ini\">iconv -f encoding1 -t encoding2 filename1 -o filename2</code></pre>\n<blockquote>\n<p>-f : 原编码格式 &nbsp; -t: 转换后格式<br><strong>一定要输出到文件中</strong>，否则只会标准输出到显示器中 </p>\n</blockquote>\n<blockquote>\n<p>我这边无法将utf-8转换为cp936 ,gbk ,gb2312<br>但可以将cp936转换为utf-8，对于日常也够了</p>\n</blockquote>\n<h3 id=\"2-3-常见问题\"><a href=\"#2-3-常见问题\" class=\"headerlink\" title=\"2.3 常见问题\"></a>2.3 常见问题</h3><ul>\n<li><p>首次使用可能需要安装</p>\n<pre><code class=\"ini\">ubuntu等：apt-get install iconv\ncentos等：yum install iconv</code></pre>\n</li>\n<li><p><code>iconv: 未知 *** 处的非法输入序列</code>,加<code>-c</code></p>\n<pre><code class=\"ini\">iconv -c -f encoding1 -t encoding2 filename1 -o filename2</code></pre>\n</li>\n<li><p>转换后乱码。建议转码输出到另外一个文件中，猜测输出到源文件中即直接转码可能会引起文件内容紊乱。。。</p>\n</li>\n</ul>"},{"title":"git命令","declare":true,"wordCount":true,"abbrlink":"335a5d78","date":"2020-04-29T08:41:10.000Z","_content":"\nGit是一个免费的开源**分布式版本控制**系统，它可以快速高效地处理从小型到大型的项目。\n\n<!-- more -->\n\n#### 基础\n* 本地与远程库的关联与取消（可以一对多）\n    * 关联：\n        * `git remote add origin https:xxxx.git`, origin 为远程仓库别名\n    * 取消：\n        * `git remote remove origin` \n    * 查看远程仓库，以及与本地仓库的关系\n        * `git remote show origin`\n* 跟踪文件\n    * 跟踪单个文件\n        * `git add file_name`\n    * 跟踪项目文件夹中的所有文件和文件夹\n        * `git add .`\n* 提交文件\n    * `git commit -m 'commit'`\n* 推送到远程仓库 `git push <远程主机名> <本地分支名>:<远程分支名>`\n    * 推送到origin主机对应分支\n        * `git push origin master`\n     * 如果当前分支与多个主机存在追踪关系，那么这个时候-u选项会指定一个默认主机，这样后面就可以不加任何参数使用git push。\n        * `git push -u origin master`\n    * 强制推送，会将远程仓库存在而本地不存在的抹除，即强制使得远程仓库内容与本地保持一样\n        * `git push -f origin master`\n* 取回远程主机某个分支的更新，再与本地的指定分支合并  \n    * `git pull = git fetch + git merge`   \n    * `git pull <远程主机名> <远程分支名>:<本地分支名>`\n    * 拉取远程主机origin的master分支与本地brantest分支合并\n        * `git pull origin master:brantest //:brantest可以省略` \n        * 等同于`git fetch origin master:brantest + \ngit merge brantest`\n    \n\n>参考   \n><https://www.cnblogs.com/of-course/p/11577318.html>\n><https://blog.csdn.net/JackLiu16/article/details/80952650>\n><https://www.cnblogs.com/taohuaya/p/10761799.html>\n\n\n","source":"_posts/tools/git命令.md","raw":"---\ntitle: git命令\ncategories: Tools\ntags: git\ndeclare: true\nwordCount: true\nabbrlink: 335a5d78\ndate: 2020-04-29 16:41:10\n---\n\nGit是一个免费的开源**分布式版本控制**系统，它可以快速高效地处理从小型到大型的项目。\n\n<!-- more -->\n\n#### 基础\n* 本地与远程库的关联与取消（可以一对多）\n    * 关联：\n        * `git remote add origin https:xxxx.git`, origin 为远程仓库别名\n    * 取消：\n        * `git remote remove origin` \n    * 查看远程仓库，以及与本地仓库的关系\n        * `git remote show origin`\n* 跟踪文件\n    * 跟踪单个文件\n        * `git add file_name`\n    * 跟踪项目文件夹中的所有文件和文件夹\n        * `git add .`\n* 提交文件\n    * `git commit -m 'commit'`\n* 推送到远程仓库 `git push <远程主机名> <本地分支名>:<远程分支名>`\n    * 推送到origin主机对应分支\n        * `git push origin master`\n     * 如果当前分支与多个主机存在追踪关系，那么这个时候-u选项会指定一个默认主机，这样后面就可以不加任何参数使用git push。\n        * `git push -u origin master`\n    * 强制推送，会将远程仓库存在而本地不存在的抹除，即强制使得远程仓库内容与本地保持一样\n        * `git push -f origin master`\n* 取回远程主机某个分支的更新，再与本地的指定分支合并  \n    * `git pull = git fetch + git merge`   \n    * `git pull <远程主机名> <远程分支名>:<本地分支名>`\n    * 拉取远程主机origin的master分支与本地brantest分支合并\n        * `git pull origin master:brantest //:brantest可以省略` \n        * 等同于`git fetch origin master:brantest + \ngit merge brantest`\n    \n\n>参考   \n><https://www.cnblogs.com/of-course/p/11577318.html>\n><https://blog.csdn.net/JackLiu16/article/details/80952650>\n><https://www.cnblogs.com/taohuaya/p/10761799.html>\n\n\n","slug":"tools/git命令","published":1,"updated":"2020-11-29T15:54:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1fd002h0w7t6j6pefup","content":"<p>Git是一个免费的开源<strong>分布式版本控制</strong>系统，它可以快速高效地处理从小型到大型的项目。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h4><ul>\n<li>本地与远程库的关联与取消（可以一对多）<ul>\n<li>关联：<ul>\n<li><code>git remote add origin https:xxxx.git</code>, origin 为远程仓库别名</li>\n</ul>\n</li>\n<li>取消：<ul>\n<li><code>git remote remove origin</code> </li>\n</ul>\n</li>\n<li>查看远程仓库，以及与本地仓库的关系<ul>\n<li><code>git remote show origin</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>跟踪文件<ul>\n<li>跟踪单个文件<ul>\n<li><code>git add file_name</code></li>\n</ul>\n</li>\n<li>跟踪项目文件夹中的所有文件和文件夹<ul>\n<li><code>git add .</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>提交文件<ul>\n<li><code>git commit -m &#39;commit&#39;</code></li>\n</ul>\n</li>\n<li>推送到远程仓库 <code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><ul>\n<li>推送到origin主机对应分支<ul>\n<li><code>git push origin master</code><ul>\n<li>如果当前分支与多个主机存在追踪关系，那么这个时候-u选项会指定一个默认主机，这样后面就可以不加任何参数使用git push。</li>\n</ul>\n</li>\n<li><code>git push -u origin master</code></li>\n</ul>\n</li>\n<li>强制推送，会将远程仓库存在而本地不存在的抹除，即强制使得远程仓库内容与本地保持一样<ul>\n<li><code>git push -f origin master</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>取回远程主机某个分支的更新，再与本地的指定分支合并  <ul>\n<li><code>git pull = git fetch + git merge</code>   </li>\n<li><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></li>\n<li>拉取远程主机origin的master分支与本地brantest分支合并<ul>\n<li><code>git pull origin master:brantest //:brantest可以省略</code> </li>\n<li>等同于<code>git fetch origin master:brantest + \ngit merge brantest</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>参考<br><a href=\"https://www.cnblogs.com/of-course/p/11577318.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/of-course/p/11577318.html</a><br><a href=\"https://blog.csdn.net/JackLiu16/article/details/80952650\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/JackLiu16/article/details/80952650</a><br><a href=\"https://www.cnblogs.com/taohuaya/p/10761799.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/taohuaya/p/10761799.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Git是一个免费的开源<strong>分布式版本控制</strong>系统，它可以快速高效地处理从小型到大型的项目。</p>","more":"<h4 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h4><ul>\n<li>本地与远程库的关联与取消（可以一对多）<ul>\n<li>关联：<ul>\n<li><code>git remote add origin https:xxxx.git</code>, origin 为远程仓库别名</li>\n</ul>\n</li>\n<li>取消：<ul>\n<li><code>git remote remove origin</code> </li>\n</ul>\n</li>\n<li>查看远程仓库，以及与本地仓库的关系<ul>\n<li><code>git remote show origin</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>跟踪文件<ul>\n<li>跟踪单个文件<ul>\n<li><code>git add file_name</code></li>\n</ul>\n</li>\n<li>跟踪项目文件夹中的所有文件和文件夹<ul>\n<li><code>git add .</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>提交文件<ul>\n<li><code>git commit -m &#39;commit&#39;</code></li>\n</ul>\n</li>\n<li>推送到远程仓库 <code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><ul>\n<li>推送到origin主机对应分支<ul>\n<li><code>git push origin master</code><ul>\n<li>如果当前分支与多个主机存在追踪关系，那么这个时候-u选项会指定一个默认主机，这样后面就可以不加任何参数使用git push。</li>\n</ul>\n</li>\n<li><code>git push -u origin master</code></li>\n</ul>\n</li>\n<li>强制推送，会将远程仓库存在而本地不存在的抹除，即强制使得远程仓库内容与本地保持一样<ul>\n<li><code>git push -f origin master</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>取回远程主机某个分支的更新，再与本地的指定分支合并  <ul>\n<li><code>git pull = git fetch + git merge</code>   </li>\n<li><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></li>\n<li>拉取远程主机origin的master分支与本地brantest分支合并<ul>\n<li><code>git pull origin master:brantest //:brantest可以省略</code> </li>\n<li>等同于<code>git fetch origin master:brantest + \ngit merge brantest</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>参考<br><a href=\"https://www.cnblogs.com/of-course/p/11577318.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/of-course/p/11577318.html</a><br><a href=\"https://blog.csdn.net/JackLiu16/article/details/80952650\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/JackLiu16/article/details/80952650</a><br><a href=\"https://www.cnblogs.com/taohuaya/p/10761799.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/taohuaya/p/10761799.html</a></p>\n</blockquote>"},{"title":"vim命令","declare":true,"wordCount":true,"date":"2020-04-29T09:02:10.000Z","abbrlink":"7de3426c","_content":"❄\n<!-- more -->\n\n#### 1. 基础操作\n* 插入模式  \n    * `i(insert)`\n* 命令模式\n    * `Esc`\n* 保存并退出  \n    * `x!`\n    * `wq`\n* 不保存退出  \n    * `q!`\n* 撤销  \n    * `u(undo)`\n* 重做\n    * `Ctrl+R`\n* 删除 \n    * `dd(delete)`\n* 显示行数\n    * `set number`\n* 跳到相应行数\n    * `number`\n* 跳到末尾  \n    * `$`\n* 搜索\n    * `/keyWord`\n\n    \n#### 2. 复制，剪切，粘贴，删除\n* 选择\n    * `v+方向键`\n* 复制\n    * `y(yank)`\n* 复制多行\n    * 复制当前行\n        * `yy`\n    * 复制光标所在行及其以下n行\n        * `n+yy`\n    * 命令行方式(复制1到10行并粘贴在12行)\n        * `1,10 co 12`\n* 剪切\n    * `d`\n* 剪切多行\n    * 剪切当前行\n        * `dd`\n    * 剪切光标所在行及其以下n行\n        * `n + dd`\n    * 命令行方式(剪切1到10行并粘贴在12行)\n        * `1,10 m 12`\n* 粘贴\n    * `p(paste)`\n    *粘贴系统复制内容\n        * 进入粘贴模式\n            * `set paste`\n        * 进入插入模式\n            * `i`\n        * 退出粘贴模式\n            * `set nopaste`\n* 删除 \n    * 删除当前行\n        * `dd`\n    * 删除光标所在行及其以下n行\n        * `n+dd`\n    * 命令行方式（删除1到10行)\n        * `1,10 de`\n#### 3. 分隔窗口\n* 水平窗口分隔\n    * `split` (开启另外一个窗口看同一文件)\n    * `split+fileName` (开启另外一个窗口查看指定文件)\n* 垂直窗口分隔\n    * `vsplit` (开启另外一个窗口看同一文件)\n    * `vplit+fileName` (开启另外一个窗口查看指定文件)\n* 窗口切换\n    * `Ctrl+w+w`\n* 增大或减小窗口大小\n    * `Ctrl+w+ +/-`\n* 关闭窗口\n    * 关闭当前窗口 \n        * `q` \n    * 关闭所有窗口 \n        * `qall`\n    * 关闭除当前窗口的所有窗口 \n        * `only`\n\n#### 4. 光标移动\n* 基本移动\n    * 左移\n        * `h`\n    * 右移\n        * `l`\n    * 上移\n        * `j`\n    * 下移\n        * `k`\n    \n\n    \n\n\n","source":"_posts/tools/vim命令.md","raw":"---\ntitle: vim命令\ncategories: Tools\ndeclare: true\nwordCount: true\ndate: 2020-04-29 17:02:10\nabbrlink: 7de3426c\n---\n❄\n<!-- more -->\n\n#### 1. 基础操作\n* 插入模式  \n    * `i(insert)`\n* 命令模式\n    * `Esc`\n* 保存并退出  \n    * `x!`\n    * `wq`\n* 不保存退出  \n    * `q!`\n* 撤销  \n    * `u(undo)`\n* 重做\n    * `Ctrl+R`\n* 删除 \n    * `dd(delete)`\n* 显示行数\n    * `set number`\n* 跳到相应行数\n    * `number`\n* 跳到末尾  \n    * `$`\n* 搜索\n    * `/keyWord`\n\n    \n#### 2. 复制，剪切，粘贴，删除\n* 选择\n    * `v+方向键`\n* 复制\n    * `y(yank)`\n* 复制多行\n    * 复制当前行\n        * `yy`\n    * 复制光标所在行及其以下n行\n        * `n+yy`\n    * 命令行方式(复制1到10行并粘贴在12行)\n        * `1,10 co 12`\n* 剪切\n    * `d`\n* 剪切多行\n    * 剪切当前行\n        * `dd`\n    * 剪切光标所在行及其以下n行\n        * `n + dd`\n    * 命令行方式(剪切1到10行并粘贴在12行)\n        * `1,10 m 12`\n* 粘贴\n    * `p(paste)`\n    *粘贴系统复制内容\n        * 进入粘贴模式\n            * `set paste`\n        * 进入插入模式\n            * `i`\n        * 退出粘贴模式\n            * `set nopaste`\n* 删除 \n    * 删除当前行\n        * `dd`\n    * 删除光标所在行及其以下n行\n        * `n+dd`\n    * 命令行方式（删除1到10行)\n        * `1,10 de`\n#### 3. 分隔窗口\n* 水平窗口分隔\n    * `split` (开启另外一个窗口看同一文件)\n    * `split+fileName` (开启另外一个窗口查看指定文件)\n* 垂直窗口分隔\n    * `vsplit` (开启另外一个窗口看同一文件)\n    * `vplit+fileName` (开启另外一个窗口查看指定文件)\n* 窗口切换\n    * `Ctrl+w+w`\n* 增大或减小窗口大小\n    * `Ctrl+w+ +/-`\n* 关闭窗口\n    * 关闭当前窗口 \n        * `q` \n    * 关闭所有窗口 \n        * `qall`\n    * 关闭除当前窗口的所有窗口 \n        * `only`\n\n#### 4. 光标移动\n* 基本移动\n    * 左移\n        * `h`\n    * 右移\n        * `l`\n    * 上移\n        * `j`\n    * 下移\n        * `k`\n    \n\n    \n\n\n","slug":"tools/vim命令","published":1,"updated":"2020-04-30T15:58:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1ff002l0w7tdig8gz5y","content":"<p>❄</p>\n<a id=\"more\"></a>\n\n<h4 id=\"1-基础操作\"><a href=\"#1-基础操作\" class=\"headerlink\" title=\"1. 基础操作\"></a>1. 基础操作</h4><ul>\n<li>插入模式  <ul>\n<li><code>i(insert)</code></li>\n</ul>\n</li>\n<li>命令模式<ul>\n<li><code>Esc</code></li>\n</ul>\n</li>\n<li>保存并退出  <ul>\n<li><code>x!</code></li>\n<li><code>wq</code></li>\n</ul>\n</li>\n<li>不保存退出  <ul>\n<li><code>q!</code></li>\n</ul>\n</li>\n<li>撤销  <ul>\n<li><code>u(undo)</code></li>\n</ul>\n</li>\n<li>重做<ul>\n<li><code>Ctrl+R</code></li>\n</ul>\n</li>\n<li>删除 <ul>\n<li><code>dd(delete)</code></li>\n</ul>\n</li>\n<li>显示行数<ul>\n<li><code>set number</code></li>\n</ul>\n</li>\n<li>跳到相应行数<ul>\n<li><code>number</code></li>\n</ul>\n</li>\n<li>跳到末尾  <ul>\n<li><code>$</code></li>\n</ul>\n</li>\n<li>搜索<ul>\n<li><code>/keyWord</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-复制，剪切，粘贴，删除\"><a href=\"#2-复制，剪切，粘贴，删除\" class=\"headerlink\" title=\"2. 复制，剪切，粘贴，删除\"></a>2. 复制，剪切，粘贴，删除</h4><ul>\n<li>选择<ul>\n<li><code>v+方向键</code></li>\n</ul>\n</li>\n<li>复制<ul>\n<li><code>y(yank)</code></li>\n</ul>\n</li>\n<li>复制多行<ul>\n<li>复制当前行<ul>\n<li><code>yy</code></li>\n</ul>\n</li>\n<li>复制光标所在行及其以下n行<ul>\n<li><code>n+yy</code></li>\n</ul>\n</li>\n<li>命令行方式(复制1到10行并粘贴在12行)<ul>\n<li><code>1,10 co 12</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>剪切<ul>\n<li><code>d</code></li>\n</ul>\n</li>\n<li>剪切多行<ul>\n<li>剪切当前行<ul>\n<li><code>dd</code></li>\n</ul>\n</li>\n<li>剪切光标所在行及其以下n行<ul>\n<li><code>n + dd</code></li>\n</ul>\n</li>\n<li>命令行方式(剪切1到10行并粘贴在12行)<ul>\n<li><code>1,10 m 12</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>粘贴<ul>\n<li><code>p(paste)</code></li>\n<li>粘贴系统复制内容<ul>\n<li>进入粘贴模式<ul>\n<li><code>set paste</code></li>\n</ul>\n</li>\n<li>进入插入模式<ul>\n<li><code>i</code></li>\n</ul>\n</li>\n<li>退出粘贴模式<ul>\n<li><code>set nopaste</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>删除 <ul>\n<li>删除当前行<ul>\n<li><code>dd</code></li>\n</ul>\n</li>\n<li>删除光标所在行及其以下n行<ul>\n<li><code>n+dd</code></li>\n</ul>\n</li>\n<li>命令行方式（删除1到10行)<ul>\n<li><code>1,10 de</code><h4 id=\"3-分隔窗口\"><a href=\"#3-分隔窗口\" class=\"headerlink\" title=\"3. 分隔窗口\"></a>3. 分隔窗口</h4></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>水平窗口分隔<ul>\n<li><code>split</code> (开启另外一个窗口看同一文件)</li>\n<li><code>split+fileName</code> (开启另外一个窗口查看指定文件)</li>\n</ul>\n</li>\n<li>垂直窗口分隔<ul>\n<li><code>vsplit</code> (开启另外一个窗口看同一文件)</li>\n<li><code>vplit+fileName</code> (开启另外一个窗口查看指定文件)</li>\n</ul>\n</li>\n<li>窗口切换<ul>\n<li><code>Ctrl+w+w</code></li>\n</ul>\n</li>\n<li>增大或减小窗口大小<ul>\n<li><code>Ctrl+w+ +/-</code></li>\n</ul>\n</li>\n<li>关闭窗口<ul>\n<li>关闭当前窗口 <ul>\n<li><code>q</code> </li>\n</ul>\n</li>\n<li>关闭所有窗口 <ul>\n<li><code>qall</code></li>\n</ul>\n</li>\n<li>关闭除当前窗口的所有窗口 <ul>\n<li><code>only</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-光标移动\"><a href=\"#4-光标移动\" class=\"headerlink\" title=\"4. 光标移动\"></a>4. 光标移动</h4><ul>\n<li>基本移动<ul>\n<li>左移<ul>\n<li><code>h</code></li>\n</ul>\n</li>\n<li>右移<ul>\n<li><code>l</code></li>\n</ul>\n</li>\n<li>上移<ul>\n<li><code>j</code></li>\n</ul>\n</li>\n<li>下移<ul>\n<li><code>k</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>❄</p>","more":"<h4 id=\"1-基础操作\"><a href=\"#1-基础操作\" class=\"headerlink\" title=\"1. 基础操作\"></a>1. 基础操作</h4><ul>\n<li>插入模式  <ul>\n<li><code>i(insert)</code></li>\n</ul>\n</li>\n<li>命令模式<ul>\n<li><code>Esc</code></li>\n</ul>\n</li>\n<li>保存并退出  <ul>\n<li><code>x!</code></li>\n<li><code>wq</code></li>\n</ul>\n</li>\n<li>不保存退出  <ul>\n<li><code>q!</code></li>\n</ul>\n</li>\n<li>撤销  <ul>\n<li><code>u(undo)</code></li>\n</ul>\n</li>\n<li>重做<ul>\n<li><code>Ctrl+R</code></li>\n</ul>\n</li>\n<li>删除 <ul>\n<li><code>dd(delete)</code></li>\n</ul>\n</li>\n<li>显示行数<ul>\n<li><code>set number</code></li>\n</ul>\n</li>\n<li>跳到相应行数<ul>\n<li><code>number</code></li>\n</ul>\n</li>\n<li>跳到末尾  <ul>\n<li><code>$</code></li>\n</ul>\n</li>\n<li>搜索<ul>\n<li><code>/keyWord</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-复制，剪切，粘贴，删除\"><a href=\"#2-复制，剪切，粘贴，删除\" class=\"headerlink\" title=\"2. 复制，剪切，粘贴，删除\"></a>2. 复制，剪切，粘贴，删除</h4><ul>\n<li>选择<ul>\n<li><code>v+方向键</code></li>\n</ul>\n</li>\n<li>复制<ul>\n<li><code>y(yank)</code></li>\n</ul>\n</li>\n<li>复制多行<ul>\n<li>复制当前行<ul>\n<li><code>yy</code></li>\n</ul>\n</li>\n<li>复制光标所在行及其以下n行<ul>\n<li><code>n+yy</code></li>\n</ul>\n</li>\n<li>命令行方式(复制1到10行并粘贴在12行)<ul>\n<li><code>1,10 co 12</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>剪切<ul>\n<li><code>d</code></li>\n</ul>\n</li>\n<li>剪切多行<ul>\n<li>剪切当前行<ul>\n<li><code>dd</code></li>\n</ul>\n</li>\n<li>剪切光标所在行及其以下n行<ul>\n<li><code>n + dd</code></li>\n</ul>\n</li>\n<li>命令行方式(剪切1到10行并粘贴在12行)<ul>\n<li><code>1,10 m 12</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>粘贴<ul>\n<li><code>p(paste)</code></li>\n<li>粘贴系统复制内容<ul>\n<li>进入粘贴模式<ul>\n<li><code>set paste</code></li>\n</ul>\n</li>\n<li>进入插入模式<ul>\n<li><code>i</code></li>\n</ul>\n</li>\n<li>退出粘贴模式<ul>\n<li><code>set nopaste</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>删除 <ul>\n<li>删除当前行<ul>\n<li><code>dd</code></li>\n</ul>\n</li>\n<li>删除光标所在行及其以下n行<ul>\n<li><code>n+dd</code></li>\n</ul>\n</li>\n<li>命令行方式（删除1到10行)<ul>\n<li><code>1,10 de</code><h4 id=\"3-分隔窗口\"><a href=\"#3-分隔窗口\" class=\"headerlink\" title=\"3. 分隔窗口\"></a>3. 分隔窗口</h4></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>水平窗口分隔<ul>\n<li><code>split</code> (开启另外一个窗口看同一文件)</li>\n<li><code>split+fileName</code> (开启另外一个窗口查看指定文件)</li>\n</ul>\n</li>\n<li>垂直窗口分隔<ul>\n<li><code>vsplit</code> (开启另外一个窗口看同一文件)</li>\n<li><code>vplit+fileName</code> (开启另外一个窗口查看指定文件)</li>\n</ul>\n</li>\n<li>窗口切换<ul>\n<li><code>Ctrl+w+w</code></li>\n</ul>\n</li>\n<li>增大或减小窗口大小<ul>\n<li><code>Ctrl+w+ +/-</code></li>\n</ul>\n</li>\n<li>关闭窗口<ul>\n<li>关闭当前窗口 <ul>\n<li><code>q</code> </li>\n</ul>\n</li>\n<li>关闭所有窗口 <ul>\n<li><code>qall</code></li>\n</ul>\n</li>\n<li>关闭除当前窗口的所有窗口 <ul>\n<li><code>only</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-光标移动\"><a href=\"#4-光标移动\" class=\"headerlink\" title=\"4. 光标移动\"></a>4. 光标移动</h4><ul>\n<li>基本移动<ul>\n<li>左移<ul>\n<li><code>h</code></li>\n</ul>\n</li>\n<li>右移<ul>\n<li><code>l</code></li>\n</ul>\n</li>\n<li>上移<ul>\n<li><code>j</code></li>\n</ul>\n</li>\n<li>下移<ul>\n<li><code>k</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"markdown基本用法","declare":true,"wordCount":true,"abbrlink":"57b3646e","data":"2020-04-29T03:40:10.000Z","_content":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。   \n<!-- more -->\n### 1.标题\n\\# 一级标题\n\\## 二级标题\n\\### 三级标题\n\\#### 四级标题\n\\##### 五级标题\n\\###### 六级标题\n># 一级标题\n>## 二级标题\n>### 三级标题\n>#### 四级标题\n>##### 五级标题\n>###### 六级标题\n\n### 2.字体形态\n\n\\*斜体文本*\n>*斜体文本*\n\n\\_斜体文本_  \n>_斜体文本_  \n\n\\**粗体**\n>**粗体**\n\n\\__粗体__\n>__粗体__\n\n\\***粗斜体***\n>***粗斜体***\n\n\\___粗斜体___\n>___粗斜体___\n\n\n### 3.分隔线\n\\***\n分割线\n\\***\n\n***\n分割线\n***\n\n### 4.删除线\n\n\\~~删除线~~  \n>~~删除线~~  \n\n### 5.下划线\n\\<u>下划线</u>\n><u>下划线</u>\n\n### 6.引用\n\n\\中文 [second]\n>中文 [second]\n\n[^second]:英文\n\n### 7.列表\n\n#### 7.1无序列表\n\n\\* 第一项\n\\* 第二项\n\\* 第三项\n\\+ 第四项\n\\+ 第五项\n\\+ 第六项\n\\- 第七项\n\\- 第八项\n\\- 第九项\n>* 第一项\n>* 第二项\n>* 第三项\n>+ 第四项\n>+ 第五项\n>+ 第六项\n>- 第七项\n>- 第八项\n>- 第九项\n\n#### 7.2有序列表\n\\1. 第一项\n\\2. 第二项\n\\3. 第三项\n\n\\* 1   \n\\    * 1.1   \n\\       * 1.1.1   \n\\            * 1.1.1.1  \n\n\n\n>1. 第一项\n>2. 第二项\n>3. 第三项\n\n>* 1\n>    * 1.1\n>        * 1.1.1\n>            * 1.1.1.1\n\n### 8.引用\n\n\\>第一层嵌套\n\\>>第二次嵌套\n\\>>>第三层嵌套\n\n>第一层嵌套\n>>第二次嵌套\n>>>第三层嵌套\n\n\n### 9.段落上的代码\n\n\\`System.out.println(\"hello world\")`\n\n`System.out.println(\"hello world\")`\n\n### 10.代码区块\n#### 10.1Tab键或四个空格\n\n    public class helloWorld{\n        public static void main(String[] args){\n            System.out.println(\"hello world\");\n        }\n    }\n\n#### 10.2 \n\n(```+指定语言)\n\n```java\n    public class helloWorld{\n        public static void main(String[] args){\n            System.out.println(\"hello world\");\n        }\n    }\n```\n\n### 11.链接\n\n这是一个\\[链接](wht.im)\n>这是一个[链接](wht.im)\n\n\\<http://www.baidu.com>\n<http://www.baidu.com>\n\n\n网址一\\[^one]  \n\\[^one]:www.baidu.com\n网址一[^one]  \n[^one]:www.baidu.com\n\n### 12.图片\n\n([]中的为图片不显示时的提示文字)\n\n\\![img_caption]\\(http://static.runoob.com/images/runoob-logo.png)\n![img_caption](http://static.runoob.com/images/runoob-logo.png)\n\n\n指定宽度\n\n\\<img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\">\n<img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\">\n\n### 13.表格\n\n\n\\| 字符 | 描述 |  例子 |  \n\\|-|-|-\n\\|   | 时代指示器 | AD |\n\\| y | 四位数年份 | 2001 |\n\\| M | 年中的月份 | July or 07 |\n\\| d | 月份中日期 | 10 |\n\n| 字符 | 描述 |  例子 |  \n|-|-|-\n|   | 时代指示器 | AD |\n| y | 四位数年份 | 2001 |\n| M | 年中的月份 | July or 07 |\n| d | 月份中日期 | 10 |\n\n* 设置对齐方式  \n    * -： 左对齐\n    * :-  右对齐\n    * :-：中间对齐\n\n\n|表头|表头|表头|\n|:----|----:| :--:\n|左对齐|右对齐|中间对齐|\n\n### 14.键盘文本\n\n使用<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Esc</kbd>打开任务管理器\n\n转义：(加斜杠)\n\n### 15.高级技巧\n><https://www.runoob.com/markdown/md-advance.html>\n\n\n\n\n\n\n\n    \n","source":"_posts/tools/markdown0.md","raw":"---\ntitle: markdown基本用法\ncategories: Tools\ndeclare: true\nwordCount: true\nabbrlink: 57b3646e\ndata: 2020-04-29 11:40:10\n---\nMarkdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。   \n<!-- more -->\n### 1.标题\n\\# 一级标题\n\\## 二级标题\n\\### 三级标题\n\\#### 四级标题\n\\##### 五级标题\n\\###### 六级标题\n># 一级标题\n>## 二级标题\n>### 三级标题\n>#### 四级标题\n>##### 五级标题\n>###### 六级标题\n\n### 2.字体形态\n\n\\*斜体文本*\n>*斜体文本*\n\n\\_斜体文本_  \n>_斜体文本_  \n\n\\**粗体**\n>**粗体**\n\n\\__粗体__\n>__粗体__\n\n\\***粗斜体***\n>***粗斜体***\n\n\\___粗斜体___\n>___粗斜体___\n\n\n### 3.分隔线\n\\***\n分割线\n\\***\n\n***\n分割线\n***\n\n### 4.删除线\n\n\\~~删除线~~  \n>~~删除线~~  \n\n### 5.下划线\n\\<u>下划线</u>\n><u>下划线</u>\n\n### 6.引用\n\n\\中文 [second]\n>中文 [second]\n\n[^second]:英文\n\n### 7.列表\n\n#### 7.1无序列表\n\n\\* 第一项\n\\* 第二项\n\\* 第三项\n\\+ 第四项\n\\+ 第五项\n\\+ 第六项\n\\- 第七项\n\\- 第八项\n\\- 第九项\n>* 第一项\n>* 第二项\n>* 第三项\n>+ 第四项\n>+ 第五项\n>+ 第六项\n>- 第七项\n>- 第八项\n>- 第九项\n\n#### 7.2有序列表\n\\1. 第一项\n\\2. 第二项\n\\3. 第三项\n\n\\* 1   \n\\    * 1.1   \n\\       * 1.1.1   \n\\            * 1.1.1.1  \n\n\n\n>1. 第一项\n>2. 第二项\n>3. 第三项\n\n>* 1\n>    * 1.1\n>        * 1.1.1\n>            * 1.1.1.1\n\n### 8.引用\n\n\\>第一层嵌套\n\\>>第二次嵌套\n\\>>>第三层嵌套\n\n>第一层嵌套\n>>第二次嵌套\n>>>第三层嵌套\n\n\n### 9.段落上的代码\n\n\\`System.out.println(\"hello world\")`\n\n`System.out.println(\"hello world\")`\n\n### 10.代码区块\n#### 10.1Tab键或四个空格\n\n    public class helloWorld{\n        public static void main(String[] args){\n            System.out.println(\"hello world\");\n        }\n    }\n\n#### 10.2 \n\n(```+指定语言)\n\n```java\n    public class helloWorld{\n        public static void main(String[] args){\n            System.out.println(\"hello world\");\n        }\n    }\n```\n\n### 11.链接\n\n这是一个\\[链接](wht.im)\n>这是一个[链接](wht.im)\n\n\\<http://www.baidu.com>\n<http://www.baidu.com>\n\n\n网址一\\[^one]  \n\\[^one]:www.baidu.com\n网址一[^one]  \n[^one]:www.baidu.com\n\n### 12.图片\n\n([]中的为图片不显示时的提示文字)\n\n\\![img_caption]\\(http://static.runoob.com/images/runoob-logo.png)\n![img_caption](http://static.runoob.com/images/runoob-logo.png)\n\n\n指定宽度\n\n\\<img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\">\n<img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\">\n\n### 13.表格\n\n\n\\| 字符 | 描述 |  例子 |  \n\\|-|-|-\n\\|   | 时代指示器 | AD |\n\\| y | 四位数年份 | 2001 |\n\\| M | 年中的月份 | July or 07 |\n\\| d | 月份中日期 | 10 |\n\n| 字符 | 描述 |  例子 |  \n|-|-|-\n|   | 时代指示器 | AD |\n| y | 四位数年份 | 2001 |\n| M | 年中的月份 | July or 07 |\n| d | 月份中日期 | 10 |\n\n* 设置对齐方式  \n    * -： 左对齐\n    * :-  右对齐\n    * :-：中间对齐\n\n\n|表头|表头|表头|\n|:----|----:| :--:\n|左对齐|右对齐|中间对齐|\n\n### 14.键盘文本\n\n使用<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Esc</kbd>打开任务管理器\n\n转义：(加斜杠)\n\n### 15.高级技巧\n><https://www.runoob.com/markdown/md-advance.html>\n\n\n\n\n\n\n\n    \n","slug":"tools/markdown0","published":1,"date":"2021-08-09T10:06:58.930Z","updated":"2020-05-06T16:05:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1ff002n0w7t9gkp1era","content":"<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。   </p>\n<a id=\"more\"></a>\n<h3 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1.标题\"></a>1.标题</h3><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题</p>\n<blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6></blockquote>\n<h3 id=\"2-字体形态\"><a href=\"#2-字体形态\" class=\"headerlink\" title=\"2.字体形态\"></a>2.字体形态</h3><p>*斜体文本*</p>\n<blockquote>\n<p><em>斜体文本</em></p>\n</blockquote>\n<p>_斜体文本_  </p>\n<blockquote>\n<p><em>斜体文本</em>  </p>\n</blockquote>\n<p>*<em>粗体*</em></p>\n<blockquote>\n<p><strong>粗体</strong></p>\n</blockquote>\n<p>_<em>粗体_</em></p>\n<blockquote>\n<p><strong>粗体</strong></p>\n</blockquote>\n<p>*<strong>粗斜体*</strong></p>\n<blockquote>\n<p><strong><em>粗斜体</em></strong></p>\n</blockquote>\n<p>_<strong>粗斜体_</strong></p>\n<blockquote>\n<p><strong><em>粗斜体</em></strong></p>\n</blockquote>\n<h3 id=\"3-分隔线\"><a href=\"#3-分隔线\" class=\"headerlink\" title=\"3.分隔线\"></a>3.分隔线</h3><p>***<br>分割线<br>***</p>\n<hr>\n<p>分割线</p>\n<hr>\n<h3 id=\"4-删除线\"><a href=\"#4-删除线\" class=\"headerlink\" title=\"4.删除线\"></a>4.删除线</h3><p>~<del>删除线</del>  </p>\n<blockquote>\n<p><del>删除线</del>  </p>\n</blockquote>\n<h3 id=\"5-下划线\"><a href=\"#5-下划线\" class=\"headerlink\" title=\"5.下划线\"></a>5.下划线</h3><p>&lt;u&gt;下划线</u></p>\n<blockquote>\n<p><u>下划线</u></p>\n</blockquote>\n<h3 id=\"6-引用\"><a href=\"#6-引用\" class=\"headerlink\" title=\"6.引用\"></a>6.引用</h3><p>\\中文 [second]</p>\n<blockquote>\n<p>中文 [second]</p>\n</blockquote>\n<h3 id=\"7-列表\"><a href=\"#7-列表\" class=\"headerlink\" title=\"7.列表\"></a>7.列表</h3><h4 id=\"7-1无序列表\"><a href=\"#7-1无序列表\" class=\"headerlink\" title=\"7.1无序列表\"></a>7.1无序列表</h4><p>* 第一项<br>* 第二项<br>* 第三项<br>+ 第四项<br>+ 第五项<br>+ 第六项<br>- 第七项<br>- 第八项<br>- 第九项</p>\n<blockquote>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n<ul>\n<li>第四项</li>\n<li>第五项</li>\n<li>第六项</li>\n</ul>\n<ul>\n<li>第七项</li>\n<li>第八项</li>\n<li>第九项</li>\n</ul>\n</blockquote>\n<h4 id=\"7-2有序列表\"><a href=\"#7-2有序列表\" class=\"headerlink\" title=\"7.2有序列表\"></a>7.2有序列表</h4><p>\\1. 第一项<br>\\2. 第二项<br>\\3. 第三项</p>\n<p>* 1<br>\\    * 1.1<br>\\       * 1.1.1<br>\\            * 1.1.1.1  </p>\n<blockquote>\n<ol>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ol>\n</blockquote>\n<blockquote>\n<ul>\n<li>1<ul>\n<li>1.1<ul>\n<li>1.1.1<ul>\n<li>1.1.1.1</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"8-引用\"><a href=\"#8-引用\" class=\"headerlink\" title=\"8.引用\"></a>8.引用</h3><p>&gt;第一层嵌套<br>&gt;&gt;第二次嵌套<br>&gt;&gt;&gt;第三层嵌套</p>\n<blockquote>\n<p>第一层嵌套</p>\n<blockquote>\n<p>第二次嵌套</p>\n<blockquote>\n<p>第三层嵌套</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"9-段落上的代码\"><a href=\"#9-段落上的代码\" class=\"headerlink\" title=\"9.段落上的代码\"></a>9.段落上的代码</h3><p>`System.out.println(“hello world”)`</p>\n<p><code>System.out.println(&quot;hello world&quot;)</code></p>\n<h3 id=\"10-代码区块\"><a href=\"#10-代码区块\" class=\"headerlink\" title=\"10.代码区块\"></a>10.代码区块</h3><h4 id=\"10-1Tab键或四个空格\"><a href=\"#10-1Tab键或四个空格\" class=\"headerlink\" title=\"10.1Tab键或四个空格\"></a>10.1Tab键或四个空格</h4><pre><code>public class helloWorld{\n    public static void main(String[] args){\n        System.out.println(&quot;hello world&quot;);\n    }\n}</code></pre><h4 id=\"10-2\"><a href=\"#10-2\" class=\"headerlink\" title=\"10.2\"></a>10.2</h4><p>(```+指定语言)</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">helloWorld</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"11-链接\"><a href=\"#11-链接\" class=\"headerlink\" title=\"11.链接\"></a>11.链接</h3><p>这是一个[链接](wht.im)</p>\n<blockquote>\n<p>这是一个<a href=\"wht.im\">链接</a></p>\n</blockquote>\n<p>&lt;<a href=\"http://www.baidu.com&gt;\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com&gt;</a><br><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a></p>\n<p>网址一[^one]<br>[^one]:<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a><br>网址一[^one]<br>[^one]:<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a></p>\n<h3 id=\"12-图片\"><a href=\"#12-图片\" class=\"headerlink\" title=\"12.图片\"></a>12.图片</h3><p>([]中的为图片不显示时的提示文字)</p>\n<p>![img_caption](<a href=\"http://static.runoob.com/images/runoob-logo.png\" target=\"_blank\" rel=\"noopener\">http://static.runoob.com/images/runoob-logo.png</a>)<br><img src=\"http://static.runoob.com/images/runoob-logo.png\" alt=\"img_caption\"></p>\n<p>指定宽度</p>\n<p>&lt;img src=”<a href=\"http://static.runoob.com/images/runoob-logo.png&quot;\" target=\"_blank\" rel=\"noopener\">http://static.runoob.com/images/runoob-logo.png&quot;</a> width=”50%”&gt;<br><img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\"></p>\n<h3 id=\"13-表格\"><a href=\"#13-表格\" class=\"headerlink\" title=\"13.表格\"></a>13.表格</h3><p>| 字符 | 描述 |  例子 |<br>|-|-|-<br>|   | 时代指示器 | AD |<br>| y | 四位数年份 | 2001 |<br>| M | 年中的月份 | July or 07 |<br>| d | 月份中日期 | 10 |</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>时代指示器</td>\n<td>AD</td>\n</tr>\n<tr>\n<td>y</td>\n<td>四位数年份</td>\n<td>2001</td>\n</tr>\n<tr>\n<td>M</td>\n<td>年中的月份</td>\n<td>July or 07</td>\n</tr>\n<tr>\n<td>d</td>\n<td>月份中日期</td>\n<td>10</td>\n</tr>\n</tbody></table>\n<ul>\n<li>设置对齐方式  <ul>\n<li>-： 左对齐</li>\n<li>:-  右对齐</li>\n<li>:-：中间对齐</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">表头</th>\n<th align=\"right\">表头</th>\n<th align=\"center\">表头</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">左对齐</td>\n<td align=\"right\">右对齐</td>\n<td align=\"center\">中间对齐</td>\n</tr>\n</tbody></table>\n<h3 id=\"14-键盘文本\"><a href=\"#14-键盘文本\" class=\"headerlink\" title=\"14.键盘文本\"></a>14.键盘文本</h3><p>使用<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Esc</kbd>打开任务管理器</p>\n<p>转义：(加斜杠)</p>\n<h3 id=\"15-高级技巧\"><a href=\"#15-高级技巧\" class=\"headerlink\" title=\"15.高级技巧\"></a>15.高级技巧</h3><blockquote>\n<p><a href=\"https://www.runoob.com/markdown/md-advance.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/markdown/md-advance.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。   </p>","more":"<h3 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1.标题\"></a>1.标题</h3><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题</p>\n<blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6></blockquote>\n<h3 id=\"2-字体形态\"><a href=\"#2-字体形态\" class=\"headerlink\" title=\"2.字体形态\"></a>2.字体形态</h3><p>*斜体文本*</p>\n<blockquote>\n<p><em>斜体文本</em></p>\n</blockquote>\n<p>_斜体文本_  </p>\n<blockquote>\n<p><em>斜体文本</em>  </p>\n</blockquote>\n<p>*<em>粗体*</em></p>\n<blockquote>\n<p><strong>粗体</strong></p>\n</blockquote>\n<p>_<em>粗体_</em></p>\n<blockquote>\n<p><strong>粗体</strong></p>\n</blockquote>\n<p>*<strong>粗斜体*</strong></p>\n<blockquote>\n<p><strong><em>粗斜体</em></strong></p>\n</blockquote>\n<p>_<strong>粗斜体_</strong></p>\n<blockquote>\n<p><strong><em>粗斜体</em></strong></p>\n</blockquote>\n<h3 id=\"3-分隔线\"><a href=\"#3-分隔线\" class=\"headerlink\" title=\"3.分隔线\"></a>3.分隔线</h3><p>***<br>分割线<br>***</p>\n<hr>\n<p>分割线</p>\n<hr>\n<h3 id=\"4-删除线\"><a href=\"#4-删除线\" class=\"headerlink\" title=\"4.删除线\"></a>4.删除线</h3><p>~<del>删除线</del>  </p>\n<blockquote>\n<p><del>删除线</del>  </p>\n</blockquote>\n<h3 id=\"5-下划线\"><a href=\"#5-下划线\" class=\"headerlink\" title=\"5.下划线\"></a>5.下划线</h3><p>&lt;u&gt;下划线</u></p>\n<blockquote>\n<p><u>下划线</u></p>\n</blockquote>\n<h3 id=\"6-引用\"><a href=\"#6-引用\" class=\"headerlink\" title=\"6.引用\"></a>6.引用</h3><p>\\中文 [second]</p>\n<blockquote>\n<p>中文 [second]</p>\n</blockquote>\n<h3 id=\"7-列表\"><a href=\"#7-列表\" class=\"headerlink\" title=\"7.列表\"></a>7.列表</h3><h4 id=\"7-1无序列表\"><a href=\"#7-1无序列表\" class=\"headerlink\" title=\"7.1无序列表\"></a>7.1无序列表</h4><p>* 第一项<br>* 第二项<br>* 第三项<br>+ 第四项<br>+ 第五项<br>+ 第六项<br>- 第七项<br>- 第八项<br>- 第九项</p>\n<blockquote>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n<ul>\n<li>第四项</li>\n<li>第五项</li>\n<li>第六项</li>\n</ul>\n<ul>\n<li>第七项</li>\n<li>第八项</li>\n<li>第九项</li>\n</ul>\n</blockquote>\n<h4 id=\"7-2有序列表\"><a href=\"#7-2有序列表\" class=\"headerlink\" title=\"7.2有序列表\"></a>7.2有序列表</h4><p>\\1. 第一项<br>\\2. 第二项<br>\\3. 第三项</p>\n<p>* 1<br>\\    * 1.1<br>\\       * 1.1.1<br>\\            * 1.1.1.1  </p>\n<blockquote>\n<ol>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ol>\n</blockquote>\n<blockquote>\n<ul>\n<li>1<ul>\n<li>1.1<ul>\n<li>1.1.1<ul>\n<li>1.1.1.1</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"8-引用\"><a href=\"#8-引用\" class=\"headerlink\" title=\"8.引用\"></a>8.引用</h3><p>&gt;第一层嵌套<br>&gt;&gt;第二次嵌套<br>&gt;&gt;&gt;第三层嵌套</p>\n<blockquote>\n<p>第一层嵌套</p>\n<blockquote>\n<p>第二次嵌套</p>\n<blockquote>\n<p>第三层嵌套</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"9-段落上的代码\"><a href=\"#9-段落上的代码\" class=\"headerlink\" title=\"9.段落上的代码\"></a>9.段落上的代码</h3><p>`System.out.println(“hello world”)`</p>\n<p><code>System.out.println(&quot;hello world&quot;)</code></p>\n<h3 id=\"10-代码区块\"><a href=\"#10-代码区块\" class=\"headerlink\" title=\"10.代码区块\"></a>10.代码区块</h3><h4 id=\"10-1Tab键或四个空格\"><a href=\"#10-1Tab键或四个空格\" class=\"headerlink\" title=\"10.1Tab键或四个空格\"></a>10.1Tab键或四个空格</h4><pre><code>public class helloWorld{\n    public static void main(String[] args){\n        System.out.println(&quot;hello world&quot;);\n    }\n}</code></pre><h4 id=\"10-2\"><a href=\"#10-2\" class=\"headerlink\" title=\"10.2\"></a>10.2</h4><p>(```+指定语言)</p>\n<pre><code class=\"java\">    public class helloWorld{\n        public static void main(String[] args){\n            System.out.println(&quot;hello world&quot;);\n        }\n    }</code></pre>\n<h3 id=\"11-链接\"><a href=\"#11-链接\" class=\"headerlink\" title=\"11.链接\"></a>11.链接</h3><p>这是一个[链接](wht.im)</p>\n<blockquote>\n<p>这是一个<a href=\"wht.im\">链接</a></p>\n</blockquote>\n<p>&lt;<a href=\"http://www.baidu.com&gt;\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com&gt;</a><br><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a></p>\n<p>网址一[^one]<br>[^one]:<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a><br>网址一[^one]<br>[^one]:<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a></p>\n<h3 id=\"12-图片\"><a href=\"#12-图片\" class=\"headerlink\" title=\"12.图片\"></a>12.图片</h3><p>([]中的为图片不显示时的提示文字)</p>\n<p>![img_caption](<a href=\"http://static.runoob.com/images/runoob-logo.png\" target=\"_blank\" rel=\"noopener\">http://static.runoob.com/images/runoob-logo.png</a>)<br><img src=\"http://static.runoob.com/images/runoob-logo.png\" alt=\"img_caption\"></p>\n<p>指定宽度</p>\n<p>&lt;img src=”<a href=\"http://static.runoob.com/images/runoob-logo.png&quot;\" target=\"_blank\" rel=\"noopener\">http://static.runoob.com/images/runoob-logo.png&quot;</a> width=”50%”&gt;<br><img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\"></p>\n<h3 id=\"13-表格\"><a href=\"#13-表格\" class=\"headerlink\" title=\"13.表格\"></a>13.表格</h3><p>| 字符 | 描述 |  例子 |<br>|-|-|-<br>|   | 时代指示器 | AD |<br>| y | 四位数年份 | 2001 |<br>| M | 年中的月份 | July or 07 |<br>| d | 月份中日期 | 10 |</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>时代指示器</td>\n<td>AD</td>\n</tr>\n<tr>\n<td>y</td>\n<td>四位数年份</td>\n<td>2001</td>\n</tr>\n<tr>\n<td>M</td>\n<td>年中的月份</td>\n<td>July or 07</td>\n</tr>\n<tr>\n<td>d</td>\n<td>月份中日期</td>\n<td>10</td>\n</tr>\n</tbody></table>\n<ul>\n<li>设置对齐方式  <ul>\n<li>-： 左对齐</li>\n<li>:-  右对齐</li>\n<li>:-：中间对齐</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">表头</th>\n<th align=\"right\">表头</th>\n<th align=\"center\">表头</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">左对齐</td>\n<td align=\"right\">右对齐</td>\n<td align=\"center\">中间对齐</td>\n</tr>\n</tbody></table>\n<h3 id=\"14-键盘文本\"><a href=\"#14-键盘文本\" class=\"headerlink\" title=\"14.键盘文本\"></a>14.键盘文本</h3><p>使用<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Esc</kbd>打开任务管理器</p>\n<p>转义：(加斜杠)</p>\n<h3 id=\"15-高级技巧\"><a href=\"#15-高级技巧\" class=\"headerlink\" title=\"15.高级技巧\"></a>15.高级技巧</h3><blockquote>\n<p><a href=\"https://www.runoob.com/markdown/md-advance.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/markdown/md-advance.html</a></p>\n</blockquote>"},{"title":"观察者模式","declare":true,"wordCount":true,"abbrlink":"168b5985","date":"2020-08-14T13:59:10.000Z","_content":"\n当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。\n使用场景：\n* 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n* 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。\n* 一个对象必须通知其他对象，而并不知道这些对象是谁。\n* 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。<br>\n\n<!-- more -->\n\n```java\nimport javax.crypto.interfaces.PBEKey;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Description\n * Author cloudr\n * Date 2020/8/14 21:03\n * Version 1.0\n **/\nclass Publish {\n    public int single;\n    public List<Reader> readers = new ArrayList<>();\n\n    public void setSingle(int single) {\n        this.single = single;\n        notifyAllReader();\n    }\n\n    public int getSingle() {\n        return single;\n    }\n\n    public void  addReader(Reader reader){\n        readers.add(reader);\n    }\n\n\n    public void notifyAllReader(){\n        for (Reader reader : readers) {\n            reader.doSomething();\n        }\n    }\n}\n\nclass   Reader{\n    public Publish publish = new Publish();\n\n    public void doSomething() {\n\n    }\n\n}\n\nclass ReadA extends Reader {\n\n    public ReadA(Publish publish){\n        this.publish = publish;\n        this.publish.addReader(this);\n    }\n\n\n    public void doSomething(){\n        System.out.println(\"I'm A, single =\" + publish.getSingle());\n    }\n}\n\nclass ReadB extends Reader{\n    public ReadB(Publish publish){\n        this.publish = publish;\n        this.publish.addReader(this);\n    }\n\n    public void doSomething(){\n        System.out.println(\"I'm B, single =\"+ publish.getSingle());\n    }\n}\n\npublic class PublishReaderDemo{\n    public static void main(String[] args) {\n        Publish publish = new Publish();\n        Reader readerA = new ReadA(publish);\n        Reader readerB = new ReadA(publish);\n        publish.setSingle(1);\n        publish.setSingle(2);\n    }\n}\n```\n\n### 参考   \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/observer-pattern.html\">https://www.runoob.com/design-pattern/observer-pattern.html</a><br>\n</div> ","source":"_posts/code/DesignMode/观察者模式.md","raw":"---\ntitle: 观察者模式\ncategories: Code\ntags: DesignMode\ndeclare: true\nwordCount: true\nabbrlink: 168b5985\ndate: 2020-08-14 21:59:10\n---\n\n当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。\n使用场景：\n* 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n* 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。\n* 一个对象必须通知其他对象，而并不知道这些对象是谁。\n* 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。<br>\n\n<!-- more -->\n\n```java\nimport javax.crypto.interfaces.PBEKey;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Description\n * Author cloudr\n * Date 2020/8/14 21:03\n * Version 1.0\n **/\nclass Publish {\n    public int single;\n    public List<Reader> readers = new ArrayList<>();\n\n    public void setSingle(int single) {\n        this.single = single;\n        notifyAllReader();\n    }\n\n    public int getSingle() {\n        return single;\n    }\n\n    public void  addReader(Reader reader){\n        readers.add(reader);\n    }\n\n\n    public void notifyAllReader(){\n        for (Reader reader : readers) {\n            reader.doSomething();\n        }\n    }\n}\n\nclass   Reader{\n    public Publish publish = new Publish();\n\n    public void doSomething() {\n\n    }\n\n}\n\nclass ReadA extends Reader {\n\n    public ReadA(Publish publish){\n        this.publish = publish;\n        this.publish.addReader(this);\n    }\n\n\n    public void doSomething(){\n        System.out.println(\"I'm A, single =\" + publish.getSingle());\n    }\n}\n\nclass ReadB extends Reader{\n    public ReadB(Publish publish){\n        this.publish = publish;\n        this.publish.addReader(this);\n    }\n\n    public void doSomething(){\n        System.out.println(\"I'm B, single =\"+ publish.getSingle());\n    }\n}\n\npublic class PublishReaderDemo{\n    public static void main(String[] args) {\n        Publish publish = new Publish();\n        Reader readerA = new ReadA(publish);\n        Reader readerB = new ReadA(publish);\n        publish.setSingle(1);\n        publish.setSingle(2);\n    }\n}\n```\n\n### 参考   \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/observer-pattern.html\">https://www.runoob.com/design-pattern/observer-pattern.html</a><br>\n</div> ","slug":"code/DesignMode/观察者模式","published":1,"updated":"2020-10-06T17:12:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1fz003b0w7t0nd17tjj","content":"<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。<br>使用场景：</p>\n<ul>\n<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>\n<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>\n<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>\n<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。<br></li>\n</ul>\n<a id=\"more\"></a>\n\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> javax<span class=\"token punctuation\">.</span>crypto<span class=\"token punctuation\">.</span>interfaces<span class=\"token punctuation\">.</span>PBEKey<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>ArrayList<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>List<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * Description\n * Author cloudr\n * Date 2020/8/14 21:03\n * Version 1.0\n **/</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Publish</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> single<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>Reader<span class=\"token operator\">></span> readers <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setSingle</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> single<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>single <span class=\"token operator\">=</span> single<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">notifyAllReader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getSingle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> single<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span>  <span class=\"token function\">addReader</span><span class=\"token punctuation\">(</span>Reader reader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        readers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">notifyAllReader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Reader reader <span class=\"token operator\">:</span> readers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            reader<span class=\"token punctuation\">.</span><span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span>   <span class=\"token class-name\">Reader</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> Publish publish <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Publish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ReadA</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Reader</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ReadA</span><span class=\"token punctuation\">(</span>Publish publish<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publish <span class=\"token operator\">=</span> publish<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">.</span><span class=\"token function\">addReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I'm A, single =\"</span> <span class=\"token operator\">+</span> publish<span class=\"token punctuation\">.</span><span class=\"token function\">getSingle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ReadB</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Reader</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ReadB</span><span class=\"token punctuation\">(</span>Publish publish<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publish <span class=\"token operator\">=</span> publish<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">.</span><span class=\"token function\">addReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I'm B, single =\"</span><span class=\"token operator\">+</span> publish<span class=\"token punctuation\">.</span><span class=\"token function\">getSingle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PublishReaderDemo</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Publish publish <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Publish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Reader readerA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReadA</span><span class=\"token punctuation\">(</span>publish<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Reader readerB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReadA</span><span class=\"token punctuation\">(</span>publish<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        publish<span class=\"token punctuation\">.</span><span class=\"token function\">setSingle</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        publish<span class=\"token punctuation\">.</span><span class=\"token function\">setSingle</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/observer-pattern.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/design-pattern/observer-pattern.html</a><br>\n</div> ","site":{"data":{}},"excerpt":"<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。<br>使用场景：</p>\n<ul>\n<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>\n<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>\n<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>\n<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。<br></li>\n</ul>","more":"<pre><code class=\"java\">import javax.crypto.interfaces.PBEKey;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Description\n * Author cloudr\n * Date 2020/8/14 21:03\n * Version 1.0\n **/\nclass Publish {\n    public int single;\n    public List&lt;Reader&gt; readers = new ArrayList&lt;&gt;();\n\n    public void setSingle(int single) {\n        this.single = single;\n        notifyAllReader();\n    }\n\n    public int getSingle() {\n        return single;\n    }\n\n    public void  addReader(Reader reader){\n        readers.add(reader);\n    }\n\n\n    public void notifyAllReader(){\n        for (Reader reader : readers) {\n            reader.doSomething();\n        }\n    }\n}\n\nclass   Reader{\n    public Publish publish = new Publish();\n\n    public void doSomething() {\n\n    }\n\n}\n\nclass ReadA extends Reader {\n\n    public ReadA(Publish publish){\n        this.publish = publish;\n        this.publish.addReader(this);\n    }\n\n\n    public void doSomething(){\n        System.out.println(&quot;I&#39;m A, single =&quot; + publish.getSingle());\n    }\n}\n\nclass ReadB extends Reader{\n    public ReadB(Publish publish){\n        this.publish = publish;\n        this.publish.addReader(this);\n    }\n\n    public void doSomething(){\n        System.out.println(&quot;I&#39;m B, single =&quot;+ publish.getSingle());\n    }\n}\n\npublic class PublishReaderDemo{\n    public static void main(String[] args) {\n        Publish publish = new Publish();\n        Reader readerA = new ReadA(publish);\n        Reader readerB = new ReadA(publish);\n        publish.setSingle(1);\n        publish.setSingle(2);\n    }\n}</code></pre>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/observer-pattern.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/design-pattern/observer-pattern.html</a><br>\n</div>"},{"title":"代理模式","declare":true,"wordCount":true,"abbrlink":"907a70d0","date":"2020-08-17T15:27:10.000Z","_content":"## 介绍 \n\n意图：为其他对象提供一种代理以**控制对这个对象的访问**。\n> 代理模式和装饰器模式很相似，但代理模式更偏向于权限控制，装饰器模式则更偏向于功能扩展\n\n主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要**安全控制**，或者需要进程外的访问），**直接访问会给使用者或者系统结构带来很多麻烦**，我们可以在访问此对象时加上一个对此对象的访问层。\n\n<!--  more -->\n\n何时使用：想在访问一个类时做一些控制。\n\n如何解决：增加中间层。\n\n关键代码：实现与被代理类组合。\n\n应用实例： 1、**Windows 里面的快捷方式**。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、**一张支票或银行存单是账户中资金的代理**。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、**spring aop**。\n\n优点： 1、职责清晰。 2、高扩展性。 3、智能化。\n\n缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式**可能会造成请求的处理速度变慢**。 2、实现代理模式需要额外的工作，**有些代理模式的实现非常复杂**。\n\n使用场景：按职责来划分，通常有以下使用场景： 1、**远程代理**。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、**防火墙**（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。\n\n注意事项： **1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。**\n\n## UML\n我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。\n\nProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。\n![proxy_pattern_uml_diagram.jpg](https://i.loli.net/2020/08/17/w7lyXZgEWQMHRvY.jpg)\n\n## 示例\n```java\npackage DP;\n\n/**\n * Description 代理模式\n * Author cloudr\n * Date 2020/8/17 22:55\n * Version 1.0\n **/\npublic class AgentPatternDemo {\n    public static void main(String[] args) {\n        new Agent().doWork();\n    }\n}\n\ninterface Subject {\n    void doWork();\n}\n\nclass RelSubject implements Subject{\n    @Override\n    public void doWork(){\n        System.out.println(\"工作...\");\n    }\n}\n\nclass Agent implements Subject{\n    private RelSubject subject;\n    public Agent(){\n        try {\n            this.subject = (RelSubject)this.getClass().getClassLoader().loadClass(\"DP.RelSubject\").newInstance(); //使用类加载器加载\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void goToWork(){\n        System.out.println(\"上班\");\n    }\n\n    public void goOffWork(){\n        System.out.println(\"下班\");\n    }\n\n    @Override\n    public void doWork(){\n        goToWork();\n        subject.doWork();;\n        goOffWork();\n    }\n}\n```\n\n\n## 参考   \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/proxy-pattern.html\">https://www.runoob.com/design-pattern/proxy-pattern.html</a><br>\n[2]<a href=\"五分钟学设计模式.11.代理模式\">https://www.bilibili.com/video/BV15V411z7nD</a><br>\n</div> ","source":"_posts/code/DesignMode/代理模式.md","raw":"---\ntitle: 代理模式\ncategories: Code\ntags: DesignMode\ndeclare: true\nwordCount: true\nabbrlink: 907a70d0\ndate: 2020-08-17 23:27:10\n---\n## 介绍 \n\n意图：为其他对象提供一种代理以**控制对这个对象的访问**。\n> 代理模式和装饰器模式很相似，但代理模式更偏向于权限控制，装饰器模式则更偏向于功能扩展\n\n主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要**安全控制**，或者需要进程外的访问），**直接访问会给使用者或者系统结构带来很多麻烦**，我们可以在访问此对象时加上一个对此对象的访问层。\n\n<!--  more -->\n\n何时使用：想在访问一个类时做一些控制。\n\n如何解决：增加中间层。\n\n关键代码：实现与被代理类组合。\n\n应用实例： 1、**Windows 里面的快捷方式**。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、**一张支票或银行存单是账户中资金的代理**。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、**spring aop**。\n\n优点： 1、职责清晰。 2、高扩展性。 3、智能化。\n\n缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式**可能会造成请求的处理速度变慢**。 2、实现代理模式需要额外的工作，**有些代理模式的实现非常复杂**。\n\n使用场景：按职责来划分，通常有以下使用场景： 1、**远程代理**。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、**防火墙**（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。\n\n注意事项： **1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。**\n\n## UML\n我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。\n\nProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。\n![proxy_pattern_uml_diagram.jpg](https://i.loli.net/2020/08/17/w7lyXZgEWQMHRvY.jpg)\n\n## 示例\n```java\npackage DP;\n\n/**\n * Description 代理模式\n * Author cloudr\n * Date 2020/8/17 22:55\n * Version 1.0\n **/\npublic class AgentPatternDemo {\n    public static void main(String[] args) {\n        new Agent().doWork();\n    }\n}\n\ninterface Subject {\n    void doWork();\n}\n\nclass RelSubject implements Subject{\n    @Override\n    public void doWork(){\n        System.out.println(\"工作...\");\n    }\n}\n\nclass Agent implements Subject{\n    private RelSubject subject;\n    public Agent(){\n        try {\n            this.subject = (RelSubject)this.getClass().getClassLoader().loadClass(\"DP.RelSubject\").newInstance(); //使用类加载器加载\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void goToWork(){\n        System.out.println(\"上班\");\n    }\n\n    public void goOffWork(){\n        System.out.println(\"下班\");\n    }\n\n    @Override\n    public void doWork(){\n        goToWork();\n        subject.doWork();;\n        goOffWork();\n    }\n}\n```\n\n\n## 参考   \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/proxy-pattern.html\">https://www.runoob.com/design-pattern/proxy-pattern.html</a><br>\n[2]<a href=\"五分钟学设计模式.11.代理模式\">https://www.bilibili.com/video/BV15V411z7nD</a><br>\n</div> ","slug":"code/DesignMode/代理模式","published":1,"updated":"2020-10-06T17:12:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1g0003c0w7tewk6fvrp","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>意图：为其他对象提供一种代理以<strong>控制对这个对象的访问</strong>。</p>\n<blockquote>\n<p>代理模式和装饰器模式很相似，但代理模式更偏向于权限控制，装饰器模式则更偏向于功能扩展</p>\n</blockquote>\n<p>主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要<strong>安全控制</strong>，或者需要进程外的访问），<strong>直接访问会给使用者或者系统结构带来很多麻烦</strong>，我们可以在访问此对象时加上一个对此对象的访问层。</p>\n<a id=\"more\"></a>\n\n<p>何时使用：想在访问一个类时做一些控制。</p>\n<p>如何解决：增加中间层。</p>\n<p>关键代码：实现与被代理类组合。</p>\n<p>应用实例： 1、<strong>Windows 里面的快捷方式</strong>。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、<strong>一张支票或银行存单是账户中资金的代理</strong>。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、<strong>spring aop</strong>。</p>\n<p>优点： 1、职责清晰。 2、高扩展性。 3、智能化。</p>\n<p>缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式<strong>可能会造成请求的处理速度变慢</strong>。 2、实现代理模式需要额外的工作，<strong>有些代理模式的实现非常复杂</strong>。</p>\n<p>使用场景：按职责来划分，通常有以下使用场景： 1、<strong>远程代理</strong>。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、<strong>防火墙</strong>（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p>\n<p>注意事项： <strong>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</strong></p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p>我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。</p>\n<p>ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。<br><img src=\"https://i.loli.net/2020/08/17/w7lyXZgEWQMHRvY.jpg\" alt=\"proxy_pattern_uml_diagram.jpg\"></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> DP<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * Description 代理模式\n * Author cloudr\n * Date 2020/8/17 22:55\n * Version 1.0\n **/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AgentPatternDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Agent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">doWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Subject</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">doWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">RelSubject</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Subject</span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"工作...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Agent</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Subject</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> RelSubject subject<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Agent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subject <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>RelSubject<span class=\"token punctuation\">)</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DP.RelSubject\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//使用类加载器加载</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">goToWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"上班\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">goOffWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"下班\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">goToWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        subject<span class=\"token punctuation\">.</span><span class=\"token function\">doWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">goOffWork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/proxy-pattern.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/design-pattern/proxy-pattern.html</a><br>\n[2]<a href=\"五分钟学设计模式.11.代理模式\">https://www.bilibili.com/video/BV15V411z7nD</a><br>\n</div> ","site":{"data":{}},"excerpt":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>意图：为其他对象提供一种代理以<strong>控制对这个对象的访问</strong>。</p>\n<blockquote>\n<p>代理模式和装饰器模式很相似，但代理模式更偏向于权限控制，装饰器模式则更偏向于功能扩展</p>\n</blockquote>\n<p>主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要<strong>安全控制</strong>，或者需要进程外的访问），<strong>直接访问会给使用者或者系统结构带来很多麻烦</strong>，我们可以在访问此对象时加上一个对此对象的访问层。</p>","more":"<p>何时使用：想在访问一个类时做一些控制。</p>\n<p>如何解决：增加中间层。</p>\n<p>关键代码：实现与被代理类组合。</p>\n<p>应用实例： 1、<strong>Windows 里面的快捷方式</strong>。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、<strong>一张支票或银行存单是账户中资金的代理</strong>。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、<strong>spring aop</strong>。</p>\n<p>优点： 1、职责清晰。 2、高扩展性。 3、智能化。</p>\n<p>缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式<strong>可能会造成请求的处理速度变慢</strong>。 2、实现代理模式需要额外的工作，<strong>有些代理模式的实现非常复杂</strong>。</p>\n<p>使用场景：按职责来划分，通常有以下使用场景： 1、<strong>远程代理</strong>。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、<strong>防火墙</strong>（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p>\n<p>注意事项： <strong>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</strong></p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p>我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。</p>\n<p>ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。<br><img src=\"https://i.loli.net/2020/08/17/w7lyXZgEWQMHRvY.jpg\" alt=\"proxy_pattern_uml_diagram.jpg\"></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre><code class=\"java\">package DP;\n\n/**\n * Description 代理模式\n * Author cloudr\n * Date 2020/8/17 22:55\n * Version 1.0\n **/\npublic class AgentPatternDemo {\n    public static void main(String[] args) {\n        new Agent().doWork();\n    }\n}\n\ninterface Subject {\n    void doWork();\n}\n\nclass RelSubject implements Subject{\n    @Override\n    public void doWork(){\n        System.out.println(&quot;工作...&quot;);\n    }\n}\n\nclass Agent implements Subject{\n    private RelSubject subject;\n    public Agent(){\n        try {\n            this.subject = (RelSubject)this.getClass().getClassLoader().loadClass(&quot;DP.RelSubject&quot;).newInstance(); //使用类加载器加载\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void goToWork(){\n        System.out.println(&quot;上班&quot;);\n    }\n\n    public void goOffWork(){\n        System.out.println(&quot;下班&quot;);\n    }\n\n    @Override\n    public void doWork(){\n        goToWork();\n        subject.doWork();;\n        goOffWork();\n    }\n}</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/proxy-pattern.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/design-pattern/proxy-pattern.html</a><br>\n[2]<a href=\"五分钟学设计模式.11.代理模式\">https://www.bilibili.com/video/BV15V411z7nD</a><br>\n</div>"},{"title":"单例模式","declare":true,"wordCount":true,"abbrlink":"1a4b62fe","date":"2020-07-02T14:59:10.000Z","_content":"\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于**创建型模式**，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，**该类负责创建自己的对象，同时确保只有单个对象被创建**。这个类提供了**一种访问其唯一的对象的方式，可以直接访问**，不需要实例化该类的对象。\n\n![单例模式](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200702230738.png)\n<!-- more -->\n\n## 一、特点\n### 1.1 属性\n意图**保证一个类仅有一个实例，并提供一个访问它的全局访问点**。\n\n主要解决：一**个全局使用的类频繁地创建与销毁**。\n\n何时使用：当您想**控制实例数目，节省系统资源**的时候。\n\n如何解决：判断系统是否已经有这个单例，如果**有则返回，如果没有则创建**。\n\n关键代码：**构造函数是私有的**。\n\n应用实例：**一些设备管理器常常设计为单例模式**，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 \n\n* 优点：\n    1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。        \n    2. 避免对资源的多重占用（比如写文件操作）。 \n\n* 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n\n* 使用场景：       \n    1. 要求生产唯一序列号       \n    2. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来            \n    3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。      \n\n* 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n\n<br>\n\n***\n\n## 二、单例模式的实现\n\n三个步骤：   \n1. 构造函数私有化   \n2. 自行对外提供实例\n3. 提供外界可以获得该实例的方法\n\n\n### 2.1 传统的创建类的方式\n```java\npublic class s1 {\n    public static void main(String[] args) {\n\n        Singleton singleton1 = new Singleton();\n        Singleton singleton2 = new Singleton();\n    }\n}\n\nclass Singleton {\n\n}\n```\n上述代码中，每次`new Singleton()`都会创建一个Signleton实例。\n\n### 2.2 恶汉模式\n>是否 Lazy 初始化：否    \n>是否多线程安全：是     \n>实现难度：易    \n\n* 描述：这种方式比较常用，但**容易产生垃圾对象**。   \n* 优点：**没有加锁，执行效率会提高**。       \n* 缺点：**类加载时就初始化，浪费内存**。      \n\n它基于 **classloader 机制避免了多线程的同步问题**，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到 lazy loading 的效果。\n>lazy loading(延迟加载):例如创建某一对象时需要花费很大的开销，而这一对象在系统的运行过程中不一定会用到，这时就可以使用延迟加载，**在第一次使用该对象时再对其进行初始化，如果没有用到则不需要进行初始化**,这样的话，使用延迟初始化就提高程序的效率，从而使程序占用更少的内存。\n```java\npublic class Singleton {\n    private static Singleton instance = new Singleton();\n\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n***\n\n### 2.3 懒汉模式\n\n> 是否Lazy初始化：是     \n> 是否多线程安全：是     \n> 实现难度：易     \n\n* 描述：这种方式**具备很好的 lazy loading，能够在多线程中很好的工作**，但是**效率很低**，99% 情况下不需要同步。\n* 优点：第一次调用才初始化，**避免内存浪费**。\n* 缺点：必须加锁 synchronized 才能保证单例，但**加锁会影响效率**。\n\ngetInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n    }\n\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n***\n\n### 2.4 双检锁/双重校验锁（DCL，即 double-checked locking）\n添加synchronized锁虽然可以保证线程安全，但是**每次访问getInstance()方法的时候，都会有加锁和解锁操作**，同时synchronized**锁加在方法上面，锁的范围过大，会成为系统的瓶颈**。\n\n\n> 是否 Lazy 初始化：是      \n> 是否多线程安全：是      \n> 实现难度：较复杂      \n\n* 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。\n\ngetInstance() 的性能对应用程序很关键\n\n```java\npublic class Singleton {\n    private volatile static Singleton singleton;\n\n    private Singleton() {\n    }\n\n    public static Singleton getSingleton() {\n        if (singleton == null) {    //第一次校验\n            synchronized (Singleton.class) {    //只对这一部分加锁\n                if (singleton == null) {    //第二次校验\n                    singleton = new Singleton();    //非原子操作\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n\n***\n\n### 2.5 双检锁/双重校验锁(增加volatile)\n\n双重校验锁会出现指令重排的问题，`singleton = new Singleton();`并非一个原子操作，实际上，它可以抽象为下面几个JVM指令：\n\n```java\n//1. 分配对象内存空间\nmemory = allocate();\n//2. 初始化对象\nctorInstance(memory);\n//3. 设置instance指向刚分配的内存地址\nsingleton = memory;\n```\n操作2依赖于操作1，但操作3并不依赖于操作1，所以JVM是可以针对它们进行指令优化，优化后如下：\n\n```java\n//1. 分配对象内存空间\nmemory = allocate();\n//3. 设置instance指向刚分配的内存地址\nsingleton = memory;\n//2. 初始化对象\nctorInstance(memory);\n```\n可以看到，指令重排之后，singleton指向分配好的内存放在前面，而这段内存的初始化被排在了后面。       \n线程A执行这段赋值语句，**在初始化分配对象之前就已经将其赋值singleton引用**，恰好**线程B进入方法判断singleton的引用不为空**，然后就将其返回使用，导致程序出错。       \n为了解决指令重排问题，可以使用`volatile`关键字修饰singleton字段，**禁止指令的重排序优化**。\n\n```java\nclass Singleton {\n    private static volatile Singleton singleton = null;\n\n    private Singleton();\n\n    public static Singleton getInstance() {\n        if (singleton = null) {\n            synchronized (Singleton.class) {\n                if (singleton = null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return signleton;\n    }\n}\n\n```\n\n***\n\n### 2.6 静态内部类\n\n> 是否 Lazy 初始化：是      \n> 是否多线程安全：是      \n> 实现难度：一般      \n\n描述：当第**一次访问类中的静态字段时，会触发类加载，并且保证同一个类只加载一次。**静态内部类也是如此，**类加载过程有类加载器负责加锁**。这种写法相对于双重检验锁的写法，更加简单。对**静态域使用延迟初始化，应使用这种方式而不是双检锁方式**。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n>静态域：如果将域定义为static，每个类中只有一个这样的域，这个类的所有对象将共享这个域，这个域称为静态域。这个域属于类，而不属于任何独立的对象。\n```java\nclass Singleton {\n    //私有的静态内部类，类加载器负责加锁\n    private static class SingletonHolder {\n        private static Singleton singleton = new Singleton();\n    }\n\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        return Singleton.singleton;\n    }\n}\n\n```\n\n***\n\n### 2.6 枚举\n\n> 是否 Lazy 初始化：否      \n> 是否多线程安全：是      \n> 实现难度：易      \n\n描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。**它更简洁，自动支持序列化机制，绝对防止多次实例化**。\n这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。\n\n```java\npublic enum Singleton {\n    INSTANCE;\n\n    public void whateverMethod() {\n    }\n}\n```\n<br><br><br>\n\n***\n\n<br><br><br>\n\n### 推荐阅读\n* [通过反射机制、序列化反序列化破解单例模式](https://www.cnblogs.com/aeon/p/10212065.html)\n* [单例模式|菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)\n* [方志朋-设计模式之单例模式](https://www.fangzhipeng.com/java/2019/09/01/sigton-design.html)\n* [我给面试官讲解了单例模式后，他对我竖起了大拇指！](https://zhuanlan.zhihu.com/p/160842212)\n\n\n\n### 参考   \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]黄文毅，Spring MVC + MyBatis快速开发与项目实战.北京：清华出版社，2019.<br>\n[2]<a href=\"https://www.runoob.com/design-pattern/singleton-pattern.html\">https://www.runoob.com/design-pattern/singleton-pattern.html</a><br>\n[3]<a href=\"https://blog.csdn.net/u013894997/article/details/81111236\">https://blog.csdn.net/u013894997/article/details/81111236</a><br>\n</div> \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/code/DesignMode/单例模式.md","raw":"---\ntitle: 单例模式\ncategories: Code\ntags: DesignMode\ndeclare: true\nwordCount: true\nabbrlink: 1a4b62fe\ndate: 2020-07-02 22:59:10\n---\n\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于**创建型模式**，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，**该类负责创建自己的对象，同时确保只有单个对象被创建**。这个类提供了**一种访问其唯一的对象的方式，可以直接访问**，不需要实例化该类的对象。\n\n![单例模式](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200702230738.png)\n<!-- more -->\n\n## 一、特点\n### 1.1 属性\n意图**保证一个类仅有一个实例，并提供一个访问它的全局访问点**。\n\n主要解决：一**个全局使用的类频繁地创建与销毁**。\n\n何时使用：当您想**控制实例数目，节省系统资源**的时候。\n\n如何解决：判断系统是否已经有这个单例，如果**有则返回，如果没有则创建**。\n\n关键代码：**构造函数是私有的**。\n\n应用实例：**一些设备管理器常常设计为单例模式**，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 \n\n* 优点：\n    1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。        \n    2. 避免对资源的多重占用（比如写文件操作）。 \n\n* 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n\n* 使用场景：       \n    1. 要求生产唯一序列号       \n    2. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来            \n    3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。      \n\n* 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n\n<br>\n\n***\n\n## 二、单例模式的实现\n\n三个步骤：   \n1. 构造函数私有化   \n2. 自行对外提供实例\n3. 提供外界可以获得该实例的方法\n\n\n### 2.1 传统的创建类的方式\n```java\npublic class s1 {\n    public static void main(String[] args) {\n\n        Singleton singleton1 = new Singleton();\n        Singleton singleton2 = new Singleton();\n    }\n}\n\nclass Singleton {\n\n}\n```\n上述代码中，每次`new Singleton()`都会创建一个Signleton实例。\n\n### 2.2 恶汉模式\n>是否 Lazy 初始化：否    \n>是否多线程安全：是     \n>实现难度：易    \n\n* 描述：这种方式比较常用，但**容易产生垃圾对象**。   \n* 优点：**没有加锁，执行效率会提高**。       \n* 缺点：**类加载时就初始化，浪费内存**。      \n\n它基于 **classloader 机制避免了多线程的同步问题**，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到 lazy loading 的效果。\n>lazy loading(延迟加载):例如创建某一对象时需要花费很大的开销，而这一对象在系统的运行过程中不一定会用到，这时就可以使用延迟加载，**在第一次使用该对象时再对其进行初始化，如果没有用到则不需要进行初始化**,这样的话，使用延迟初始化就提高程序的效率，从而使程序占用更少的内存。\n```java\npublic class Singleton {\n    private static Singleton instance = new Singleton();\n\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n***\n\n### 2.3 懒汉模式\n\n> 是否Lazy初始化：是     \n> 是否多线程安全：是     \n> 实现难度：易     \n\n* 描述：这种方式**具备很好的 lazy loading，能够在多线程中很好的工作**，但是**效率很低**，99% 情况下不需要同步。\n* 优点：第一次调用才初始化，**避免内存浪费**。\n* 缺点：必须加锁 synchronized 才能保证单例，但**加锁会影响效率**。\n\ngetInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n    }\n\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n***\n\n### 2.4 双检锁/双重校验锁（DCL，即 double-checked locking）\n添加synchronized锁虽然可以保证线程安全，但是**每次访问getInstance()方法的时候，都会有加锁和解锁操作**，同时synchronized**锁加在方法上面，锁的范围过大，会成为系统的瓶颈**。\n\n\n> 是否 Lazy 初始化：是      \n> 是否多线程安全：是      \n> 实现难度：较复杂      \n\n* 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。\n\ngetInstance() 的性能对应用程序很关键\n\n```java\npublic class Singleton {\n    private volatile static Singleton singleton;\n\n    private Singleton() {\n    }\n\n    public static Singleton getSingleton() {\n        if (singleton == null) {    //第一次校验\n            synchronized (Singleton.class) {    //只对这一部分加锁\n                if (singleton == null) {    //第二次校验\n                    singleton = new Singleton();    //非原子操作\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n\n***\n\n### 2.5 双检锁/双重校验锁(增加volatile)\n\n双重校验锁会出现指令重排的问题，`singleton = new Singleton();`并非一个原子操作，实际上，它可以抽象为下面几个JVM指令：\n\n```java\n//1. 分配对象内存空间\nmemory = allocate();\n//2. 初始化对象\nctorInstance(memory);\n//3. 设置instance指向刚分配的内存地址\nsingleton = memory;\n```\n操作2依赖于操作1，但操作3并不依赖于操作1，所以JVM是可以针对它们进行指令优化，优化后如下：\n\n```java\n//1. 分配对象内存空间\nmemory = allocate();\n//3. 设置instance指向刚分配的内存地址\nsingleton = memory;\n//2. 初始化对象\nctorInstance(memory);\n```\n可以看到，指令重排之后，singleton指向分配好的内存放在前面，而这段内存的初始化被排在了后面。       \n线程A执行这段赋值语句，**在初始化分配对象之前就已经将其赋值singleton引用**，恰好**线程B进入方法判断singleton的引用不为空**，然后就将其返回使用，导致程序出错。       \n为了解决指令重排问题，可以使用`volatile`关键字修饰singleton字段，**禁止指令的重排序优化**。\n\n```java\nclass Singleton {\n    private static volatile Singleton singleton = null;\n\n    private Singleton();\n\n    public static Singleton getInstance() {\n        if (singleton = null) {\n            synchronized (Singleton.class) {\n                if (singleton = null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return signleton;\n    }\n}\n\n```\n\n***\n\n### 2.6 静态内部类\n\n> 是否 Lazy 初始化：是      \n> 是否多线程安全：是      \n> 实现难度：一般      \n\n描述：当第**一次访问类中的静态字段时，会触发类加载，并且保证同一个类只加载一次。**静态内部类也是如此，**类加载过程有类加载器负责加锁**。这种写法相对于双重检验锁的写法，更加简单。对**静态域使用延迟初始化，应使用这种方式而不是双检锁方式**。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n>静态域：如果将域定义为static，每个类中只有一个这样的域，这个类的所有对象将共享这个域，这个域称为静态域。这个域属于类，而不属于任何独立的对象。\n```java\nclass Singleton {\n    //私有的静态内部类，类加载器负责加锁\n    private static class SingletonHolder {\n        private static Singleton singleton = new Singleton();\n    }\n\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        return Singleton.singleton;\n    }\n}\n\n```\n\n***\n\n### 2.6 枚举\n\n> 是否 Lazy 初始化：否      \n> 是否多线程安全：是      \n> 实现难度：易      \n\n描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。**它更简洁，自动支持序列化机制，绝对防止多次实例化**。\n这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。\n\n```java\npublic enum Singleton {\n    INSTANCE;\n\n    public void whateverMethod() {\n    }\n}\n```\n<br><br><br>\n\n***\n\n<br><br><br>\n\n### 推荐阅读\n* [通过反射机制、序列化反序列化破解单例模式](https://www.cnblogs.com/aeon/p/10212065.html)\n* [单例模式|菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)\n* [方志朋-设计模式之单例模式](https://www.fangzhipeng.com/java/2019/09/01/sigton-design.html)\n* [我给面试官讲解了单例模式后，他对我竖起了大拇指！](https://zhuanlan.zhihu.com/p/160842212)\n\n\n\n### 参考   \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]黄文毅，Spring MVC + MyBatis快速开发与项目实战.北京：清华出版社，2019.<br>\n[2]<a href=\"https://www.runoob.com/design-pattern/singleton-pattern.html\">https://www.runoob.com/design-pattern/singleton-pattern.html</a><br>\n[3]<a href=\"https://blog.csdn.net/u013894997/article/details/81111236\">https://blog.csdn.net/u013894997/article/details/81111236</a><br>\n</div> \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"code/DesignMode/单例模式","published":1,"updated":"2020-10-06T17:12:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1g0003e0w7t2ctb3cqp","content":"<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了<strong>一种访问其唯一的对象的方式，可以直接访问</strong>，不需要实例化该类的对象。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200702230738.png\" alt=\"单例模式\"></p>\n<a id=\"more\"></a>\n\n<h2 id=\"一、特点\"><a href=\"#一、特点\" class=\"headerlink\" title=\"一、特点\"></a>一、特点</h2><h3 id=\"1-1-属性\"><a href=\"#1-1-属性\" class=\"headerlink\" title=\"1.1 属性\"></a>1.1 属性</h3><p>意图<strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点</strong>。</p>\n<p>主要解决：一<strong>个全局使用的类频繁地创建与销毁</strong>。</p>\n<p>何时使用：当您想<strong>控制实例数目，节省系统资源</strong>的时候。</p>\n<p>如何解决：判断系统是否已经有这个单例，如果<strong>有则返回，如果没有则创建</strong>。</p>\n<p>关键代码：<strong>构造函数是私有的</strong>。</p>\n<p>应用实例：<strong>一些设备管理器常常设计为单例模式</strong>，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 </p>\n<ul>\n<li><p>优点：</p>\n<ol>\n<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。        </li>\n<li>避免对资源的多重占用（比如写文件操作）。 </li>\n</ol>\n</li>\n<li><p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>\n</li>\n<li><p>使用场景：       </p>\n<ol>\n<li>要求生产唯一序列号       </li>\n<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来            </li>\n<li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。      </li>\n</ol>\n</li>\n<li><p>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>\n</li>\n</ul>\n<br>\n\n<hr>\n<h2 id=\"二、单例模式的实现\"><a href=\"#二、单例模式的实现\" class=\"headerlink\" title=\"二、单例模式的实现\"></a>二、单例模式的实现</h2><p>三个步骤：   </p>\n<ol>\n<li>构造函数私有化   </li>\n<li>自行对外提供实例</li>\n<li>提供外界可以获得该实例的方法</li>\n</ol>\n<h3 id=\"2-1-传统的创建类的方式\"><a href=\"#2-1-传统的创建类的方式\" class=\"headerlink\" title=\"2.1 传统的创建类的方式\"></a>2.1 传统的创建类的方式</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">s1</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        Singleton singleton1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Singleton singleton2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上述代码中，每次<code>new Singleton()</code>都会创建一个Signleton实例。</p>\n<h3 id=\"2-2-恶汉模式\"><a href=\"#2-2-恶汉模式\" class=\"headerlink\" title=\"2.2 恶汉模式\"></a>2.2 恶汉模式</h3><blockquote>\n<p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易    </p>\n</blockquote>\n<ul>\n<li>描述：这种方式比较常用，但<strong>容易产生垃圾对象</strong>。   </li>\n<li>优点：<strong>没有加锁，执行效率会提高</strong>。       </li>\n<li>缺点：<strong>类加载时就初始化，浪费内存</strong>。      </li>\n</ul>\n<p>它基于 <strong>classloader 机制避免了多线程的同步问题</strong>，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到 lazy loading 的效果。</p>\n<blockquote>\n<p>lazy loading(延迟加载):例如创建某一对象时需要花费很大的开销，而这一对象在系统的运行过程中不一定会用到，这时就可以使用延迟加载，<strong>在第一次使用该对象时再对其进行初始化，如果没有用到则不需要进行初始化</strong>,这样的话，使用延迟初始化就提高程序的效率，从而使程序占用更少的内存。</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<hr>\n<h3 id=\"2-3-懒汉模式\"><a href=\"#2-3-懒汉模式\" class=\"headerlink\" title=\"2.3 懒汉模式\"></a>2.3 懒汉模式</h3><blockquote>\n<p>是否Lazy初始化：是<br>是否多线程安全：是<br>实现难度：易     </p>\n</blockquote>\n<ul>\n<li>描述：这种方式<strong>具备很好的 lazy loading，能够在多线程中很好的工作</strong>，但是<strong>效率很低</strong>，99% 情况下不需要同步。</li>\n<li>优点：第一次调用才初始化，<strong>避免内存浪费</strong>。</li>\n<li>缺点：必须加锁 synchronized 才能保证单例，但<strong>加锁会影响效率</strong>。</li>\n</ul>\n<p>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton instance<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<hr>\n<h3 id=\"2-4-双检锁-双重校验锁（DCL，即-double-checked-locking）\"><a href=\"#2-4-双检锁-双重校验锁（DCL，即-double-checked-locking）\" class=\"headerlink\" title=\"2.4 双检锁/双重校验锁（DCL，即 double-checked locking）\"></a>2.4 双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p>添加synchronized锁虽然可以保证线程安全，但是<strong>每次访问getInstance()方法的时候，都会有加锁和解锁操作</strong>，同时synchronized<strong>锁加在方法上面，锁的范围过大，会成为系统的瓶颈</strong>。</p>\n<blockquote>\n<p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：较复杂      </p>\n</blockquote>\n<ul>\n<li>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</li>\n</ul>\n<p>getInstance() 的性能对应用程序很关键</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">static</span> Singleton singleton<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singleton <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//第一次校验</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>Singleton<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//只对这一部分加锁</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singleton <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//第二次校验</span>\n                    singleton <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//非原子操作</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> singleton<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<hr>\n<h3 id=\"2-5-双检锁-双重校验锁-增加volatile\"><a href=\"#2-5-双检锁-双重校验锁-增加volatile\" class=\"headerlink\" title=\"2.5 双检锁/双重校验锁(增加volatile)\"></a>2.5 双检锁/双重校验锁(增加volatile)</h3><p>双重校验锁会出现指令重排的问题，<code>singleton = new Singleton();</code>并非一个原子操作，实际上，它可以抽象为下面几个JVM指令：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//1. 分配对象内存空间</span>\nmemory <span class=\"token operator\">=</span> <span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//2. 初始化对象</span>\n<span class=\"token function\">ctorInstance</span><span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//3. 设置instance指向刚分配的内存地址</span>\nsingleton <span class=\"token operator\">=</span> memory<span class=\"token punctuation\">;</span></code></pre>\n<p>操作2依赖于操作1，但操作3并不依赖于操作1，所以JVM是可以针对它们进行指令优化，优化后如下：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//1. 分配对象内存空间</span>\nmemory <span class=\"token operator\">=</span> <span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//3. 设置instance指向刚分配的内存地址</span>\nsingleton <span class=\"token operator\">=</span> memory<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//2. 初始化对象</span>\n<span class=\"token function\">ctorInstance</span><span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>可以看到，指令重排之后，singleton指向分配好的内存放在前面，而这段内存的初始化被排在了后面。<br>线程A执行这段赋值语句，<strong>在初始化分配对象之前就已经将其赋值singleton引用</strong>，恰好<strong>线程B进入方法判断singleton的引用不为空</strong>，然后就将其返回使用，导致程序出错。<br>为了解决指令重排问题，可以使用<code>volatile</code>关键字修饰singleton字段，<strong>禁止指令的重排序优化</strong>。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> Singleton singleton <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singleton <span class=\"token operator\">=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>Singleton<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singleton <span class=\"token operator\">=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    singleton <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> signleton<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<hr>\n<h3 id=\"2-6-静态内部类\"><a href=\"#2-6-静态内部类\" class=\"headerlink\" title=\"2.6 静态内部类\"></a>2.6 静态内部类</h3><blockquote>\n<p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：一般      </p>\n</blockquote>\n<p>描述：当第<strong>一次访问类中的静态字段时，会触发类加载，并且保证同一个类只加载一次。</strong>静态内部类也是如此，<strong>类加载过程有类加载器负责加锁</strong>。这种写法相对于双重检验锁的写法，更加简单。对<strong>静态域使用延迟初始化，应使用这种方式而不是双检锁方式</strong>。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<blockquote>\n<p>静态域：如果将域定义为static，每个类中只有一个这样的域，这个类的所有对象将共享这个域，这个域称为静态域。这个域属于类，而不属于任何独立的对象。</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//私有的静态内部类，类加载器负责加锁</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonHolder</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton singleton <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> Singleton<span class=\"token punctuation\">.</span>singleton<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<hr>\n<h3 id=\"2-6-枚举\"><a href=\"#2-6-枚举\" class=\"headerlink\" title=\"2.6 枚举\"></a>2.6 枚举</h3><blockquote>\n<p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易      </p>\n</blockquote>\n<p>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。<strong>它更简洁，自动支持序列化机制，绝对防止多次实例化</strong>。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> Singleton <span class=\"token punctuation\">{</span>\n    INSTANCE<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">whateverMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h3><ul>\n<li><a href=\"https://www.cnblogs.com/aeon/p/10212065.html\" target=\"_blank\" rel=\"noopener\">通过反射机制、序列化反序列化破解单例模式</a></li>\n<li><a href=\"https://www.runoob.com/design-pattern/singleton-pattern.html\" target=\"_blank\" rel=\"noopener\">单例模式|菜鸟教程</a></li>\n<li><a href=\"https://www.fangzhipeng.com/java/2019/09/01/sigton-design.html\" target=\"_blank\" rel=\"noopener\">方志朋-设计模式之单例模式</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/160842212\" target=\"_blank\" rel=\"noopener\">我给面试官讲解了单例模式后，他对我竖起了大拇指！</a></li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><div style=\"margin-left: 5px  font-size:16px;\">\n[1]黄文毅，Spring MVC + MyBatis快速开发与项目实战.北京：清华出版社，2019.<br>\n[2]<a href=\"https://www.runoob.com/design-pattern/singleton-pattern.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/design-pattern/singleton-pattern.html</a><br>\n[3]<a href=\"https://blog.csdn.net/u013894997/article/details/81111236\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013894997/article/details/81111236</a><br>\n</div> \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了<strong>一种访问其唯一的对象的方式，可以直接访问</strong>，不需要实例化该类的对象。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200702230738.png\" alt=\"单例模式\"></p>","more":"<h2 id=\"一、特点\"><a href=\"#一、特点\" class=\"headerlink\" title=\"一、特点\"></a>一、特点</h2><h3 id=\"1-1-属性\"><a href=\"#1-1-属性\" class=\"headerlink\" title=\"1.1 属性\"></a>1.1 属性</h3><p>意图<strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点</strong>。</p>\n<p>主要解决：一<strong>个全局使用的类频繁地创建与销毁</strong>。</p>\n<p>何时使用：当您想<strong>控制实例数目，节省系统资源</strong>的时候。</p>\n<p>如何解决：判断系统是否已经有这个单例，如果<strong>有则返回，如果没有则创建</strong>。</p>\n<p>关键代码：<strong>构造函数是私有的</strong>。</p>\n<p>应用实例：<strong>一些设备管理器常常设计为单例模式</strong>，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 </p>\n<ul>\n<li><p>优点：</p>\n<ol>\n<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。        </li>\n<li>避免对资源的多重占用（比如写文件操作）。 </li>\n</ol>\n</li>\n<li><p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>\n</li>\n<li><p>使用场景：       </p>\n<ol>\n<li>要求生产唯一序列号       </li>\n<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来            </li>\n<li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。      </li>\n</ol>\n</li>\n<li><p>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>\n</li>\n</ul>\n<br>\n\n<hr>\n<h2 id=\"二、单例模式的实现\"><a href=\"#二、单例模式的实现\" class=\"headerlink\" title=\"二、单例模式的实现\"></a>二、单例模式的实现</h2><p>三个步骤：   </p>\n<ol>\n<li>构造函数私有化   </li>\n<li>自行对外提供实例</li>\n<li>提供外界可以获得该实例的方法</li>\n</ol>\n<h3 id=\"2-1-传统的创建类的方式\"><a href=\"#2-1-传统的创建类的方式\" class=\"headerlink\" title=\"2.1 传统的创建类的方式\"></a>2.1 传统的创建类的方式</h3><pre><code class=\"java\">public class s1 {\n    public static void main(String[] args) {\n\n        Singleton singleton1 = new Singleton();\n        Singleton singleton2 = new Singleton();\n    }\n}\n\nclass Singleton {\n\n}</code></pre>\n<p>上述代码中，每次<code>new Singleton()</code>都会创建一个Signleton实例。</p>\n<h3 id=\"2-2-恶汉模式\"><a href=\"#2-2-恶汉模式\" class=\"headerlink\" title=\"2.2 恶汉模式\"></a>2.2 恶汉模式</h3><blockquote>\n<p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易    </p>\n</blockquote>\n<ul>\n<li>描述：这种方式比较常用，但<strong>容易产生垃圾对象</strong>。   </li>\n<li>优点：<strong>没有加锁，执行效率会提高</strong>。       </li>\n<li>缺点：<strong>类加载时就初始化，浪费内存</strong>。      </li>\n</ul>\n<p>它基于 <strong>classloader 机制避免了多线程的同步问题</strong>，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到 lazy loading 的效果。</p>\n<blockquote>\n<p>lazy loading(延迟加载):例如创建某一对象时需要花费很大的开销，而这一对象在系统的运行过程中不一定会用到，这时就可以使用延迟加载，<strong>在第一次使用该对象时再对其进行初始化，如果没有用到则不需要进行初始化</strong>,这样的话，使用延迟初始化就提高程序的效率，从而使程序占用更少的内存。</p>\n</blockquote>\n<pre><code class=\"java\">public class Singleton {\n    private static Singleton instance = new Singleton();\n\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n}</code></pre>\n<hr>\n<h3 id=\"2-3-懒汉模式\"><a href=\"#2-3-懒汉模式\" class=\"headerlink\" title=\"2.3 懒汉模式\"></a>2.3 懒汉模式</h3><blockquote>\n<p>是否Lazy初始化：是<br>是否多线程安全：是<br>实现难度：易     </p>\n</blockquote>\n<ul>\n<li>描述：这种方式<strong>具备很好的 lazy loading，能够在多线程中很好的工作</strong>，但是<strong>效率很低</strong>，99% 情况下不需要同步。</li>\n<li>优点：第一次调用才初始化，<strong>避免内存浪费</strong>。</li>\n<li>缺点：必须加锁 synchronized 才能保证单例，但<strong>加锁会影响效率</strong>。</li>\n</ul>\n<p>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>\n<pre><code class=\"java\">public class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n    }\n\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}</code></pre>\n<hr>\n<h3 id=\"2-4-双检锁-双重校验锁（DCL，即-double-checked-locking）\"><a href=\"#2-4-双检锁-双重校验锁（DCL，即-double-checked-locking）\" class=\"headerlink\" title=\"2.4 双检锁/双重校验锁（DCL，即 double-checked locking）\"></a>2.4 双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p>添加synchronized锁虽然可以保证线程安全，但是<strong>每次访问getInstance()方法的时候，都会有加锁和解锁操作</strong>，同时synchronized<strong>锁加在方法上面，锁的范围过大，会成为系统的瓶颈</strong>。</p>\n<blockquote>\n<p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：较复杂      </p>\n</blockquote>\n<ul>\n<li>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</li>\n</ul>\n<p>getInstance() 的性能对应用程序很关键</p>\n<pre><code class=\"java\">public class Singleton {\n    private volatile static Singleton singleton;\n\n    private Singleton() {\n    }\n\n    public static Singleton getSingleton() {\n        if (singleton == null) {    //第一次校验\n            synchronized (Singleton.class) {    //只对这一部分加锁\n                if (singleton == null) {    //第二次校验\n                    singleton = new Singleton();    //非原子操作\n                }\n            }\n        }\n        return singleton;\n    }\n}</code></pre>\n<hr>\n<h3 id=\"2-5-双检锁-双重校验锁-增加volatile\"><a href=\"#2-5-双检锁-双重校验锁-增加volatile\" class=\"headerlink\" title=\"2.5 双检锁/双重校验锁(增加volatile)\"></a>2.5 双检锁/双重校验锁(增加volatile)</h3><p>双重校验锁会出现指令重排的问题，<code>singleton = new Singleton();</code>并非一个原子操作，实际上，它可以抽象为下面几个JVM指令：</p>\n<pre><code class=\"java\">//1. 分配对象内存空间\nmemory = allocate();\n//2. 初始化对象\nctorInstance(memory);\n//3. 设置instance指向刚分配的内存地址\nsingleton = memory;</code></pre>\n<p>操作2依赖于操作1，但操作3并不依赖于操作1，所以JVM是可以针对它们进行指令优化，优化后如下：</p>\n<pre><code class=\"java\">//1. 分配对象内存空间\nmemory = allocate();\n//3. 设置instance指向刚分配的内存地址\nsingleton = memory;\n//2. 初始化对象\nctorInstance(memory);</code></pre>\n<p>可以看到，指令重排之后，singleton指向分配好的内存放在前面，而这段内存的初始化被排在了后面。<br>线程A执行这段赋值语句，<strong>在初始化分配对象之前就已经将其赋值singleton引用</strong>，恰好<strong>线程B进入方法判断singleton的引用不为空</strong>，然后就将其返回使用，导致程序出错。<br>为了解决指令重排问题，可以使用<code>volatile</code>关键字修饰singleton字段，<strong>禁止指令的重排序优化</strong>。</p>\n<pre><code class=\"java\">class Singleton {\n    private static volatile Singleton singleton = null;\n\n    private Singleton();\n\n    public static Singleton getInstance() {\n        if (singleton = null) {\n            synchronized (Singleton.class) {\n                if (singleton = null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return signleton;\n    }\n}\n</code></pre>\n<hr>\n<h3 id=\"2-6-静态内部类\"><a href=\"#2-6-静态内部类\" class=\"headerlink\" title=\"2.6 静态内部类\"></a>2.6 静态内部类</h3><blockquote>\n<p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：一般      </p>\n</blockquote>\n<p>描述：当第<strong>一次访问类中的静态字段时，会触发类加载，并且保证同一个类只加载一次。</strong>静态内部类也是如此，<strong>类加载过程有类加载器负责加锁</strong>。这种写法相对于双重检验锁的写法，更加简单。对<strong>静态域使用延迟初始化，应使用这种方式而不是双检锁方式</strong>。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>\n<blockquote>\n<p>静态域：如果将域定义为static，每个类中只有一个这样的域，这个类的所有对象将共享这个域，这个域称为静态域。这个域属于类，而不属于任何独立的对象。</p>\n</blockquote>\n<pre><code class=\"java\">class Singleton {\n    //私有的静态内部类，类加载器负责加锁\n    private static class SingletonHolder {\n        private static Singleton singleton = new Singleton();\n    }\n\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        return Singleton.singleton;\n    }\n}\n</code></pre>\n<hr>\n<h3 id=\"2-6-枚举\"><a href=\"#2-6-枚举\" class=\"headerlink\" title=\"2.6 枚举\"></a>2.6 枚举</h3><blockquote>\n<p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易      </p>\n</blockquote>\n<p>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。<strong>它更简洁，自动支持序列化机制，绝对防止多次实例化</strong>。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。</p>\n<pre><code class=\"java\">public enum Singleton {\n    INSTANCE;\n\n    public void whateverMethod() {\n    }\n}</code></pre>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h3><ul>\n<li><a href=\"https://www.cnblogs.com/aeon/p/10212065.html\" target=\"_blank\" rel=\"noopener\">通过反射机制、序列化反序列化破解单例模式</a></li>\n<li><a href=\"https://www.runoob.com/design-pattern/singleton-pattern.html\" target=\"_blank\" rel=\"noopener\">单例模式|菜鸟教程</a></li>\n<li><a href=\"https://www.fangzhipeng.com/java/2019/09/01/sigton-design.html\" target=\"_blank\" rel=\"noopener\">方志朋-设计模式之单例模式</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/160842212\" target=\"_blank\" rel=\"noopener\">我给面试官讲解了单例模式后，他对我竖起了大拇指！</a></li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><div style=\"margin-left: 5px  font-size:16px;\">\n[1]黄文毅，Spring MVC + MyBatis快速开发与项目实战.北京：清华出版社，2019.<br>\n[2]<a href=\"https://www.runoob.com/design-pattern/singleton-pattern.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/design-pattern/singleton-pattern.html</a><br>\n[3]<a href=\"https://blog.csdn.net/u013894997/article/details/81111236\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013894997/article/details/81111236</a><br>\n</div>"},{"title":"模板模式","declare":true,"wordCount":true,"abbrlink":"64f4f5cc","date":"2020-08-25T02:27:10.000Z","_content":"**模板模式**\n\n在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。\n\n<!-- more-->\n\n## 介绍\n\n意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的**某些特定步骤**。\n\n主要解决：一些方法通用，却在每一个子类都重新写了这一方法。\n\n何时使用：有一些通用的方法。\n\n如何解决：**将这些通用算法抽象出来。**\n\n关键代码：在抽象类实现，其他步骤在子类实现。\n\n应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\n\n优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n\n缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n\n注意事项：为防止恶意操作，**一般模板方法都加上 final关键词。**\n实现\n\n## UML\n![模板模式uml](https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg)\n\n## 实例\n```java\npublic  class TemplatePatternDemo {\n    public static void main(String[] args) {\n        Cooking cooking = new CookFood();\n        cooking.cook();\n    }\n}\n\nabstract class Cooking{\n    protected abstract void step1();\n    protected abstract void step2();\n    public final void cook(){\n        System.out.println(\"做饭开始\");\n        step1();\n        step2();\n        System.out.println(\"做饭结束\");\n    }\n}\n\nclass CookFood extends Cooking{\n    @Override\n    protected void step1(){\n        System.out.println(\"放入食材\");\n    }\n\n    @Override\n    protected void step2(){\n        System.out.println(\"放入调料\");\n    }\n}\n```\n\n\n## 参考   \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/adapter-pattern.html\">https://www.runoob.com/design-pattern/adapter-pattern.html</a><br>\n[2]<a href=\"https://www.bilibili.com/video/BV1kk4y117j5\">五分钟学设计模式.13.模板方法模式</a><br>\n</div> ","source":"_posts/code/DesignMode/模板模式.md","raw":"---\ntitle: 模板模式\ncategories: Code\ntags: DesignMode\ndeclare: true\nwordCount: true\nabbrlink: 64f4f5cc\ndate: 2020-08-25 10:27:10\n---\n**模板模式**\n\n在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。\n\n<!-- more-->\n\n## 介绍\n\n意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的**某些特定步骤**。\n\n主要解决：一些方法通用，却在每一个子类都重新写了这一方法。\n\n何时使用：有一些通用的方法。\n\n如何解决：**将这些通用算法抽象出来。**\n\n关键代码：在抽象类实现，其他步骤在子类实现。\n\n应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\n\n优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n\n缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n\n注意事项：为防止恶意操作，**一般模板方法都加上 final关键词。**\n实现\n\n## UML\n![模板模式uml](https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg)\n\n## 实例\n```java\npublic  class TemplatePatternDemo {\n    public static void main(String[] args) {\n        Cooking cooking = new CookFood();\n        cooking.cook();\n    }\n}\n\nabstract class Cooking{\n    protected abstract void step1();\n    protected abstract void step2();\n    public final void cook(){\n        System.out.println(\"做饭开始\");\n        step1();\n        step2();\n        System.out.println(\"做饭结束\");\n    }\n}\n\nclass CookFood extends Cooking{\n    @Override\n    protected void step1(){\n        System.out.println(\"放入食材\");\n    }\n\n    @Override\n    protected void step2(){\n        System.out.println(\"放入调料\");\n    }\n}\n```\n\n\n## 参考   \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/adapter-pattern.html\">https://www.runoob.com/design-pattern/adapter-pattern.html</a><br>\n[2]<a href=\"https://www.bilibili.com/video/BV1kk4y117j5\">五分钟学设计模式.13.模板方法模式</a><br>\n</div> ","slug":"code/DesignMode/模板模式","published":1,"updated":"2020-10-06T17:12:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1g1003f0w7tcbym2oqt","content":"<p><strong>模板模式</strong></p>\n<p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的<strong>某些特定步骤</strong>。</p>\n<p>主要解决：一些方法通用，却在每一个子类都重新写了这一方法。</p>\n<p>何时使用：有一些通用的方法。</p>\n<p>如何解决：<strong>将这些通用算法抽象出来。</strong></p>\n<p>关键代码：在抽象类实现，其他步骤在子类实现。</p>\n<p>应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p>\n<p>优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p>\n<p>缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>\n<p>使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p>\n<p>注意事项：为防止恶意操作，<strong>一般模板方法都加上 final关键词。</strong><br>实现</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p><img src=\"https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg\" alt=\"模板模式uml\"></p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span>  <span class=\"token keyword\">class</span> <span class=\"token class-name\">TemplatePatternDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Cooking cooking <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CookFood</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cooking<span class=\"token punctuation\">.</span><span class=\"token function\">cook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Cooking</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">cook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"做饭开始\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"做饭结束\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CookFood</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Cooking</span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"放入食材\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"放入调料\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/adapter-pattern.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/design-pattern/adapter-pattern.html</a><br>\n[2]<a href=\"https://www.bilibili.com/video/BV1kk4y117j5\" target=\"_blank\" rel=\"noopener\">五分钟学设计模式.13.模板方法模式</a><br>\n</div> ","site":{"data":{}},"excerpt":"<p><strong>模板模式</strong></p>\n<p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的<strong>某些特定步骤</strong>。</p>\n<p>主要解决：一些方法通用，却在每一个子类都重新写了这一方法。</p>\n<p>何时使用：有一些通用的方法。</p>\n<p>如何解决：<strong>将这些通用算法抽象出来。</strong></p>\n<p>关键代码：在抽象类实现，其他步骤在子类实现。</p>\n<p>应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p>\n<p>优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p>\n<p>缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>\n<p>使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p>\n<p>注意事项：为防止恶意操作，<strong>一般模板方法都加上 final关键词。</strong><br>实现</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><p><img src=\"https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg\" alt=\"模板模式uml\"></p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><pre><code class=\"java\">public  class TemplatePatternDemo {\n    public static void main(String[] args) {\n        Cooking cooking = new CookFood();\n        cooking.cook();\n    }\n}\n\nabstract class Cooking{\n    protected abstract void step1();\n    protected abstract void step2();\n    public final void cook(){\n        System.out.println(&quot;做饭开始&quot;);\n        step1();\n        step2();\n        System.out.println(&quot;做饭结束&quot;);\n    }\n}\n\nclass CookFood extends Cooking{\n    @Override\n    protected void step1(){\n        System.out.println(&quot;放入食材&quot;);\n    }\n\n    @Override\n    protected void step2(){\n        System.out.println(&quot;放入调料&quot;);\n    }\n}</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><div style=\"margin-left: 5px  font-size:16px;\">\n[1]<a href=\"https://www.runoob.com/design-pattern/adapter-pattern.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/design-pattern/adapter-pattern.html</a><br>\n[2]<a href=\"https://www.bilibili.com/video/BV1kk4y117j5\" target=\"_blank\" rel=\"noopener\">五分钟学设计模式.13.模板方法模式</a><br>\n</div>"},{"title":"JVM学习笔记(一) ——Java虚拟机内存结构","declare":true,"wordCount":true,"abbrlink":"1862c94","date":"2020-05-17T13:53:10.000Z","_content":"\n\n## JAVA虚拟机内存结构\n* JAVA虚拟机内存结构可分为公有和私有两部分\n    * 公有： 堆、方法区、运行时常量池\n    * 私有： 程序计数器、JAVA虚拟机栈、本地方法栈\n\n<!-- more -->\n\n\n![JAVA虚拟机内存结构](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/timg.jpg)\n\n        \n \n\n### 1.1 程序计数器\n* 可以看**当前线程所执行字节码的行号指示器**\n    * 分支、循环、跳转、异常处理等基础功能都需要依赖计数器完成\n    * Java虚拟机的**多线程是通过线程轮流切换并分配执行时间的方式来实现的**，因此任何一个时刻，一个处理器（多核处理器的一个内核）都只会执行一条线程中的指令。因此，通过程序计数器可以做到线程切换后能够恢复到正确的执行位置。\n* 如果线程正在执行的是一个Java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，计数器则为空。\n* 程序计数器是JVM中唯一个没有OOM的区域\n\n### 1.2 JAVA虚拟机栈\n* **线程私有的，生命周期与线程相同。**\n* 虚拟机描述的是**Java方法执行的内存模型**：每个方法在执行的同时都会创建一个栈帧用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等。\n    > 局部变量表中存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型\n* 两种异常状况：\n    * StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度\n    * OutOfMemoryError: 如果可以扩展，但申请不到足够的内存\n\n### 1.3 本地方法栈\n* 与虚拟机栈十分相似、区别在于**虚拟机栈**为虚拟机执行**Java方法（字节码）服务**，而**本地方法栈**则为虚拟机使用到的**Native方法服务**。\n* 两种异常状况：\n    * StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度\n    * OutOfMemoryError: 如果可以扩展，但申请不到足够的内存\n\n### 1.4 JAVA堆\n* Java Heap是虚拟机所管理的内存中最大的一块，是**被所有线程所共享**的一块内存区域。\n* 此内存区域的唯一目的就是存放对象实例，**几乎**所有的对象实例都在这里分配。Java堆可以处于不连续的空间中，只要逻辑上相连即可\n    > 之所以说几乎是因为有特殊情况，有些时候小对象会直接在栈上进行分配，这种现象我们称之为「栈上分配」\n* Java堆是垃圾收集器管理的主要区域。从内存回收的角度，由于现在收集器基本都采用分代回收算法，所以Java队还可细分为：**新生代**和**老年代**： 再细致一点的有：**Eden空间**、**From Survivor空间**和**To Survivor**等。\n![Java Heap](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/java_heap.png)\n\n\n* 异常：\n    * OutOfMemoryError：堆中内存没有能力完成实例分配\n\n### 1.5 方法区\n* 各个**线程共享的内存区域**。用于存储**已被虚拟机加载的类信息、常量、静态变量**、即时**编译器编译后的代码等数据**。\n* Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以**选择不实现垃圾回收**，相对而言，垃圾回收行为在方法区**比较少见**，**但并非数据进入了方法区就如永久代的名字一样“永久”存在了**。这部分的垃圾回收主要针对常量池的回收和对类型的卸载。很多人更愿意把方法区称为“**永久代**”，但本质上两者并不等价，只是HotSpot虚拟机设计人员选择把GC分代收集扩展至方法区而已。\n* 异常：\n    * OutOfMemoryError：方法区无法满足内存分配需求\n\n### 1.6 运行时常量池\n* **方法区的一部分**，方法区中除了存放有**类的相关信息**，如**成员、方法或者接口等**，还有**各种字面量和符号引用**，这部分数据就存放在运行时常量池\n* 异常\n    * OutOfMemoryError：常量池无法满足内存分配需求\n\n### 1.7 直接内存\n* **并不是虚拟机运行时数据区的一部分，也是不虚拟机规范中定义的内存区域**，但这部分也被频繁使用，也可能会导致**OutOfMemoryError**异常出现。\n* 在JDK1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 \n    > 通信数据传输可以通过NIO实现的，NIO使用的就是直接内存——更为直观的说，就是JVM外的本地内存。\n* **直接内存不受Java堆大小的限制**，但是既然是内存，那么必然受系统内存的限制，除了JVM分配后的内存，以及其他进程使用的内存，剩下才能给直接内存使用。\n* 异常：\n    * OutOfMemoryError：直接内存无法申请到足够空间\n\n\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n## 推荐文章：\n> https://www.cnblogs.com/yuhuiqing/p/12066733.html\n\n\n\n\n\n\n\n### 参考    \n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社   \n[2]https://blog.csdn.net/o983950935/article/details/85849606    \n[3]https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html    \n\n\n","source":"_posts/code/JVM/JVM学习笔记(一) ——Java虚拟机内存结构.md","raw":"---\ntitle: JVM学习笔记(一) ——Java虚拟机内存结构\ncategories: Code\ntags: JVM\ndeclare: true\nwordCount: true\nabbrlink: 1862c94\ndate: 2020-05-17 21:53:10\n---\n\n\n## JAVA虚拟机内存结构\n* JAVA虚拟机内存结构可分为公有和私有两部分\n    * 公有： 堆、方法区、运行时常量池\n    * 私有： 程序计数器、JAVA虚拟机栈、本地方法栈\n\n<!-- more -->\n\n\n![JAVA虚拟机内存结构](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/timg.jpg)\n\n        \n \n\n### 1.1 程序计数器\n* 可以看**当前线程所执行字节码的行号指示器**\n    * 分支、循环、跳转、异常处理等基础功能都需要依赖计数器完成\n    * Java虚拟机的**多线程是通过线程轮流切换并分配执行时间的方式来实现的**，因此任何一个时刻，一个处理器（多核处理器的一个内核）都只会执行一条线程中的指令。因此，通过程序计数器可以做到线程切换后能够恢复到正确的执行位置。\n* 如果线程正在执行的是一个Java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，计数器则为空。\n* 程序计数器是JVM中唯一个没有OOM的区域\n\n### 1.2 JAVA虚拟机栈\n* **线程私有的，生命周期与线程相同。**\n* 虚拟机描述的是**Java方法执行的内存模型**：每个方法在执行的同时都会创建一个栈帧用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等。\n    > 局部变量表中存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型\n* 两种异常状况：\n    * StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度\n    * OutOfMemoryError: 如果可以扩展，但申请不到足够的内存\n\n### 1.3 本地方法栈\n* 与虚拟机栈十分相似、区别在于**虚拟机栈**为虚拟机执行**Java方法（字节码）服务**，而**本地方法栈**则为虚拟机使用到的**Native方法服务**。\n* 两种异常状况：\n    * StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度\n    * OutOfMemoryError: 如果可以扩展，但申请不到足够的内存\n\n### 1.4 JAVA堆\n* Java Heap是虚拟机所管理的内存中最大的一块，是**被所有线程所共享**的一块内存区域。\n* 此内存区域的唯一目的就是存放对象实例，**几乎**所有的对象实例都在这里分配。Java堆可以处于不连续的空间中，只要逻辑上相连即可\n    > 之所以说几乎是因为有特殊情况，有些时候小对象会直接在栈上进行分配，这种现象我们称之为「栈上分配」\n* Java堆是垃圾收集器管理的主要区域。从内存回收的角度，由于现在收集器基本都采用分代回收算法，所以Java队还可细分为：**新生代**和**老年代**： 再细致一点的有：**Eden空间**、**From Survivor空间**和**To Survivor**等。\n![Java Heap](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/java_heap.png)\n\n\n* 异常：\n    * OutOfMemoryError：堆中内存没有能力完成实例分配\n\n### 1.5 方法区\n* 各个**线程共享的内存区域**。用于存储**已被虚拟机加载的类信息、常量、静态变量**、即时**编译器编译后的代码等数据**。\n* Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以**选择不实现垃圾回收**，相对而言，垃圾回收行为在方法区**比较少见**，**但并非数据进入了方法区就如永久代的名字一样“永久”存在了**。这部分的垃圾回收主要针对常量池的回收和对类型的卸载。很多人更愿意把方法区称为“**永久代**”，但本质上两者并不等价，只是HotSpot虚拟机设计人员选择把GC分代收集扩展至方法区而已。\n* 异常：\n    * OutOfMemoryError：方法区无法满足内存分配需求\n\n### 1.6 运行时常量池\n* **方法区的一部分**，方法区中除了存放有**类的相关信息**，如**成员、方法或者接口等**，还有**各种字面量和符号引用**，这部分数据就存放在运行时常量池\n* 异常\n    * OutOfMemoryError：常量池无法满足内存分配需求\n\n### 1.7 直接内存\n* **并不是虚拟机运行时数据区的一部分，也是不虚拟机规范中定义的内存区域**，但这部分也被频繁使用，也可能会导致**OutOfMemoryError**异常出现。\n* 在JDK1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 \n    > 通信数据传输可以通过NIO实现的，NIO使用的就是直接内存——更为直观的说，就是JVM外的本地内存。\n* **直接内存不受Java堆大小的限制**，但是既然是内存，那么必然受系统内存的限制，除了JVM分配后的内存，以及其他进程使用的内存，剩下才能给直接内存使用。\n* 异常：\n    * OutOfMemoryError：直接内存无法申请到足够空间\n\n\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n## 推荐文章：\n> https://www.cnblogs.com/yuhuiqing/p/12066733.html\n\n\n\n\n\n\n\n### 参考    \n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社   \n[2]https://blog.csdn.net/o983950935/article/details/85849606    \n[3]https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html    \n\n\n","slug":"code/JVM/JVM学习笔记(一) ——Java虚拟机内存结构","published":1,"updated":"2020-07-22T11:11:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1g2003h0w7tfi132ozf","content":"<h2 id=\"JAVA虚拟机内存结构\"><a href=\"#JAVA虚拟机内存结构\" class=\"headerlink\" title=\"JAVA虚拟机内存结构\"></a>JAVA虚拟机内存结构</h2><ul>\n<li>JAVA虚拟机内存结构可分为公有和私有两部分<ul>\n<li>公有： 堆、方法区、运行时常量池</li>\n<li>私有： 程序计数器、JAVA虚拟机栈、本地方法栈</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/timg.jpg\" alt=\"JAVA虚拟机内存结构\"></p>\n<h3 id=\"1-1-程序计数器\"><a href=\"#1-1-程序计数器\" class=\"headerlink\" title=\"1.1 程序计数器\"></a>1.1 程序计数器</h3><ul>\n<li>可以看<strong>当前线程所执行字节码的行号指示器</strong><ul>\n<li>分支、循环、跳转、异常处理等基础功能都需要依赖计数器完成</li>\n<li>Java虚拟机的<strong>多线程是通过线程轮流切换并分配执行时间的方式来实现的</strong>，因此任何一个时刻，一个处理器（多核处理器的一个内核）都只会执行一条线程中的指令。因此，通过程序计数器可以做到线程切换后能够恢复到正确的执行位置。</li>\n</ul>\n</li>\n<li>如果线程正在执行的是一个Java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，计数器则为空。</li>\n<li>程序计数器是JVM中唯一个没有OOM的区域</li>\n</ul>\n<h3 id=\"1-2-JAVA虚拟机栈\"><a href=\"#1-2-JAVA虚拟机栈\" class=\"headerlink\" title=\"1.2 JAVA虚拟机栈\"></a>1.2 JAVA虚拟机栈</h3><ul>\n<li><strong>线程私有的，生命周期与线程相同。</strong></li>\n<li>虚拟机描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行的同时都会创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等。<blockquote>\n<p>局部变量表中存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型</p>\n</blockquote>\n</li>\n<li>两种异常状况：<ul>\n<li>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度</li>\n<li>OutOfMemoryError: 如果可以扩展，但申请不到足够的内存</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-本地方法栈\"><a href=\"#1-3-本地方法栈\" class=\"headerlink\" title=\"1.3 本地方法栈\"></a>1.3 本地方法栈</h3><ul>\n<li>与虚拟机栈十分相似、区别在于<strong>虚拟机栈</strong>为虚拟机执行<strong>Java方法（字节码）服务</strong>，而<strong>本地方法栈</strong>则为虚拟机使用到的<strong>Native方法服务</strong>。</li>\n<li>两种异常状况：<ul>\n<li>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度</li>\n<li>OutOfMemoryError: 如果可以扩展，但申请不到足够的内存</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-4-JAVA堆\"><a href=\"#1-4-JAVA堆\" class=\"headerlink\" title=\"1.4 JAVA堆\"></a>1.4 JAVA堆</h3><ul>\n<li>Java Heap是虚拟机所管理的内存中最大的一块，是<strong>被所有线程所共享</strong>的一块内存区域。</li>\n<li>此内存区域的唯一目的就是存放对象实例，<strong>几乎</strong>所有的对象实例都在这里分配。Java堆可以处于不连续的空间中，只要逻辑上相连即可<blockquote>\n<p>之所以说几乎是因为有特殊情况，有些时候小对象会直接在栈上进行分配，这种现象我们称之为「栈上分配」</p>\n</blockquote>\n</li>\n<li>Java堆是垃圾收集器管理的主要区域。从内存回收的角度，由于现在收集器基本都采用分代回收算法，所以Java队还可细分为：<strong>新生代</strong>和<strong>老年代</strong>： 再细致一点的有：<strong>Eden空间</strong>、<strong>From Survivor空间</strong>和<strong>To Survivor</strong>等。<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/java_heap.png\" alt=\"Java Heap\"></li>\n</ul>\n<ul>\n<li>异常：<ul>\n<li>OutOfMemoryError：堆中内存没有能力完成实例分配</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-5-方法区\"><a href=\"#1-5-方法区\" class=\"headerlink\" title=\"1.5 方法区\"></a>1.5 方法区</h3><ul>\n<li>各个<strong>线程共享的内存区域</strong>。用于存储<strong>已被虚拟机加载的类信息、常量、静态变量</strong>、即时<strong>编译器编译后的代码等数据</strong>。</li>\n<li>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以<strong>选择不实现垃圾回收</strong>，相对而言，垃圾回收行为在方法区<strong>比较少见</strong>，<strong>但并非数据进入了方法区就如永久代的名字一样“永久”存在了</strong>。这部分的垃圾回收主要针对常量池的回收和对类型的卸载。很多人更愿意把方法区称为“<strong>永久代</strong>”，但本质上两者并不等价，只是HotSpot虚拟机设计人员选择把GC分代收集扩展至方法区而已。</li>\n<li>异常：<ul>\n<li>OutOfMemoryError：方法区无法满足内存分配需求</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-6-运行时常量池\"><a href=\"#1-6-运行时常量池\" class=\"headerlink\" title=\"1.6 运行时常量池\"></a>1.6 运行时常量池</h3><ul>\n<li><strong>方法区的一部分</strong>，方法区中除了存放有<strong>类的相关信息</strong>，如<strong>成员、方法或者接口等</strong>，还有<strong>各种字面量和符号引用</strong>，这部分数据就存放在运行时常量池</li>\n<li>异常<ul>\n<li>OutOfMemoryError：常量池无法满足内存分配需求</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-7-直接内存\"><a href=\"#1-7-直接内存\" class=\"headerlink\" title=\"1.7 直接内存\"></a>1.7 直接内存</h3><ul>\n<li><strong>并不是虚拟机运行时数据区的一部分，也是不虚拟机规范中定义的内存区域</strong>，但这部分也被频繁使用，也可能会导致<strong>OutOfMemoryError</strong>异常出现。</li>\n<li>在JDK1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 <blockquote>\n<p>通信数据传输可以通过NIO实现的，NIO使用的就是直接内存——更为直观的说，就是JVM外的本地内存。</p>\n</blockquote>\n</li>\n<li><strong>直接内存不受Java堆大小的限制</strong>，但是既然是内存，那么必然受系统内存的限制，除了JVM分配后的内存，以及其他进程使用的内存，剩下才能给直接内存使用。</li>\n<li>异常：<ul>\n<li>OutOfMemoryError：直接内存无法申请到足够空间</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n<h2 id=\"推荐文章：\"><a href=\"#推荐文章：\" class=\"headerlink\" title=\"推荐文章：\"></a>推荐文章：</h2><blockquote>\n<p><a href=\"https://www.cnblogs.com/yuhuiqing/p/12066733.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yuhuiqing/p/12066733.html</a></p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br>[2]<a href=\"https://blog.csdn.net/o983950935/article/details/85849606\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/o983950935/article/details/85849606</a><br>[3]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html</a>    </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"JAVA虚拟机内存结构\"><a href=\"#JAVA虚拟机内存结构\" class=\"headerlink\" title=\"JAVA虚拟机内存结构\"></a>JAVA虚拟机内存结构</h2><ul>\n<li>JAVA虚拟机内存结构可分为公有和私有两部分<ul>\n<li>公有： 堆、方法区、运行时常量池</li>\n<li>私有： 程序计数器、JAVA虚拟机栈、本地方法栈</li>\n</ul>\n</li>\n</ul>","more":"<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/timg.jpg\" alt=\"JAVA虚拟机内存结构\"></p>\n<h3 id=\"1-1-程序计数器\"><a href=\"#1-1-程序计数器\" class=\"headerlink\" title=\"1.1 程序计数器\"></a>1.1 程序计数器</h3><ul>\n<li>可以看<strong>当前线程所执行字节码的行号指示器</strong><ul>\n<li>分支、循环、跳转、异常处理等基础功能都需要依赖计数器完成</li>\n<li>Java虚拟机的<strong>多线程是通过线程轮流切换并分配执行时间的方式来实现的</strong>，因此任何一个时刻，一个处理器（多核处理器的一个内核）都只会执行一条线程中的指令。因此，通过程序计数器可以做到线程切换后能够恢复到正确的执行位置。</li>\n</ul>\n</li>\n<li>如果线程正在执行的是一个Java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，计数器则为空。</li>\n<li>程序计数器是JVM中唯一个没有OOM的区域</li>\n</ul>\n<h3 id=\"1-2-JAVA虚拟机栈\"><a href=\"#1-2-JAVA虚拟机栈\" class=\"headerlink\" title=\"1.2 JAVA虚拟机栈\"></a>1.2 JAVA虚拟机栈</h3><ul>\n<li><strong>线程私有的，生命周期与线程相同。</strong></li>\n<li>虚拟机描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行的同时都会创建一个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等。<blockquote>\n<p>局部变量表中存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型</p>\n</blockquote>\n</li>\n<li>两种异常状况：<ul>\n<li>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度</li>\n<li>OutOfMemoryError: 如果可以扩展，但申请不到足够的内存</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-本地方法栈\"><a href=\"#1-3-本地方法栈\" class=\"headerlink\" title=\"1.3 本地方法栈\"></a>1.3 本地方法栈</h3><ul>\n<li>与虚拟机栈十分相似、区别在于<strong>虚拟机栈</strong>为虚拟机执行<strong>Java方法（字节码）服务</strong>，而<strong>本地方法栈</strong>则为虚拟机使用到的<strong>Native方法服务</strong>。</li>\n<li>两种异常状况：<ul>\n<li>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度</li>\n<li>OutOfMemoryError: 如果可以扩展，但申请不到足够的内存</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-4-JAVA堆\"><a href=\"#1-4-JAVA堆\" class=\"headerlink\" title=\"1.4 JAVA堆\"></a>1.4 JAVA堆</h3><ul>\n<li>Java Heap是虚拟机所管理的内存中最大的一块，是<strong>被所有线程所共享</strong>的一块内存区域。</li>\n<li>此内存区域的唯一目的就是存放对象实例，<strong>几乎</strong>所有的对象实例都在这里分配。Java堆可以处于不连续的空间中，只要逻辑上相连即可<blockquote>\n<p>之所以说几乎是因为有特殊情况，有些时候小对象会直接在栈上进行分配，这种现象我们称之为「栈上分配」</p>\n</blockquote>\n</li>\n<li>Java堆是垃圾收集器管理的主要区域。从内存回收的角度，由于现在收集器基本都采用分代回收算法，所以Java队还可细分为：<strong>新生代</strong>和<strong>老年代</strong>： 再细致一点的有：<strong>Eden空间</strong>、<strong>From Survivor空间</strong>和<strong>To Survivor</strong>等。<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/java_heap.png\" alt=\"Java Heap\"></li>\n</ul>\n<ul>\n<li>异常：<ul>\n<li>OutOfMemoryError：堆中内存没有能力完成实例分配</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-5-方法区\"><a href=\"#1-5-方法区\" class=\"headerlink\" title=\"1.5 方法区\"></a>1.5 方法区</h3><ul>\n<li>各个<strong>线程共享的内存区域</strong>。用于存储<strong>已被虚拟机加载的类信息、常量、静态变量</strong>、即时<strong>编译器编译后的代码等数据</strong>。</li>\n<li>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以<strong>选择不实现垃圾回收</strong>，相对而言，垃圾回收行为在方法区<strong>比较少见</strong>，<strong>但并非数据进入了方法区就如永久代的名字一样“永久”存在了</strong>。这部分的垃圾回收主要针对常量池的回收和对类型的卸载。很多人更愿意把方法区称为“<strong>永久代</strong>”，但本质上两者并不等价，只是HotSpot虚拟机设计人员选择把GC分代收集扩展至方法区而已。</li>\n<li>异常：<ul>\n<li>OutOfMemoryError：方法区无法满足内存分配需求</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-6-运行时常量池\"><a href=\"#1-6-运行时常量池\" class=\"headerlink\" title=\"1.6 运行时常量池\"></a>1.6 运行时常量池</h3><ul>\n<li><strong>方法区的一部分</strong>，方法区中除了存放有<strong>类的相关信息</strong>，如<strong>成员、方法或者接口等</strong>，还有<strong>各种字面量和符号引用</strong>，这部分数据就存放在运行时常量池</li>\n<li>异常<ul>\n<li>OutOfMemoryError：常量池无法满足内存分配需求</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-7-直接内存\"><a href=\"#1-7-直接内存\" class=\"headerlink\" title=\"1.7 直接内存\"></a>1.7 直接内存</h3><ul>\n<li><strong>并不是虚拟机运行时数据区的一部分，也是不虚拟机规范中定义的内存区域</strong>，但这部分也被频繁使用，也可能会导致<strong>OutOfMemoryError</strong>异常出现。</li>\n<li>在JDK1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 <blockquote>\n<p>通信数据传输可以通过NIO实现的，NIO使用的就是直接内存——更为直观的说，就是JVM外的本地内存。</p>\n</blockquote>\n</li>\n<li><strong>直接内存不受Java堆大小的限制</strong>，但是既然是内存，那么必然受系统内存的限制，除了JVM分配后的内存，以及其他进程使用的内存，剩下才能给直接内存使用。</li>\n<li>异常：<ul>\n<li>OutOfMemoryError：直接内存无法申请到足够空间</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n<h2 id=\"推荐文章：\"><a href=\"#推荐文章：\" class=\"headerlink\" title=\"推荐文章：\"></a>推荐文章：</h2><blockquote>\n<p><a href=\"https://www.cnblogs.com/yuhuiqing/p/12066733.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yuhuiqing/p/12066733.html</a></p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br>[2]<a href=\"https://blog.csdn.net/o983950935/article/details/85849606\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/o983950935/article/details/85849606</a><br>[3]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html</a>    </p>"},{"title":"JVM学习笔记(二)——垃圾收集器和内存分配策略","declare":true,"wordCount":true,"abbrlink":"1e17e950","date":"2020-07-02T05:40:10.000Z","_content":"\n\nJava与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外的人想进去，墙内的人却想出去。\n![垃圾收集器和内存分配策略](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200702132536.png)\n<!-- more -->\n\n对于Java内存运行时区域的各个部分，其中**程序计数器、虚拟机栈、本地方法栈**3个区域的内存随线程而生，随线程而灭。所以方法或者线程结束的时候，内存就自然的随着回收了。而**Java堆和方法区的内存**则不一样，这些部分的内存是需要动态分配的。\n>栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈的操作。每一个线栈中分配多少内存基本上是在类结构确定下来时就已知的。\n\n>Java堆和方法区中，一个接口的多个实现类、一个方法中的多个分支也可能不一样，我们只有在程序处于运行期间才知道会创建那些对象。\n\n\n## 一、如何判断对象已死\n### 1.1 引用计数法\n在一个对象被引用时加一，被去除引用时减一，这样我们就可以通过**判断引用计数是否为零**来判断一个对象是垃圾。\n\n优点是实现简单，判定效率也很高，但很少被使用，因为存在着一个很致命的问题，即**循环引用问题**。\n>A引用了B，B引用了C，C引用了A，它们各自的引用计数都为 1。但是**它们三个对象却从未被其他对象引用，只有它们自身互相引用**。从垃圾的判断思想来看，它们三个确实是不被其他对象引用的，但是此时它们的引用计数却不为零。这就是引用计数法存在的循环引用问题。\n\n<br>\n\n***\n\n<br>\n\n### 1.2 可达性分析算法（GC Root Tracing）\n**从GC Root出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾**。\n\n* GC Root:      \n    * 虚拟机栈中（栈帧中的本地变量表）中引用的对象\n    * 方法区中静态属性引用的对象\n    * 方法区中常量引用的对象\n\n简单地说，GC Root就是**经过精心挑选的一组活跃引用**，这些引用是肯定存活的。那么通过这些引用延伸到的对象，自然也是存活的。\n\n此时需要注意的是，**即使是在可达性分析算法中不可达的对象，也并非是“非死不可”**，此时它们处于“缓刑”阶段，然后需要至少经历两次标记过程：\n1. 此对象是否有必要执行`finalize()`方法，如果有必要则进入下一阶段。\n    >当对象没有覆盖`finalize()`方法或者此方法已经被虚拟机调用过，则会被视为没必要执行。如果有必要执行，则会被放置在`F-QueueL`的一个队列中，并由一个低优先级的`Finalizer`线程去执行它\n2. 对`F-QueueL`中的对象进行二次标记，如果对象在`finalize()`中成功拯救自己，则会被移出“即将回收”的集合。\n    >`finalize()`:只要重新与引用链上任意一个对象建立关联即可\n\n再谈引用：    \n* 强引用：在程序代码之中普遍存在的，类似`Object c=new Object()`\n* 软引用：**有用但并非有必需的对象**，对于这一类对象，在系统将要发生内存溢出的之前，将会把这些对象列进回收范围之中进行第二次回收\n* 弱引用：**非必需对象**，**只能生存到下一次垃圾收集之前**\n* 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例，一个对象设置虚引用的唯一目的就是**能在这个对象被收集器回收时收到一个系统通知**，JDK1.2以后通过`PhantomReference`类来实现虚引用\n\n<br>\n\n***\n\n<br>\n\n### 1.3 方法区的回收\n虽然Java虚拟机规范中确实说过**可以不要求**虚拟机在方法区实现垃圾收集，但**方法区并不是没有垃圾回收**\n\n<br>\n\n方法区（永久代）的垃圾回收主要是两部分的内容：\n>**仅仅是“可以”**,并不是像对象一样，不使用了就必然会被回收\n* 废弃常量\n    >例如一个字符串“abc\"已经进入了常量池，但当前系统并没有任何一个String对象的值引用常量池中的“abc”变量的\n* 无用的类\n    >该类的所有实例都已经被回收<br>\n    >加载该类的ClassLoader已经被回收<br>\n    >该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。(以上三点需同时满足)\n\n<br><br>\n\n***\n\n<br><br>\n\n## 二、垃圾回收算法\n\n### 2.1 标记-清除算法\n算法分为两个部分：\n* 标记：首先标记出所有需要回收的对象\n* 清除：在标记完成后统一回收所有被标记的对象\n\n\n不足：\n* 效率问题\n>标记和清除的效率都很低\n* 空间问题\n>标记清除之后会产生大量不连续的内存碎片，导致以后分配较大的对象时，找不到足够多的连续内存而不得不触发一次GC\n\n<br>\n\n***\n\n<br>\n\n### 2.2 复制算法\n将原有的内存空间分为两块，每次只使用一块，**在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收**。\n\n\n不足：\n* 要将内存空间折半，极大地浪费了内存空间。\n\n改进：     \n* IBM公司的专门研究表明，新生代的98%对象都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，**每次使用Eden和其中一块Survivor。当回收时，将Eden空间和Survivor中还活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚刚用过的那一个Survivor。**\n* HotSpot虚拟机默认的Eden和Survivor的大小比例是8:1:1，如果Survivor空间不够用时，则需要依赖其他内存空间进行**担保**（直接进入老年代）\n\n<br>\n\n***\n\n<br>\n\n### 2.3 标记整理算法\n可以理解是标记清除算法的优化版，其同样需要经历两个阶段：\n* 标记结算\n>从 GC Root 引用集合触发去标记所有对象\n* 整理阶段\n>让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存\n\n<br><br>\n\n***\n\n<br><br>\n\n## 三、分代思想\n如果我们单独采用任何一种算法，那么最终的垃圾回收效率都不会很好。因此在实际的垃圾回收算法中采用了分代算法。即根据对象存活周期的不同将内存划分为几块。一般是将堆划分为**新生代**和**老年代**，这样就可以根据各个年代的特点采用不同的垃圾回收算法。\n\n例如对于**存活对象少的新生代区域，比较适合采用复制算法。这样只需要复制少量对象，便可完成垃圾回收，并且还不会有内存碎片。而对于老年代这种存活对象多的区域，比较适合采用标记压缩算法或标记清除算法，这样不需要移动太多的内存对象。**\n\n\nHotSpot的算法实现\n### 枚举根节点\n可达性分析从GC Roots结点找引用链，但可作为结点的全局性引用和执行上下文的数据可能会过于庞大，因此如果要逐个检查里面的应用，那么必然会消耗非常多的资源。此外可达性分析对于时间的敏感性还体现在GC停顿上，**不可以出现分析对象引用关系的过程时其还在不断变化**,因此GC进行时必须停顿所有Java执行线程（**“Stop The World”**）。\n\n目前主流的Java虚拟机使用的都是准确式GC:\n\n所以当执行系统停顿下来时，**并不需要逐个检查所有全局性引用和执行上下文**。HotSpot使用一组称为**OopMap的数据结构**来达到这个目的。\n>在类加载完成的时候，HotSpot就把对象内什么偏移量什么偏移量是什么类型的数据计算出来，在JIT编译的过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样在GC扫描时，就可以直接得到这些信息了。\n\n***\n\n### 安全点\n在OopMap的帮助下，HotSop可以很快的完成GC Roots枚举，但是如果为每一条指令都生成对于的OopMap，那么会使得GC的空间成本很高。\n\n所以程序**只是在特点的位置（安全点）停下来开始GC**\n>安全点的选择不能选得太少让GC等待时间过长，也不能选得太多让程序长时间执行。所以选择的地方的特征是**指令序列复用**，例如方法调用、循环跳转、异常跳转等。\n\n\n如何在GC发生是让所有线程都\"跑\"到最近的安全点？\n\n1. 抢先式中断\n>不需要线程的执行代码主动去配合，首先把所有线程中断，然后让没有到安全点的线程，跑到安全点上\n2. 主动式中断\n>不直接对线程操作，仅仅简单地设置一个标志，各个线程执行是主动轮询这个标志\n\n***\n\n###  安全区域\n如果在程序线程处于Sleep状态或者Blocked状态时，线程无法响应JVM中断请求，走到安全点去挂起。对于这种情况就需要安全区域来解决\n\n即安全区域是指在一段代码之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的，我们也可以把安全区看做是被扩展了的安全点。\n\n\n\n<br><br>\n\n***\n\n<br><br>\n\n## 四、分区思想\n分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代），但 JVM 中其实还有一个分区思想，即将**整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收**，这种算法的好处是可以控制一次回收多少个区间，可以较好地控制 GC 时间。\n\n<br><br>\n\n***\n\n<br><br>\n\n## 五、垃圾回收器\n\n### 5.1 串形(Serial)回收器\n串行回收器是指使用**单线程**进行垃圾回收的回收器。因为每次回收时只有一个线程，因此串行回收器**在并发能力较弱的计算机上，其专注性和独占性的特点往往能让其有更好的性能表现。**\n\n串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收器和老年代串行回收器。\n\n#### 5.1.1 新生代串行回收器\n在新生代串行回收器中使用的是**复制算法**。在串行回收器进行垃圾回收时，会触发`Stop-The-World`现象，即其他线程都需要暂停，等待垃圾回收完成。因此在某些情况下，其会造成较为糟糕的用户体验。\n\n***\n\n#### 5.1.2 老年代串行回收器\n在老年代串行回收器中使用的是**标记整理算法**。其与新生代串行收集器一样，只能串行、独占式地进行垃圾回收，因此也经常会有较长时间的 Stop-The-World 发生。\n\n但老年代串行回收器的好处之一，就是其**可以与多种新生代回收器配合使用**。\n\n<br>\n\n***\n\n<br>\n\n### 5.2 并行回收器\n\n#### 5.2.1 新生代ParNew回收器\n**串行回收器的多线程版本**，其回收策略、算法以及参数和新生代串行回收器一样。\n\n新生代 ParNew 回收器同样使用复制算法的垃圾回收算法，其垃圾收集过程中同样会触发`Stop-The-World`现象。但因为其使用多线程进行垃圾回收，因此**在并发能力强的CPU上，其产生的停顿时间要短于串行回收器**。\n\n但在**单CPU或并能能力弱**的系统中，并行回收器效果会因为线程切换的原因，其实际表现**反而不如串行回收器**。\n\n***\n\n#### 5.2.2 新生代Parallel GC回收器\n新生代 Parallel GC 回收器与新生代 ParNew 回收器非常类似，其也是**使用复制算法，都是多线程、独占式的收集器，也会导致 Stop-The-World**。但其余 ParNew 回收器的一个重大不同是：其**非常注重系统的吞吐量**\n\n之所以说新生代 Parallel GC 回收器非常注重系统吞吐量，是因为其有一个自适应GC调节策略\n\n***\n\n#### 5.2.3 老年代 ParallelOldGC 回收器\n老年代 ParallelOldGC 回收器也是一种多线程并发的回收器，与新生代ParallelGC收集器一样，其**也是注重吞吐量的收集器，只不过其是作用于老年代**。\n\nParallelOldGC回收器使用的是**标记整理算法**，只有在 JDK1.6中才可以使用。\n\n<br>\n\n***\n\n<br>\n\n### 5.3 CMS回收器\nCMS 回收器**主要关注系统停顿时间**。CMS回收器全称为 Concurrent Mark Sweep，意为**标记清除**算法，其是一个使用**多线程并行回收**的垃圾回收器。\n\nCMS 的主要工作步骤有：\n1. 初始标记\n2. 并发标记\n3. 重新标记\n>为了修正标记期间因程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记阶段时间较长，但远小于并发标记\n4. 并发清除\n>耗时最长的并发标记和并发清除线程都可以与用户线程并发执行\n\n\n优点：\n* 并发收集低停顿\n\n\n缺点:\n* 对CPU资源非常敏感\n* 无法处理浮动资源\n>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，只能等待下一次GC,这些垃圾就被称为浮动垃圾\n* 会出现空间碎片\n>基于标记-清理算法\n\n<br><br><br>\n\n***\n\n<br><br><br>\n\n### 5.4 G1收集器\nG1 回收器是 JDK 1.7 中使用的全新垃圾回收器，从长期目标来看，其是为了取代 CMS 回收器。\n\nG1 回收器拥有独特的垃圾回收策略，和之前所有垃圾回收器采用的垃圾回收策略不同。从分代看，G1 依然属于分代垃圾回收器。但它**最大的改变是使用了分区算法**，从而**使得 Eden 区、From 区、Survivor 区和老年代等各块内存不必连续**。\n\n工作过程：\n1. 初始标记\n>耗时较短，仅仅标记一下GC Roots能够直接关联到的对象\n2. 并发标记\n>耗时较长，进行可达性分析，找出存活的对象\n3. 最终标记\n>修正在并发标记过程中因用户程序继续运行而导致的标记变动的那一部分\n4. 筛选回收\n>首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划\n\n\n\n特点：\n* 并行和并发\n* 分代收集\n* 空间整合\n>基于**标记-整理**算法\n* 可预测的停顿\n>通过建立一个可预测的停顿时间模型，使得消耗在垃圾收集上的时间不得超过可预测的时间。之所以能够建立一个可预测的停顿时间模型，是因为它在后台维护了一个优先列表，每次优先收集价值最大的Region，有效地提高收集效率。\n\n\n<br><br>\n\n***\n\n<br><br>\n\n## 六、内存分配和回收策略\nJava对象的内存分配，大方向来讲，就是在堆上分配（但也有可能经过JIT编译后被拆散为标量类型并间接地在栈上分配)\n\n对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按照线程优先在TLAB上分配，少数情况下也会直接在老年代中分配，分配规则并不是固定不变的，其细节取决于使用的哪一种垃圾回收器组合以及虚拟机的相关参数设置。\n\n以下是几条最普遍的内存分配规则：\n\n### 6.1 对象优先在Eden分配\n大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC\n\n***\n\n### 6.2 大对象直接进入老年代\n大对象是指需要大量连续内存空间的Java对象，最典型的就是那种很长的字符串或者数组\n\n***\n\n### 6.3 长期存活的对象将进入老年代\n虚拟机给每个对象定义了一个对象年龄计数器。**如果对象在Eden出生并经过一此Minor GC后仍然存错，并且被Survivor容纳的话，就将对象年龄设为1，此后每经历过一此Minor GC,对象年龄就加1，当年龄增加到一定程度时（默认为15）,就晋升到老年代**。\n\n***\n\n### 6.4 动态对象年龄判定\n虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，**如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代**。\n\n***\n\n### 6.5 空间担保分配\n**虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间**，如果这个条件成立，那么可以确认Minor GC是安全的。如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败？如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试进行一次Minor GC,尽管这次是有风险的。如果小于或者HandlePromotionFailure设置不允许冒险，那这是也要改为进行一次Full GC。\n\n什么是冒险？前面提到过新生代使用复制收集算法，但为了提升内存利用率。只使用其中一个survivor空间作为备份。因此当出现大量对象在Minor GC后仍然存活的情况。就需要老年代进行分担,把survivor无法容纳的对象直接进入老年代。前提是老年代本身还有容纳这些对象的剩余空间。**有多少对象会活下来，在实际完成内存回收之前是无法明确知道。所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值与剩余老年代的剩余空间进行比较。**决定是否进行一次Full GC让老年代腾出更多空间。\n\n如果担保失败的话，就只好在担保失败后重新发起一次Full GC.\n\n\n## 七、垃圾回收的几种类型\n\n### 7.1 Minor GC\n**新生代空间回收内存被称为 Minor GC**，有时候也称之为 Young GC。对于 Minor GC，你需要知道的一些点：\n\n* JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以 Eden 区越小，越频繁执行 Minor GC。\n\n* 当年轻代中的 Eden 区分配满的时候，年轻代中的部分对象会晋升到老年代，所以 Minor GC 后老年代的占用量通常会有所升高。\n\n* 质疑常规的认知，所有的 Minor GC 都会触发 Stop-The-World，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的，因为大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果情况相反，即 Eden 区大部分新生对象不符合 GC 条件（即他们不被垃圾回收器收集），那么 Minor GC 执行时暂停的时间将会长很多（因为他们要JVM要将他们复制到 Survivor 区或老年代）。\n\n***\n\n### 7.2 Major GC\n**从老年代空间回收内存被称为 Major GC**，有时候也称之为 Old GC。\n\n**许多 Major GC 是由 Minor GC 触发的**，所以很多情况下将这两种 GC 分离是不太可能的。\n>Minor GC 作用于新生代，Major GC 作用于老年代。 分配对象内存时发现内存不够，触发 Minor GC。Minor GC 会将对象移到老年代中，如果此时老年代空间不够，那么触发 Major GC。因此才会说，许多 Major GC 是由 Minor GC 引起的。\n\n***\n\n### 7.3 Full GC\n\n**Full GC 是清理整个堆空间 —— 包括年轻代、老年代和永久代（如果有的话）**。因此 Full GC 可以说是 Minor GC 和 Major GC 的结合。\n>当准备要触发一次 Minor GC 时，如果发现年轻代的剩余空间比以往晋升的空间小，则不会触发 Minor GC 而是转为触发 Full GC。因为JVM此时认为：之前这么大空间的时候已经发生对象晋升了，那现在剩余空间更小了，那么很大概率上也会发生对象晋升。既然如此，那么我就直接帮你把事情给做了吧，直接来一次 Full GC，整理一下老年代和年轻代的空间。\n\n>另外，即在永久代分配空间但已经没有足够空间时，也会触发 Full GC。\n\n\n### 7.4 Stop-The-World\n\nStop-The-World，中文一般翻译为全世界暂停，是指**在进行垃圾回收时因为标记或清理的需要，必须让所有执行任务的线程停止执行任务，从而让垃圾回收线程回收垃圾的时间间隔。**\n\n在 Stop-The-World 这段时间里，**所有非垃圾回收线程都无法工作**，都暂停下来。只有等到垃圾回收线程工作完成才可以继续工作。可以看出，Stop-The-World 时间的长短将关系到应用程序的响应时间，因此在 GC 过程中，Stop-The-World 的时间是一个非常重要的指标。\n\n## 推荐文章：\n\n\n>[陈树义 JVM基础系列第8讲：JVM 垃圾回收机制](https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html)\n\n>[陈树义 JVM基础系列第9讲：JVM垃圾回收器](https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html)\n\n>[陈树义 JVM基础系列第10讲：垃圾回收的几种类型](https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html)\n\n\n### 参考    \n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社   \n[2]https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html\n[3]https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html\n[4]https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html","source":"_posts/code/JVM/JVM学习笔记(二) ——垃圾收集器和内存分配策略.md","raw":"---\ntitle: JVM学习笔记(二)——垃圾收集器和内存分配策略\ncategories: Code\ntags: JVM\ndeclare: true\nwordCount: true\nabbrlink: 1e17e950\ndate: 2020-07-02 13:40:10\n---\n\n\nJava与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外的人想进去，墙内的人却想出去。\n![垃圾收集器和内存分配策略](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200702132536.png)\n<!-- more -->\n\n对于Java内存运行时区域的各个部分，其中**程序计数器、虚拟机栈、本地方法栈**3个区域的内存随线程而生，随线程而灭。所以方法或者线程结束的时候，内存就自然的随着回收了。而**Java堆和方法区的内存**则不一样，这些部分的内存是需要动态分配的。\n>栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈的操作。每一个线栈中分配多少内存基本上是在类结构确定下来时就已知的。\n\n>Java堆和方法区中，一个接口的多个实现类、一个方法中的多个分支也可能不一样，我们只有在程序处于运行期间才知道会创建那些对象。\n\n\n## 一、如何判断对象已死\n### 1.1 引用计数法\n在一个对象被引用时加一，被去除引用时减一，这样我们就可以通过**判断引用计数是否为零**来判断一个对象是垃圾。\n\n优点是实现简单，判定效率也很高，但很少被使用，因为存在着一个很致命的问题，即**循环引用问题**。\n>A引用了B，B引用了C，C引用了A，它们各自的引用计数都为 1。但是**它们三个对象却从未被其他对象引用，只有它们自身互相引用**。从垃圾的判断思想来看，它们三个确实是不被其他对象引用的，但是此时它们的引用计数却不为零。这就是引用计数法存在的循环引用问题。\n\n<br>\n\n***\n\n<br>\n\n### 1.2 可达性分析算法（GC Root Tracing）\n**从GC Root出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾**。\n\n* GC Root:      \n    * 虚拟机栈中（栈帧中的本地变量表）中引用的对象\n    * 方法区中静态属性引用的对象\n    * 方法区中常量引用的对象\n\n简单地说，GC Root就是**经过精心挑选的一组活跃引用**，这些引用是肯定存活的。那么通过这些引用延伸到的对象，自然也是存活的。\n\n此时需要注意的是，**即使是在可达性分析算法中不可达的对象，也并非是“非死不可”**，此时它们处于“缓刑”阶段，然后需要至少经历两次标记过程：\n1. 此对象是否有必要执行`finalize()`方法，如果有必要则进入下一阶段。\n    >当对象没有覆盖`finalize()`方法或者此方法已经被虚拟机调用过，则会被视为没必要执行。如果有必要执行，则会被放置在`F-QueueL`的一个队列中，并由一个低优先级的`Finalizer`线程去执行它\n2. 对`F-QueueL`中的对象进行二次标记，如果对象在`finalize()`中成功拯救自己，则会被移出“即将回收”的集合。\n    >`finalize()`:只要重新与引用链上任意一个对象建立关联即可\n\n再谈引用：    \n* 强引用：在程序代码之中普遍存在的，类似`Object c=new Object()`\n* 软引用：**有用但并非有必需的对象**，对于这一类对象，在系统将要发生内存溢出的之前，将会把这些对象列进回收范围之中进行第二次回收\n* 弱引用：**非必需对象**，**只能生存到下一次垃圾收集之前**\n* 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例，一个对象设置虚引用的唯一目的就是**能在这个对象被收集器回收时收到一个系统通知**，JDK1.2以后通过`PhantomReference`类来实现虚引用\n\n<br>\n\n***\n\n<br>\n\n### 1.3 方法区的回收\n虽然Java虚拟机规范中确实说过**可以不要求**虚拟机在方法区实现垃圾收集，但**方法区并不是没有垃圾回收**\n\n<br>\n\n方法区（永久代）的垃圾回收主要是两部分的内容：\n>**仅仅是“可以”**,并不是像对象一样，不使用了就必然会被回收\n* 废弃常量\n    >例如一个字符串“abc\"已经进入了常量池，但当前系统并没有任何一个String对象的值引用常量池中的“abc”变量的\n* 无用的类\n    >该类的所有实例都已经被回收<br>\n    >加载该类的ClassLoader已经被回收<br>\n    >该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。(以上三点需同时满足)\n\n<br><br>\n\n***\n\n<br><br>\n\n## 二、垃圾回收算法\n\n### 2.1 标记-清除算法\n算法分为两个部分：\n* 标记：首先标记出所有需要回收的对象\n* 清除：在标记完成后统一回收所有被标记的对象\n\n\n不足：\n* 效率问题\n>标记和清除的效率都很低\n* 空间问题\n>标记清除之后会产生大量不连续的内存碎片，导致以后分配较大的对象时，找不到足够多的连续内存而不得不触发一次GC\n\n<br>\n\n***\n\n<br>\n\n### 2.2 复制算法\n将原有的内存空间分为两块，每次只使用一块，**在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收**。\n\n\n不足：\n* 要将内存空间折半，极大地浪费了内存空间。\n\n改进：     \n* IBM公司的专门研究表明，新生代的98%对象都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，**每次使用Eden和其中一块Survivor。当回收时，将Eden空间和Survivor中还活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚刚用过的那一个Survivor。**\n* HotSpot虚拟机默认的Eden和Survivor的大小比例是8:1:1，如果Survivor空间不够用时，则需要依赖其他内存空间进行**担保**（直接进入老年代）\n\n<br>\n\n***\n\n<br>\n\n### 2.3 标记整理算法\n可以理解是标记清除算法的优化版，其同样需要经历两个阶段：\n* 标记结算\n>从 GC Root 引用集合触发去标记所有对象\n* 整理阶段\n>让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存\n\n<br><br>\n\n***\n\n<br><br>\n\n## 三、分代思想\n如果我们单独采用任何一种算法，那么最终的垃圾回收效率都不会很好。因此在实际的垃圾回收算法中采用了分代算法。即根据对象存活周期的不同将内存划分为几块。一般是将堆划分为**新生代**和**老年代**，这样就可以根据各个年代的特点采用不同的垃圾回收算法。\n\n例如对于**存活对象少的新生代区域，比较适合采用复制算法。这样只需要复制少量对象，便可完成垃圾回收，并且还不会有内存碎片。而对于老年代这种存活对象多的区域，比较适合采用标记压缩算法或标记清除算法，这样不需要移动太多的内存对象。**\n\n\nHotSpot的算法实现\n### 枚举根节点\n可达性分析从GC Roots结点找引用链，但可作为结点的全局性引用和执行上下文的数据可能会过于庞大，因此如果要逐个检查里面的应用，那么必然会消耗非常多的资源。此外可达性分析对于时间的敏感性还体现在GC停顿上，**不可以出现分析对象引用关系的过程时其还在不断变化**,因此GC进行时必须停顿所有Java执行线程（**“Stop The World”**）。\n\n目前主流的Java虚拟机使用的都是准确式GC:\n\n所以当执行系统停顿下来时，**并不需要逐个检查所有全局性引用和执行上下文**。HotSpot使用一组称为**OopMap的数据结构**来达到这个目的。\n>在类加载完成的时候，HotSpot就把对象内什么偏移量什么偏移量是什么类型的数据计算出来，在JIT编译的过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样在GC扫描时，就可以直接得到这些信息了。\n\n***\n\n### 安全点\n在OopMap的帮助下，HotSop可以很快的完成GC Roots枚举，但是如果为每一条指令都生成对于的OopMap，那么会使得GC的空间成本很高。\n\n所以程序**只是在特点的位置（安全点）停下来开始GC**\n>安全点的选择不能选得太少让GC等待时间过长，也不能选得太多让程序长时间执行。所以选择的地方的特征是**指令序列复用**，例如方法调用、循环跳转、异常跳转等。\n\n\n如何在GC发生是让所有线程都\"跑\"到最近的安全点？\n\n1. 抢先式中断\n>不需要线程的执行代码主动去配合，首先把所有线程中断，然后让没有到安全点的线程，跑到安全点上\n2. 主动式中断\n>不直接对线程操作，仅仅简单地设置一个标志，各个线程执行是主动轮询这个标志\n\n***\n\n###  安全区域\n如果在程序线程处于Sleep状态或者Blocked状态时，线程无法响应JVM中断请求，走到安全点去挂起。对于这种情况就需要安全区域来解决\n\n即安全区域是指在一段代码之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的，我们也可以把安全区看做是被扩展了的安全点。\n\n\n\n<br><br>\n\n***\n\n<br><br>\n\n## 四、分区思想\n分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代），但 JVM 中其实还有一个分区思想，即将**整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收**，这种算法的好处是可以控制一次回收多少个区间，可以较好地控制 GC 时间。\n\n<br><br>\n\n***\n\n<br><br>\n\n## 五、垃圾回收器\n\n### 5.1 串形(Serial)回收器\n串行回收器是指使用**单线程**进行垃圾回收的回收器。因为每次回收时只有一个线程，因此串行回收器**在并发能力较弱的计算机上，其专注性和独占性的特点往往能让其有更好的性能表现。**\n\n串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收器和老年代串行回收器。\n\n#### 5.1.1 新生代串行回收器\n在新生代串行回收器中使用的是**复制算法**。在串行回收器进行垃圾回收时，会触发`Stop-The-World`现象，即其他线程都需要暂停，等待垃圾回收完成。因此在某些情况下，其会造成较为糟糕的用户体验。\n\n***\n\n#### 5.1.2 老年代串行回收器\n在老年代串行回收器中使用的是**标记整理算法**。其与新生代串行收集器一样，只能串行、独占式地进行垃圾回收，因此也经常会有较长时间的 Stop-The-World 发生。\n\n但老年代串行回收器的好处之一，就是其**可以与多种新生代回收器配合使用**。\n\n<br>\n\n***\n\n<br>\n\n### 5.2 并行回收器\n\n#### 5.2.1 新生代ParNew回收器\n**串行回收器的多线程版本**，其回收策略、算法以及参数和新生代串行回收器一样。\n\n新生代 ParNew 回收器同样使用复制算法的垃圾回收算法，其垃圾收集过程中同样会触发`Stop-The-World`现象。但因为其使用多线程进行垃圾回收，因此**在并发能力强的CPU上，其产生的停顿时间要短于串行回收器**。\n\n但在**单CPU或并能能力弱**的系统中，并行回收器效果会因为线程切换的原因，其实际表现**反而不如串行回收器**。\n\n***\n\n#### 5.2.2 新生代Parallel GC回收器\n新生代 Parallel GC 回收器与新生代 ParNew 回收器非常类似，其也是**使用复制算法，都是多线程、独占式的收集器，也会导致 Stop-The-World**。但其余 ParNew 回收器的一个重大不同是：其**非常注重系统的吞吐量**\n\n之所以说新生代 Parallel GC 回收器非常注重系统吞吐量，是因为其有一个自适应GC调节策略\n\n***\n\n#### 5.2.3 老年代 ParallelOldGC 回收器\n老年代 ParallelOldGC 回收器也是一种多线程并发的回收器，与新生代ParallelGC收集器一样，其**也是注重吞吐量的收集器，只不过其是作用于老年代**。\n\nParallelOldGC回收器使用的是**标记整理算法**，只有在 JDK1.6中才可以使用。\n\n<br>\n\n***\n\n<br>\n\n### 5.3 CMS回收器\nCMS 回收器**主要关注系统停顿时间**。CMS回收器全称为 Concurrent Mark Sweep，意为**标记清除**算法，其是一个使用**多线程并行回收**的垃圾回收器。\n\nCMS 的主要工作步骤有：\n1. 初始标记\n2. 并发标记\n3. 重新标记\n>为了修正标记期间因程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记阶段时间较长，但远小于并发标记\n4. 并发清除\n>耗时最长的并发标记和并发清除线程都可以与用户线程并发执行\n\n\n优点：\n* 并发收集低停顿\n\n\n缺点:\n* 对CPU资源非常敏感\n* 无法处理浮动资源\n>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，只能等待下一次GC,这些垃圾就被称为浮动垃圾\n* 会出现空间碎片\n>基于标记-清理算法\n\n<br><br><br>\n\n***\n\n<br><br><br>\n\n### 5.4 G1收集器\nG1 回收器是 JDK 1.7 中使用的全新垃圾回收器，从长期目标来看，其是为了取代 CMS 回收器。\n\nG1 回收器拥有独特的垃圾回收策略，和之前所有垃圾回收器采用的垃圾回收策略不同。从分代看，G1 依然属于分代垃圾回收器。但它**最大的改变是使用了分区算法**，从而**使得 Eden 区、From 区、Survivor 区和老年代等各块内存不必连续**。\n\n工作过程：\n1. 初始标记\n>耗时较短，仅仅标记一下GC Roots能够直接关联到的对象\n2. 并发标记\n>耗时较长，进行可达性分析，找出存活的对象\n3. 最终标记\n>修正在并发标记过程中因用户程序继续运行而导致的标记变动的那一部分\n4. 筛选回收\n>首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划\n\n\n\n特点：\n* 并行和并发\n* 分代收集\n* 空间整合\n>基于**标记-整理**算法\n* 可预测的停顿\n>通过建立一个可预测的停顿时间模型，使得消耗在垃圾收集上的时间不得超过可预测的时间。之所以能够建立一个可预测的停顿时间模型，是因为它在后台维护了一个优先列表，每次优先收集价值最大的Region，有效地提高收集效率。\n\n\n<br><br>\n\n***\n\n<br><br>\n\n## 六、内存分配和回收策略\nJava对象的内存分配，大方向来讲，就是在堆上分配（但也有可能经过JIT编译后被拆散为标量类型并间接地在栈上分配)\n\n对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按照线程优先在TLAB上分配，少数情况下也会直接在老年代中分配，分配规则并不是固定不变的，其细节取决于使用的哪一种垃圾回收器组合以及虚拟机的相关参数设置。\n\n以下是几条最普遍的内存分配规则：\n\n### 6.1 对象优先在Eden分配\n大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC\n\n***\n\n### 6.2 大对象直接进入老年代\n大对象是指需要大量连续内存空间的Java对象，最典型的就是那种很长的字符串或者数组\n\n***\n\n### 6.3 长期存活的对象将进入老年代\n虚拟机给每个对象定义了一个对象年龄计数器。**如果对象在Eden出生并经过一此Minor GC后仍然存错，并且被Survivor容纳的话，就将对象年龄设为1，此后每经历过一此Minor GC,对象年龄就加1，当年龄增加到一定程度时（默认为15）,就晋升到老年代**。\n\n***\n\n### 6.4 动态对象年龄判定\n虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，**如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代**。\n\n***\n\n### 6.5 空间担保分配\n**虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间**，如果这个条件成立，那么可以确认Minor GC是安全的。如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败？如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试进行一次Minor GC,尽管这次是有风险的。如果小于或者HandlePromotionFailure设置不允许冒险，那这是也要改为进行一次Full GC。\n\n什么是冒险？前面提到过新生代使用复制收集算法，但为了提升内存利用率。只使用其中一个survivor空间作为备份。因此当出现大量对象在Minor GC后仍然存活的情况。就需要老年代进行分担,把survivor无法容纳的对象直接进入老年代。前提是老年代本身还有容纳这些对象的剩余空间。**有多少对象会活下来，在实际完成内存回收之前是无法明确知道。所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值与剩余老年代的剩余空间进行比较。**决定是否进行一次Full GC让老年代腾出更多空间。\n\n如果担保失败的话，就只好在担保失败后重新发起一次Full GC.\n\n\n## 七、垃圾回收的几种类型\n\n### 7.1 Minor GC\n**新生代空间回收内存被称为 Minor GC**，有时候也称之为 Young GC。对于 Minor GC，你需要知道的一些点：\n\n* JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以 Eden 区越小，越频繁执行 Minor GC。\n\n* 当年轻代中的 Eden 区分配满的时候，年轻代中的部分对象会晋升到老年代，所以 Minor GC 后老年代的占用量通常会有所升高。\n\n* 质疑常规的认知，所有的 Minor GC 都会触发 Stop-The-World，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的，因为大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果情况相反，即 Eden 区大部分新生对象不符合 GC 条件（即他们不被垃圾回收器收集），那么 Minor GC 执行时暂停的时间将会长很多（因为他们要JVM要将他们复制到 Survivor 区或老年代）。\n\n***\n\n### 7.2 Major GC\n**从老年代空间回收内存被称为 Major GC**，有时候也称之为 Old GC。\n\n**许多 Major GC 是由 Minor GC 触发的**，所以很多情况下将这两种 GC 分离是不太可能的。\n>Minor GC 作用于新生代，Major GC 作用于老年代。 分配对象内存时发现内存不够，触发 Minor GC。Minor GC 会将对象移到老年代中，如果此时老年代空间不够，那么触发 Major GC。因此才会说，许多 Major GC 是由 Minor GC 引起的。\n\n***\n\n### 7.3 Full GC\n\n**Full GC 是清理整个堆空间 —— 包括年轻代、老年代和永久代（如果有的话）**。因此 Full GC 可以说是 Minor GC 和 Major GC 的结合。\n>当准备要触发一次 Minor GC 时，如果发现年轻代的剩余空间比以往晋升的空间小，则不会触发 Minor GC 而是转为触发 Full GC。因为JVM此时认为：之前这么大空间的时候已经发生对象晋升了，那现在剩余空间更小了，那么很大概率上也会发生对象晋升。既然如此，那么我就直接帮你把事情给做了吧，直接来一次 Full GC，整理一下老年代和年轻代的空间。\n\n>另外，即在永久代分配空间但已经没有足够空间时，也会触发 Full GC。\n\n\n### 7.4 Stop-The-World\n\nStop-The-World，中文一般翻译为全世界暂停，是指**在进行垃圾回收时因为标记或清理的需要，必须让所有执行任务的线程停止执行任务，从而让垃圾回收线程回收垃圾的时间间隔。**\n\n在 Stop-The-World 这段时间里，**所有非垃圾回收线程都无法工作**，都暂停下来。只有等到垃圾回收线程工作完成才可以继续工作。可以看出，Stop-The-World 时间的长短将关系到应用程序的响应时间，因此在 GC 过程中，Stop-The-World 的时间是一个非常重要的指标。\n\n## 推荐文章：\n\n\n>[陈树义 JVM基础系列第8讲：JVM 垃圾回收机制](https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html)\n\n>[陈树义 JVM基础系列第9讲：JVM垃圾回收器](https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html)\n\n>[陈树义 JVM基础系列第10讲：垃圾回收的几种类型](https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html)\n\n\n### 参考    \n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社   \n[2]https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html\n[3]https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html\n[4]https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html","slug":"code/JVM/JVM学习笔记(二) ——垃圾收集器和内存分配策略","published":1,"updated":"2020-07-02T05:36:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1g3003l0w7t6m6080yq","content":"<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外的人想进去，墙内的人却想出去。<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200702132536.png\" alt=\"垃圾收集器和内存分配策略\"></p>\n<a id=\"more\"></a>\n\n<p>对于Java内存运行时区域的各个部分，其中<strong>程序计数器、虚拟机栈、本地方法栈</strong>3个区域的内存随线程而生，随线程而灭。所以方法或者线程结束的时候，内存就自然的随着回收了。而<strong>Java堆和方法区的内存</strong>则不一样，这些部分的内存是需要动态分配的。</p>\n<blockquote>\n<p>栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈的操作。每一个线栈中分配多少内存基本上是在类结构确定下来时就已知的。</p>\n</blockquote>\n<blockquote>\n<p>Java堆和方法区中，一个接口的多个实现类、一个方法中的多个分支也可能不一样，我们只有在程序处于运行期间才知道会创建那些对象。</p>\n</blockquote>\n<h2 id=\"一、如何判断对象已死\"><a href=\"#一、如何判断对象已死\" class=\"headerlink\" title=\"一、如何判断对象已死\"></a>一、如何判断对象已死</h2><h3 id=\"1-1-引用计数法\"><a href=\"#1-1-引用计数法\" class=\"headerlink\" title=\"1.1 引用计数法\"></a>1.1 引用计数法</h3><p>在一个对象被引用时加一，被去除引用时减一，这样我们就可以通过<strong>判断引用计数是否为零</strong>来判断一个对象是垃圾。</p>\n<p>优点是实现简单，判定效率也很高，但很少被使用，因为存在着一个很致命的问题，即<strong>循环引用问题</strong>。</p>\n<blockquote>\n<p>A引用了B，B引用了C，C引用了A，它们各自的引用计数都为 1。但是<strong>它们三个对象却从未被其他对象引用，只有它们自身互相引用</strong>。从垃圾的判断思想来看，它们三个确实是不被其他对象引用的，但是此时它们的引用计数却不为零。这就是引用计数法存在的循环引用问题。</p>\n</blockquote>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"1-2-可达性分析算法（GC-Root-Tracing）\"><a href=\"#1-2-可达性分析算法（GC-Root-Tracing）\" class=\"headerlink\" title=\"1.2 可达性分析算法（GC Root Tracing）\"></a>1.2 可达性分析算法（GC Root Tracing）</h3><p><strong>从GC Root出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾</strong>。</p>\n<ul>\n<li>GC Root:      <ul>\n<li>虚拟机栈中（栈帧中的本地变量表）中引用的对象</li>\n<li>方法区中静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n</ul>\n</li>\n</ul>\n<p>简单地说，GC Root就是<strong>经过精心挑选的一组活跃引用</strong>，这些引用是肯定存活的。那么通过这些引用延伸到的对象，自然也是存活的。</p>\n<p>此时需要注意的是，<strong>即使是在可达性分析算法中不可达的对象，也并非是“非死不可”</strong>，此时它们处于“缓刑”阶段，然后需要至少经历两次标记过程：</p>\n<ol>\n<li>此对象是否有必要执行<code>finalize()</code>方法，如果有必要则进入下一阶段。<blockquote>\n<p>当对象没有覆盖<code>finalize()</code>方法或者此方法已经被虚拟机调用过，则会被视为没必要执行。如果有必要执行，则会被放置在<code>F-QueueL</code>的一个队列中，并由一个低优先级的<code>Finalizer</code>线程去执行它</p>\n</blockquote>\n</li>\n<li>对<code>F-QueueL</code>中的对象进行二次标记，如果对象在<code>finalize()</code>中成功拯救自己，则会被移出“即将回收”的集合。<blockquote>\n<p><code>finalize()</code>:只要重新与引用链上任意一个对象建立关联即可</p>\n</blockquote>\n</li>\n</ol>\n<p>再谈引用：    </p>\n<ul>\n<li>强引用：在程序代码之中普遍存在的，类似<code>Object c=new Object()</code></li>\n<li>软引用：<strong>有用但并非有必需的对象</strong>，对于这一类对象，在系统将要发生内存溢出的之前，将会把这些对象列进回收范围之中进行第二次回收</li>\n<li>弱引用：<strong>非必需对象</strong>，<strong>只能生存到下一次垃圾收集之前</strong></li>\n<li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例，一个对象设置虚引用的唯一目的就是<strong>能在这个对象被收集器回收时收到一个系统通知</strong>，JDK1.2以后通过<code>PhantomReference</code>类来实现虚引用</li>\n</ul>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"1-3-方法区的回收\"><a href=\"#1-3-方法区的回收\" class=\"headerlink\" title=\"1.3 方法区的回收\"></a>1.3 方法区的回收</h3><p>虽然Java虚拟机规范中确实说过<strong>可以不要求</strong>虚拟机在方法区实现垃圾收集，但<strong>方法区并不是没有垃圾回收</strong></p>\n<br>\n\n<p>方法区（永久代）的垃圾回收主要是两部分的内容：</p>\n<blockquote>\n<p><strong>仅仅是“可以”</strong>,并不是像对象一样，不使用了就必然会被回收</p>\n</blockquote>\n<ul>\n<li>废弃常量<blockquote>\n<p>例如一个字符串“abc”已经进入了常量池，但当前系统并没有任何一个String对象的值引用常量池中的“abc”变量的</p>\n</blockquote>\n</li>\n<li>无用的类<blockquote>\n<p>该类的所有实例都已经被回收<br><br>加载该类的ClassLoader已经被回收<br><br>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。(以上三点需同时满足)</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"二、垃圾回收算法\"><a href=\"#二、垃圾回收算法\" class=\"headerlink\" title=\"二、垃圾回收算法\"></a>二、垃圾回收算法</h2><h3 id=\"2-1-标记-清除算法\"><a href=\"#2-1-标记-清除算法\" class=\"headerlink\" title=\"2.1 标记-清除算法\"></a>2.1 标记-清除算法</h3><p>算法分为两个部分：</p>\n<ul>\n<li>标记：首先标记出所有需要回收的对象</li>\n<li>清除：在标记完成后统一回收所有被标记的对象</li>\n</ul>\n<p>不足：</p>\n<ul>\n<li>效率问题<blockquote>\n<p>标记和清除的效率都很低</p>\n</blockquote>\n</li>\n<li>空间问题<blockquote>\n<p>标记清除之后会产生大量不连续的内存碎片，导致以后分配较大的对象时，找不到足够多的连续内存而不得不触发一次GC</p>\n</blockquote>\n</li>\n</ul>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"2-2-复制算法\"><a href=\"#2-2-复制算法\" class=\"headerlink\" title=\"2.2 复制算法\"></a>2.2 复制算法</h3><p>将原有的内存空间分为两块，每次只使用一块，<strong>在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收</strong>。</p>\n<p>不足：</p>\n<ul>\n<li>要将内存空间折半，极大地浪费了内存空间。</li>\n</ul>\n<p>改进：     </p>\n<ul>\n<li>IBM公司的专门研究表明，新生代的98%对象都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，<strong>每次使用Eden和其中一块Survivor。当回收时，将Eden空间和Survivor中还活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚刚用过的那一个Survivor。</strong></li>\n<li>HotSpot虚拟机默认的Eden和Survivor的大小比例是8:1:1，如果Survivor空间不够用时，则需要依赖其他内存空间进行<strong>担保</strong>（直接进入老年代）</li>\n</ul>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"2-3-标记整理算法\"><a href=\"#2-3-标记整理算法\" class=\"headerlink\" title=\"2.3 标记整理算法\"></a>2.3 标记整理算法</h3><p>可以理解是标记清除算法的优化版，其同样需要经历两个阶段：</p>\n<ul>\n<li>标记结算<blockquote>\n<p>从 GC Root 引用集合触发去标记所有对象</p>\n</blockquote>\n</li>\n<li>整理阶段<blockquote>\n<p>让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"三、分代思想\"><a href=\"#三、分代思想\" class=\"headerlink\" title=\"三、分代思想\"></a>三、分代思想</h2><p>如果我们单独采用任何一种算法，那么最终的垃圾回收效率都不会很好。因此在实际的垃圾回收算法中采用了分代算法。即根据对象存活周期的不同将内存划分为几块。一般是将堆划分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以根据各个年代的特点采用不同的垃圾回收算法。</p>\n<p>例如对于<strong>存活对象少的新生代区域，比较适合采用复制算法。这样只需要复制少量对象，便可完成垃圾回收，并且还不会有内存碎片。而对于老年代这种存活对象多的区域，比较适合采用标记压缩算法或标记清除算法，这样不需要移动太多的内存对象。</strong></p>\n<p>HotSpot的算法实现</p>\n<h3 id=\"枚举根节点\"><a href=\"#枚举根节点\" class=\"headerlink\" title=\"枚举根节点\"></a>枚举根节点</h3><p>可达性分析从GC Roots结点找引用链，但可作为结点的全局性引用和执行上下文的数据可能会过于庞大，因此如果要逐个检查里面的应用，那么必然会消耗非常多的资源。此外可达性分析对于时间的敏感性还体现在GC停顿上，<strong>不可以出现分析对象引用关系的过程时其还在不断变化</strong>,因此GC进行时必须停顿所有Java执行线程（<strong>“Stop The World”</strong>）。</p>\n<p>目前主流的Java虚拟机使用的都是准确式GC:</p>\n<p>所以当执行系统停顿下来时，<strong>并不需要逐个检查所有全局性引用和执行上下文</strong>。HotSpot使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的。</p>\n<blockquote>\n<p>在类加载完成的时候，HotSpot就把对象内什么偏移量什么偏移量是什么类型的数据计算出来，在JIT编译的过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样在GC扫描时，就可以直接得到这些信息了。</p>\n</blockquote>\n<hr>\n<h3 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h3><p>在OopMap的帮助下，HotSop可以很快的完成GC Roots枚举，但是如果为每一条指令都生成对于的OopMap，那么会使得GC的空间成本很高。</p>\n<p>所以程序<strong>只是在特点的位置（安全点）停下来开始GC</strong></p>\n<blockquote>\n<p>安全点的选择不能选得太少让GC等待时间过长，也不能选得太多让程序长时间执行。所以选择的地方的特征是<strong>指令序列复用</strong>，例如方法调用、循环跳转、异常跳转等。</p>\n</blockquote>\n<p>如何在GC发生是让所有线程都”跑”到最近的安全点？</p>\n<ol>\n<li>抢先式中断<blockquote>\n<p>不需要线程的执行代码主动去配合，首先把所有线程中断，然后让没有到安全点的线程，跑到安全点上</p>\n</blockquote>\n</li>\n<li>主动式中断<blockquote>\n<p>不直接对线程操作，仅仅简单地设置一个标志，各个线程执行是主动轮询这个标志</p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h3 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h3><p>如果在程序线程处于Sleep状态或者Blocked状态时，线程无法响应JVM中断请求，走到安全点去挂起。对于这种情况就需要安全区域来解决</p>\n<p>即安全区域是指在一段代码之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的，我们也可以把安全区看做是被扩展了的安全点。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"四、分区思想\"><a href=\"#四、分区思想\" class=\"headerlink\" title=\"四、分区思想\"></a>四、分区思想</h2><p>分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代），但 JVM 中其实还有一个分区思想，即将<strong>整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收</strong>，这种算法的好处是可以控制一次回收多少个区间，可以较好地控制 GC 时间。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"五、垃圾回收器\"><a href=\"#五、垃圾回收器\" class=\"headerlink\" title=\"五、垃圾回收器\"></a>五、垃圾回收器</h2><h3 id=\"5-1-串形-Serial-回收器\"><a href=\"#5-1-串形-Serial-回收器\" class=\"headerlink\" title=\"5.1 串形(Serial)回收器\"></a>5.1 串形(Serial)回收器</h3><p>串行回收器是指使用<strong>单线程</strong>进行垃圾回收的回收器。因为每次回收时只有一个线程，因此串行回收器<strong>在并发能力较弱的计算机上，其专注性和独占性的特点往往能让其有更好的性能表现。</strong></p>\n<p>串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收器和老年代串行回收器。</p>\n<h4 id=\"5-1-1-新生代串行回收器\"><a href=\"#5-1-1-新生代串行回收器\" class=\"headerlink\" title=\"5.1.1 新生代串行回收器\"></a>5.1.1 新生代串行回收器</h4><p>在新生代串行回收器中使用的是<strong>复制算法</strong>。在串行回收器进行垃圾回收时，会触发<code>Stop-The-World</code>现象，即其他线程都需要暂停，等待垃圾回收完成。因此在某些情况下，其会造成较为糟糕的用户体验。</p>\n<hr>\n<h4 id=\"5-1-2-老年代串行回收器\"><a href=\"#5-1-2-老年代串行回收器\" class=\"headerlink\" title=\"5.1.2 老年代串行回收器\"></a>5.1.2 老年代串行回收器</h4><p>在老年代串行回收器中使用的是<strong>标记整理算法</strong>。其与新生代串行收集器一样，只能串行、独占式地进行垃圾回收，因此也经常会有较长时间的 Stop-The-World 发生。</p>\n<p>但老年代串行回收器的好处之一，就是其<strong>可以与多种新生代回收器配合使用</strong>。</p>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"5-2-并行回收器\"><a href=\"#5-2-并行回收器\" class=\"headerlink\" title=\"5.2 并行回收器\"></a>5.2 并行回收器</h3><h4 id=\"5-2-1-新生代ParNew回收器\"><a href=\"#5-2-1-新生代ParNew回收器\" class=\"headerlink\" title=\"5.2.1 新生代ParNew回收器\"></a>5.2.1 新生代ParNew回收器</h4><p><strong>串行回收器的多线程版本</strong>，其回收策略、算法以及参数和新生代串行回收器一样。</p>\n<p>新生代 ParNew 回收器同样使用复制算法的垃圾回收算法，其垃圾收集过程中同样会触发<code>Stop-The-World</code>现象。但因为其使用多线程进行垃圾回收，因此<strong>在并发能力强的CPU上，其产生的停顿时间要短于串行回收器</strong>。</p>\n<p>但在<strong>单CPU或并能能力弱</strong>的系统中，并行回收器效果会因为线程切换的原因，其实际表现<strong>反而不如串行回收器</strong>。</p>\n<hr>\n<h4 id=\"5-2-2-新生代Parallel-GC回收器\"><a href=\"#5-2-2-新生代Parallel-GC回收器\" class=\"headerlink\" title=\"5.2.2 新生代Parallel GC回收器\"></a>5.2.2 新生代Parallel GC回收器</h4><p>新生代 Parallel GC 回收器与新生代 ParNew 回收器非常类似，其也是<strong>使用复制算法，都是多线程、独占式的收集器，也会导致 Stop-The-World</strong>。但其余 ParNew 回收器的一个重大不同是：其<strong>非常注重系统的吞吐量</strong></p>\n<p>之所以说新生代 Parallel GC 回收器非常注重系统吞吐量，是因为其有一个自适应GC调节策略</p>\n<hr>\n<h4 id=\"5-2-3-老年代-ParallelOldGC-回收器\"><a href=\"#5-2-3-老年代-ParallelOldGC-回收器\" class=\"headerlink\" title=\"5.2.3 老年代 ParallelOldGC 回收器\"></a>5.2.3 老年代 ParallelOldGC 回收器</h4><p>老年代 ParallelOldGC 回收器也是一种多线程并发的回收器，与新生代ParallelGC收集器一样，其<strong>也是注重吞吐量的收集器，只不过其是作用于老年代</strong>。</p>\n<p>ParallelOldGC回收器使用的是<strong>标记整理算法</strong>，只有在 JDK1.6中才可以使用。</p>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"5-3-CMS回收器\"><a href=\"#5-3-CMS回收器\" class=\"headerlink\" title=\"5.3 CMS回收器\"></a>5.3 CMS回收器</h3><p>CMS 回收器<strong>主要关注系统停顿时间</strong>。CMS回收器全称为 Concurrent Mark Sweep，意为<strong>标记清除</strong>算法，其是一个使用<strong>多线程并行回收</strong>的垃圾回收器。</p>\n<p>CMS 的主要工作步骤有：</p>\n<ol>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>重新标记<blockquote>\n<p>为了修正标记期间因程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记阶段时间较长，但远小于并发标记</p>\n</blockquote>\n</li>\n<li>并发清除<blockquote>\n<p>耗时最长的并发标记和并发清除线程都可以与用户线程并发执行</p>\n</blockquote>\n</li>\n</ol>\n<p>优点：</p>\n<ul>\n<li>并发收集低停顿</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>对CPU资源非常敏感</li>\n<li>无法处理浮动资源<blockquote>\n<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，只能等待下一次GC,这些垃圾就被称为浮动垃圾</p>\n</blockquote>\n</li>\n<li>会出现空间碎片<blockquote>\n<p>基于标记-清理算法</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"5-4-G1收集器\"><a href=\"#5-4-G1收集器\" class=\"headerlink\" title=\"5.4 G1收集器\"></a>5.4 G1收集器</h3><p>G1 回收器是 JDK 1.7 中使用的全新垃圾回收器，从长期目标来看，其是为了取代 CMS 回收器。</p>\n<p>G1 回收器拥有独特的垃圾回收策略，和之前所有垃圾回收器采用的垃圾回收策略不同。从分代看，G1 依然属于分代垃圾回收器。但它<strong>最大的改变是使用了分区算法</strong>，从而<strong>使得 Eden 区、From 区、Survivor 区和老年代等各块内存不必连续</strong>。</p>\n<p>工作过程：</p>\n<ol>\n<li>初始标记<blockquote>\n<p>耗时较短，仅仅标记一下GC Roots能够直接关联到的对象</p>\n</blockquote>\n</li>\n<li>并发标记<blockquote>\n<p>耗时较长，进行可达性分析，找出存活的对象</p>\n</blockquote>\n</li>\n<li>最终标记<blockquote>\n<p>修正在并发标记过程中因用户程序继续运行而导致的标记变动的那一部分</p>\n</blockquote>\n</li>\n<li>筛选回收<blockquote>\n<p>首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划</p>\n</blockquote>\n</li>\n</ol>\n<p>特点：</p>\n<ul>\n<li>并行和并发</li>\n<li>分代收集</li>\n<li>空间整合<blockquote>\n<p>基于<strong>标记-整理</strong>算法</p>\n</blockquote>\n</li>\n<li>可预测的停顿<blockquote>\n<p>通过建立一个可预测的停顿时间模型，使得消耗在垃圾收集上的时间不得超过可预测的时间。之所以能够建立一个可预测的停顿时间模型，是因为它在后台维护了一个优先列表，每次优先收集价值最大的Region，有效地提高收集效率。</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"六、内存分配和回收策略\"><a href=\"#六、内存分配和回收策略\" class=\"headerlink\" title=\"六、内存分配和回收策略\"></a>六、内存分配和回收策略</h2><p>Java对象的内存分配，大方向来讲，就是在堆上分配（但也有可能经过JIT编译后被拆散为标量类型并间接地在栈上分配)</p>\n<p>对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按照线程优先在TLAB上分配，少数情况下也会直接在老年代中分配，分配规则并不是固定不变的，其细节取决于使用的哪一种垃圾回收器组合以及虚拟机的相关参数设置。</p>\n<p>以下是几条最普遍的内存分配规则：</p>\n<h3 id=\"6-1-对象优先在Eden分配\"><a href=\"#6-1-对象优先在Eden分配\" class=\"headerlink\" title=\"6.1 对象优先在Eden分配\"></a>6.1 对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC</p>\n<hr>\n<h3 id=\"6-2-大对象直接进入老年代\"><a href=\"#6-2-大对象直接进入老年代\" class=\"headerlink\" title=\"6.2 大对象直接进入老年代\"></a>6.2 大对象直接进入老年代</h3><p>大对象是指需要大量连续内存空间的Java对象，最典型的就是那种很长的字符串或者数组</p>\n<hr>\n<h3 id=\"6-3-长期存活的对象将进入老年代\"><a href=\"#6-3-长期存活的对象将进入老年代\" class=\"headerlink\" title=\"6.3 长期存活的对象将进入老年代\"></a>6.3 长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄计数器。<strong>如果对象在Eden出生并经过一此Minor GC后仍然存错，并且被Survivor容纳的话，就将对象年龄设为1，此后每经历过一此Minor GC,对象年龄就加1，当年龄增加到一定程度时（默认为15）,就晋升到老年代</strong>。</p>\n<hr>\n<h3 id=\"6-4-动态对象年龄判定\"><a href=\"#6-4-动态对象年龄判定\" class=\"headerlink\" title=\"6.4 动态对象年龄判定\"></a>6.4 动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，<strong>如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>。</p>\n<hr>\n<h3 id=\"6-5-空间担保分配\"><a href=\"#6-5-空间担保分配\" class=\"headerlink\" title=\"6.5 空间担保分配\"></a>6.5 空间担保分配</h3><p><strong>虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>，如果这个条件成立，那么可以确认Minor GC是安全的。如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败？如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试进行一次Minor GC,尽管这次是有风险的。如果小于或者HandlePromotionFailure设置不允许冒险，那这是也要改为进行一次Full GC。</p>\n<p>什么是冒险？前面提到过新生代使用复制收集算法，但为了提升内存利用率。只使用其中一个survivor空间作为备份。因此当出现大量对象在Minor GC后仍然存活的情况。就需要老年代进行分担,把survivor无法容纳的对象直接进入老年代。前提是老年代本身还有容纳这些对象的剩余空间。<strong>有多少对象会活下来，在实际完成内存回收之前是无法明确知道。所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值与剩余老年代的剩余空间进行比较。</strong>决定是否进行一次Full GC让老年代腾出更多空间。</p>\n<p>如果担保失败的话，就只好在担保失败后重新发起一次Full GC.</p>\n<h2 id=\"七、垃圾回收的几种类型\"><a href=\"#七、垃圾回收的几种类型\" class=\"headerlink\" title=\"七、垃圾回收的几种类型\"></a>七、垃圾回收的几种类型</h2><h3 id=\"7-1-Minor-GC\"><a href=\"#7-1-Minor-GC\" class=\"headerlink\" title=\"7.1 Minor GC\"></a>7.1 Minor GC</h3><p><strong>新生代空间回收内存被称为 Minor GC</strong>，有时候也称之为 Young GC。对于 Minor GC，你需要知道的一些点：</p>\n<ul>\n<li><p>JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以 Eden 区越小，越频繁执行 Minor GC。</p>\n</li>\n<li><p>当年轻代中的 Eden 区分配满的时候，年轻代中的部分对象会晋升到老年代，所以 Minor GC 后老年代的占用量通常会有所升高。</p>\n</li>\n<li><p>质疑常规的认知，所有的 Minor GC 都会触发 Stop-The-World，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的，因为大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果情况相反，即 Eden 区大部分新生对象不符合 GC 条件（即他们不被垃圾回收器收集），那么 Minor GC 执行时暂停的时间将会长很多（因为他们要JVM要将他们复制到 Survivor 区或老年代）。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"7-2-Major-GC\"><a href=\"#7-2-Major-GC\" class=\"headerlink\" title=\"7.2 Major GC\"></a>7.2 Major GC</h3><p><strong>从老年代空间回收内存被称为 Major GC</strong>，有时候也称之为 Old GC。</p>\n<p><strong>许多 Major GC 是由 Minor GC 触发的</strong>，所以很多情况下将这两种 GC 分离是不太可能的。</p>\n<blockquote>\n<p>Minor GC 作用于新生代，Major GC 作用于老年代。 分配对象内存时发现内存不够，触发 Minor GC。Minor GC 会将对象移到老年代中，如果此时老年代空间不够，那么触发 Major GC。因此才会说，许多 Major GC 是由 Minor GC 引起的。</p>\n</blockquote>\n<hr>\n<h3 id=\"7-3-Full-GC\"><a href=\"#7-3-Full-GC\" class=\"headerlink\" title=\"7.3 Full GC\"></a>7.3 Full GC</h3><p><strong>Full GC 是清理整个堆空间 —— 包括年轻代、老年代和永久代（如果有的话）</strong>。因此 Full GC 可以说是 Minor GC 和 Major GC 的结合。</p>\n<blockquote>\n<p>当准备要触发一次 Minor GC 时，如果发现年轻代的剩余空间比以往晋升的空间小，则不会触发 Minor GC 而是转为触发 Full GC。因为JVM此时认为：之前这么大空间的时候已经发生对象晋升了，那现在剩余空间更小了，那么很大概率上也会发生对象晋升。既然如此，那么我就直接帮你把事情给做了吧，直接来一次 Full GC，整理一下老年代和年轻代的空间。</p>\n</blockquote>\n<blockquote>\n<p>另外，即在永久代分配空间但已经没有足够空间时，也会触发 Full GC。</p>\n</blockquote>\n<h3 id=\"7-4-Stop-The-World\"><a href=\"#7-4-Stop-The-World\" class=\"headerlink\" title=\"7.4 Stop-The-World\"></a>7.4 Stop-The-World</h3><p>Stop-The-World，中文一般翻译为全世界暂停，是指<strong>在进行垃圾回收时因为标记或清理的需要，必须让所有执行任务的线程停止执行任务，从而让垃圾回收线程回收垃圾的时间间隔。</strong></p>\n<p>在 Stop-The-World 这段时间里，<strong>所有非垃圾回收线程都无法工作</strong>，都暂停下来。只有等到垃圾回收线程工作完成才可以继续工作。可以看出，Stop-The-World 时间的长短将关系到应用程序的响应时间，因此在 GC 过程中，Stop-The-World 的时间是一个非常重要的指标。</p>\n<h2 id=\"推荐文章：\"><a href=\"#推荐文章：\" class=\"headerlink\" title=\"推荐文章：\"></a>推荐文章：</h2><blockquote>\n<p><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第8讲：JVM 垃圾回收机制</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第9讲：JVM垃圾回收器</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第10讲：垃圾回收的几种类型</a></p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br>[2]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html</a><br>[3]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html</a><br>[4]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html</a></p>\n","site":{"data":{}},"excerpt":"<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外的人想进去，墙内的人却想出去。<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200702132536.png\" alt=\"垃圾收集器和内存分配策略\"></p>","more":"<p>对于Java内存运行时区域的各个部分，其中<strong>程序计数器、虚拟机栈、本地方法栈</strong>3个区域的内存随线程而生，随线程而灭。所以方法或者线程结束的时候，内存就自然的随着回收了。而<strong>Java堆和方法区的内存</strong>则不一样，这些部分的内存是需要动态分配的。</p>\n<blockquote>\n<p>栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈的操作。每一个线栈中分配多少内存基本上是在类结构确定下来时就已知的。</p>\n</blockquote>\n<blockquote>\n<p>Java堆和方法区中，一个接口的多个实现类、一个方法中的多个分支也可能不一样，我们只有在程序处于运行期间才知道会创建那些对象。</p>\n</blockquote>\n<h2 id=\"一、如何判断对象已死\"><a href=\"#一、如何判断对象已死\" class=\"headerlink\" title=\"一、如何判断对象已死\"></a>一、如何判断对象已死</h2><h3 id=\"1-1-引用计数法\"><a href=\"#1-1-引用计数法\" class=\"headerlink\" title=\"1.1 引用计数法\"></a>1.1 引用计数法</h3><p>在一个对象被引用时加一，被去除引用时减一，这样我们就可以通过<strong>判断引用计数是否为零</strong>来判断一个对象是垃圾。</p>\n<p>优点是实现简单，判定效率也很高，但很少被使用，因为存在着一个很致命的问题，即<strong>循环引用问题</strong>。</p>\n<blockquote>\n<p>A引用了B，B引用了C，C引用了A，它们各自的引用计数都为 1。但是<strong>它们三个对象却从未被其他对象引用，只有它们自身互相引用</strong>。从垃圾的判断思想来看，它们三个确实是不被其他对象引用的，但是此时它们的引用计数却不为零。这就是引用计数法存在的循环引用问题。</p>\n</blockquote>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"1-2-可达性分析算法（GC-Root-Tracing）\"><a href=\"#1-2-可达性分析算法（GC-Root-Tracing）\" class=\"headerlink\" title=\"1.2 可达性分析算法（GC Root Tracing）\"></a>1.2 可达性分析算法（GC Root Tracing）</h3><p><strong>从GC Root出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾</strong>。</p>\n<ul>\n<li>GC Root:      <ul>\n<li>虚拟机栈中（栈帧中的本地变量表）中引用的对象</li>\n<li>方法区中静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n</ul>\n</li>\n</ul>\n<p>简单地说，GC Root就是<strong>经过精心挑选的一组活跃引用</strong>，这些引用是肯定存活的。那么通过这些引用延伸到的对象，自然也是存活的。</p>\n<p>此时需要注意的是，<strong>即使是在可达性分析算法中不可达的对象，也并非是“非死不可”</strong>，此时它们处于“缓刑”阶段，然后需要至少经历两次标记过程：</p>\n<ol>\n<li>此对象是否有必要执行<code>finalize()</code>方法，如果有必要则进入下一阶段。<blockquote>\n<p>当对象没有覆盖<code>finalize()</code>方法或者此方法已经被虚拟机调用过，则会被视为没必要执行。如果有必要执行，则会被放置在<code>F-QueueL</code>的一个队列中，并由一个低优先级的<code>Finalizer</code>线程去执行它</p>\n</blockquote>\n</li>\n<li>对<code>F-QueueL</code>中的对象进行二次标记，如果对象在<code>finalize()</code>中成功拯救自己，则会被移出“即将回收”的集合。<blockquote>\n<p><code>finalize()</code>:只要重新与引用链上任意一个对象建立关联即可</p>\n</blockquote>\n</li>\n</ol>\n<p>再谈引用：    </p>\n<ul>\n<li>强引用：在程序代码之中普遍存在的，类似<code>Object c=new Object()</code></li>\n<li>软引用：<strong>有用但并非有必需的对象</strong>，对于这一类对象，在系统将要发生内存溢出的之前，将会把这些对象列进回收范围之中进行第二次回收</li>\n<li>弱引用：<strong>非必需对象</strong>，<strong>只能生存到下一次垃圾收集之前</strong></li>\n<li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例，一个对象设置虚引用的唯一目的就是<strong>能在这个对象被收集器回收时收到一个系统通知</strong>，JDK1.2以后通过<code>PhantomReference</code>类来实现虚引用</li>\n</ul>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"1-3-方法区的回收\"><a href=\"#1-3-方法区的回收\" class=\"headerlink\" title=\"1.3 方法区的回收\"></a>1.3 方法区的回收</h3><p>虽然Java虚拟机规范中确实说过<strong>可以不要求</strong>虚拟机在方法区实现垃圾收集，但<strong>方法区并不是没有垃圾回收</strong></p>\n<br>\n\n<p>方法区（永久代）的垃圾回收主要是两部分的内容：</p>\n<blockquote>\n<p><strong>仅仅是“可以”</strong>,并不是像对象一样，不使用了就必然会被回收</p>\n</blockquote>\n<ul>\n<li>废弃常量<blockquote>\n<p>例如一个字符串“abc”已经进入了常量池，但当前系统并没有任何一个String对象的值引用常量池中的“abc”变量的</p>\n</blockquote>\n</li>\n<li>无用的类<blockquote>\n<p>该类的所有实例都已经被回收<br><br>加载该类的ClassLoader已经被回收<br><br>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。(以上三点需同时满足)</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"二、垃圾回收算法\"><a href=\"#二、垃圾回收算法\" class=\"headerlink\" title=\"二、垃圾回收算法\"></a>二、垃圾回收算法</h2><h3 id=\"2-1-标记-清除算法\"><a href=\"#2-1-标记-清除算法\" class=\"headerlink\" title=\"2.1 标记-清除算法\"></a>2.1 标记-清除算法</h3><p>算法分为两个部分：</p>\n<ul>\n<li>标记：首先标记出所有需要回收的对象</li>\n<li>清除：在标记完成后统一回收所有被标记的对象</li>\n</ul>\n<p>不足：</p>\n<ul>\n<li>效率问题<blockquote>\n<p>标记和清除的效率都很低</p>\n</blockquote>\n</li>\n<li>空间问题<blockquote>\n<p>标记清除之后会产生大量不连续的内存碎片，导致以后分配较大的对象时，找不到足够多的连续内存而不得不触发一次GC</p>\n</blockquote>\n</li>\n</ul>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"2-2-复制算法\"><a href=\"#2-2-复制算法\" class=\"headerlink\" title=\"2.2 复制算法\"></a>2.2 复制算法</h3><p>将原有的内存空间分为两块，每次只使用一块，<strong>在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收</strong>。</p>\n<p>不足：</p>\n<ul>\n<li>要将内存空间折半，极大地浪费了内存空间。</li>\n</ul>\n<p>改进：     </p>\n<ul>\n<li>IBM公司的专门研究表明，新生代的98%对象都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，<strong>每次使用Eden和其中一块Survivor。当回收时，将Eden空间和Survivor中还活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚刚用过的那一个Survivor。</strong></li>\n<li>HotSpot虚拟机默认的Eden和Survivor的大小比例是8:1:1，如果Survivor空间不够用时，则需要依赖其他内存空间进行<strong>担保</strong>（直接进入老年代）</li>\n</ul>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"2-3-标记整理算法\"><a href=\"#2-3-标记整理算法\" class=\"headerlink\" title=\"2.3 标记整理算法\"></a>2.3 标记整理算法</h3><p>可以理解是标记清除算法的优化版，其同样需要经历两个阶段：</p>\n<ul>\n<li>标记结算<blockquote>\n<p>从 GC Root 引用集合触发去标记所有对象</p>\n</blockquote>\n</li>\n<li>整理阶段<blockquote>\n<p>让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"三、分代思想\"><a href=\"#三、分代思想\" class=\"headerlink\" title=\"三、分代思想\"></a>三、分代思想</h2><p>如果我们单独采用任何一种算法，那么最终的垃圾回收效率都不会很好。因此在实际的垃圾回收算法中采用了分代算法。即根据对象存活周期的不同将内存划分为几块。一般是将堆划分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以根据各个年代的特点采用不同的垃圾回收算法。</p>\n<p>例如对于<strong>存活对象少的新生代区域，比较适合采用复制算法。这样只需要复制少量对象，便可完成垃圾回收，并且还不会有内存碎片。而对于老年代这种存活对象多的区域，比较适合采用标记压缩算法或标记清除算法，这样不需要移动太多的内存对象。</strong></p>\n<p>HotSpot的算法实现</p>\n<h3 id=\"枚举根节点\"><a href=\"#枚举根节点\" class=\"headerlink\" title=\"枚举根节点\"></a>枚举根节点</h3><p>可达性分析从GC Roots结点找引用链，但可作为结点的全局性引用和执行上下文的数据可能会过于庞大，因此如果要逐个检查里面的应用，那么必然会消耗非常多的资源。此外可达性分析对于时间的敏感性还体现在GC停顿上，<strong>不可以出现分析对象引用关系的过程时其还在不断变化</strong>,因此GC进行时必须停顿所有Java执行线程（<strong>“Stop The World”</strong>）。</p>\n<p>目前主流的Java虚拟机使用的都是准确式GC:</p>\n<p>所以当执行系统停顿下来时，<strong>并不需要逐个检查所有全局性引用和执行上下文</strong>。HotSpot使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的。</p>\n<blockquote>\n<p>在类加载完成的时候，HotSpot就把对象内什么偏移量什么偏移量是什么类型的数据计算出来，在JIT编译的过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样在GC扫描时，就可以直接得到这些信息了。</p>\n</blockquote>\n<hr>\n<h3 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h3><p>在OopMap的帮助下，HotSop可以很快的完成GC Roots枚举，但是如果为每一条指令都生成对于的OopMap，那么会使得GC的空间成本很高。</p>\n<p>所以程序<strong>只是在特点的位置（安全点）停下来开始GC</strong></p>\n<blockquote>\n<p>安全点的选择不能选得太少让GC等待时间过长，也不能选得太多让程序长时间执行。所以选择的地方的特征是<strong>指令序列复用</strong>，例如方法调用、循环跳转、异常跳转等。</p>\n</blockquote>\n<p>如何在GC发生是让所有线程都”跑”到最近的安全点？</p>\n<ol>\n<li>抢先式中断<blockquote>\n<p>不需要线程的执行代码主动去配合，首先把所有线程中断，然后让没有到安全点的线程，跑到安全点上</p>\n</blockquote>\n</li>\n<li>主动式中断<blockquote>\n<p>不直接对线程操作，仅仅简单地设置一个标志，各个线程执行是主动轮询这个标志</p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h3 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h3><p>如果在程序线程处于Sleep状态或者Blocked状态时，线程无法响应JVM中断请求，走到安全点去挂起。对于这种情况就需要安全区域来解决</p>\n<p>即安全区域是指在一段代码之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的，我们也可以把安全区看做是被扩展了的安全点。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"四、分区思想\"><a href=\"#四、分区思想\" class=\"headerlink\" title=\"四、分区思想\"></a>四、分区思想</h2><p>分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代），但 JVM 中其实还有一个分区思想，即将<strong>整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收</strong>，这种算法的好处是可以控制一次回收多少个区间，可以较好地控制 GC 时间。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"五、垃圾回收器\"><a href=\"#五、垃圾回收器\" class=\"headerlink\" title=\"五、垃圾回收器\"></a>五、垃圾回收器</h2><h3 id=\"5-1-串形-Serial-回收器\"><a href=\"#5-1-串形-Serial-回收器\" class=\"headerlink\" title=\"5.1 串形(Serial)回收器\"></a>5.1 串形(Serial)回收器</h3><p>串行回收器是指使用<strong>单线程</strong>进行垃圾回收的回收器。因为每次回收时只有一个线程，因此串行回收器<strong>在并发能力较弱的计算机上，其专注性和独占性的特点往往能让其有更好的性能表现。</strong></p>\n<p>串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收器和老年代串行回收器。</p>\n<h4 id=\"5-1-1-新生代串行回收器\"><a href=\"#5-1-1-新生代串行回收器\" class=\"headerlink\" title=\"5.1.1 新生代串行回收器\"></a>5.1.1 新生代串行回收器</h4><p>在新生代串行回收器中使用的是<strong>复制算法</strong>。在串行回收器进行垃圾回收时，会触发<code>Stop-The-World</code>现象，即其他线程都需要暂停，等待垃圾回收完成。因此在某些情况下，其会造成较为糟糕的用户体验。</p>\n<hr>\n<h4 id=\"5-1-2-老年代串行回收器\"><a href=\"#5-1-2-老年代串行回收器\" class=\"headerlink\" title=\"5.1.2 老年代串行回收器\"></a>5.1.2 老年代串行回收器</h4><p>在老年代串行回收器中使用的是<strong>标记整理算法</strong>。其与新生代串行收集器一样，只能串行、独占式地进行垃圾回收，因此也经常会有较长时间的 Stop-The-World 发生。</p>\n<p>但老年代串行回收器的好处之一，就是其<strong>可以与多种新生代回收器配合使用</strong>。</p>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"5-2-并行回收器\"><a href=\"#5-2-并行回收器\" class=\"headerlink\" title=\"5.2 并行回收器\"></a>5.2 并行回收器</h3><h4 id=\"5-2-1-新生代ParNew回收器\"><a href=\"#5-2-1-新生代ParNew回收器\" class=\"headerlink\" title=\"5.2.1 新生代ParNew回收器\"></a>5.2.1 新生代ParNew回收器</h4><p><strong>串行回收器的多线程版本</strong>，其回收策略、算法以及参数和新生代串行回收器一样。</p>\n<p>新生代 ParNew 回收器同样使用复制算法的垃圾回收算法，其垃圾收集过程中同样会触发<code>Stop-The-World</code>现象。但因为其使用多线程进行垃圾回收，因此<strong>在并发能力强的CPU上，其产生的停顿时间要短于串行回收器</strong>。</p>\n<p>但在<strong>单CPU或并能能力弱</strong>的系统中，并行回收器效果会因为线程切换的原因，其实际表现<strong>反而不如串行回收器</strong>。</p>\n<hr>\n<h4 id=\"5-2-2-新生代Parallel-GC回收器\"><a href=\"#5-2-2-新生代Parallel-GC回收器\" class=\"headerlink\" title=\"5.2.2 新生代Parallel GC回收器\"></a>5.2.2 新生代Parallel GC回收器</h4><p>新生代 Parallel GC 回收器与新生代 ParNew 回收器非常类似，其也是<strong>使用复制算法，都是多线程、独占式的收集器，也会导致 Stop-The-World</strong>。但其余 ParNew 回收器的一个重大不同是：其<strong>非常注重系统的吞吐量</strong></p>\n<p>之所以说新生代 Parallel GC 回收器非常注重系统吞吐量，是因为其有一个自适应GC调节策略</p>\n<hr>\n<h4 id=\"5-2-3-老年代-ParallelOldGC-回收器\"><a href=\"#5-2-3-老年代-ParallelOldGC-回收器\" class=\"headerlink\" title=\"5.2.3 老年代 ParallelOldGC 回收器\"></a>5.2.3 老年代 ParallelOldGC 回收器</h4><p>老年代 ParallelOldGC 回收器也是一种多线程并发的回收器，与新生代ParallelGC收集器一样，其<strong>也是注重吞吐量的收集器，只不过其是作用于老年代</strong>。</p>\n<p>ParallelOldGC回收器使用的是<strong>标记整理算法</strong>，只有在 JDK1.6中才可以使用。</p>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"5-3-CMS回收器\"><a href=\"#5-3-CMS回收器\" class=\"headerlink\" title=\"5.3 CMS回收器\"></a>5.3 CMS回收器</h3><p>CMS 回收器<strong>主要关注系统停顿时间</strong>。CMS回收器全称为 Concurrent Mark Sweep，意为<strong>标记清除</strong>算法，其是一个使用<strong>多线程并行回收</strong>的垃圾回收器。</p>\n<p>CMS 的主要工作步骤有：</p>\n<ol>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>重新标记<blockquote>\n<p>为了修正标记期间因程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记阶段时间较长，但远小于并发标记</p>\n</blockquote>\n</li>\n<li>并发清除<blockquote>\n<p>耗时最长的并发标记和并发清除线程都可以与用户线程并发执行</p>\n</blockquote>\n</li>\n</ol>\n<p>优点：</p>\n<ul>\n<li>并发收集低停顿</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>对CPU资源非常敏感</li>\n<li>无法处理浮动资源<blockquote>\n<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，只能等待下一次GC,这些垃圾就被称为浮动垃圾</p>\n</blockquote>\n</li>\n<li>会出现空间碎片<blockquote>\n<p>基于标记-清理算法</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"5-4-G1收集器\"><a href=\"#5-4-G1收集器\" class=\"headerlink\" title=\"5.4 G1收集器\"></a>5.4 G1收集器</h3><p>G1 回收器是 JDK 1.7 中使用的全新垃圾回收器，从长期目标来看，其是为了取代 CMS 回收器。</p>\n<p>G1 回收器拥有独特的垃圾回收策略，和之前所有垃圾回收器采用的垃圾回收策略不同。从分代看，G1 依然属于分代垃圾回收器。但它<strong>最大的改变是使用了分区算法</strong>，从而<strong>使得 Eden 区、From 区、Survivor 区和老年代等各块内存不必连续</strong>。</p>\n<p>工作过程：</p>\n<ol>\n<li>初始标记<blockquote>\n<p>耗时较短，仅仅标记一下GC Roots能够直接关联到的对象</p>\n</blockquote>\n</li>\n<li>并发标记<blockquote>\n<p>耗时较长，进行可达性分析，找出存活的对象</p>\n</blockquote>\n</li>\n<li>最终标记<blockquote>\n<p>修正在并发标记过程中因用户程序继续运行而导致的标记变动的那一部分</p>\n</blockquote>\n</li>\n<li>筛选回收<blockquote>\n<p>首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划</p>\n</blockquote>\n</li>\n</ol>\n<p>特点：</p>\n<ul>\n<li>并行和并发</li>\n<li>分代收集</li>\n<li>空间整合<blockquote>\n<p>基于<strong>标记-整理</strong>算法</p>\n</blockquote>\n</li>\n<li>可预测的停顿<blockquote>\n<p>通过建立一个可预测的停顿时间模型，使得消耗在垃圾收集上的时间不得超过可预测的时间。之所以能够建立一个可预测的停顿时间模型，是因为它在后台维护了一个优先列表，每次优先收集价值最大的Region，有效地提高收集效率。</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"六、内存分配和回收策略\"><a href=\"#六、内存分配和回收策略\" class=\"headerlink\" title=\"六、内存分配和回收策略\"></a>六、内存分配和回收策略</h2><p>Java对象的内存分配，大方向来讲，就是在堆上分配（但也有可能经过JIT编译后被拆散为标量类型并间接地在栈上分配)</p>\n<p>对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按照线程优先在TLAB上分配，少数情况下也会直接在老年代中分配，分配规则并不是固定不变的，其细节取决于使用的哪一种垃圾回收器组合以及虚拟机的相关参数设置。</p>\n<p>以下是几条最普遍的内存分配规则：</p>\n<h3 id=\"6-1-对象优先在Eden分配\"><a href=\"#6-1-对象优先在Eden分配\" class=\"headerlink\" title=\"6.1 对象优先在Eden分配\"></a>6.1 对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC</p>\n<hr>\n<h3 id=\"6-2-大对象直接进入老年代\"><a href=\"#6-2-大对象直接进入老年代\" class=\"headerlink\" title=\"6.2 大对象直接进入老年代\"></a>6.2 大对象直接进入老年代</h3><p>大对象是指需要大量连续内存空间的Java对象，最典型的就是那种很长的字符串或者数组</p>\n<hr>\n<h3 id=\"6-3-长期存活的对象将进入老年代\"><a href=\"#6-3-长期存活的对象将进入老年代\" class=\"headerlink\" title=\"6.3 长期存活的对象将进入老年代\"></a>6.3 长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄计数器。<strong>如果对象在Eden出生并经过一此Minor GC后仍然存错，并且被Survivor容纳的话，就将对象年龄设为1，此后每经历过一此Minor GC,对象年龄就加1，当年龄增加到一定程度时（默认为15）,就晋升到老年代</strong>。</p>\n<hr>\n<h3 id=\"6-4-动态对象年龄判定\"><a href=\"#6-4-动态对象年龄判定\" class=\"headerlink\" title=\"6.4 动态对象年龄判定\"></a>6.4 动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，<strong>如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>。</p>\n<hr>\n<h3 id=\"6-5-空间担保分配\"><a href=\"#6-5-空间担保分配\" class=\"headerlink\" title=\"6.5 空间担保分配\"></a>6.5 空间担保分配</h3><p><strong>虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>，如果这个条件成立，那么可以确认Minor GC是安全的。如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败？如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试进行一次Minor GC,尽管这次是有风险的。如果小于或者HandlePromotionFailure设置不允许冒险，那这是也要改为进行一次Full GC。</p>\n<p>什么是冒险？前面提到过新生代使用复制收集算法，但为了提升内存利用率。只使用其中一个survivor空间作为备份。因此当出现大量对象在Minor GC后仍然存活的情况。就需要老年代进行分担,把survivor无法容纳的对象直接进入老年代。前提是老年代本身还有容纳这些对象的剩余空间。<strong>有多少对象会活下来，在实际完成内存回收之前是无法明确知道。所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值与剩余老年代的剩余空间进行比较。</strong>决定是否进行一次Full GC让老年代腾出更多空间。</p>\n<p>如果担保失败的话，就只好在担保失败后重新发起一次Full GC.</p>\n<h2 id=\"七、垃圾回收的几种类型\"><a href=\"#七、垃圾回收的几种类型\" class=\"headerlink\" title=\"七、垃圾回收的几种类型\"></a>七、垃圾回收的几种类型</h2><h3 id=\"7-1-Minor-GC\"><a href=\"#7-1-Minor-GC\" class=\"headerlink\" title=\"7.1 Minor GC\"></a>7.1 Minor GC</h3><p><strong>新生代空间回收内存被称为 Minor GC</strong>，有时候也称之为 Young GC。对于 Minor GC，你需要知道的一些点：</p>\n<ul>\n<li><p>JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以 Eden 区越小，越频繁执行 Minor GC。</p>\n</li>\n<li><p>当年轻代中的 Eden 区分配满的时候，年轻代中的部分对象会晋升到老年代，所以 Minor GC 后老年代的占用量通常会有所升高。</p>\n</li>\n<li><p>质疑常规的认知，所有的 Minor GC 都会触发 Stop-The-World，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的，因为大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果情况相反，即 Eden 区大部分新生对象不符合 GC 条件（即他们不被垃圾回收器收集），那么 Minor GC 执行时暂停的时间将会长很多（因为他们要JVM要将他们复制到 Survivor 区或老年代）。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"7-2-Major-GC\"><a href=\"#7-2-Major-GC\" class=\"headerlink\" title=\"7.2 Major GC\"></a>7.2 Major GC</h3><p><strong>从老年代空间回收内存被称为 Major GC</strong>，有时候也称之为 Old GC。</p>\n<p><strong>许多 Major GC 是由 Minor GC 触发的</strong>，所以很多情况下将这两种 GC 分离是不太可能的。</p>\n<blockquote>\n<p>Minor GC 作用于新生代，Major GC 作用于老年代。 分配对象内存时发现内存不够，触发 Minor GC。Minor GC 会将对象移到老年代中，如果此时老年代空间不够，那么触发 Major GC。因此才会说，许多 Major GC 是由 Minor GC 引起的。</p>\n</blockquote>\n<hr>\n<h3 id=\"7-3-Full-GC\"><a href=\"#7-3-Full-GC\" class=\"headerlink\" title=\"7.3 Full GC\"></a>7.3 Full GC</h3><p><strong>Full GC 是清理整个堆空间 —— 包括年轻代、老年代和永久代（如果有的话）</strong>。因此 Full GC 可以说是 Minor GC 和 Major GC 的结合。</p>\n<blockquote>\n<p>当准备要触发一次 Minor GC 时，如果发现年轻代的剩余空间比以往晋升的空间小，则不会触发 Minor GC 而是转为触发 Full GC。因为JVM此时认为：之前这么大空间的时候已经发生对象晋升了，那现在剩余空间更小了，那么很大概率上也会发生对象晋升。既然如此，那么我就直接帮你把事情给做了吧，直接来一次 Full GC，整理一下老年代和年轻代的空间。</p>\n</blockquote>\n<blockquote>\n<p>另外，即在永久代分配空间但已经没有足够空间时，也会触发 Full GC。</p>\n</blockquote>\n<h3 id=\"7-4-Stop-The-World\"><a href=\"#7-4-Stop-The-World\" class=\"headerlink\" title=\"7.4 Stop-The-World\"></a>7.4 Stop-The-World</h3><p>Stop-The-World，中文一般翻译为全世界暂停，是指<strong>在进行垃圾回收时因为标记或清理的需要，必须让所有执行任务的线程停止执行任务，从而让垃圾回收线程回收垃圾的时间间隔。</strong></p>\n<p>在 Stop-The-World 这段时间里，<strong>所有非垃圾回收线程都无法工作</strong>，都暂停下来。只有等到垃圾回收线程工作完成才可以继续工作。可以看出，Stop-The-World 时间的长短将关系到应用程序的响应时间，因此在 GC 过程中，Stop-The-World 的时间是一个非常重要的指标。</p>\n<h2 id=\"推荐文章：\"><a href=\"#推荐文章：\" class=\"headerlink\" title=\"推荐文章：\"></a>推荐文章：</h2><blockquote>\n<p><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第8讲：JVM 垃圾回收机制</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第9讲：JVM垃圾回收器</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第10讲：垃圾回收的几种类型</a></p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br>[2]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html</a><br>[3]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html</a><br>[4]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html</a></p>"},{"title":"JVM学习笔记——推荐文章","declare":true,"wordCount":true,"abbrlink":"3ad27f93","date":"2020-07-01T23:30:10.000Z","_content":"\n* [陈树义 JVM基础系列开篇：为什么要学虚拟机？](https://www.cnblogs.com/chanshuyi/p/jvm_serial_00_why_learn_jvm.html)\n* [陈树义 JVM基础系列第1讲：Java 语言的前世今生](https://www.cnblogs.com/chanshuyi/p/jvm_serial_01_the_history_of_java.html)\n* [陈树义 JVM基础系列第2讲：Java 虚拟机的历史](https://www.cnblogs.com/chanshuyi/p/jvm_serial_02_the_history_of_jvm.html)\n* [陈树义 JVM基础系列第3讲：到底什么是虚拟机？](https://www.cnblogs.com/chanshuyi/p/jvm_serial_03_the_nature_of_jvm.html)\n* [陈树义 JVM基础系列第4讲：从源代码到机器码，发生了什么？](https://www.cnblogs.com/chanshuyi/p/jvm_serial_04_from_source_code_to_machine_code.html)\n* [陈树义 JVM基础系列第5讲：字节码文件结构](https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html)\n* [陈树义 JVM基础系列第6讲：Java 虚拟机内存结构](https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html)\n* [陈树义 JVM基础系列第7讲：JVM 类加载机制](https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html)\n* [陈树义 JVM基础系列第8讲：JVM 垃圾回收机制](https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html)\n* [陈树义 JVM基础系列第9讲：JVM垃圾回收器](https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html)\n* [陈树义 JVM基础系列第10讲：垃圾回收的几种类型](https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html)\n* [Java虚拟机（JVM）你只要看这一篇就够了！](https://blog.csdn.net/qq_41701956/article/details/81664921)\n* [Java虚拟机JVM学习笔记](https://blog.csdn.net/x_panda/article/details/14215819)","source":"_posts/code/JVM/JVM学习笔记——推荐文章.md","raw":"---\ntitle: JVM学习笔记——推荐文章\ncategories: Code\ntags: JVM\ndeclare: true\nwordCount: true\nabbrlink: 3ad27f93\ndate: 2020-07-02 07:30:10\n---\n\n* [陈树义 JVM基础系列开篇：为什么要学虚拟机？](https://www.cnblogs.com/chanshuyi/p/jvm_serial_00_why_learn_jvm.html)\n* [陈树义 JVM基础系列第1讲：Java 语言的前世今生](https://www.cnblogs.com/chanshuyi/p/jvm_serial_01_the_history_of_java.html)\n* [陈树义 JVM基础系列第2讲：Java 虚拟机的历史](https://www.cnblogs.com/chanshuyi/p/jvm_serial_02_the_history_of_jvm.html)\n* [陈树义 JVM基础系列第3讲：到底什么是虚拟机？](https://www.cnblogs.com/chanshuyi/p/jvm_serial_03_the_nature_of_jvm.html)\n* [陈树义 JVM基础系列第4讲：从源代码到机器码，发生了什么？](https://www.cnblogs.com/chanshuyi/p/jvm_serial_04_from_source_code_to_machine_code.html)\n* [陈树义 JVM基础系列第5讲：字节码文件结构](https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html)\n* [陈树义 JVM基础系列第6讲：Java 虚拟机内存结构](https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html)\n* [陈树义 JVM基础系列第7讲：JVM 类加载机制](https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html)\n* [陈树义 JVM基础系列第8讲：JVM 垃圾回收机制](https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html)\n* [陈树义 JVM基础系列第9讲：JVM垃圾回收器](https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html)\n* [陈树义 JVM基础系列第10讲：垃圾回收的几种类型](https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html)\n* [Java虚拟机（JVM）你只要看这一篇就够了！](https://blog.csdn.net/qq_41701956/article/details/81664921)\n* [Java虚拟机JVM学习笔记](https://blog.csdn.net/x_panda/article/details/14215819)","slug":"code/JVM/JVM学习笔记——推荐文章","published":1,"updated":"2020-07-07T06:19:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1g3003o0w7t7j1x0p5s","content":"<ul>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_00_why_learn_jvm.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列开篇：为什么要学虚拟机？</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_01_the_history_of_java.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第1讲：Java 语言的前世今生</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_02_the_history_of_jvm.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第2讲：Java 虚拟机的历史</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_03_the_nature_of_jvm.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第3讲：到底什么是虚拟机？</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_04_from_source_code_to_machine_code.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第4讲：从源代码到机器码，发生了什么？</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第5讲：字节码文件结构</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第6讲：Java 虚拟机内存结构</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第7讲：JVM 类加载机制</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第8讲：JVM 垃圾回收机制</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第9讲：JVM垃圾回收器</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第10讲：垃圾回收的几种类型</a></li>\n<li><a href=\"https://blog.csdn.net/qq_41701956/article/details/81664921\" target=\"_blank\" rel=\"noopener\">Java虚拟机（JVM）你只要看这一篇就够了！</a></li>\n<li><a href=\"https://blog.csdn.net/x_panda/article/details/14215819\" target=\"_blank\" rel=\"noopener\">Java虚拟机JVM学习笔记</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_00_why_learn_jvm.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列开篇：为什么要学虚拟机？</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_01_the_history_of_java.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第1讲：Java 语言的前世今生</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_02_the_history_of_jvm.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第2讲：Java 虚拟机的历史</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_03_the_nature_of_jvm.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第3讲：到底什么是虚拟机？</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_04_from_source_code_to_machine_code.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第4讲：从源代码到机器码，发生了什么？</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第5讲：字节码文件结构</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_06_jvm_memory_model.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第6讲：Java 虚拟机内存结构</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第7讲：JVM 类加载机制</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_08_jvm_garbage_collection.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第8讲：JVM 垃圾回收机制</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_09_jvm_garabage_collector.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第9讲：JVM垃圾回收器</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_10_gc_type.html\" target=\"_blank\" rel=\"noopener\">陈树义 JVM基础系列第10讲：垃圾回收的几种类型</a></li>\n<li><a href=\"https://blog.csdn.net/qq_41701956/article/details/81664921\" target=\"_blank\" rel=\"noopener\">Java虚拟机（JVM）你只要看这一篇就够了！</a></li>\n<li><a href=\"https://blog.csdn.net/x_panda/article/details/14215819\" target=\"_blank\" rel=\"noopener\">Java虚拟机JVM学习笔记</a></li>\n</ul>\n"},{"abbrlink":"181f0b61","_content":"\n**虚拟机的类加载机制就是虚拟机把Java类的源码编译为*字节码*后，将其*读取进内存*，并对数据进行校验、转换解析和初始化、最终形成可以被虚拟机直接使用的Java类型。**\n\n![类加载机制](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200703214206.png)\n\n<!-- more -->\n\n## 一、类加载的时机\n\n类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：**加载、验证、准备、解析、初始化、使用、卸载**7个阶段。其中验证、准备、解析三个阶段统称为连接。\n![类加载过程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/类加载过程.png)\n>其中解析的阶段的顺序可能会发生变化，某些情况下可能会在初始化后再开始，另外**注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成**，因为这些阶段**通常都是互相交叉地混合进行**的，通常在一个阶段执行的过程中调用或激活另一个阶段。\n\n什么时候需要进行类加载的第一个阶段是由**虚拟机的具体实现来自由把握的**。\n\n\n<br><br>\n\n***\n\n<br><br>\n\n\n## 二、类加载的过程\n\n### 2.1 加载\n\n加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是**将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中**，接着会为这个类在 **JVM 的方法区创建一个对应的 Class 对象**，这个 Class 对象就是这个类各种**数据的访问入口**。\n\n* 从哪里去加载字节码文件\n    * 本地磁盘\n    * 网上加载.class文件（Applet）\n    * 从数据库中\n    * 压缩文件中（ZAR，jar等）\n    * 从其他文件生成的（JSP应用）\n\n    对于非数组类的加载阶段，可以使用系统提供的引导加载类，也可以使用自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。（重写一个类加载器的`loadClass()`方法）\n\n    对于数组类，**其本身由Java虚拟机直接创建的**，但数据类的**元素类型最终还是要靠类加载器去创建的**\n\n***\n\n### 2.2 验证\n当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。\n\n其目的是**确保Class文件中的字节流包含的信息符合档期那虚拟机的要求，并不会危害虚拟机自身的安全。**对于虚拟机的类加载机制来说，验证阶段是非常重要的，但**不是一定必要的**，如果运行的全部代码都已经被反复使用和验证过，那么在实施阶段可以考虑使用某些参数来关闭类验证，以缩短虚拟机类加载的时间。\n\n\n验证阶段主要完成以下4个阶段的校验动作：\n\n1. **文件格式验证**\n    验证字节流是否符合Class文件格式的规范，而且能够被当前版本的虚拟机处理，可能会包含以下验证点：\n    * 是否以魔数`0cCAFEBABE`开头\n    * 主次版本号是否在当前虚拟机处理范围之类\n    * 常量池的常量中是否有不被支持的类型\n    ······\n\n2. **元数据验证**\n    对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，可能会包含以下验证点：\n    * 这个类是否有父类（除java.lang.Object以外，所有的类都应当有父类）\n    * 这个类的父类是否继承了不被允许的类（例如被final修饰的类）\n    * 如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的所有方法\n    * 类中的字段是否会和父类产生矛盾（例如覆盖了父类的final字段，或者不符合规则的重载）\n    ······\n\n3. **字节码验证**\n    通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。保证被校验类在运行时不会做出危害虚拟机安全的事情，可能会包含以下验证点：\n    * 保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作。例如不会出现：在操作栈放置了一个int类型的数据，使用时却按照long类型载入本地变量表中\n    * 保证跳转指令不会跳转到方法体以外的字节码指令上\n    * 保证方法体中的类型转换是有效的，比如不能把父类对象赋值给子类数据类型\n    ······\n\n    如果一个类通过字节码验证，**也不能够说明其一定是安全的**\n    >\"**Halting Problem问题**\"：通过程序去校验程序逻辑是无法做到绝对准确的\n\n4. **符号应用验证**\n    符号引用验证可以看做是类自身以外（常量池中的各种符号引用）的信息进行匹配性验证。可能会包含以下验证点：\n    >此阶段发生在虚拟机将符号应用转换为直接引用的时候，即发生在连接的第三阶段——解析阶段中。\n\n    * 符号引用中通过字符串描述的全限定名是否能找到对应的类\n    * 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段\n    * 符号引用中的类、字段、方法的访问性是否可以被当前类访问\n    ······\n\n***\n\n### 2.3 准备\n当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即**内存分配的对象**以及**变量初始值的设置。**\n\n* 内存分配的对象\n\n    Java 中的变量有**类变量**和**类成员变量**两种类型，\n\n    **被static修饰的变量为类变量**，**而其他所有类型的变量都属类成员变量**。在准备阶段，**JVM 只会为类变量分配内存，而不会为类成员变量分配内存**。\n\n    **类成员变量的内存分配需要等到初始化阶段和对象一起分配在Java堆中**\n\n\n* 变量初始值的设置\n\n    在准备阶段，JVM 会为类变量分配内存，并为其初始化。**但是这里的初始化指的是为变量赋予Java语言中该数据类型的零值，而不是用户代码里初始化的值**。\n    >例如`public static int value = 123;`那么变量在准备阶段过后的初始值是0而不是123，因为这时候尚未执行Java方法。\n\n    特殊情况：\n    如果类字段的字段属性表中存在`ConstantValue`属性（例如 **static final**修饰的变量），那么在准备阶段变量value就会被初始化为ConstantValue属性所指定的值\n\n***\n\n### 2.4 解析\n\n解析阶段就是虚拟机将**常量池内的符号引用替换为直接引用**的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。\n>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量\n\n>直接应用：可以是直接执行目标的指针，相对偏移量或者一格能够直接定位到目标的句柄\n\n***\n\n### 2.5 初始化\n初始化时类加载过程的最后一步，到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。\n\n对于初始化阶段，虚拟机**严格规定了有且只有5中情况下必须对类进行初始化**：\n* 遇到 **new、getstatic、putstatic、invokestatic** 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：**使用new关键字实例化对象的时候、读取或设置一个类的静态字段**（**被final修饰、已在编译器把结果放入常量池的静态字段除外**）的时候，以及调用一个类的静态方法的时候。\n* **使用 java.lang.reflect 包的方法对类进行反射调用**的时候，如果类没有进行过初始化，则需要先触发其初始化。\n* 当初始化一个类的时候，如果发现**其父类还没有进行过初始化**，则需要先触发其父类的初始化。\n* 当虚拟机启动时，用户需要**指定一个要执行的主类**（包含main()方法的那个类），虚拟机会先初始化这个主类。\n* 当使用 JDK1.7 动态语言支持时，如果一个 **java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄**，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。\n\n<br>\n\n接口的加载过程和类的加载过程**稍有不同**：\n* 接口中不能使用**static{}**语句块，但是编译器仍然会为接口生成`<client>()`类构造器，用于初始化接口中所定义的成员变量。\n* 当一个类在初始化时，要求其父类全部已经都被初始化了，但是一个接口在初始化时，**并不要求其父接口全部已经初始化，只有真正使用到父接口时才会被初始化**。\n\n\n从另外一个角度来说：**初始化阶段是执行类构造器`<clinit>()`的过程**\n\n* `<clinit>()`类初始化方法，编译器会按照其出现顺序，收集**类变量的赋值语句、静态代码块**，最终组成类初始化方法。类初始化方法一般在**类初始化的时候执行**。\n例如：\n```java\n    static\n    {\n        System.out.println(\"静态代码块\");\n    }\n    static int a = 1;\n```\n\n* `<init>()`实例构造器，编译器会按照其出现顺序，收集**成员变量的赋值语句、普通代码块**，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在**实例化类对象的时候执行**。\n例如：\n```java\n     {\n        System.out.println(\"普通代码块\");\n    }\n    int b = 110;\n```\n\n* `<clinit>()`方法与实例构造器(<init>())方法不同，它不需要显式地调用父类构造器， 虚拟机会保证在**子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕。**\n\n* 由于父类的`<clinit>()`方法先执行，也就意味着**父类中定义的静态语句块要优先于子类的变量赋值操作**。\n\n* 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中能够被正确地加速、同步，**如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的`<clinit>()`方法**，其他线程都需要**阻塞等待**，直到活动线程执行`<clinit>()`方法完毕。\n\n***\n\n### 2.6 使用\n当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。\n\n***\n\n### 2.7 卸载\n\n当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。\n\n\n<br><br>\n\n***\n\n<br><br>\n\n## 三、类加载器\n>**通过一个类的全限定名来获取此类的二进制字节流并将其加载到JVM内存中，转化为Class对象**，这个动作**被放到Java虚拟机外部去实现**，以便让应用程序自己决定如何去获取所需要的类，\n\n实现这个动作的代码模块被称为**类加载器**。\n\n### 3.1 类与类加载器\n类加载器虽然只用于实现类的加载动作，但它在Java程序中的作用却远远不限于类加载阶段。\n\n**对于任意一个类，都需要由加载它的类加载器和这个类本身异同确立其在Java虚拟机中的唯一性**，每一个类都拥有一个独立的类名称空间。\n>**比较两个类是否相等，只有在这个两个类是由同一个类加载器加载的前提下才有意义**，即使两个类来源于同一个Class文件，但是由于加载他们的类加载器不同，那么这两个类也必然不同。\n\n****\n\n### 3.2 类加载的三种方式\n\n* 通过命令行启动应用时由**JVM初始化加载含有main()方法的主类**。\n\n* 通过**Class.forName()方法动态加载**，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。\n\n* 通过**ClassLoader.loadClass()方法动态加载**，不会执行初始化块。\n\n****\n\n### 3.3 Java语言自带的三个类加载器\n* **Bootstrap ClassLoader** ：最顶层的加载类，主要加载核心类库，也就是我们环境变量下面%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。（C++实现）\n\n* **Extention ClassLoader** ：扩展的类加载器，加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。\n\n* **Appclass Loader**：也称为SystemAppClass。 加载当前应用的classpath的所有类\n\n\n****\n\n### 3.4 双亲委派模型\n\n应用程序都是由这**三种类加载器互相配合进行加载的**，如果有必要，我们还可以加入自定义的类加载器。\n\n**这几种类加载器之间的层次关系，称为双亲委派模型。**\n\n双亲委派模型要求**除了顶层的启动加载器外，其余的类加载器都应当有自己的父类加载器**。这里的**类加载器之间的父子关系一般都不会以继承的关系来实现**，而是都**使用组合关系来复用父加载器的代码**。\n\n![双亲委派模型](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/双亲委派模型.png)\n\n\n* 双亲委派机制工作过程：\n\n    如果一个类加载器收到了类加载的请求.它**首先不会自己去尝试加载这个类.而是把这个请求委派给父加载器去完成,每个层次的类加载器都是如此**.因此**所有的加载请求最终都会传送到Bootstrap类加载器**(启动类加载器)中.**只有父类加载返回自己无法加载这个请求(它的搜索范围中没有找到所需的类)时.子加载器才会尝试自己去加载**。\n\n    >比如说，另外一个人给小费，自己不会先去直接拿来塞自己钱包，我们先把钱给领导，领导再给领导，一直到公司老板，老板不想要了，再一级一级往下分。老板要是要这个钱，下面的领导和自己就一分钱没有了。\n\n<br>\n\n>子类先委托父类加载\n\n>父类加载器有自己的加载范围，范围内没有找到，则不加载，**并返回给子类**\n\n>子类在收到父类无法加载的时候，才会自己去加载\n\n\n* 优势\n    Java类随着它的类加载器一起具备了一种**优先级的层次关系，保证了Java程序的稳定运行**。\n>例如无论哪一个类加载器加载一个类，最终都是委派到处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载环境中都是同一个类。相反，如果没有这种机制，由各个类自行去加载的话，那么系统中将会出现多个不同的Objec类，Java体系中最基础的行为也就无法保证，应用程序也会变得一片混乱。\n\n>在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么**类之间的比较结果及类的唯一性将无法保证**，因此，为什么需要双亲委派模型？**防止内存中出现多份同样的字节码**\n\n* 双亲委派模型的实现\n\n    先检查是否已经被加载过，若没有被加载过则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父类加载器，如果加载失败，则再调用自己的findClass()方法。\n\n\n```java\n    protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                \t//先判断parent是否为空，如果不为空，先尝试用父类加载器加载；如果为空，则先尝试用类启动加载器加载\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // 如果父类加载器抛出ClassNotFoundException异常则说明父类加载器无法完成加载请求\n                }\n                if (c == null) {\n                    //如果父类加载器没加载成功，则调用findClass尝试自己加载这个类\n                    c = findClass(name);\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n\n```\n****\n\n### 3.5 破坏双亲委派模型\n\n在某些情况下**父类加载器需要委托子类加载器去加载class文件**。受到加载范围的限制，父类加载器无法加载到需要的文件。\n\n>以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。\n\n<br><br>\n\n***\n\n<br><br>\n\n## 四、实例分析\n>转载自[JVM基础系列第7讲：JVM 类加载机制](https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html)\n\n### 4.1\n\n```java\npublic class Book {\n    public static void main(String[] args)\n    {\n        System.out.println(\"Hello ShuYi.\");\n    }\n\n    Book()\n    {\n        System.out.println(\"书的构造方法\");\n        System.out.println(\"price=\" + price +\",amount=\" + amount);\n    }\n\n    {\n        System.out.println(\"书的普通代码块\");\n    }\n\n    int price = 110;\n\n    static\n    {\n        System.out.println(\"书的静态代码块\");\n    }\n\n    static int amount = 112;\n}\n\n```\n\n最后的输出字符串为\n>书的静态代码块     \n>Hello ShuYi.\n\n>下面我们来简单分析一下，首先根据上面说到的触发初始化的5种情况的第4种（**当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类**），我们会进行类的初始化。初始化会按照顺序进行，\n\n并且此处没有 Book 类对象的实例化，所以`<init>()`方法不会被执行\n\n\n\n\n\n***\n\n\n### 4.2\n```java\nclass Grandpa\n{\n    static\n    {\n        System.out.println(\"爷爷在静态代码块\");\n    }\n}    \nclass Father extends Grandpa\n{\n    static\n    {\n        System.out.println(\"爸爸在静态代码块\");\n    }\n\n    public static int factor = 25;\n\n    public Father()\n    {\n        System.out.println(\"我是爸爸~\");\n    }\n}\nclass Son extends Father\n{\n    static \n    {\n        System.out.println(\"儿子在静态代码块\");\n    }\n\n    public Son()\n    {\n        System.out.println(\"我是儿子~\");\n    }\n}\npublic class InitializationDemo\n{\n    public static void main(String[] args)\n    {\n        System.out.println(\"爸爸的岁数:\" + Son.factor);\t//入口\n    }\n}\n\n```\n最后的输出字符串为\n>爷爷在静态代码块     \n>爸爸在静态代码块    \n>爸爸的岁数:25    \n\n<br>\n\n也许会有人问为什么没有输出「儿子在静态代码块」这个字符串？\n\n这是因为**对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块）**。因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。\n\n对面上面的这个例子，我们可以从入口开始分析一路分析下去：\n\n>首先程序到 main 方法这里，使用标准化输出 Son 类中的 factor 类成员变量，但是 Son 类中并没有定义这个类成员变量。于是往父类去找，我们在 Father 类中找到了对应的类成员变量，于是触发了 Father 的初始化。\n\n>但根据我们上面说到的初始化的 5 种情况中的第 3 种（当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化）。我们需要先初始化 Father 类的父类，也就是先初始化 Grandpa 类再初始化 Father 类。于是我们先初始化 Grandpa 类输出：「爷爷在静态代码块」，再初始化 Father 类输出：「爸爸在静态代码块」。\n\n>最后，所有父类都初始化完成之后，Son 类才能调用父类的静态变量，从而输出：「爸爸的岁数：25」。\n\n***\n\n### 4.3\n\n```java\nclass Grandpa\n{\n    static\n    {\n        System.out.println(\"爷爷在静态代码块\");\n    }\n\n    public Grandpa() {\n        System.out.println(\"我是爷爷~\");\n    }\n}\nclass Father extends Grandpa\n{\n    static\n    {\n        System.out.println(\"爸爸在静态代码块\");\n    }\n\n    public Father()\n    {\n        System.out.println(\"我是爸爸~\");\n    }\n}\nclass Son extends Father\n{\n    static \n    {\n        System.out.println(\"儿子在静态代码块\");\n    }\n\n    public Son()\n    {\n        System.out.println(\"我是儿子~\");\n    }\n}\npublic class InitializationDemo\n{\n    public static void main(String[] args)\n    {\n        new Son(); \t//入口\n    }\n}\n```\n\n最后的输出字符串为\n>爷爷在静态代码块     \n>爸爸在静态代码块     \n>儿子在静态代码块     \n>我是爷爷~     \n>我是爸爸~     \n>我是儿子~     \n\n<br>\n\n>让我们仔细来分析一下上面代码的执行流程：\n\n>首先在入口这里我们实例化一个 Son 对象，因此会触发 Son 类的初始化，而 Son 类的初始化又会带动 Father 、Grandpa 类的初始化，从而执行对应类中的静态代码块。因此会输出：「爷爷在静态代码块」、「爸爸在静态代码块」、「儿子在静态代码块」。\n\n>当 Son 类完成初始化之后，便会调用 Son 类的构造方法，而 Son 类构造方法的调用同样会带动 Father、Grandpa 类构造方法的调用，最后会输出：「我是爷爷」、「我是爸爸」、「我是儿子~」。\n\n\n\n***\n\n### 4.4\n\n```java\npublic class Book {\n    public static void main(String[] args)\n    {\n        staticFunction();\n    }\n\n    static Book book = new Book();\n\n    static\n    {\n        System.out.println(\"书的静态代码块\");\n    }\n\n    {\n        System.out.println(\"书的普通代码块\");\n    }\n\n    Book()\n    {\n        System.out.println(\"书的构造方法\");\n        System.out.println(\"price=\" + price +\",amount=\" + amount);\n    }\n\n    public static void staticFunction(){\n        System.out.println(\"书的静态方法\");\n    }\n\n    int price = 110;\n    static int amount = 112;\n}\n```\n输出结果：\n>书的普通代码块     \n>书的构造方法     \n>price=110,amount=0     \n>书的静态代码块     \n>书的静态方法     \n\n\n>下面我们一步步来分析一下代码的整个执行流程。    \n>在上面两个例子中，因为 main 方法所在类并没有多余的代码，我们都直接忽略了 main 方法所在类的初始化。    \n>但在这个例子中，main 方法所在类有许多代码，我们就并不能直接忽略了。\n\n>* 当 JVM 在准备阶段的时候，便会为类变量分配内存和进行初始化。此时，我们的 book 实例变量被初始化为 null，amount 变量被初始化为 0。\n\n>*  当进入初始化阶段后，因为 Book 方法是程序的入口，根据我们上面说到的类初始化的五种情况的第四种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类）。所以JVM 会初始化 Book 类，即执行类构造器 。\n\n>*  JVM 对 Book 类进行初始化首先是执行类构造器（按顺序收集类中所有静态代码块和类变量赋值语句就组成了类构造器 ），后执行对象的构造器（按顺序收集成员变量赋值和普通代码块，最后收集对象构造器，最终组成对象构造器 ）。\n\n>对于 Book 类，其类构造方法（）可以简单表示如下：\n```java\nstatic Book book = new Book();\nstatic\n{\n    System.out.println(\"书的静态代码块\");\n}\nstatic int amount = 112;\n```\n>于是首先执行`static Book book = new Book();`这一条语句，这条语句又触发了类的实例化。于是 JVM 执行对象构造器 ，收集后的对象构造器 代码：\n```java\n{\n    System.out.println(\"书的普通代码块\");\n}\nint price = 110;\nBook()\n{\n    System.out.println(\"书的构造方法\");\n    System.out.println(\"price=\" + price +\", amount=\" + amount);\n}\n```\n>于是此时 price 赋予 110 的值，输出：「书的普通代码块」、「书的构造方法」。而此时 price 为 110 的值，而 amount 的赋值语句并未执行，所以只有在准备阶段赋予的零值，所以之后输出「price=110,amount=0」。\n\n>当类实例化完成之后，JVM 继续进行类构造器的初始化：\n\n```java\nstatic Book book = new Book();  //完成类实例化\nstatic\n{\n    System.out.println(\"书的静态代码块\");\n}\nstatic int amount = 112;\n```\n>即输出：「书的静态代码块」，之后对 amount 赋予 112 的值。\n\n>* 到这里，类的初始化已经完成，JVM 执行 main 方法的内容。\n\n```java\npublic static void main(String[] args)\n{\n    staticFunction();\n}\n```\n>即输出：「书的静态方法」。\n\n***\n\n### 4.5 方法论\n从上面几个例子可以看出，分析一个类的执行顺序大概可以按照如下步骤：\n\n1. **确定类变量的初始值**。在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。\n    \n2. **初始化入口方法**。当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。\n3. **初始化类构造器**。JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。\n    \n4. **初始化对象构造器**。JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。\n\n如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。\n\n\n\n\n\n\n<br><br><br>\n\n***\n\n<br><br><br>\n\n\n### 参考    \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br>\n[2]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html</a><br>\n[3]<a href=\"https://www.cnblogs.com/joemsu/p/9310226.html\">https://www.cnblogs.com/joemsu/p/9310226.html</a><br>\n[4]<a href=\"https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc\">https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc</a><br>\n[5]<a href=\"https://blog.csdn.net/qq_41701956/article/details/100074023\">https://blog.csdn.net/qq_41701956/article/details/100074023</a><br>\n</div>","source":"_posts/code/JVM/JVM学习笔记(三)——类加载机制.md","raw":"---\nabbrlink: 181f0b61\n---\n\n**虚拟机的类加载机制就是虚拟机把Java类的源码编译为*字节码*后，将其*读取进内存*，并对数据进行校验、转换解析和初始化、最终形成可以被虚拟机直接使用的Java类型。**\n\n![类加载机制](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200703214206.png)\n\n<!-- more -->\n\n## 一、类加载的时机\n\n类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：**加载、验证、准备、解析、初始化、使用、卸载**7个阶段。其中验证、准备、解析三个阶段统称为连接。\n![类加载过程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/类加载过程.png)\n>其中解析的阶段的顺序可能会发生变化，某些情况下可能会在初始化后再开始，另外**注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成**，因为这些阶段**通常都是互相交叉地混合进行**的，通常在一个阶段执行的过程中调用或激活另一个阶段。\n\n什么时候需要进行类加载的第一个阶段是由**虚拟机的具体实现来自由把握的**。\n\n\n<br><br>\n\n***\n\n<br><br>\n\n\n## 二、类加载的过程\n\n### 2.1 加载\n\n加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是**将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中**，接着会为这个类在 **JVM 的方法区创建一个对应的 Class 对象**，这个 Class 对象就是这个类各种**数据的访问入口**。\n\n* 从哪里去加载字节码文件\n    * 本地磁盘\n    * 网上加载.class文件（Applet）\n    * 从数据库中\n    * 压缩文件中（ZAR，jar等）\n    * 从其他文件生成的（JSP应用）\n\n    对于非数组类的加载阶段，可以使用系统提供的引导加载类，也可以使用自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。（重写一个类加载器的`loadClass()`方法）\n\n    对于数组类，**其本身由Java虚拟机直接创建的**，但数据类的**元素类型最终还是要靠类加载器去创建的**\n\n***\n\n### 2.2 验证\n当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。\n\n其目的是**确保Class文件中的字节流包含的信息符合档期那虚拟机的要求，并不会危害虚拟机自身的安全。**对于虚拟机的类加载机制来说，验证阶段是非常重要的，但**不是一定必要的**，如果运行的全部代码都已经被反复使用和验证过，那么在实施阶段可以考虑使用某些参数来关闭类验证，以缩短虚拟机类加载的时间。\n\n\n验证阶段主要完成以下4个阶段的校验动作：\n\n1. **文件格式验证**\n    验证字节流是否符合Class文件格式的规范，而且能够被当前版本的虚拟机处理，可能会包含以下验证点：\n    * 是否以魔数`0cCAFEBABE`开头\n    * 主次版本号是否在当前虚拟机处理范围之类\n    * 常量池的常量中是否有不被支持的类型\n    ······\n\n2. **元数据验证**\n    对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，可能会包含以下验证点：\n    * 这个类是否有父类（除java.lang.Object以外，所有的类都应当有父类）\n    * 这个类的父类是否继承了不被允许的类（例如被final修饰的类）\n    * 如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的所有方法\n    * 类中的字段是否会和父类产生矛盾（例如覆盖了父类的final字段，或者不符合规则的重载）\n    ······\n\n3. **字节码验证**\n    通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。保证被校验类在运行时不会做出危害虚拟机安全的事情，可能会包含以下验证点：\n    * 保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作。例如不会出现：在操作栈放置了一个int类型的数据，使用时却按照long类型载入本地变量表中\n    * 保证跳转指令不会跳转到方法体以外的字节码指令上\n    * 保证方法体中的类型转换是有效的，比如不能把父类对象赋值给子类数据类型\n    ······\n\n    如果一个类通过字节码验证，**也不能够说明其一定是安全的**\n    >\"**Halting Problem问题**\"：通过程序去校验程序逻辑是无法做到绝对准确的\n\n4. **符号应用验证**\n    符号引用验证可以看做是类自身以外（常量池中的各种符号引用）的信息进行匹配性验证。可能会包含以下验证点：\n    >此阶段发生在虚拟机将符号应用转换为直接引用的时候，即发生在连接的第三阶段——解析阶段中。\n\n    * 符号引用中通过字符串描述的全限定名是否能找到对应的类\n    * 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段\n    * 符号引用中的类、字段、方法的访问性是否可以被当前类访问\n    ······\n\n***\n\n### 2.3 准备\n当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即**内存分配的对象**以及**变量初始值的设置。**\n\n* 内存分配的对象\n\n    Java 中的变量有**类变量**和**类成员变量**两种类型，\n\n    **被static修饰的变量为类变量**，**而其他所有类型的变量都属类成员变量**。在准备阶段，**JVM 只会为类变量分配内存，而不会为类成员变量分配内存**。\n\n    **类成员变量的内存分配需要等到初始化阶段和对象一起分配在Java堆中**\n\n\n* 变量初始值的设置\n\n    在准备阶段，JVM 会为类变量分配内存，并为其初始化。**但是这里的初始化指的是为变量赋予Java语言中该数据类型的零值，而不是用户代码里初始化的值**。\n    >例如`public static int value = 123;`那么变量在准备阶段过后的初始值是0而不是123，因为这时候尚未执行Java方法。\n\n    特殊情况：\n    如果类字段的字段属性表中存在`ConstantValue`属性（例如 **static final**修饰的变量），那么在准备阶段变量value就会被初始化为ConstantValue属性所指定的值\n\n***\n\n### 2.4 解析\n\n解析阶段就是虚拟机将**常量池内的符号引用替换为直接引用**的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。\n>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量\n\n>直接应用：可以是直接执行目标的指针，相对偏移量或者一格能够直接定位到目标的句柄\n\n***\n\n### 2.5 初始化\n初始化时类加载过程的最后一步，到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。\n\n对于初始化阶段，虚拟机**严格规定了有且只有5中情况下必须对类进行初始化**：\n* 遇到 **new、getstatic、putstatic、invokestatic** 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：**使用new关键字实例化对象的时候、读取或设置一个类的静态字段**（**被final修饰、已在编译器把结果放入常量池的静态字段除外**）的时候，以及调用一个类的静态方法的时候。\n* **使用 java.lang.reflect 包的方法对类进行反射调用**的时候，如果类没有进行过初始化，则需要先触发其初始化。\n* 当初始化一个类的时候，如果发现**其父类还没有进行过初始化**，则需要先触发其父类的初始化。\n* 当虚拟机启动时，用户需要**指定一个要执行的主类**（包含main()方法的那个类），虚拟机会先初始化这个主类。\n* 当使用 JDK1.7 动态语言支持时，如果一个 **java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄**，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。\n\n<br>\n\n接口的加载过程和类的加载过程**稍有不同**：\n* 接口中不能使用**static{}**语句块，但是编译器仍然会为接口生成`<client>()`类构造器，用于初始化接口中所定义的成员变量。\n* 当一个类在初始化时，要求其父类全部已经都被初始化了，但是一个接口在初始化时，**并不要求其父接口全部已经初始化，只有真正使用到父接口时才会被初始化**。\n\n\n从另外一个角度来说：**初始化阶段是执行类构造器`<clinit>()`的过程**\n\n* `<clinit>()`类初始化方法，编译器会按照其出现顺序，收集**类变量的赋值语句、静态代码块**，最终组成类初始化方法。类初始化方法一般在**类初始化的时候执行**。\n例如：\n```java\n    static\n    {\n        System.out.println(\"静态代码块\");\n    }\n    static int a = 1;\n```\n\n* `<init>()`实例构造器，编译器会按照其出现顺序，收集**成员变量的赋值语句、普通代码块**，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在**实例化类对象的时候执行**。\n例如：\n```java\n     {\n        System.out.println(\"普通代码块\");\n    }\n    int b = 110;\n```\n\n* `<clinit>()`方法与实例构造器(<init>())方法不同，它不需要显式地调用父类构造器， 虚拟机会保证在**子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕。**\n\n* 由于父类的`<clinit>()`方法先执行，也就意味着**父类中定义的静态语句块要优先于子类的变量赋值操作**。\n\n* 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中能够被正确地加速、同步，**如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的`<clinit>()`方法**，其他线程都需要**阻塞等待**，直到活动线程执行`<clinit>()`方法完毕。\n\n***\n\n### 2.6 使用\n当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。\n\n***\n\n### 2.7 卸载\n\n当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。\n\n\n<br><br>\n\n***\n\n<br><br>\n\n## 三、类加载器\n>**通过一个类的全限定名来获取此类的二进制字节流并将其加载到JVM内存中，转化为Class对象**，这个动作**被放到Java虚拟机外部去实现**，以便让应用程序自己决定如何去获取所需要的类，\n\n实现这个动作的代码模块被称为**类加载器**。\n\n### 3.1 类与类加载器\n类加载器虽然只用于实现类的加载动作，但它在Java程序中的作用却远远不限于类加载阶段。\n\n**对于任意一个类，都需要由加载它的类加载器和这个类本身异同确立其在Java虚拟机中的唯一性**，每一个类都拥有一个独立的类名称空间。\n>**比较两个类是否相等，只有在这个两个类是由同一个类加载器加载的前提下才有意义**，即使两个类来源于同一个Class文件，但是由于加载他们的类加载器不同，那么这两个类也必然不同。\n\n****\n\n### 3.2 类加载的三种方式\n\n* 通过命令行启动应用时由**JVM初始化加载含有main()方法的主类**。\n\n* 通过**Class.forName()方法动态加载**，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。\n\n* 通过**ClassLoader.loadClass()方法动态加载**，不会执行初始化块。\n\n****\n\n### 3.3 Java语言自带的三个类加载器\n* **Bootstrap ClassLoader** ：最顶层的加载类，主要加载核心类库，也就是我们环境变量下面%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。（C++实现）\n\n* **Extention ClassLoader** ：扩展的类加载器，加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。\n\n* **Appclass Loader**：也称为SystemAppClass。 加载当前应用的classpath的所有类\n\n\n****\n\n### 3.4 双亲委派模型\n\n应用程序都是由这**三种类加载器互相配合进行加载的**，如果有必要，我们还可以加入自定义的类加载器。\n\n**这几种类加载器之间的层次关系，称为双亲委派模型。**\n\n双亲委派模型要求**除了顶层的启动加载器外，其余的类加载器都应当有自己的父类加载器**。这里的**类加载器之间的父子关系一般都不会以继承的关系来实现**，而是都**使用组合关系来复用父加载器的代码**。\n\n![双亲委派模型](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/双亲委派模型.png)\n\n\n* 双亲委派机制工作过程：\n\n    如果一个类加载器收到了类加载的请求.它**首先不会自己去尝试加载这个类.而是把这个请求委派给父加载器去完成,每个层次的类加载器都是如此**.因此**所有的加载请求最终都会传送到Bootstrap类加载器**(启动类加载器)中.**只有父类加载返回自己无法加载这个请求(它的搜索范围中没有找到所需的类)时.子加载器才会尝试自己去加载**。\n\n    >比如说，另外一个人给小费，自己不会先去直接拿来塞自己钱包，我们先把钱给领导，领导再给领导，一直到公司老板，老板不想要了，再一级一级往下分。老板要是要这个钱，下面的领导和自己就一分钱没有了。\n\n<br>\n\n>子类先委托父类加载\n\n>父类加载器有自己的加载范围，范围内没有找到，则不加载，**并返回给子类**\n\n>子类在收到父类无法加载的时候，才会自己去加载\n\n\n* 优势\n    Java类随着它的类加载器一起具备了一种**优先级的层次关系，保证了Java程序的稳定运行**。\n>例如无论哪一个类加载器加载一个类，最终都是委派到处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载环境中都是同一个类。相反，如果没有这种机制，由各个类自行去加载的话，那么系统中将会出现多个不同的Objec类，Java体系中最基础的行为也就无法保证，应用程序也会变得一片混乱。\n\n>在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么**类之间的比较结果及类的唯一性将无法保证**，因此，为什么需要双亲委派模型？**防止内存中出现多份同样的字节码**\n\n* 双亲委派模型的实现\n\n    先检查是否已经被加载过，若没有被加载过则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父类加载器，如果加载失败，则再调用自己的findClass()方法。\n\n\n```java\n    protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                \t//先判断parent是否为空，如果不为空，先尝试用父类加载器加载；如果为空，则先尝试用类启动加载器加载\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // 如果父类加载器抛出ClassNotFoundException异常则说明父类加载器无法完成加载请求\n                }\n                if (c == null) {\n                    //如果父类加载器没加载成功，则调用findClass尝试自己加载这个类\n                    c = findClass(name);\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n\n```\n****\n\n### 3.5 破坏双亲委派模型\n\n在某些情况下**父类加载器需要委托子类加载器去加载class文件**。受到加载范围的限制，父类加载器无法加载到需要的文件。\n\n>以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。\n\n<br><br>\n\n***\n\n<br><br>\n\n## 四、实例分析\n>转载自[JVM基础系列第7讲：JVM 类加载机制](https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html)\n\n### 4.1\n\n```java\npublic class Book {\n    public static void main(String[] args)\n    {\n        System.out.println(\"Hello ShuYi.\");\n    }\n\n    Book()\n    {\n        System.out.println(\"书的构造方法\");\n        System.out.println(\"price=\" + price +\",amount=\" + amount);\n    }\n\n    {\n        System.out.println(\"书的普通代码块\");\n    }\n\n    int price = 110;\n\n    static\n    {\n        System.out.println(\"书的静态代码块\");\n    }\n\n    static int amount = 112;\n}\n\n```\n\n最后的输出字符串为\n>书的静态代码块     \n>Hello ShuYi.\n\n>下面我们来简单分析一下，首先根据上面说到的触发初始化的5种情况的第4种（**当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类**），我们会进行类的初始化。初始化会按照顺序进行，\n\n并且此处没有 Book 类对象的实例化，所以`<init>()`方法不会被执行\n\n\n\n\n\n***\n\n\n### 4.2\n```java\nclass Grandpa\n{\n    static\n    {\n        System.out.println(\"爷爷在静态代码块\");\n    }\n}    \nclass Father extends Grandpa\n{\n    static\n    {\n        System.out.println(\"爸爸在静态代码块\");\n    }\n\n    public static int factor = 25;\n\n    public Father()\n    {\n        System.out.println(\"我是爸爸~\");\n    }\n}\nclass Son extends Father\n{\n    static \n    {\n        System.out.println(\"儿子在静态代码块\");\n    }\n\n    public Son()\n    {\n        System.out.println(\"我是儿子~\");\n    }\n}\npublic class InitializationDemo\n{\n    public static void main(String[] args)\n    {\n        System.out.println(\"爸爸的岁数:\" + Son.factor);\t//入口\n    }\n}\n\n```\n最后的输出字符串为\n>爷爷在静态代码块     \n>爸爸在静态代码块    \n>爸爸的岁数:25    \n\n<br>\n\n也许会有人问为什么没有输出「儿子在静态代码块」这个字符串？\n\n这是因为**对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块）**。因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。\n\n对面上面的这个例子，我们可以从入口开始分析一路分析下去：\n\n>首先程序到 main 方法这里，使用标准化输出 Son 类中的 factor 类成员变量，但是 Son 类中并没有定义这个类成员变量。于是往父类去找，我们在 Father 类中找到了对应的类成员变量，于是触发了 Father 的初始化。\n\n>但根据我们上面说到的初始化的 5 种情况中的第 3 种（当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化）。我们需要先初始化 Father 类的父类，也就是先初始化 Grandpa 类再初始化 Father 类。于是我们先初始化 Grandpa 类输出：「爷爷在静态代码块」，再初始化 Father 类输出：「爸爸在静态代码块」。\n\n>最后，所有父类都初始化完成之后，Son 类才能调用父类的静态变量，从而输出：「爸爸的岁数：25」。\n\n***\n\n### 4.3\n\n```java\nclass Grandpa\n{\n    static\n    {\n        System.out.println(\"爷爷在静态代码块\");\n    }\n\n    public Grandpa() {\n        System.out.println(\"我是爷爷~\");\n    }\n}\nclass Father extends Grandpa\n{\n    static\n    {\n        System.out.println(\"爸爸在静态代码块\");\n    }\n\n    public Father()\n    {\n        System.out.println(\"我是爸爸~\");\n    }\n}\nclass Son extends Father\n{\n    static \n    {\n        System.out.println(\"儿子在静态代码块\");\n    }\n\n    public Son()\n    {\n        System.out.println(\"我是儿子~\");\n    }\n}\npublic class InitializationDemo\n{\n    public static void main(String[] args)\n    {\n        new Son(); \t//入口\n    }\n}\n```\n\n最后的输出字符串为\n>爷爷在静态代码块     \n>爸爸在静态代码块     \n>儿子在静态代码块     \n>我是爷爷~     \n>我是爸爸~     \n>我是儿子~     \n\n<br>\n\n>让我们仔细来分析一下上面代码的执行流程：\n\n>首先在入口这里我们实例化一个 Son 对象，因此会触发 Son 类的初始化，而 Son 类的初始化又会带动 Father 、Grandpa 类的初始化，从而执行对应类中的静态代码块。因此会输出：「爷爷在静态代码块」、「爸爸在静态代码块」、「儿子在静态代码块」。\n\n>当 Son 类完成初始化之后，便会调用 Son 类的构造方法，而 Son 类构造方法的调用同样会带动 Father、Grandpa 类构造方法的调用，最后会输出：「我是爷爷」、「我是爸爸」、「我是儿子~」。\n\n\n\n***\n\n### 4.4\n\n```java\npublic class Book {\n    public static void main(String[] args)\n    {\n        staticFunction();\n    }\n\n    static Book book = new Book();\n\n    static\n    {\n        System.out.println(\"书的静态代码块\");\n    }\n\n    {\n        System.out.println(\"书的普通代码块\");\n    }\n\n    Book()\n    {\n        System.out.println(\"书的构造方法\");\n        System.out.println(\"price=\" + price +\",amount=\" + amount);\n    }\n\n    public static void staticFunction(){\n        System.out.println(\"书的静态方法\");\n    }\n\n    int price = 110;\n    static int amount = 112;\n}\n```\n输出结果：\n>书的普通代码块     \n>书的构造方法     \n>price=110,amount=0     \n>书的静态代码块     \n>书的静态方法     \n\n\n>下面我们一步步来分析一下代码的整个执行流程。    \n>在上面两个例子中，因为 main 方法所在类并没有多余的代码，我们都直接忽略了 main 方法所在类的初始化。    \n>但在这个例子中，main 方法所在类有许多代码，我们就并不能直接忽略了。\n\n>* 当 JVM 在准备阶段的时候，便会为类变量分配内存和进行初始化。此时，我们的 book 实例变量被初始化为 null，amount 变量被初始化为 0。\n\n>*  当进入初始化阶段后，因为 Book 方法是程序的入口，根据我们上面说到的类初始化的五种情况的第四种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类）。所以JVM 会初始化 Book 类，即执行类构造器 。\n\n>*  JVM 对 Book 类进行初始化首先是执行类构造器（按顺序收集类中所有静态代码块和类变量赋值语句就组成了类构造器 ），后执行对象的构造器（按顺序收集成员变量赋值和普通代码块，最后收集对象构造器，最终组成对象构造器 ）。\n\n>对于 Book 类，其类构造方法（）可以简单表示如下：\n```java\nstatic Book book = new Book();\nstatic\n{\n    System.out.println(\"书的静态代码块\");\n}\nstatic int amount = 112;\n```\n>于是首先执行`static Book book = new Book();`这一条语句，这条语句又触发了类的实例化。于是 JVM 执行对象构造器 ，收集后的对象构造器 代码：\n```java\n{\n    System.out.println(\"书的普通代码块\");\n}\nint price = 110;\nBook()\n{\n    System.out.println(\"书的构造方法\");\n    System.out.println(\"price=\" + price +\", amount=\" + amount);\n}\n```\n>于是此时 price 赋予 110 的值，输出：「书的普通代码块」、「书的构造方法」。而此时 price 为 110 的值，而 amount 的赋值语句并未执行，所以只有在准备阶段赋予的零值，所以之后输出「price=110,amount=0」。\n\n>当类实例化完成之后，JVM 继续进行类构造器的初始化：\n\n```java\nstatic Book book = new Book();  //完成类实例化\nstatic\n{\n    System.out.println(\"书的静态代码块\");\n}\nstatic int amount = 112;\n```\n>即输出：「书的静态代码块」，之后对 amount 赋予 112 的值。\n\n>* 到这里，类的初始化已经完成，JVM 执行 main 方法的内容。\n\n```java\npublic static void main(String[] args)\n{\n    staticFunction();\n}\n```\n>即输出：「书的静态方法」。\n\n***\n\n### 4.5 方法论\n从上面几个例子可以看出，分析一个类的执行顺序大概可以按照如下步骤：\n\n1. **确定类变量的初始值**。在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。\n    \n2. **初始化入口方法**。当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。\n3. **初始化类构造器**。JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。\n    \n4. **初始化对象构造器**。JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。\n\n如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。\n\n\n\n\n\n\n<br><br><br>\n\n***\n\n<br><br><br>\n\n\n### 参考    \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br>\n[2]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html</a><br>\n[3]<a href=\"https://www.cnblogs.com/joemsu/p/9310226.html\">https://www.cnblogs.com/joemsu/p/9310226.html</a><br>\n[4]<a href=\"https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc\">https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc</a><br>\n[5]<a href=\"https://blog.csdn.net/qq_41701956/article/details/100074023\">https://blog.csdn.net/qq_41701956/article/details/100074023</a><br>\n</div>","slug":"code/JVM/JVM学习笔记(三)——类加载机制","published":1,"date":"2021-08-09T10:06:58.839Z","updated":"2020-07-23T12:48:16.000Z","title":"code/JVM/JVM学习笔记(三)——类加载机制","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1g5003s0w7th7hq04my","content":"<p><strong>虚拟机的类加载机制就是虚拟机把Java类的源码编译为<em>字节码</em>后，将其<em>读取进内存</em>，并对数据进行校验、转换解析和初始化、最终形成可以被虚拟机直接使用的Java类型。</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200703214206.png\" alt=\"类加载机制\"></p>\n<a id=\"more\"></a>\n\n<h2 id=\"一、类加载的时机\"><a href=\"#一、类加载的时机\" class=\"headerlink\" title=\"一、类加载的时机\"></a>一、类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用、卸载</strong>7个阶段。其中验证、准备、解析三个阶段统称为连接。<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png\" alt=\"类加载过程\"></p>\n<blockquote>\n<p>其中解析的阶段的顺序可能会发生变化，某些情况下可能会在初始化后再开始，另外<strong>注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成</strong>，因为这些阶段<strong>通常都是互相交叉地混合进行</strong>的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>\n</blockquote>\n<p>什么时候需要进行类加载的第一个阶段是由<strong>虚拟机的具体实现来自由把握的</strong>。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"二、类加载的过程\"><a href=\"#二、类加载的过程\" class=\"headerlink\" title=\"二、类加载的过程\"></a>二、类加载的过程</h2><h3 id=\"2-1-加载\"><a href=\"#2-1-加载\" class=\"headerlink\" title=\"2.1 加载\"></a>2.1 加载</h3><p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是<strong>将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中</strong>，接着会为这个类在 <strong>JVM 的方法区创建一个对应的 Class 对象</strong>，这个 Class 对象就是这个类各种<strong>数据的访问入口</strong>。</p>\n<ul>\n<li><p>从哪里去加载字节码文件</p>\n<ul>\n<li><p>本地磁盘</p>\n</li>\n<li><p>网上加载.class文件（Applet）</p>\n</li>\n<li><p>从数据库中</p>\n</li>\n<li><p>压缩文件中（ZAR，jar等）</p>\n</li>\n<li><p>从其他文件生成的（JSP应用）</p>\n<p>对于非数组类的加载阶段，可以使用系统提供的引导加载类，也可以使用自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。（重写一个类加载器的<code>loadClass()</code>方法）</p>\n<p>对于数组类，<strong>其本身由Java虚拟机直接创建的</strong>，但数据类的<strong>元素类型最终还是要靠类加载器去创建的</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-2-验证\"><a href=\"#2-2-验证\" class=\"headerlink\" title=\"2.2 验证\"></a>2.2 验证</h3><p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。</p>\n<p>其目的是<strong>确保Class文件中的字节流包含的信息符合档期那虚拟机的要求，并不会危害虚拟机自身的安全。</strong>对于虚拟机的类加载机制来说，验证阶段是非常重要的，但<strong>不是一定必要的</strong>，如果运行的全部代码都已经被反复使用和验证过，那么在实施阶段可以考虑使用某些参数来关闭类验证，以缩短虚拟机类加载的时间。</p>\n<p>验证阶段主要完成以下4个阶段的校验动作：</p>\n<ol>\n<li><p><strong>文件格式验证</strong><br> 验证字节流是否符合Class文件格式的规范，而且能够被当前版本的虚拟机处理，可能会包含以下验证点：</p>\n<ul>\n<li>是否以魔数<code>0cCAFEBABE</code>开头</li>\n<li>主次版本号是否在当前虚拟机处理范围之类</li>\n<li>常量池的常量中是否有不被支持的类型<br>······</li>\n</ul>\n</li>\n<li><p><strong>元数据验证</strong><br> 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，可能会包含以下验证点：</p>\n<ul>\n<li>这个类是否有父类（除java.lang.Object以外，所有的类都应当有父类）</li>\n<li>这个类的父类是否继承了不被允许的类（例如被final修饰的类）</li>\n<li>如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的所有方法</li>\n<li>类中的字段是否会和父类产生矛盾（例如覆盖了父类的final字段，或者不符合规则的重载）<br>······</li>\n</ul>\n</li>\n<li><p><strong>字节码验证</strong><br> 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。保证被校验类在运行时不会做出危害虚拟机安全的事情，可能会包含以下验证点：</p>\n<ul>\n<li><p>保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作。例如不会出现：在操作栈放置了一个int类型的数据，使用时却按照long类型载入本地变量表中</p>\n</li>\n<li><p>保证跳转指令不会跳转到方法体以外的字节码指令上</p>\n</li>\n<li><p>保证方法体中的类型转换是有效的，比如不能把父类对象赋值给子类数据类型<br>······</p>\n<p>如果一个类通过字节码验证，<strong>也不能够说明其一定是安全的</strong></p>\n<blockquote>\n<p>“<strong>Halting Problem问题</strong>“：通过程序去校验程序逻辑是无法做到绝对准确的</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>符号应用验证</strong><br> 符号引用验证可以看做是类自身以外（常量池中的各种符号引用）的信息进行匹配性验证。可能会包含以下验证点：</p>\n<blockquote>\n<p>此阶段发生在虚拟机将符号应用转换为直接引用的时候，即发生在连接的第三阶段——解析阶段中。</p>\n</blockquote>\n<ul>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>\n<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>\n<li>符号引用中的类、字段、方法的访问性是否可以被当前类访问<br>······</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-3-准备\"><a href=\"#2-3-准备\" class=\"headerlink\" title=\"2.3 准备\"></a>2.3 准备</h3><p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即<strong>内存分配的对象</strong>以及<strong>变量初始值的设置。</strong></p>\n<ul>\n<li><p>内存分配的对象</p>\n<p>  Java 中的变量有<strong>类变量</strong>和<strong>类成员变量</strong>两种类型，</p>\n<p>  <strong>被static修饰的变量为类变量</strong>，<strong>而其他所有类型的变量都属类成员变量</strong>。在准备阶段，<strong>JVM 只会为类变量分配内存，而不会为类成员变量分配内存</strong>。</p>\n<p>  <strong>类成员变量的内存分配需要等到初始化阶段和对象一起分配在Java堆中</strong></p>\n</li>\n</ul>\n<ul>\n<li><p>变量初始值的设置</p>\n<p>  在准备阶段，JVM 会为类变量分配内存，并为其初始化。<strong>但是这里的初始化指的是为变量赋予Java语言中该数据类型的零值，而不是用户代码里初始化的值</strong>。</p>\n<blockquote>\n<p>例如<code>public static int value = 123;</code>那么变量在准备阶段过后的初始值是0而不是123，因为这时候尚未执行Java方法。</p>\n</blockquote>\n<p>  特殊情况：<br>  如果类字段的字段属性表中存在<code>ConstantValue</code>属性（例如 <strong>static final</strong>修饰的变量），那么在准备阶段变量value就会被初始化为ConstantValue属性所指定的值</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-4-解析\"><a href=\"#2-4-解析\" class=\"headerlink\" title=\"2.4 解析\"></a>2.4 解析</h3><p>解析阶段就是虚拟机将<strong>常量池内的符号引用替换为直接引用</strong>的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>\n<blockquote>\n<p>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p>\n</blockquote>\n<blockquote>\n<p>直接应用：可以是直接执行目标的指针，相对偏移量或者一格能够直接定位到目标的句柄</p>\n</blockquote>\n<hr>\n<h3 id=\"2-5-初始化\"><a href=\"#2-5-初始化\" class=\"headerlink\" title=\"2.5 初始化\"></a>2.5 初始化</h3><p>初始化时类加载过程的最后一步，到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。</p>\n<p>对于初始化阶段，虚拟机<strong>严格规定了有且只有5中情况下必须对类进行初始化</strong>：</p>\n<ul>\n<li>遇到 <strong>new、getstatic、putstatic、invokestatic</strong> 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：<strong>使用new关键字实例化对象的时候、读取或设置一个类的静态字段</strong>（<strong>被final修饰、已在编译器把结果放入常量池的静态字段除外</strong>）的时候，以及调用一个类的静态方法的时候。</li>\n<li><strong>使用 java.lang.reflect 包的方法对类进行反射调用</strong>的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>\n<li>当初始化一个类的时候，如果发现<strong>其父类还没有进行过初始化</strong>，则需要先触发其父类的初始化。</li>\n<li>当虚拟机启动时，用户需要<strong>指定一个要执行的主类</strong>（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>\n<li>当使用 JDK1.7 动态语言支持时，如果一个 <strong>java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄</strong>，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li>\n</ul>\n<br>\n\n<p>接口的加载过程和类的加载过程<strong>稍有不同</strong>：</p>\n<ul>\n<li>接口中不能使用<strong>static{}</strong>语句块，但是编译器仍然会为接口生成<code>&lt;client&gt;()</code>类构造器，用于初始化接口中所定义的成员变量。</li>\n<li>当一个类在初始化时，要求其父类全部已经都被初始化了，但是一个接口在初始化时，<strong>并不要求其父接口全部已经初始化，只有真正使用到父接口时才会被初始化</strong>。</li>\n</ul>\n<p>从另外一个角度来说：<strong>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>的过程</strong></p>\n<ul>\n<li><p><code>&lt;clinit&gt;()</code>类初始化方法，编译器会按照其出现顺序，收集<strong>类变量的赋值语句、静态代码块</strong>，最终组成类初始化方法。类初始化方法一般在<strong>类初始化的时候执行</strong>。<br>例如：</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">static</span>\n  <span class=\"token punctuation\">{</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p><code>&lt;init&gt;()</code>实例构造器，编译器会按照其出现顺序，收集<strong>成员变量的赋值语句、普通代码块</strong>，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在<strong>实例化类对象的时候执行</strong>。<br>例如：</p>\n<pre class=\" language-java\"><code class=\"language-java\">   <span class=\"token punctuation\">{</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"普通代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">110</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p><code>&lt;clinit&gt;()</code>方法与实例构造器(<init>())方法不同，它不需要显式地调用父类构造器， 虚拟机会保证在<strong>子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</strong></p>\n</li>\n<li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着<strong>父类中定义的静态语句块要优先于子类的变量赋值操作</strong>。</p>\n</li>\n<li><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中能够被正确地加速、同步，<strong>如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法</strong>，其他线程都需要<strong>阻塞等待</strong>，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-6-使用\"><a href=\"#2-6-使用\" class=\"headerlink\" title=\"2.6 使用\"></a>2.6 使用</h3><p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。</p>\n<hr>\n<h3 id=\"2-7-卸载\"><a href=\"#2-7-卸载\" class=\"headerlink\" title=\"2.7 卸载\"></a>2.7 卸载</h3><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"三、类加载器\"><a href=\"#三、类加载器\" class=\"headerlink\" title=\"三、类加载器\"></a>三、类加载器</h2><blockquote>\n<p><strong>通过一个类的全限定名来获取此类的二进制字节流并将其加载到JVM内存中，转化为Class对象</strong>，这个动作<strong>被放到Java虚拟机外部去实现</strong>，以便让应用程序自己决定如何去获取所需要的类，</p>\n</blockquote>\n<p>实现这个动作的代码模块被称为<strong>类加载器</strong>。</p>\n<h3 id=\"3-1-类与类加载器\"><a href=\"#3-1-类与类加载器\" class=\"headerlink\" title=\"3.1 类与类加载器\"></a>3.1 类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中的作用却远远不限于类加载阶段。</p>\n<p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身异同确立其在Java虚拟机中的唯一性</strong>，每一个类都拥有一个独立的类名称空间。</p>\n<blockquote>\n<p><strong>比较两个类是否相等，只有在这个两个类是由同一个类加载器加载的前提下才有意义</strong>，即使两个类来源于同一个Class文件，但是由于加载他们的类加载器不同，那么这两个类也必然不同。</p>\n</blockquote>\n<hr>\n<h3 id=\"3-2-类加载的三种方式\"><a href=\"#3-2-类加载的三种方式\" class=\"headerlink\" title=\"3.2 类加载的三种方式\"></a>3.2 类加载的三种方式</h3><ul>\n<li><p>通过命令行启动应用时由<strong>JVM初始化加载含有main()方法的主类</strong>。</p>\n</li>\n<li><p>通过<strong>Class.forName()方法动态加载</strong>，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。</p>\n</li>\n<li><p>通过<strong>ClassLoader.loadClass()方法动态加载</strong>，不会执行初始化块。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-3-Java语言自带的三个类加载器\"><a href=\"#3-3-Java语言自带的三个类加载器\" class=\"headerlink\" title=\"3.3 Java语言自带的三个类加载器\"></a>3.3 Java语言自带的三个类加载器</h3><ul>\n<li><p><strong>Bootstrap ClassLoader</strong> ：最顶层的加载类，主要加载核心类库，也就是我们环境变量下面%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。（C++实现）</p>\n</li>\n<li><p><strong>Extention ClassLoader</strong> ：扩展的类加载器，加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。</p>\n</li>\n<li><p><strong>Appclass Loader</strong>：也称为SystemAppClass。 加载当前应用的classpath的所有类</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-4-双亲委派模型\"><a href=\"#3-4-双亲委派模型\" class=\"headerlink\" title=\"3.4 双亲委派模型\"></a>3.4 双亲委派模型</h3><p>应用程序都是由这<strong>三种类加载器互相配合进行加载的</strong>，如果有必要，我们还可以加入自定义的类加载器。</p>\n<p><strong>这几种类加载器之间的层次关系，称为双亲委派模型。</strong></p>\n<p>双亲委派模型要求<strong>除了顶层的启动加载器外，其余的类加载器都应当有自己的父类加载器</strong>。这里的<strong>类加载器之间的父子关系一般都不会以继承的关系来实现</strong>，而是都<strong>使用组合关系来复用父加载器的代码</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png\" alt=\"双亲委派模型\"></p>\n<ul>\n<li><p>双亲委派机制工作过程：</p>\n<p>  如果一个类加载器收到了类加载的请求.它<strong>首先不会自己去尝试加载这个类.而是把这个请求委派给父加载器去完成,每个层次的类加载器都是如此</strong>.因此<strong>所有的加载请求最终都会传送到Bootstrap类加载器</strong>(启动类加载器)中.<strong>只有父类加载返回自己无法加载这个请求(它的搜索范围中没有找到所需的类)时.子加载器才会尝试自己去加载</strong>。</p>\n<blockquote>\n<p>比如说，另外一个人给小费，自己不会先去直接拿来塞自己钱包，我们先把钱给领导，领导再给领导，一直到公司老板，老板不想要了，再一级一级往下分。老板要是要这个钱，下面的领导和自己就一分钱没有了。</p>\n</blockquote>\n</li>\n</ul>\n<br>\n\n<blockquote>\n<p>子类先委托父类加载</p>\n</blockquote>\n<blockquote>\n<p>父类加载器有自己的加载范围，范围内没有找到，则不加载，<strong>并返回给子类</strong></p>\n</blockquote>\n<blockquote>\n<p>子类在收到父类无法加载的时候，才会自己去加载</p>\n</blockquote>\n<ul>\n<li>优势<br>  Java类随着它的类加载器一起具备了一种<strong>优先级的层次关系，保证了Java程序的稳定运行</strong>。<blockquote>\n<p>例如无论哪一个类加载器加载一个类，最终都是委派到处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载环境中都是同一个类。相反，如果没有这种机制，由各个类自行去加载的话，那么系统中将会出现多个不同的Objec类，Java体系中最基础的行为也就无法保证，应用程序也会变得一片混乱。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么<strong>类之间的比较结果及类的唯一性将无法保证</strong>，因此，为什么需要双亲委派模型？<strong>防止内存中出现多份同样的字节码</strong></p>\n</blockquote>\n<ul>\n<li><p>双亲委派模型的实现</p>\n<p>  先检查是否已经被加载过，若没有被加载过则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父类加载器，如果加载失败，则再调用自己的findClass()方法。</p>\n</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">protected</span> Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>String name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> resolve<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throws</span> ClassNotFoundException\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token function\">getClassLoadingLock</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// First, check if the class has already been loaded</span>\n            Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> c <span class=\"token operator\">=</span> <span class=\"token function\">findLoadedClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">long</span> t0 <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//先判断parent是否为空，如果不为空，先尝试用父类加载器加载；如果为空，则先尝试用类启动加载器加载</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        c <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                        c <span class=\"token operator\">=</span> <span class=\"token function\">findBootstrapClassOrNull</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果父类加载器抛出ClassNotFoundException异常则说明父类加载器无法完成加载请求</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//如果父类加载器没加载成功，则调用findClass尝试自己加载这个类</span>\n                    c <span class=\"token operator\">=</span> <span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">resolveClass</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<hr>\n<h3 id=\"3-5-破坏双亲委派模型\"><a href=\"#3-5-破坏双亲委派模型\" class=\"headerlink\" title=\"3.5 破坏双亲委派模型\"></a>3.5 破坏双亲委派模型</h3><p>在某些情况下<strong>父类加载器需要委托子类加载器去加载class文件</strong>。受到加载范围的限制，父类加载器无法加载到需要的文件。</p>\n<blockquote>\n<p>以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。</p>\n</blockquote>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"四、实例分析\"><a href=\"#四、实例分析\" class=\"headerlink\" title=\"四、实例分析\"></a>四、实例分析</h2><blockquote>\n<p>转载自<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html\" target=\"_blank\" rel=\"noopener\">JVM基础系列第7讲：JVM 类加载机制</a></p>\n</blockquote>\n<h3 id=\"4-1\"><a href=\"#4-1\" class=\"headerlink\" title=\"4.1\"></a>4.1</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Book</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello ShuYi.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">Book</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的构造方法\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"price=\"</span> <span class=\"token operator\">+</span> price <span class=\"token operator\">+</span><span class=\"token string\">\",amount=\"</span> <span class=\"token operator\">+</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的普通代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> price <span class=\"token operator\">=</span> <span class=\"token number\">110</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">static</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> amount <span class=\"token operator\">=</span> <span class=\"token number\">112</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>最后的输出字符串为</p>\n<blockquote>\n<p>书的静态代码块<br>Hello ShuYi.</p>\n</blockquote>\n<blockquote>\n<p>下面我们来简单分析一下，首先根据上面说到的触发初始化的5种情况的第4种（<strong>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</strong>），我们会进行类的初始化。初始化会按照顺序进行，</p>\n</blockquote>\n<p>并且此处没有 Book 类对象的实例化，所以<code>&lt;init&gt;()</code>方法不会被执行</p>\n<hr>\n<h3 id=\"4-2\"><a href=\"#4-2\" class=\"headerlink\" title=\"4.2\"></a>4.2</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Grandpa</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"爷爷在静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>    \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Father</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Grandpa</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"爸爸在静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> factor <span class=\"token operator\">=</span> <span class=\"token number\">25</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Father</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我是爸爸~\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Son</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Father</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> \n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"儿子在静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Son</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我是儿子~\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InitializationDemo</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"爸爸的岁数:\"</span> <span class=\"token operator\">+</span> Son<span class=\"token punctuation\">.</span>factor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//入口</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>最后的输出字符串为</p>\n<blockquote>\n<p>爷爷在静态代码块<br>爸爸在静态代码块<br>爸爸的岁数:25    </p>\n</blockquote>\n<br>\n\n<p>也许会有人问为什么没有输出「儿子在静态代码块」这个字符串？</p>\n<p>这是因为<strong>对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块）</strong>。因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>\n<p>对面上面的这个例子，我们可以从入口开始分析一路分析下去：</p>\n<blockquote>\n<p>首先程序到 main 方法这里，使用标准化输出 Son 类中的 factor 类成员变量，但是 Son 类中并没有定义这个类成员变量。于是往父类去找，我们在 Father 类中找到了对应的类成员变量，于是触发了 Father 的初始化。</p>\n</blockquote>\n<blockquote>\n<p>但根据我们上面说到的初始化的 5 种情况中的第 3 种（当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化）。我们需要先初始化 Father 类的父类，也就是先初始化 Grandpa 类再初始化 Father 类。于是我们先初始化 Grandpa 类输出：「爷爷在静态代码块」，再初始化 Father 类输出：「爸爸在静态代码块」。</p>\n</blockquote>\n<blockquote>\n<p>最后，所有父类都初始化完成之后，Son 类才能调用父类的静态变量，从而输出：「爸爸的岁数：25」。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-3\"><a href=\"#4-3\" class=\"headerlink\" title=\"4.3\"></a>4.3</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Grandpa</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"爷爷在静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Grandpa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我是爷爷~\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Father</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Grandpa</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"爸爸在静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Father</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我是爸爸~\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Son</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Father</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> \n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"儿子在静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Son</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我是儿子~\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InitializationDemo</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Son</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">//入口</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>最后的输出字符串为</p>\n<blockquote>\n<p>爷爷在静态代码块<br>爸爸在静态代码块<br>儿子在静态代码块<br>我是爷爷~<br>我是爸爸~<br>我是儿子~     </p>\n</blockquote>\n<br>\n\n<blockquote>\n<p>让我们仔细来分析一下上面代码的执行流程：</p>\n</blockquote>\n<blockquote>\n<p>首先在入口这里我们实例化一个 Son 对象，因此会触发 Son 类的初始化，而 Son 类的初始化又会带动 Father 、Grandpa 类的初始化，从而执行对应类中的静态代码块。因此会输出：「爷爷在静态代码块」、「爸爸在静态代码块」、「儿子在静态代码块」。</p>\n</blockquote>\n<blockquote>\n<p>当 Son 类完成初始化之后，便会调用 Son 类的构造方法，而 Son 类构造方法的调用同样会带动 Father、Grandpa 类构造方法的调用，最后会输出：「我是爷爷」、「我是爸爸」、「我是儿子~」。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-4\"><a href=\"#4-4\" class=\"headerlink\" title=\"4.4\"></a>4.4</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Book</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">staticFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> Book book <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Book</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">static</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的普通代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">Book</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的构造方法\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"price=\"</span> <span class=\"token operator\">+</span> price <span class=\"token operator\">+</span><span class=\"token string\">\",amount=\"</span> <span class=\"token operator\">+</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">staticFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的静态方法\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> price <span class=\"token operator\">=</span> <span class=\"token number\">110</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> amount <span class=\"token operator\">=</span> <span class=\"token number\">112</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>书的普通代码块<br>书的构造方法<br>price=110,amount=0<br>书的静态代码块<br>书的静态方法     </p>\n</blockquote>\n<blockquote>\n<p>下面我们一步步来分析一下代码的整个执行流程。<br>在上面两个例子中，因为 main 方法所在类并没有多余的代码，我们都直接忽略了 main 方法所在类的初始化。<br>但在这个例子中，main 方法所在类有许多代码，我们就并不能直接忽略了。</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>当 JVM 在准备阶段的时候，便会为类变量分配内存和进行初始化。此时，我们的 book 实例变量被初始化为 null，amount 变量被初始化为 0。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>当进入初始化阶段后，因为 Book 方法是程序的入口，根据我们上面说到的类初始化的五种情况的第四种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类）。所以JVM 会初始化 Book 类，即执行类构造器 。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>JVM 对 Book 类进行初始化首先是执行类构造器（按顺序收集类中所有静态代码块和类变量赋值语句就组成了类构造器 ），后执行对象的构造器（按顺序收集成员变量赋值和普通代码块，最后收集对象构造器，最终组成对象构造器 ）。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>对于 Book 类，其类构造方法（）可以简单表示如下：</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> Book book <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Book</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">static</span>\n<span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> amount <span class=\"token operator\">=</span> <span class=\"token number\">112</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>于是首先执行<code>static Book book = new Book();</code>这一条语句，这条语句又触发了类的实例化。于是 JVM 执行对象构造器 ，收集后的对象构造器 代码：</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的普通代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> price <span class=\"token operator\">=</span> <span class=\"token number\">110</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">Book</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的构造方法\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"price=\"</span> <span class=\"token operator\">+</span> price <span class=\"token operator\">+</span><span class=\"token string\">\", amount=\"</span> <span class=\"token operator\">+</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<blockquote>\n<p>于是此时 price 赋予 110 的值，输出：「书的普通代码块」、「书的构造方法」。而此时 price 为 110 的值，而 amount 的赋值语句并未执行，所以只有在准备阶段赋予的零值，所以之后输出「price=110,amount=0」。</p>\n</blockquote>\n<blockquote>\n<p>当类实例化完成之后，JVM 继续进行类构造器的初始化：</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> Book book <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Book</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//完成类实例化</span>\n<span class=\"token keyword\">static</span>\n<span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"书的静态代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> amount <span class=\"token operator\">=</span> <span class=\"token number\">112</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>即输出：「书的静态代码块」，之后对 amount 赋予 112 的值。</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>到这里，类的初始化已经完成，JVM 执行 main 方法的内容。</li>\n</ul>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">staticFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<blockquote>\n<p>即输出：「书的静态方法」。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-5-方法论\"><a href=\"#4-5-方法论\" class=\"headerlink\" title=\"4.5 方法论\"></a>4.5 方法论</h3><p>从上面几个例子可以看出，分析一个类的执行顺序大概可以按照如下步骤：</p>\n<ol>\n<li><p><strong>确定类变量的初始值</strong>。在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。</p>\n</li>\n<li><p><strong>初始化入口方法</strong>。当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。</p>\n</li>\n<li><p><strong>初始化类构造器</strong>。JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。</p>\n</li>\n<li><p><strong>初始化对象构造器</strong>。JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。</p>\n</li>\n</ol>\n<p>如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。</p>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><div style=\"margin-left: 5px  font-size:16px;\">\n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br>\n[2]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html</a><br>\n[3]<a href=\"https://www.cnblogs.com/joemsu/p/9310226.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/joemsu/p/9310226.html</a><br>\n[4]<a href=\"https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc\" target=\"_blank\" rel=\"noopener\">https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc</a><br>\n[5]<a href=\"https://blog.csdn.net/qq_41701956/article/details/100074023\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_41701956/article/details/100074023</a><br>\n</div>","site":{"data":{}},"excerpt":"<p><strong>虚拟机的类加载机制就是虚拟机把Java类的源码编译为<em>字节码</em>后，将其<em>读取进内存</em>，并对数据进行校验、转换解析和初始化、最终形成可以被虚拟机直接使用的Java类型。</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200703214206.png\" alt=\"类加载机制\"></p>","more":"<h2 id=\"一、类加载的时机\"><a href=\"#一、类加载的时机\" class=\"headerlink\" title=\"一、类加载的时机\"></a>一、类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用、卸载</strong>7个阶段。其中验证、准备、解析三个阶段统称为连接。<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png\" alt=\"类加载过程\"></p>\n<blockquote>\n<p>其中解析的阶段的顺序可能会发生变化，某些情况下可能会在初始化后再开始，另外<strong>注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成</strong>，因为这些阶段<strong>通常都是互相交叉地混合进行</strong>的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>\n</blockquote>\n<p>什么时候需要进行类加载的第一个阶段是由<strong>虚拟机的具体实现来自由把握的</strong>。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"二、类加载的过程\"><a href=\"#二、类加载的过程\" class=\"headerlink\" title=\"二、类加载的过程\"></a>二、类加载的过程</h2><h3 id=\"2-1-加载\"><a href=\"#2-1-加载\" class=\"headerlink\" title=\"2.1 加载\"></a>2.1 加载</h3><p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是<strong>将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中</strong>，接着会为这个类在 <strong>JVM 的方法区创建一个对应的 Class 对象</strong>，这个 Class 对象就是这个类各种<strong>数据的访问入口</strong>。</p>\n<ul>\n<li><p>从哪里去加载字节码文件</p>\n<ul>\n<li><p>本地磁盘</p>\n</li>\n<li><p>网上加载.class文件（Applet）</p>\n</li>\n<li><p>从数据库中</p>\n</li>\n<li><p>压缩文件中（ZAR，jar等）</p>\n</li>\n<li><p>从其他文件生成的（JSP应用）</p>\n<p>对于非数组类的加载阶段，可以使用系统提供的引导加载类，也可以使用自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。（重写一个类加载器的<code>loadClass()</code>方法）</p>\n<p>对于数组类，<strong>其本身由Java虚拟机直接创建的</strong>，但数据类的<strong>元素类型最终还是要靠类加载器去创建的</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-2-验证\"><a href=\"#2-2-验证\" class=\"headerlink\" title=\"2.2 验证\"></a>2.2 验证</h3><p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。</p>\n<p>其目的是<strong>确保Class文件中的字节流包含的信息符合档期那虚拟机的要求，并不会危害虚拟机自身的安全。</strong>对于虚拟机的类加载机制来说，验证阶段是非常重要的，但<strong>不是一定必要的</strong>，如果运行的全部代码都已经被反复使用和验证过，那么在实施阶段可以考虑使用某些参数来关闭类验证，以缩短虚拟机类加载的时间。</p>\n<p>验证阶段主要完成以下4个阶段的校验动作：</p>\n<ol>\n<li><p><strong>文件格式验证</strong><br> 验证字节流是否符合Class文件格式的规范，而且能够被当前版本的虚拟机处理，可能会包含以下验证点：</p>\n<ul>\n<li>是否以魔数<code>0cCAFEBABE</code>开头</li>\n<li>主次版本号是否在当前虚拟机处理范围之类</li>\n<li>常量池的常量中是否有不被支持的类型<br>······</li>\n</ul>\n</li>\n<li><p><strong>元数据验证</strong><br> 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，可能会包含以下验证点：</p>\n<ul>\n<li>这个类是否有父类（除java.lang.Object以外，所有的类都应当有父类）</li>\n<li>这个类的父类是否继承了不被允许的类（例如被final修饰的类）</li>\n<li>如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的所有方法</li>\n<li>类中的字段是否会和父类产生矛盾（例如覆盖了父类的final字段，或者不符合规则的重载）<br>······</li>\n</ul>\n</li>\n<li><p><strong>字节码验证</strong><br> 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。保证被校验类在运行时不会做出危害虚拟机安全的事情，可能会包含以下验证点：</p>\n<ul>\n<li><p>保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作。例如不会出现：在操作栈放置了一个int类型的数据，使用时却按照long类型载入本地变量表中</p>\n</li>\n<li><p>保证跳转指令不会跳转到方法体以外的字节码指令上</p>\n</li>\n<li><p>保证方法体中的类型转换是有效的，比如不能把父类对象赋值给子类数据类型<br>······</p>\n<p>如果一个类通过字节码验证，<strong>也不能够说明其一定是安全的</strong></p>\n<blockquote>\n<p>“<strong>Halting Problem问题</strong>“：通过程序去校验程序逻辑是无法做到绝对准确的</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>符号应用验证</strong><br> 符号引用验证可以看做是类自身以外（常量池中的各种符号引用）的信息进行匹配性验证。可能会包含以下验证点：</p>\n<blockquote>\n<p>此阶段发生在虚拟机将符号应用转换为直接引用的时候，即发生在连接的第三阶段——解析阶段中。</p>\n</blockquote>\n<ul>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>\n<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>\n<li>符号引用中的类、字段、方法的访问性是否可以被当前类访问<br>······</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-3-准备\"><a href=\"#2-3-准备\" class=\"headerlink\" title=\"2.3 准备\"></a>2.3 准备</h3><p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即<strong>内存分配的对象</strong>以及<strong>变量初始值的设置。</strong></p>\n<ul>\n<li><p>内存分配的对象</p>\n<p>  Java 中的变量有<strong>类变量</strong>和<strong>类成员变量</strong>两种类型，</p>\n<p>  <strong>被static修饰的变量为类变量</strong>，<strong>而其他所有类型的变量都属类成员变量</strong>。在准备阶段，<strong>JVM 只会为类变量分配内存，而不会为类成员变量分配内存</strong>。</p>\n<p>  <strong>类成员变量的内存分配需要等到初始化阶段和对象一起分配在Java堆中</strong></p>\n</li>\n</ul>\n<ul>\n<li><p>变量初始值的设置</p>\n<p>  在准备阶段，JVM 会为类变量分配内存，并为其初始化。<strong>但是这里的初始化指的是为变量赋予Java语言中该数据类型的零值，而不是用户代码里初始化的值</strong>。</p>\n<blockquote>\n<p>例如<code>public static int value = 123;</code>那么变量在准备阶段过后的初始值是0而不是123，因为这时候尚未执行Java方法。</p>\n</blockquote>\n<p>  特殊情况：<br>  如果类字段的字段属性表中存在<code>ConstantValue</code>属性（例如 <strong>static final</strong>修饰的变量），那么在准备阶段变量value就会被初始化为ConstantValue属性所指定的值</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-4-解析\"><a href=\"#2-4-解析\" class=\"headerlink\" title=\"2.4 解析\"></a>2.4 解析</h3><p>解析阶段就是虚拟机将<strong>常量池内的符号引用替换为直接引用</strong>的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>\n<blockquote>\n<p>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p>\n</blockquote>\n<blockquote>\n<p>直接应用：可以是直接执行目标的指针，相对偏移量或者一格能够直接定位到目标的句柄</p>\n</blockquote>\n<hr>\n<h3 id=\"2-5-初始化\"><a href=\"#2-5-初始化\" class=\"headerlink\" title=\"2.5 初始化\"></a>2.5 初始化</h3><p>初始化时类加载过程的最后一步，到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。</p>\n<p>对于初始化阶段，虚拟机<strong>严格规定了有且只有5中情况下必须对类进行初始化</strong>：</p>\n<ul>\n<li>遇到 <strong>new、getstatic、putstatic、invokestatic</strong> 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：<strong>使用new关键字实例化对象的时候、读取或设置一个类的静态字段</strong>（<strong>被final修饰、已在编译器把结果放入常量池的静态字段除外</strong>）的时候，以及调用一个类的静态方法的时候。</li>\n<li><strong>使用 java.lang.reflect 包的方法对类进行反射调用</strong>的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>\n<li>当初始化一个类的时候，如果发现<strong>其父类还没有进行过初始化</strong>，则需要先触发其父类的初始化。</li>\n<li>当虚拟机启动时，用户需要<strong>指定一个要执行的主类</strong>（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>\n<li>当使用 JDK1.7 动态语言支持时，如果一个 <strong>java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄</strong>，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li>\n</ul>\n<br>\n\n<p>接口的加载过程和类的加载过程<strong>稍有不同</strong>：</p>\n<ul>\n<li>接口中不能使用<strong>static{}</strong>语句块，但是编译器仍然会为接口生成<code>&lt;client&gt;()</code>类构造器，用于初始化接口中所定义的成员变量。</li>\n<li>当一个类在初始化时，要求其父类全部已经都被初始化了，但是一个接口在初始化时，<strong>并不要求其父接口全部已经初始化，只有真正使用到父接口时才会被初始化</strong>。</li>\n</ul>\n<p>从另外一个角度来说：<strong>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>的过程</strong></p>\n<ul>\n<li><p><code>&lt;clinit&gt;()</code>类初始化方法，编译器会按照其出现顺序，收集<strong>类变量的赋值语句、静态代码块</strong>，最终组成类初始化方法。类初始化方法一般在<strong>类初始化的时候执行</strong>。<br>例如：</p>\n<pre><code class=\"java\">  static\n  {\n      System.out.println(&quot;静态代码块&quot;);\n  }\n  static int a = 1;</code></pre>\n</li>\n<li><p><code>&lt;init&gt;()</code>实例构造器，编译器会按照其出现顺序，收集<strong>成员变量的赋值语句、普通代码块</strong>，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在<strong>实例化类对象的时候执行</strong>。<br>例如：</p>\n<pre><code class=\"java\">   {\n      System.out.println(&quot;普通代码块&quot;);\n  }\n  int b = 110;</code></pre>\n</li>\n<li><p><code>&lt;clinit&gt;()</code>方法与实例构造器(<init>())方法不同，它不需要显式地调用父类构造器， 虚拟机会保证在<strong>子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</strong></p>\n</li>\n<li><p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着<strong>父类中定义的静态语句块要优先于子类的变量赋值操作</strong>。</p>\n</li>\n<li><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中能够被正确地加速、同步，<strong>如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法</strong>，其他线程都需要<strong>阻塞等待</strong>，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"2-6-使用\"><a href=\"#2-6-使用\" class=\"headerlink\" title=\"2.6 使用\"></a>2.6 使用</h3><p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。</p>\n<hr>\n<h3 id=\"2-7-卸载\"><a href=\"#2-7-卸载\" class=\"headerlink\" title=\"2.7 卸载\"></a>2.7 卸载</h3><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"三、类加载器\"><a href=\"#三、类加载器\" class=\"headerlink\" title=\"三、类加载器\"></a>三、类加载器</h2><blockquote>\n<p><strong>通过一个类的全限定名来获取此类的二进制字节流并将其加载到JVM内存中，转化为Class对象</strong>，这个动作<strong>被放到Java虚拟机外部去实现</strong>，以便让应用程序自己决定如何去获取所需要的类，</p>\n</blockquote>\n<p>实现这个动作的代码模块被称为<strong>类加载器</strong>。</p>\n<h3 id=\"3-1-类与类加载器\"><a href=\"#3-1-类与类加载器\" class=\"headerlink\" title=\"3.1 类与类加载器\"></a>3.1 类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中的作用却远远不限于类加载阶段。</p>\n<p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身异同确立其在Java虚拟机中的唯一性</strong>，每一个类都拥有一个独立的类名称空间。</p>\n<blockquote>\n<p><strong>比较两个类是否相等，只有在这个两个类是由同一个类加载器加载的前提下才有意义</strong>，即使两个类来源于同一个Class文件，但是由于加载他们的类加载器不同，那么这两个类也必然不同。</p>\n</blockquote>\n<hr>\n<h3 id=\"3-2-类加载的三种方式\"><a href=\"#3-2-类加载的三种方式\" class=\"headerlink\" title=\"3.2 类加载的三种方式\"></a>3.2 类加载的三种方式</h3><ul>\n<li><p>通过命令行启动应用时由<strong>JVM初始化加载含有main()方法的主类</strong>。</p>\n</li>\n<li><p>通过<strong>Class.forName()方法动态加载</strong>，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。</p>\n</li>\n<li><p>通过<strong>ClassLoader.loadClass()方法动态加载</strong>，不会执行初始化块。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-3-Java语言自带的三个类加载器\"><a href=\"#3-3-Java语言自带的三个类加载器\" class=\"headerlink\" title=\"3.3 Java语言自带的三个类加载器\"></a>3.3 Java语言自带的三个类加载器</h3><ul>\n<li><p><strong>Bootstrap ClassLoader</strong> ：最顶层的加载类，主要加载核心类库，也就是我们环境变量下面%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。（C++实现）</p>\n</li>\n<li><p><strong>Extention ClassLoader</strong> ：扩展的类加载器，加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。</p>\n</li>\n<li><p><strong>Appclass Loader</strong>：也称为SystemAppClass。 加载当前应用的classpath的所有类</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"3-4-双亲委派模型\"><a href=\"#3-4-双亲委派模型\" class=\"headerlink\" title=\"3.4 双亲委派模型\"></a>3.4 双亲委派模型</h3><p>应用程序都是由这<strong>三种类加载器互相配合进行加载的</strong>，如果有必要，我们还可以加入自定义的类加载器。</p>\n<p><strong>这几种类加载器之间的层次关系，称为双亲委派模型。</strong></p>\n<p>双亲委派模型要求<strong>除了顶层的启动加载器外，其余的类加载器都应当有自己的父类加载器</strong>。这里的<strong>类加载器之间的父子关系一般都不会以继承的关系来实现</strong>，而是都<strong>使用组合关系来复用父加载器的代码</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png\" alt=\"双亲委派模型\"></p>\n<ul>\n<li><p>双亲委派机制工作过程：</p>\n<p>  如果一个类加载器收到了类加载的请求.它<strong>首先不会自己去尝试加载这个类.而是把这个请求委派给父加载器去完成,每个层次的类加载器都是如此</strong>.因此<strong>所有的加载请求最终都会传送到Bootstrap类加载器</strong>(启动类加载器)中.<strong>只有父类加载返回自己无法加载这个请求(它的搜索范围中没有找到所需的类)时.子加载器才会尝试自己去加载</strong>。</p>\n<blockquote>\n<p>比如说，另外一个人给小费，自己不会先去直接拿来塞自己钱包，我们先把钱给领导，领导再给领导，一直到公司老板，老板不想要了，再一级一级往下分。老板要是要这个钱，下面的领导和自己就一分钱没有了。</p>\n</blockquote>\n</li>\n</ul>\n<br>\n\n<blockquote>\n<p>子类先委托父类加载</p>\n</blockquote>\n<blockquote>\n<p>父类加载器有自己的加载范围，范围内没有找到，则不加载，<strong>并返回给子类</strong></p>\n</blockquote>\n<blockquote>\n<p>子类在收到父类无法加载的时候，才会自己去加载</p>\n</blockquote>\n<ul>\n<li>优势<br>  Java类随着它的类加载器一起具备了一种<strong>优先级的层次关系，保证了Java程序的稳定运行</strong>。<blockquote>\n<p>例如无论哪一个类加载器加载一个类，最终都是委派到处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载环境中都是同一个类。相反，如果没有这种机制，由各个类自行去加载的话，那么系统中将会出现多个不同的Objec类，Java体系中最基础的行为也就无法保证，应用程序也会变得一片混乱。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么<strong>类之间的比较结果及类的唯一性将无法保证</strong>，因此，为什么需要双亲委派模型？<strong>防止内存中出现多份同样的字节码</strong></p>\n</blockquote>\n<ul>\n<li><p>双亲委派模型的实现</p>\n<p>  先检查是否已经被加载过，若没有被加载过则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父类加载器，如果加载失败，则再调用自己的findClass()方法。</p>\n</li>\n</ul>\n<pre><code class=\"java\">    protected Class&lt;?&gt; loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class&lt;?&gt; c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    //先判断parent是否为空，如果不为空，先尝试用父类加载器加载；如果为空，则先尝试用类启动加载器加载\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // 如果父类加载器抛出ClassNotFoundException异常则说明父类加载器无法完成加载请求\n                }\n                if (c == null) {\n                    //如果父类加载器没加载成功，则调用findClass尝试自己加载这个类\n                    c = findClass(name);\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n</code></pre>\n<hr>\n<h3 id=\"3-5-破坏双亲委派模型\"><a href=\"#3-5-破坏双亲委派模型\" class=\"headerlink\" title=\"3.5 破坏双亲委派模型\"></a>3.5 破坏双亲委派模型</h3><p>在某些情况下<strong>父类加载器需要委托子类加载器去加载class文件</strong>。受到加载范围的限制，父类加载器无法加载到需要的文件。</p>\n<blockquote>\n<p>以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。</p>\n</blockquote>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"四、实例分析\"><a href=\"#四、实例分析\" class=\"headerlink\" title=\"四、实例分析\"></a>四、实例分析</h2><blockquote>\n<p>转载自<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html\" target=\"_blank\" rel=\"noopener\">JVM基础系列第7讲：JVM 类加载机制</a></p>\n</blockquote>\n<h3 id=\"4-1\"><a href=\"#4-1\" class=\"headerlink\" title=\"4.1\"></a>4.1</h3><pre><code class=\"java\">public class Book {\n    public static void main(String[] args)\n    {\n        System.out.println(&quot;Hello ShuYi.&quot;);\n    }\n\n    Book()\n    {\n        System.out.println(&quot;书的构造方法&quot;);\n        System.out.println(&quot;price=&quot; + price +&quot;,amount=&quot; + amount);\n    }\n\n    {\n        System.out.println(&quot;书的普通代码块&quot;);\n    }\n\n    int price = 110;\n\n    static\n    {\n        System.out.println(&quot;书的静态代码块&quot;);\n    }\n\n    static int amount = 112;\n}\n</code></pre>\n<p>最后的输出字符串为</p>\n<blockquote>\n<p>书的静态代码块<br>Hello ShuYi.</p>\n</blockquote>\n<blockquote>\n<p>下面我们来简单分析一下，首先根据上面说到的触发初始化的5种情况的第4种（<strong>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</strong>），我们会进行类的初始化。初始化会按照顺序进行，</p>\n</blockquote>\n<p>并且此处没有 Book 类对象的实例化，所以<code>&lt;init&gt;()</code>方法不会被执行</p>\n<hr>\n<h3 id=\"4-2\"><a href=\"#4-2\" class=\"headerlink\" title=\"4.2\"></a>4.2</h3><pre><code class=\"java\">class Grandpa\n{\n    static\n    {\n        System.out.println(&quot;爷爷在静态代码块&quot;);\n    }\n}    \nclass Father extends Grandpa\n{\n    static\n    {\n        System.out.println(&quot;爸爸在静态代码块&quot;);\n    }\n\n    public static int factor = 25;\n\n    public Father()\n    {\n        System.out.println(&quot;我是爸爸~&quot;);\n    }\n}\nclass Son extends Father\n{\n    static \n    {\n        System.out.println(&quot;儿子在静态代码块&quot;);\n    }\n\n    public Son()\n    {\n        System.out.println(&quot;我是儿子~&quot;);\n    }\n}\npublic class InitializationDemo\n{\n    public static void main(String[] args)\n    {\n        System.out.println(&quot;爸爸的岁数:&quot; + Son.factor);    //入口\n    }\n}\n</code></pre>\n<p>最后的输出字符串为</p>\n<blockquote>\n<p>爷爷在静态代码块<br>爸爸在静态代码块<br>爸爸的岁数:25    </p>\n</blockquote>\n<br>\n\n<p>也许会有人问为什么没有输出「儿子在静态代码块」这个字符串？</p>\n<p>这是因为<strong>对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块）</strong>。因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>\n<p>对面上面的这个例子，我们可以从入口开始分析一路分析下去：</p>\n<blockquote>\n<p>首先程序到 main 方法这里，使用标准化输出 Son 类中的 factor 类成员变量，但是 Son 类中并没有定义这个类成员变量。于是往父类去找，我们在 Father 类中找到了对应的类成员变量，于是触发了 Father 的初始化。</p>\n</blockquote>\n<blockquote>\n<p>但根据我们上面说到的初始化的 5 种情况中的第 3 种（当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化）。我们需要先初始化 Father 类的父类，也就是先初始化 Grandpa 类再初始化 Father 类。于是我们先初始化 Grandpa 类输出：「爷爷在静态代码块」，再初始化 Father 类输出：「爸爸在静态代码块」。</p>\n</blockquote>\n<blockquote>\n<p>最后，所有父类都初始化完成之后，Son 类才能调用父类的静态变量，从而输出：「爸爸的岁数：25」。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-3\"><a href=\"#4-3\" class=\"headerlink\" title=\"4.3\"></a>4.3</h3><pre><code class=\"java\">class Grandpa\n{\n    static\n    {\n        System.out.println(&quot;爷爷在静态代码块&quot;);\n    }\n\n    public Grandpa() {\n        System.out.println(&quot;我是爷爷~&quot;);\n    }\n}\nclass Father extends Grandpa\n{\n    static\n    {\n        System.out.println(&quot;爸爸在静态代码块&quot;);\n    }\n\n    public Father()\n    {\n        System.out.println(&quot;我是爸爸~&quot;);\n    }\n}\nclass Son extends Father\n{\n    static \n    {\n        System.out.println(&quot;儿子在静态代码块&quot;);\n    }\n\n    public Son()\n    {\n        System.out.println(&quot;我是儿子~&quot;);\n    }\n}\npublic class InitializationDemo\n{\n    public static void main(String[] args)\n    {\n        new Son();     //入口\n    }\n}</code></pre>\n<p>最后的输出字符串为</p>\n<blockquote>\n<p>爷爷在静态代码块<br>爸爸在静态代码块<br>儿子在静态代码块<br>我是爷爷~<br>我是爸爸~<br>我是儿子~     </p>\n</blockquote>\n<br>\n\n<blockquote>\n<p>让我们仔细来分析一下上面代码的执行流程：</p>\n</blockquote>\n<blockquote>\n<p>首先在入口这里我们实例化一个 Son 对象，因此会触发 Son 类的初始化，而 Son 类的初始化又会带动 Father 、Grandpa 类的初始化，从而执行对应类中的静态代码块。因此会输出：「爷爷在静态代码块」、「爸爸在静态代码块」、「儿子在静态代码块」。</p>\n</blockquote>\n<blockquote>\n<p>当 Son 类完成初始化之后，便会调用 Son 类的构造方法，而 Son 类构造方法的调用同样会带动 Father、Grandpa 类构造方法的调用，最后会输出：「我是爷爷」、「我是爸爸」、「我是儿子~」。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-4\"><a href=\"#4-4\" class=\"headerlink\" title=\"4.4\"></a>4.4</h3><pre><code class=\"java\">public class Book {\n    public static void main(String[] args)\n    {\n        staticFunction();\n    }\n\n    static Book book = new Book();\n\n    static\n    {\n        System.out.println(&quot;书的静态代码块&quot;);\n    }\n\n    {\n        System.out.println(&quot;书的普通代码块&quot;);\n    }\n\n    Book()\n    {\n        System.out.println(&quot;书的构造方法&quot;);\n        System.out.println(&quot;price=&quot; + price +&quot;,amount=&quot; + amount);\n    }\n\n    public static void staticFunction(){\n        System.out.println(&quot;书的静态方法&quot;);\n    }\n\n    int price = 110;\n    static int amount = 112;\n}</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>书的普通代码块<br>书的构造方法<br>price=110,amount=0<br>书的静态代码块<br>书的静态方法     </p>\n</blockquote>\n<blockquote>\n<p>下面我们一步步来分析一下代码的整个执行流程。<br>在上面两个例子中，因为 main 方法所在类并没有多余的代码，我们都直接忽略了 main 方法所在类的初始化。<br>但在这个例子中，main 方法所在类有许多代码，我们就并不能直接忽略了。</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>当 JVM 在准备阶段的时候，便会为类变量分配内存和进行初始化。此时，我们的 book 实例变量被初始化为 null，amount 变量被初始化为 0。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>当进入初始化阶段后，因为 Book 方法是程序的入口，根据我们上面说到的类初始化的五种情况的第四种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类）。所以JVM 会初始化 Book 类，即执行类构造器 。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>JVM 对 Book 类进行初始化首先是执行类构造器（按顺序收集类中所有静态代码块和类变量赋值语句就组成了类构造器 ），后执行对象的构造器（按顺序收集成员变量赋值和普通代码块，最后收集对象构造器，最终组成对象构造器 ）。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>对于 Book 类，其类构造方法（）可以简单表示如下：</p>\n</blockquote>\n<pre><code class=\"java\">static Book book = new Book();\nstatic\n{\n    System.out.println(&quot;书的静态代码块&quot;);\n}\nstatic int amount = 112;</code></pre>\n<blockquote>\n<p>于是首先执行<code>static Book book = new Book();</code>这一条语句，这条语句又触发了类的实例化。于是 JVM 执行对象构造器 ，收集后的对象构造器 代码：</p>\n</blockquote>\n<pre><code class=\"java\">{\n    System.out.println(&quot;书的普通代码块&quot;);\n}\nint price = 110;\nBook()\n{\n    System.out.println(&quot;书的构造方法&quot;);\n    System.out.println(&quot;price=&quot; + price +&quot;, amount=&quot; + amount);\n}</code></pre>\n<blockquote>\n<p>于是此时 price 赋予 110 的值，输出：「书的普通代码块」、「书的构造方法」。而此时 price 为 110 的值，而 amount 的赋值语句并未执行，所以只有在准备阶段赋予的零值，所以之后输出「price=110,amount=0」。</p>\n</blockquote>\n<blockquote>\n<p>当类实例化完成之后，JVM 继续进行类构造器的初始化：</p>\n</blockquote>\n<pre><code class=\"java\">static Book book = new Book();  //完成类实例化\nstatic\n{\n    System.out.println(&quot;书的静态代码块&quot;);\n}\nstatic int amount = 112;</code></pre>\n<blockquote>\n<p>即输出：「书的静态代码块」，之后对 amount 赋予 112 的值。</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>到这里，类的初始化已经完成，JVM 执行 main 方法的内容。</li>\n</ul>\n</blockquote>\n<pre><code class=\"java\">public static void main(String[] args)\n{\n    staticFunction();\n}</code></pre>\n<blockquote>\n<p>即输出：「书的静态方法」。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-5-方法论\"><a href=\"#4-5-方法论\" class=\"headerlink\" title=\"4.5 方法论\"></a>4.5 方法论</h3><p>从上面几个例子可以看出，分析一个类的执行顺序大概可以按照如下步骤：</p>\n<ol>\n<li><p><strong>确定类变量的初始值</strong>。在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。</p>\n</li>\n<li><p><strong>初始化入口方法</strong>。当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。</p>\n</li>\n<li><p><strong>初始化类构造器</strong>。JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。</p>\n</li>\n<li><p><strong>初始化对象构造器</strong>。JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。</p>\n</li>\n</ol>\n<p>如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。</p>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><div style=\"margin-left: 5px  font-size:16px;\">\n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br>\n[2]<a href=\"https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html</a><br>\n[3]<a href=\"https://www.cnblogs.com/joemsu/p/9310226.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/joemsu/p/9310226.html</a><br>\n[4]<a href=\"https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc\" target=\"_blank\" rel=\"noopener\">https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc</a><br>\n[5]<a href=\"https://blog.csdn.net/qq_41701956/article/details/100074023\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_41701956/article/details/100074023</a><br>\n</div>"},{"title":"BigDecimal","declare":true,"wordCount":true,"abbrlink":"5b0774c7","date":"2020-05-02T15:53:10.000Z","_content":"\n​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java在java.math包中提供的API类BigDecimal，用来**对超过16位有效位的数**进行精确的运算。双精度浮点型变量double可以处理16位有效数，但在实际应用中，可能需要对更大或者更小的数进行运算和处理。一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用Float和Double处理，但是Double.valueOf(String) 和Float.valueOf(String)会丢失精度。所以开发中，如果我们需要精确计算的结果，则必须使用BigDecimal类来操作。\n<!-- more -->\n​ ​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**BigDecimal所创建的是对象**，故我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。\n\n### 1.构造方法\n\n ```java\n    new BigDecimal(int)\n\n    new BigDecimal(double)\n\n    new BigDecimal(long)\n\n    new BigDecimal(String)\n```\n\n> **尽量使用参数类型为String的构造函数**。因为参数类型为double的构造方法的结果有一定的不可预知性，因为`BigDecimal a =new BigDecimal(0.1)`,a可能等0.1000000000000000055511151231257827021181583\n\n### 2.BigDecimal常用方法\n\n#### 2.1 加法\n```java\n    new BigDecimal(0.01).add(new BigDecimal(0.02));\n```\n#### 2.2 减法\n```java\n    new BigDecimal(0.01).subtract(new BigDecimal(0.02));\n```\n#### 2.3 乘法\n```java\n    new BigDecimal(0.01).multiply(new BigDecimal(0.02));\n```\n#### 2.4 除法\n```java\n    //除数、保留小数位数、舍入模式\n    new BigDecimal(0.01).divide(new BigDecimal(0.02), 5, ROUND_HALF_UP); \n```\n* 舍入模式    \n    1. **ROUND_UP**\n        **舍入远离零**的舍入模式。\n        在丢弃非零部分之前始终增加数字(始终对非零舍弃部分前面的数字加1)。\n        注意：此舍入模式始终不会减少计算值的大小。 \n    2. **ROUND_DOWN**\n        **接近零**的舍入模式。\n        在丢弃某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截短)。\n        注意：此舍入模式始终不会增加计算值的大小。\n    3. **ROUND_CEILING**\n        **接近正无穷大**的舍入模式。\n        如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同;\n        如果为负，则舍入行为与 ROUND_DOWN 相同。\n        注意，此舍入模式始终不会减少计算值。\n    4.**ROUND_FLOOR**\n        **接近负无穷大**的舍入模式。\n        如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同;\n        如果为负，则舍入行为与 ROUND_UP 相同。\n        注意，此舍入模式始终不会增加计算值。\n    5.**ROUND_HALF_UP**\n        **向“最接近的”数字舍入**，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。\n        如果舍弃部分 >= 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同。\n        注意，这是我们大多数人在小学时就学过的舍入模式(四舍五入)。\n    6.**ROUND_HALF_DOWN**\n        **向“最接近的”数字舍入**，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。\n        如果舍弃部分 > 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同(五舍六入)。\n    7.**ROUND_HALF_EVEN**\n        **向“最接近的”数字舍入**，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。\n        如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同;\n        如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。\n        注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。\n        此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况。\n        如果前一位为奇数，则入位，否则舍去。\n        以下例子为保留小数点1位，那么这种舍入方式下的结果。\n        1.15>1.2 1.25>1.2\n    8.**ROUND_UNNECESSARY**\n        断言请求的操作具有精确的结果，因此不需要舍入。\n        如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。 \n\n#### 2.5 转换为字符串\n```java\n    new BigDecimal(0.01).toString();\n```\n#### 2.6 转换成双精度数\n```java\n    new BigDecimal(0.01).doubleValue();\n```\n#### 2.7 转换为单精度数\n```java\n    new BigDecimal(0.01).floatValue();\n```\n#### 2.8 转换为长整数\n```java\n    new BigDecimal(0.01).longValue();\n```\n#### 2.9 转换为整型\n```java\n    new BigDecimal(0.01).intValue();\n```\n\n### 3.BigDecimal比较大小\n```java\n    BigDecimal a=new BigDecimal(1);\n    BigDecimal b=new BigDecimal(2);\n    int c=a.compareTo(b);\n```\n```\n c =  0 ;  a = b\n c = -1 ;  a < b\n c =  1 ;  a > b\n```\n<br>\n\n```\nc > -1 ;  a >= b\nc <  1 ;  a <= b\n```\n\n### 4.利用BigDecimal格式化参数\n\n    保留两位小数\n\n```java\n    public class BigDecimalFormat {\n\n        private static String formatToNumber(BigDecimal obj) {\n            DecimalFormat format = new DecimalFormat(\"#.00\");\n            if (obj.compareTo(BigDecimal.ZERO) == 0) {\n                return \"0.00\";\n            } else if (obj.compareTo(BigDecimal.ZERO) > 0 && obj.compareTo(new BigDecimal(1)) < 0) {\n                return \"0\" + format.format(obj).toString();\n            } else {\n                return format.format(obj).toString();\n            }\n        }\n\n        public static void main(String[] s) {\n            System.out.println(formatToNumber(new BigDecimal(\"3.435\")));\n            System.out.println(formatToNumber(new BigDecimal(0)));\n            System.out.println(formatToNumber(new BigDecimal(\"0.00\")));\n            System.out.println(formatToNumber(new BigDecimal(\"0.001\")));\n            System.out.println(formatToNumber(new BigDecimal(\"0.012412536\")));\n        }\n    }\n```\n\n\n\n\n\n        \n>参考：https://www.cnblogs.com/zhangyinhua/p/11545305.html","source":"_posts/code/JavaSE/BigDecimal.md","raw":"---\ntitle: BigDecimal\ncategories: Code\ntags: JavaSE\ndeclare: true\nwordCount: true\nabbrlink: 5b0774c7\ndate: 2020-05-02 23:53:10\n---\n\n​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java在java.math包中提供的API类BigDecimal，用来**对超过16位有效位的数**进行精确的运算。双精度浮点型变量double可以处理16位有效数，但在实际应用中，可能需要对更大或者更小的数进行运算和处理。一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用Float和Double处理，但是Double.valueOf(String) 和Float.valueOf(String)会丢失精度。所以开发中，如果我们需要精确计算的结果，则必须使用BigDecimal类来操作。\n<!-- more -->\n​ ​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**BigDecimal所创建的是对象**，故我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。\n\n### 1.构造方法\n\n ```java\n    new BigDecimal(int)\n\n    new BigDecimal(double)\n\n    new BigDecimal(long)\n\n    new BigDecimal(String)\n```\n\n> **尽量使用参数类型为String的构造函数**。因为参数类型为double的构造方法的结果有一定的不可预知性，因为`BigDecimal a =new BigDecimal(0.1)`,a可能等0.1000000000000000055511151231257827021181583\n\n### 2.BigDecimal常用方法\n\n#### 2.1 加法\n```java\n    new BigDecimal(0.01).add(new BigDecimal(0.02));\n```\n#### 2.2 减法\n```java\n    new BigDecimal(0.01).subtract(new BigDecimal(0.02));\n```\n#### 2.3 乘法\n```java\n    new BigDecimal(0.01).multiply(new BigDecimal(0.02));\n```\n#### 2.4 除法\n```java\n    //除数、保留小数位数、舍入模式\n    new BigDecimal(0.01).divide(new BigDecimal(0.02), 5, ROUND_HALF_UP); \n```\n* 舍入模式    \n    1. **ROUND_UP**\n        **舍入远离零**的舍入模式。\n        在丢弃非零部分之前始终增加数字(始终对非零舍弃部分前面的数字加1)。\n        注意：此舍入模式始终不会减少计算值的大小。 \n    2. **ROUND_DOWN**\n        **接近零**的舍入模式。\n        在丢弃某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截短)。\n        注意：此舍入模式始终不会增加计算值的大小。\n    3. **ROUND_CEILING**\n        **接近正无穷大**的舍入模式。\n        如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同;\n        如果为负，则舍入行为与 ROUND_DOWN 相同。\n        注意，此舍入模式始终不会减少计算值。\n    4.**ROUND_FLOOR**\n        **接近负无穷大**的舍入模式。\n        如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同;\n        如果为负，则舍入行为与 ROUND_UP 相同。\n        注意，此舍入模式始终不会增加计算值。\n    5.**ROUND_HALF_UP**\n        **向“最接近的”数字舍入**，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。\n        如果舍弃部分 >= 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同。\n        注意，这是我们大多数人在小学时就学过的舍入模式(四舍五入)。\n    6.**ROUND_HALF_DOWN**\n        **向“最接近的”数字舍入**，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。\n        如果舍弃部分 > 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同(五舍六入)。\n    7.**ROUND_HALF_EVEN**\n        **向“最接近的”数字舍入**，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。\n        如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同;\n        如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。\n        注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。\n        此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况。\n        如果前一位为奇数，则入位，否则舍去。\n        以下例子为保留小数点1位，那么这种舍入方式下的结果。\n        1.15>1.2 1.25>1.2\n    8.**ROUND_UNNECESSARY**\n        断言请求的操作具有精确的结果，因此不需要舍入。\n        如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。 \n\n#### 2.5 转换为字符串\n```java\n    new BigDecimal(0.01).toString();\n```\n#### 2.6 转换成双精度数\n```java\n    new BigDecimal(0.01).doubleValue();\n```\n#### 2.7 转换为单精度数\n```java\n    new BigDecimal(0.01).floatValue();\n```\n#### 2.8 转换为长整数\n```java\n    new BigDecimal(0.01).longValue();\n```\n#### 2.9 转换为整型\n```java\n    new BigDecimal(0.01).intValue();\n```\n\n### 3.BigDecimal比较大小\n```java\n    BigDecimal a=new BigDecimal(1);\n    BigDecimal b=new BigDecimal(2);\n    int c=a.compareTo(b);\n```\n```\n c =  0 ;  a = b\n c = -1 ;  a < b\n c =  1 ;  a > b\n```\n<br>\n\n```\nc > -1 ;  a >= b\nc <  1 ;  a <= b\n```\n\n### 4.利用BigDecimal格式化参数\n\n    保留两位小数\n\n```java\n    public class BigDecimalFormat {\n\n        private static String formatToNumber(BigDecimal obj) {\n            DecimalFormat format = new DecimalFormat(\"#.00\");\n            if (obj.compareTo(BigDecimal.ZERO) == 0) {\n                return \"0.00\";\n            } else if (obj.compareTo(BigDecimal.ZERO) > 0 && obj.compareTo(new BigDecimal(1)) < 0) {\n                return \"0\" + format.format(obj).toString();\n            } else {\n                return format.format(obj).toString();\n            }\n        }\n\n        public static void main(String[] s) {\n            System.out.println(formatToNumber(new BigDecimal(\"3.435\")));\n            System.out.println(formatToNumber(new BigDecimal(0)));\n            System.out.println(formatToNumber(new BigDecimal(\"0.00\")));\n            System.out.println(formatToNumber(new BigDecimal(\"0.001\")));\n            System.out.println(formatToNumber(new BigDecimal(\"0.012412536\")));\n        }\n    }\n```\n\n\n\n\n\n        \n>参考：https://www.cnblogs.com/zhangyinhua/p/11545305.html","slug":"code/JavaSE/BigDecimal","published":1,"updated":"2020-11-20T06:42:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1g6003u0w7t5f5u3yun","content":"<p>​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java在java.math包中提供的API类BigDecimal，用来<strong>对超过16位有效位的数</strong>进行精确的运算。双精度浮点型变量double可以处理16位有效数，但在实际应用中，可能需要对更大或者更小的数进行运算和处理。一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用Float和Double处理，但是Double.valueOf(String) 和Float.valueOf(String)会丢失精度。所以开发中，如果我们需要精确计算的结果，则必须使用BigDecimal类来操作。</p>\n<a id=\"more\"></a>\n<p>​ ​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>BigDecimal所创建的是对象</strong>，故我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。</p>\n<h3 id=\"1-构造方法\"><a href=\"#1-构造方法\" class=\"headerlink\" title=\"1.构造方法\"></a>1.构造方法</h3><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span></code></pre>\n<blockquote>\n<p><strong>尽量使用参数类型为String的构造函数</strong>。因为参数类型为double的构造方法的结果有一定的不可预知性，因为<code>BigDecimal a =new BigDecimal(0.1)</code>,a可能等0.1000000000000000055511151231257827021181583</p>\n</blockquote>\n<h3 id=\"2-BigDecimal常用方法\"><a href=\"#2-BigDecimal常用方法\" class=\"headerlink\" title=\"2.BigDecimal常用方法\"></a>2.BigDecimal常用方法</h3><h4 id=\"2-1-加法\"><a href=\"#2-1-加法\" class=\"headerlink\" title=\"2.1 加法\"></a>2.1 加法</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.02</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"2-2-减法\"><a href=\"#2-2-减法\" class=\"headerlink\" title=\"2.2 减法\"></a>2.2 减法</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.02</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"2-3-乘法\"><a href=\"#2-3-乘法\" class=\"headerlink\" title=\"2.3 乘法\"></a>2.3 乘法</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">multiply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.02</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"2-4-除法\"><a href=\"#2-4-除法\" class=\"headerlink\" title=\"2.4 除法\"></a>2.4 除法</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token comment\" spellcheck=\"true\">//除数、保留小数位数、舍入模式</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">divide</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.02</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> ROUND_HALF_UP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </code></pre>\n<ul>\n<li>舍入模式    <ol>\n<li><strong>ROUND_UP</strong><br> <strong>舍入远离零</strong>的舍入模式。<br> 在丢弃非零部分之前始终增加数字(始终对非零舍弃部分前面的数字加1)。<br> 注意：此舍入模式始终不会减少计算值的大小。 </li>\n<li><strong>ROUND_DOWN</strong><br> <strong>接近零</strong>的舍入模式。<br> 在丢弃某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截短)。<br> 注意：此舍入模式始终不会增加计算值的大小。</li>\n<li><strong>ROUND_CEILING</strong><br> <strong>接近正无穷大</strong>的舍入模式。<br> 如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同;<br> 如果为负，则舍入行为与 ROUND_DOWN 相同。<br> 注意，此舍入模式始终不会减少计算值。</li>\n<li><strong>ROUND_FLOOR</strong><br>  <strong>接近负无穷大</strong>的舍入模式。<br>  如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同;<br>  如果为负，则舍入行为与 ROUND_UP 相同。<br>  注意，此舍入模式始终不会增加计算值。</li>\n<li><strong>ROUND_HALF_UP</strong><br>  <strong>向“最接近的”数字舍入</strong>，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。<br>  如果舍弃部分 &gt;= 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同。<br>  注意，这是我们大多数人在小学时就学过的舍入模式(四舍五入)。</li>\n<li><strong>ROUND_HALF_DOWN</strong><br>  <strong>向“最接近的”数字舍入</strong>，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。<br>  如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同(五舍六入)。</li>\n<li><strong>ROUND_HALF_EVEN</strong><br>  <strong>向“最接近的”数字舍入</strong>，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。<br>  如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同;<br>  如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。<br>  注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。<br>  此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况。<br>  如果前一位为奇数，则入位，否则舍去。<br>  以下例子为保留小数点1位，那么这种舍入方式下的结果。<br>  1.15&gt;1.2 1.25&gt;1.2</li>\n<li><strong>ROUND_UNNECESSARY</strong><br>  断言请求的操作具有精确的结果，因此不需要舍入。<br>  如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。 </li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-5-转换为字符串\"><a href=\"#2-5-转换为字符串\" class=\"headerlink\" title=\"2.5 转换为字符串\"></a>2.5 转换为字符串</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"2-6-转换成双精度数\"><a href=\"#2-6-转换成双精度数\" class=\"headerlink\" title=\"2.6 转换成双精度数\"></a>2.6 转换成双精度数</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">doubleValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"2-7-转换为单精度数\"><a href=\"#2-7-转换为单精度数\" class=\"headerlink\" title=\"2.7 转换为单精度数\"></a>2.7 转换为单精度数</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">floatValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"2-8-转换为长整数\"><a href=\"#2-8-转换为长整数\" class=\"headerlink\" title=\"2.8 转换为长整数\"></a>2.8 转换为长整数</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">longValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"2-9-转换为整型\"><a href=\"#2-9-转换为整型\" class=\"headerlink\" title=\"2.9 转换为整型\"></a>2.9 转换为整型</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">intValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"3-BigDecimal比较大小\"><a href=\"#3-BigDecimal比较大小\" class=\"headerlink\" title=\"3.BigDecimal比较大小\"></a>3.BigDecimal比较大小</h3><pre class=\" language-java\"><code class=\"language-java\">    BigDecimal a<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    BigDecimal b<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c<span class=\"token operator\">=</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<pre><code> c =  0 ;  a = b\n c = -1 ;  a &lt; b\n c =  1 ;  a &gt; b</code></pre><br>\n\n<pre><code>c &gt; -1 ;  a &gt;= b\nc &lt;  1 ;  a &lt;= b</code></pre><h3 id=\"4-利用BigDecimal格式化参数\"><a href=\"#4-利用BigDecimal格式化参数\" class=\"headerlink\" title=\"4.利用BigDecimal格式化参数\"></a>4.利用BigDecimal格式化参数</h3><pre><code>保留两位小数</code></pre><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BigDecimalFormat</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">formatToNumber</span><span class=\"token punctuation\">(</span>BigDecimal obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            DecimalFormat format <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DecimalFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"#.00\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>BigDecimal<span class=\"token punctuation\">.</span>ZERO<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token string\">\"0.00\"</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>BigDecimal<span class=\"token punctuation\">.</span>ZERO<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> obj<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token string\">\"0\"</span> <span class=\"token operator\">+</span> format<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> format<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">formatToNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"3.435\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">formatToNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">formatToNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0.00\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">formatToNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0.001\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">formatToNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0.012412536\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/zhangyinhua/p/11545305.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhangyinhua/p/11545305.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java在java.math包中提供的API类BigDecimal，用来<strong>对超过16位有效位的数</strong>进行精确的运算。双精度浮点型变量double可以处理16位有效数，但在实际应用中，可能需要对更大或者更小的数进行运算和处理。一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用Float和Double处理，但是Double.valueOf(String) 和Float.valueOf(String)会丢失精度。所以开发中，如果我们需要精确计算的结果，则必须使用BigDecimal类来操作。</p>","more":"<p>​ ​&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>BigDecimal所创建的是对象</strong>，故我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。</p>\n<h3 id=\"1-构造方法\"><a href=\"#1-构造方法\" class=\"headerlink\" title=\"1.构造方法\"></a>1.构造方法</h3><pre><code class=\"java\">    new BigDecimal(int)\n\n    new BigDecimal(double)\n\n    new BigDecimal(long)\n\n    new BigDecimal(String)</code></pre>\n<blockquote>\n<p><strong>尽量使用参数类型为String的构造函数</strong>。因为参数类型为double的构造方法的结果有一定的不可预知性，因为<code>BigDecimal a =new BigDecimal(0.1)</code>,a可能等0.1000000000000000055511151231257827021181583</p>\n</blockquote>\n<h3 id=\"2-BigDecimal常用方法\"><a href=\"#2-BigDecimal常用方法\" class=\"headerlink\" title=\"2.BigDecimal常用方法\"></a>2.BigDecimal常用方法</h3><h4 id=\"2-1-加法\"><a href=\"#2-1-加法\" class=\"headerlink\" title=\"2.1 加法\"></a>2.1 加法</h4><pre><code class=\"java\">    new BigDecimal(0.01).add(new BigDecimal(0.02));</code></pre>\n<h4 id=\"2-2-减法\"><a href=\"#2-2-减法\" class=\"headerlink\" title=\"2.2 减法\"></a>2.2 减法</h4><pre><code class=\"java\">    new BigDecimal(0.01).subtract(new BigDecimal(0.02));</code></pre>\n<h4 id=\"2-3-乘法\"><a href=\"#2-3-乘法\" class=\"headerlink\" title=\"2.3 乘法\"></a>2.3 乘法</h4><pre><code class=\"java\">    new BigDecimal(0.01).multiply(new BigDecimal(0.02));</code></pre>\n<h4 id=\"2-4-除法\"><a href=\"#2-4-除法\" class=\"headerlink\" title=\"2.4 除法\"></a>2.4 除法</h4><pre><code class=\"java\">    //除数、保留小数位数、舍入模式\n    new BigDecimal(0.01).divide(new BigDecimal(0.02), 5, ROUND_HALF_UP); </code></pre>\n<ul>\n<li>舍入模式    <ol>\n<li><strong>ROUND_UP</strong><br> <strong>舍入远离零</strong>的舍入模式。<br> 在丢弃非零部分之前始终增加数字(始终对非零舍弃部分前面的数字加1)。<br> 注意：此舍入模式始终不会减少计算值的大小。 </li>\n<li><strong>ROUND_DOWN</strong><br> <strong>接近零</strong>的舍入模式。<br> 在丢弃某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截短)。<br> 注意：此舍入模式始终不会增加计算值的大小。</li>\n<li><strong>ROUND_CEILING</strong><br> <strong>接近正无穷大</strong>的舍入模式。<br> 如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同;<br> 如果为负，则舍入行为与 ROUND_DOWN 相同。<br> 注意，此舍入模式始终不会减少计算值。</li>\n<li><strong>ROUND_FLOOR</strong><br>  <strong>接近负无穷大</strong>的舍入模式。<br>  如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同;<br>  如果为负，则舍入行为与 ROUND_UP 相同。<br>  注意，此舍入模式始终不会增加计算值。</li>\n<li><strong>ROUND_HALF_UP</strong><br>  <strong>向“最接近的”数字舍入</strong>，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。<br>  如果舍弃部分 &gt;= 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同。<br>  注意，这是我们大多数人在小学时就学过的舍入模式(四舍五入)。</li>\n<li><strong>ROUND_HALF_DOWN</strong><br>  <strong>向“最接近的”数字舍入</strong>，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。<br>  如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同(五舍六入)。</li>\n<li><strong>ROUND_HALF_EVEN</strong><br>  <strong>向“最接近的”数字舍入</strong>，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。<br>  如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同;<br>  如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。<br>  注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。<br>  此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况。<br>  如果前一位为奇数，则入位，否则舍去。<br>  以下例子为保留小数点1位，那么这种舍入方式下的结果。<br>  1.15&gt;1.2 1.25&gt;1.2</li>\n<li><strong>ROUND_UNNECESSARY</strong><br>  断言请求的操作具有精确的结果，因此不需要舍入。<br>  如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。 </li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-5-转换为字符串\"><a href=\"#2-5-转换为字符串\" class=\"headerlink\" title=\"2.5 转换为字符串\"></a>2.5 转换为字符串</h4><pre><code class=\"java\">    new BigDecimal(0.01).toString();</code></pre>\n<h4 id=\"2-6-转换成双精度数\"><a href=\"#2-6-转换成双精度数\" class=\"headerlink\" title=\"2.6 转换成双精度数\"></a>2.6 转换成双精度数</h4><pre><code class=\"java\">    new BigDecimal(0.01).doubleValue();</code></pre>\n<h4 id=\"2-7-转换为单精度数\"><a href=\"#2-7-转换为单精度数\" class=\"headerlink\" title=\"2.7 转换为单精度数\"></a>2.7 转换为单精度数</h4><pre><code class=\"java\">    new BigDecimal(0.01).floatValue();</code></pre>\n<h4 id=\"2-8-转换为长整数\"><a href=\"#2-8-转换为长整数\" class=\"headerlink\" title=\"2.8 转换为长整数\"></a>2.8 转换为长整数</h4><pre><code class=\"java\">    new BigDecimal(0.01).longValue();</code></pre>\n<h4 id=\"2-9-转换为整型\"><a href=\"#2-9-转换为整型\" class=\"headerlink\" title=\"2.9 转换为整型\"></a>2.9 转换为整型</h4><pre><code class=\"java\">    new BigDecimal(0.01).intValue();</code></pre>\n<h3 id=\"3-BigDecimal比较大小\"><a href=\"#3-BigDecimal比较大小\" class=\"headerlink\" title=\"3.BigDecimal比较大小\"></a>3.BigDecimal比较大小</h3><pre><code class=\"java\">    BigDecimal a=new BigDecimal(1);\n    BigDecimal b=new BigDecimal(2);\n    int c=a.compareTo(b);</code></pre>\n<pre><code> c =  0 ;  a = b\n c = -1 ;  a &lt; b\n c =  1 ;  a &gt; b</code></pre><br>\n\n<pre><code>c &gt; -1 ;  a &gt;= b\nc &lt;  1 ;  a &lt;= b</code></pre><h3 id=\"4-利用BigDecimal格式化参数\"><a href=\"#4-利用BigDecimal格式化参数\" class=\"headerlink\" title=\"4.利用BigDecimal格式化参数\"></a>4.利用BigDecimal格式化参数</h3><pre><code>保留两位小数</code></pre><pre><code class=\"java\">    public class BigDecimalFormat {\n\n        private static String formatToNumber(BigDecimal obj) {\n            DecimalFormat format = new DecimalFormat(&quot;#.00&quot;);\n            if (obj.compareTo(BigDecimal.ZERO) == 0) {\n                return &quot;0.00&quot;;\n            } else if (obj.compareTo(BigDecimal.ZERO) &gt; 0 &amp;&amp; obj.compareTo(new BigDecimal(1)) &lt; 0) {\n                return &quot;0&quot; + format.format(obj).toString();\n            } else {\n                return format.format(obj).toString();\n            }\n        }\n\n        public static void main(String[] s) {\n            System.out.println(formatToNumber(new BigDecimal(&quot;3.435&quot;)));\n            System.out.println(formatToNumber(new BigDecimal(0)));\n            System.out.println(formatToNumber(new BigDecimal(&quot;0.00&quot;)));\n            System.out.println(formatToNumber(new BigDecimal(&quot;0.001&quot;)));\n            System.out.println(formatToNumber(new BigDecimal(&quot;0.012412536&quot;)));\n        }\n    }</code></pre>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/zhangyinhua/p/11545305.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhangyinhua/p/11545305.html</a></p>\n</blockquote>"},{"title":"【转载】不可不说的Java“锁”事","declare":false,"wordCount":true,"abbrlink":"86818cd5","date":"2020-07-07T00:15:10.000Z","_content":"\nJava提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。\n\nJava中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：\n![java主流锁](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/java主流锁.png)\n<!-- more -->\n\n\n### 1. 乐观锁 VS 悲观锁\n\n乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。\n\n先说概念。对于同一个数据的并发操作，**悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改**。Java中，synchronized关键字和Lock的实现类都是悲观锁。\n\n**而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据**。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（**例如报错或者自动重试**）。\n\n乐观锁在Java中是通过使用无锁编程来实现，**最常采用的是CAS算法**，Java原子类中的递增操作就通过CAS自旋实现的。\n<div style=\"width: 95%\">\n\n![悲观锁和乐观锁](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/悲观锁和乐观锁.png)\n</div>\n\n根据从上面的概念描述我们可以发现：\n\n* 悲观锁适合**写操作多**的场景，先加锁可以保证写操作时数据正确。\n\n* 乐观锁适合**读操作多**的场景，不加锁的特点能够使其读操作的性能大幅提升。\n\n光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：\n\n\n```java\n// ------------------------- 悲观锁的调用方式 -------------------------\n// synchronized\npublic synchronized void testMethod() {\n\t// 操作同步资源\n}\n// ReentrantLock\nprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁\npublic void modifyPublicResources() {\n\tlock.lock();\n\t// 操作同步资源\n\tlock.unlock();\n}\n\n// ------------------------- 乐观锁的调用方式 -------------------------\nprivate AtomicInteger atomicInteger = new AtomicInteger();  // 需要保证多个线程使用的是同一个AtomicInteger\natomicInteger.incrementAndGet(); //执行自增1\n```\n\n\n通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。\n\nCAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。\n\nCAS算法涉及到三个操作数：\n\n* 当前内存值 V。\n* 旧的预期值 A。\n* 即将更新的值 B。\n\n**当且仅当 V (当前内存值) 的值等于 A (旧的预期值)** 时，CAS通过原子方式**用新值B来更新V的值**（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。\n\n之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：\n<div style=\"width: 95%\">\n\n![AtomicInteger定义](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/AtomicInteger定义.png)\n</div>\n\n根据定义我们可以看出各属性的作用：\n\n* unsafe： 获取并操作内存的数据。\n\n* valueOffset： 存储value在AtomicInteger中的偏移量。\n\n* value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。\n\n接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：\n\n```java\n// ------------------------- JDK 8 -------------------------\n// AtomicInteger 自增方法\npublic final int incrementAndGet() {\n  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n}\n\n// Unsafe.class\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n  int var5;\n  do {\n      var5 = this.getIntVolatile(var1, var2);\n  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n  return var5;\n}\n\n// ------------------------- OpenJDK 8 -------------------------\n// Unsafe.java\npublic final int getAndAddInt(Object o, long offset, int delta) {\n   int v;\n   do {\n       v = getIntVolatile(o, offset);\n   } while (!compareAndSwapInt(o, offset, v, v + delta));\n   return v;\n}\n```\n\n根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。\n\n后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。\n\nCAS虽然很高效，但是它也存在三大问题，这里也简单说一下：\n\n1. **ABA问题**。CAS需要在操作值的时候**检查内存值是否发生变化，有发生变化才会更新内存值**。但是**如果内存值原来是A，后来变成了B，然后又变成了A**，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面**添加版本号**，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。  JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。\n\n2. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。\n\n3. **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。  Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。\n\n<br><br>\n\n***\n\n<br><br>\n\n### 2. 自旋锁 VS 适应性自旋锁\n\n介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。\n\n**阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时**间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。\n\n在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，**线程挂起和恢复现场的花费可能会让系统得不偿失**。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。\n\n而为了**让当前线程“稍等一下”，我们需让当前线程进行自旋**，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，**从而避免切换线程的开销**。这就是自旋锁。\n<div style=\"width: 95%\">\n\n![自旋锁.png](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/自旋锁.png)\n</div>\n\n自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。**如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源**。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（**默认是10次**，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。\n\n自旋锁的**实现原理同样也是CAS**，AtomicInteger中调用unsafe进行**自增操作的源码中的do-while循环就是一个自旋操作**，如果修改数值失败则通过循环来执行自旋，直至修改成功。\n<div style=\"width: 95%\">\n\n![Unsafe源码自增](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/Unsafe源码自增.png)\n</div>\n自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。\n\n自适应意味着**自旋的时间（次数）不再固定**，而是*由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。*\n\n在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。\n\n<br><br>\n\n***\n\n<br><br>\n\n### 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁\n\n这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。\n\n首先为什么Synchronized能实现线程同步？\n\n在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。\n\nJava对象头\n\n**synchronized是悲观锁**，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？\n\n我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。\n\nMark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。\n\nKlass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n\nMonitor\n\nMonitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。\n\nMonitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。\n\n现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。\n\n如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。\n\n所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。\n\n通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：\n\n\n|锁状态|存储特点|存储内容|\n|-|-|-|\n|无锁|对象的hashCode、对象分代年龄、是否偏向锁（0）|01|\n|偏向锁|偏向线程ID、偏向时间戳、对象分代年龄、是否偏向锁（1）|01|\n|轻量级锁|指向栈中锁记录的指针|00|\n|重量级锁|指向互斥量（重量级锁）的指针|10|\n\n\n**无锁**\n\n**无锁没有对资源进行锁定**，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。\n\n无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的**CAS原理及应用即是无锁的实现**。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。\n\n**偏向锁**\n\n偏向锁是指**一段同步代码一直被一个线程所访问，那么该线程会自动获取锁**，降低获取锁的代价。\n\n在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。\n\n当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。\n\n偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。\n\n**轻量级锁**\n\n是指**当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁**，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。\n\n在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。\n\n拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。\n\n如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。\n\n如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。\n\n若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。\n\n重量级锁\n\n升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。\n\n整体的锁状态升级流程如下：\n<div style=\"width: 95%\">\n\n![锁状态升级流程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/锁状态升级流程.png)\n</div>\n综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。\n\n<br><br>\n\n***\n\n<br><br>\n\n### 4. 公平锁 VS 非公平锁\n\n**公平锁是指多个线程按照申请锁的顺序来获取锁**，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的**线程不会饿死。缺点是整体吞吐效率相对非公平锁要低**，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。\n\n**非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待**。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，**所以非公平锁有可能出现后申请锁的线程先获取锁的场景**。非公平锁的**优点是可以减少唤起线程的开销，整体的吞吐效率高，**因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。\n\n直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。\n<div style=\"width: 95%\">\n\n![公平锁和非公平锁的例子-1](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/公平锁和非公平锁的例子-1.png)\n</div>\n\n如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。\n\n但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：\n<div style=\"width: 95%\">\n\n![公平锁和非公平锁例子-2](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/公平锁和非公平锁例子-2.png)\n</div>\n接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。\n<div style=\"width: 95%\">\n\n![ReentrantLock源码](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantLock源码.png)\n</div>\n根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。\n\n下面我们来看一下公平锁与非公平锁的加锁方法的源码:\n<div style=\"width: 95%\">\n\n![公平锁和非公平锁加锁源码](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/公平锁和非公平锁加锁源码.png)\n</div>\n通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。\n<div style=\"width: 95%\">\n\n![hasQueuePredecessors()源码](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/hasQueuePredecessors()源码.png)\n</div>\n再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。\n\n综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。\n\n<br><br>\n\n***\n\n<br><br>\n\n### 5. 可重入锁 VS 非可重入锁\n\n可重入锁又名递归锁，是指在**同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁**（前提锁对象得是同一个对象或者class），**不会因为之前已经获取过还没释放而阻塞**。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：\n\n\n```java\npublic class Widget {\n    public synchronized void doSomething() {\n        System.out.println(\"方法1执行...\");\n        doOthers();\n    }\n\n    public synchronized void doOthers() {\n        System.out.println(\"方法2执行...\");\n    }\n}\n```\n\n在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。\n\n如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。\n\n而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。\n\n还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。\n<div style=\"width: 95%\">\n\n![可重入锁实例-2](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/可重入锁实例-2.png)\n</div>\n但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。\n<div style=\"width: 95%\">\n\n![可重入锁实例-3](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/可重入锁实例-3.png)\n</div>\n之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。\n\n首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。\n\n当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。\n\n释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。\n<div style=\"width: 95%\">\n\n![可重入锁实例-4](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/可重入锁实例-4.png)\n</div>\n<br><br>\n\n***\n\n<br><br>\n\n### 6. 独享锁 VS 共享锁#\n\n独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。\n\n**独享锁也叫排他锁，是指该锁一次只能被一个线程所持有**。如果线程T对数据A加上排它锁后，则**其他线程不能再对A加任何类型的锁**。获得排它锁的线程**既能读数据又能修改数据**。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。\n\n**共享锁是指该锁可被多个线程所持有**。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得**共享锁的线程只能读数据，不能修改数据**。\n\n独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。\n\n下图为ReentrantReadWriteLock的部分源码：\n<div style=\"width: 95%\">\n\n![ReentrantReadWriteLock部分源码](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantReadWriteLock部分源码.png)\n\n</div>\n我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。\n\n在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。\n\n那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。\n\n在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。\n\n在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：\n<div style=\"width: 95%\">\n\n![ReentrantReadWriteLock中state变量](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantReadWriteLock中state变量.png)\n</div>\n了解了概念之后我们再来看代码，先看写锁的加锁源码：\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n\tThread current = Thread.currentThread();\n\tint c = getState(); // 取到当前锁的个数\n\tint w = exclusiveCount(c); // 取写锁的个数w\n\tif (c != 0) { // 如果已经有线程持有了锁(c!=0)\n    // (Note: if c != 0 and w == 0 then shared count != 0)\n\t\tif (w == 0 || current != getExclusiveOwnerThread()) // 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败\n\t\t\treturn false;\n\t\tif (w + exclusiveCount(acquires) > MAX_COUNT)    // 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。\n      throw new Error(\"Maximum lock count exceeded\");\n\t\t// Reentrant acquire\n    setState(c + acquires);\n    return true;\n  }\n  if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。\n\t\treturn false;\n\tsetExclusiveOwnerThread(current); // 如果c=0，w=0或者c>0，w>0（重入），则设置当前线程或锁的拥有者\n\treturn true;\n}\n```\n\n* 这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount(c); ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。\n\n* 在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁（c!=0），则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。\n\n* 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。\n\n* 如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。\n\n* 如果c=0，w=0或者c>0，w>0（重入），则设置当前线程或锁的拥有者，返回成功！\n\ntryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。\n\n因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。\n\n接着是读锁的代码：\n\n```java\nprotected final int tryAcquireShared(int unused) {\n    Thread current = Thread.currentThread();\n    int c = getState();\n    if (exclusiveCount(c) != 0 &&\n        getExclusiveOwnerThread() != current)\n        return -1;                                   // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态\n    int r = sharedCount(c);\n    if (!readerShouldBlock() &&\n        r < MAX_COUNT &&\n        compareAndSetState(c, c + SHARED_UNIT)) {\n        if (r == 0) {\n            firstReader = current;\n            firstReaderHoldCount = 1;\n        } else if (firstReader == current) {\n            firstReaderHoldCount++;\n        } else {\n            HoldCounter rh = cachedHoldCounter;\n            if (rh == null || rh.tid != getThreadId(current))\n                cachedHoldCounter = rh = readHolds.get();\n            else if (rh.count == 0)\n                readHolds.set(rh);\n            rh.count++;\n        }\n        return 1;\n    }\n    return fullTryAcquireShared(current);\n}\n```\n\n可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1<<16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。\n\n此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：\n<div style=\"width: 95%\">\n\n![ReentrantLock中公平锁和非公平锁的加锁源码](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantLock中公平锁和非公平锁的加锁源码.png)\n</div>\n我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。\n\n\n结语\n\n本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。\n\n其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。\n\n\n<br><br>\n\n\n<br><br>\n>版权声明：本文为CSDN博主「美团技术团队」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。    \n>原文链接：https://blog.csdn.net/MeituanTech/article/details/84138163\n","source":"_posts/code/JVM/JVM学习笔记(五)——Java的各种锁.md","raw":"---\ntitle: 【转载】不可不说的Java“锁”事\ncategories: Code\ntags: JVM\ndeclare: false\nwordCount: true\nabbrlink: 86818cd5\ndate: 2020-07-07 08:15:10\n---\n\nJava提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。\n\nJava中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：\n![java主流锁](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/java主流锁.png)\n<!-- more -->\n\n\n### 1. 乐观锁 VS 悲观锁\n\n乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。\n\n先说概念。对于同一个数据的并发操作，**悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改**。Java中，synchronized关键字和Lock的实现类都是悲观锁。\n\n**而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据**。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（**例如报错或者自动重试**）。\n\n乐观锁在Java中是通过使用无锁编程来实现，**最常采用的是CAS算法**，Java原子类中的递增操作就通过CAS自旋实现的。\n<div style=\"width: 95%\">\n\n![悲观锁和乐观锁](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/悲观锁和乐观锁.png)\n</div>\n\n根据从上面的概念描述我们可以发现：\n\n* 悲观锁适合**写操作多**的场景，先加锁可以保证写操作时数据正确。\n\n* 乐观锁适合**读操作多**的场景，不加锁的特点能够使其读操作的性能大幅提升。\n\n光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：\n\n\n```java\n// ------------------------- 悲观锁的调用方式 -------------------------\n// synchronized\npublic synchronized void testMethod() {\n\t// 操作同步资源\n}\n// ReentrantLock\nprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁\npublic void modifyPublicResources() {\n\tlock.lock();\n\t// 操作同步资源\n\tlock.unlock();\n}\n\n// ------------------------- 乐观锁的调用方式 -------------------------\nprivate AtomicInteger atomicInteger = new AtomicInteger();  // 需要保证多个线程使用的是同一个AtomicInteger\natomicInteger.incrementAndGet(); //执行自增1\n```\n\n\n通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。\n\nCAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。\n\nCAS算法涉及到三个操作数：\n\n* 当前内存值 V。\n* 旧的预期值 A。\n* 即将更新的值 B。\n\n**当且仅当 V (当前内存值) 的值等于 A (旧的预期值)** 时，CAS通过原子方式**用新值B来更新V的值**（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。\n\n之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：\n<div style=\"width: 95%\">\n\n![AtomicInteger定义](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/AtomicInteger定义.png)\n</div>\n\n根据定义我们可以看出各属性的作用：\n\n* unsafe： 获取并操作内存的数据。\n\n* valueOffset： 存储value在AtomicInteger中的偏移量。\n\n* value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。\n\n接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：\n\n```java\n// ------------------------- JDK 8 -------------------------\n// AtomicInteger 自增方法\npublic final int incrementAndGet() {\n  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n}\n\n// Unsafe.class\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n  int var5;\n  do {\n      var5 = this.getIntVolatile(var1, var2);\n  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n  return var5;\n}\n\n// ------------------------- OpenJDK 8 -------------------------\n// Unsafe.java\npublic final int getAndAddInt(Object o, long offset, int delta) {\n   int v;\n   do {\n       v = getIntVolatile(o, offset);\n   } while (!compareAndSwapInt(o, offset, v, v + delta));\n   return v;\n}\n```\n\n根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。\n\n后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。\n\nCAS虽然很高效，但是它也存在三大问题，这里也简单说一下：\n\n1. **ABA问题**。CAS需要在操作值的时候**检查内存值是否发生变化，有发生变化才会更新内存值**。但是**如果内存值原来是A，后来变成了B，然后又变成了A**，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面**添加版本号**，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。  JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。\n\n2. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。\n\n3. **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。  Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。\n\n<br><br>\n\n***\n\n<br><br>\n\n### 2. 自旋锁 VS 适应性自旋锁\n\n介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。\n\n**阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时**间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。\n\n在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，**线程挂起和恢复现场的花费可能会让系统得不偿失**。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。\n\n而为了**让当前线程“稍等一下”，我们需让当前线程进行自旋**，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，**从而避免切换线程的开销**。这就是自旋锁。\n<div style=\"width: 95%\">\n\n![自旋锁.png](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/自旋锁.png)\n</div>\n\n自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。**如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源**。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（**默认是10次**，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。\n\n自旋锁的**实现原理同样也是CAS**，AtomicInteger中调用unsafe进行**自增操作的源码中的do-while循环就是一个自旋操作**，如果修改数值失败则通过循环来执行自旋，直至修改成功。\n<div style=\"width: 95%\">\n\n![Unsafe源码自增](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/Unsafe源码自增.png)\n</div>\n自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。\n\n自适应意味着**自旋的时间（次数）不再固定**，而是*由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。*\n\n在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。\n\n<br><br>\n\n***\n\n<br><br>\n\n### 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁\n\n这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。\n\n首先为什么Synchronized能实现线程同步？\n\n在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。\n\nJava对象头\n\n**synchronized是悲观锁**，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？\n\n我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。\n\nMark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。\n\nKlass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n\nMonitor\n\nMonitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。\n\nMonitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。\n\n现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。\n\n如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。\n\n所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。\n\n通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：\n\n\n|锁状态|存储特点|存储内容|\n|-|-|-|\n|无锁|对象的hashCode、对象分代年龄、是否偏向锁（0）|01|\n|偏向锁|偏向线程ID、偏向时间戳、对象分代年龄、是否偏向锁（1）|01|\n|轻量级锁|指向栈中锁记录的指针|00|\n|重量级锁|指向互斥量（重量级锁）的指针|10|\n\n\n**无锁**\n\n**无锁没有对资源进行锁定**，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。\n\n无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的**CAS原理及应用即是无锁的实现**。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。\n\n**偏向锁**\n\n偏向锁是指**一段同步代码一直被一个线程所访问，那么该线程会自动获取锁**，降低获取锁的代价。\n\n在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。\n\n当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。\n\n偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。\n\n**轻量级锁**\n\n是指**当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁**，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。\n\n在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。\n\n拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。\n\n如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。\n\n如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。\n\n若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。\n\n重量级锁\n\n升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。\n\n整体的锁状态升级流程如下：\n<div style=\"width: 95%\">\n\n![锁状态升级流程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/锁状态升级流程.png)\n</div>\n综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。\n\n<br><br>\n\n***\n\n<br><br>\n\n### 4. 公平锁 VS 非公平锁\n\n**公平锁是指多个线程按照申请锁的顺序来获取锁**，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的**线程不会饿死。缺点是整体吞吐效率相对非公平锁要低**，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。\n\n**非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待**。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，**所以非公平锁有可能出现后申请锁的线程先获取锁的场景**。非公平锁的**优点是可以减少唤起线程的开销，整体的吞吐效率高，**因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。\n\n直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。\n<div style=\"width: 95%\">\n\n![公平锁和非公平锁的例子-1](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/公平锁和非公平锁的例子-1.png)\n</div>\n\n如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。\n\n但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：\n<div style=\"width: 95%\">\n\n![公平锁和非公平锁例子-2](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/公平锁和非公平锁例子-2.png)\n</div>\n接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。\n<div style=\"width: 95%\">\n\n![ReentrantLock源码](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantLock源码.png)\n</div>\n根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。\n\n下面我们来看一下公平锁与非公平锁的加锁方法的源码:\n<div style=\"width: 95%\">\n\n![公平锁和非公平锁加锁源码](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/公平锁和非公平锁加锁源码.png)\n</div>\n通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。\n<div style=\"width: 95%\">\n\n![hasQueuePredecessors()源码](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/hasQueuePredecessors()源码.png)\n</div>\n再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。\n\n综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。\n\n<br><br>\n\n***\n\n<br><br>\n\n### 5. 可重入锁 VS 非可重入锁\n\n可重入锁又名递归锁，是指在**同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁**（前提锁对象得是同一个对象或者class），**不会因为之前已经获取过还没释放而阻塞**。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：\n\n\n```java\npublic class Widget {\n    public synchronized void doSomething() {\n        System.out.println(\"方法1执行...\");\n        doOthers();\n    }\n\n    public synchronized void doOthers() {\n        System.out.println(\"方法2执行...\");\n    }\n}\n```\n\n在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。\n\n如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。\n\n而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。\n\n还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。\n<div style=\"width: 95%\">\n\n![可重入锁实例-2](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/可重入锁实例-2.png)\n</div>\n但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。\n<div style=\"width: 95%\">\n\n![可重入锁实例-3](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/可重入锁实例-3.png)\n</div>\n之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。\n\n首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。\n\n当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。\n\n释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。\n<div style=\"width: 95%\">\n\n![可重入锁实例-4](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/可重入锁实例-4.png)\n</div>\n<br><br>\n\n***\n\n<br><br>\n\n### 6. 独享锁 VS 共享锁#\n\n独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。\n\n**独享锁也叫排他锁，是指该锁一次只能被一个线程所持有**。如果线程T对数据A加上排它锁后，则**其他线程不能再对A加任何类型的锁**。获得排它锁的线程**既能读数据又能修改数据**。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。\n\n**共享锁是指该锁可被多个线程所持有**。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得**共享锁的线程只能读数据，不能修改数据**。\n\n独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。\n\n下图为ReentrantReadWriteLock的部分源码：\n<div style=\"width: 95%\">\n\n![ReentrantReadWriteLock部分源码](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantReadWriteLock部分源码.png)\n\n</div>\n我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。\n\n在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。\n\n那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。\n\n在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。\n\n在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：\n<div style=\"width: 95%\">\n\n![ReentrantReadWriteLock中state变量](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantReadWriteLock中state变量.png)\n</div>\n了解了概念之后我们再来看代码，先看写锁的加锁源码：\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n\tThread current = Thread.currentThread();\n\tint c = getState(); // 取到当前锁的个数\n\tint w = exclusiveCount(c); // 取写锁的个数w\n\tif (c != 0) { // 如果已经有线程持有了锁(c!=0)\n    // (Note: if c != 0 and w == 0 then shared count != 0)\n\t\tif (w == 0 || current != getExclusiveOwnerThread()) // 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败\n\t\t\treturn false;\n\t\tif (w + exclusiveCount(acquires) > MAX_COUNT)    // 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。\n      throw new Error(\"Maximum lock count exceeded\");\n\t\t// Reentrant acquire\n    setState(c + acquires);\n    return true;\n  }\n  if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。\n\t\treturn false;\n\tsetExclusiveOwnerThread(current); // 如果c=0，w=0或者c>0，w>0（重入），则设置当前线程或锁的拥有者\n\treturn true;\n}\n```\n\n* 这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount(c); ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。\n\n* 在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁（c!=0），则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。\n\n* 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。\n\n* 如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。\n\n* 如果c=0，w=0或者c>0，w>0（重入），则设置当前线程或锁的拥有者，返回成功！\n\ntryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。\n\n因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。\n\n接着是读锁的代码：\n\n```java\nprotected final int tryAcquireShared(int unused) {\n    Thread current = Thread.currentThread();\n    int c = getState();\n    if (exclusiveCount(c) != 0 &&\n        getExclusiveOwnerThread() != current)\n        return -1;                                   // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态\n    int r = sharedCount(c);\n    if (!readerShouldBlock() &&\n        r < MAX_COUNT &&\n        compareAndSetState(c, c + SHARED_UNIT)) {\n        if (r == 0) {\n            firstReader = current;\n            firstReaderHoldCount = 1;\n        } else if (firstReader == current) {\n            firstReaderHoldCount++;\n        } else {\n            HoldCounter rh = cachedHoldCounter;\n            if (rh == null || rh.tid != getThreadId(current))\n                cachedHoldCounter = rh = readHolds.get();\n            else if (rh.count == 0)\n                readHolds.set(rh);\n            rh.count++;\n        }\n        return 1;\n    }\n    return fullTryAcquireShared(current);\n}\n```\n\n可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1<<16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。\n\n此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：\n<div style=\"width: 95%\">\n\n![ReentrantLock中公平锁和非公平锁的加锁源码](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantLock中公平锁和非公平锁的加锁源码.png)\n</div>\n我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。\n\n\n结语\n\n本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。\n\n其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。\n\n\n<br><br>\n\n\n<br><br>\n>版权声明：本文为CSDN博主「美团技术团队」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。    \n>原文链接：https://blog.csdn.net/MeituanTech/article/details/84138163\n","slug":"code/JVM/JVM学习笔记(五)——Java的各种锁","published":1,"updated":"2020-07-25T01:34:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1g7003y0w7tbmtc2t1k","content":"<p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p>\n<p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/java%E4%B8%BB%E6%B5%81%E9%94%81.png\" alt=\"java主流锁\"></p>\n<a id=\"more\"></a>\n\n\n<h3 id=\"1-乐观锁-VS-悲观锁\"><a href=\"#1-乐观锁-VS-悲观锁\" class=\"headerlink\" title=\"1. 乐观锁 VS 悲观锁\"></a>1. 乐观锁 VS 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p>\n<p>先说概念。对于同一个数据的并发操作，<strong>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改</strong>。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>\n<p><strong>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据</strong>。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（<strong>例如报错或者自动重试</strong>）。</p>\n<p>乐观锁在Java中是通过使用无锁编程来实现，<strong>最常采用的是CAS算法</strong>，Java原子类中的递增操作就通过CAS自旋实现的。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81.png\" alt=\"悲观锁和乐观锁\"></p>\n</div>\n\n<p>根据从上面的概念描述我们可以发现：</p>\n<ul>\n<li><p>悲观锁适合<strong>写操作多</strong>的场景，先加锁可以保证写操作时数据正确。</p>\n</li>\n<li><p>乐观锁适合<strong>读操作多</strong>的场景，不加锁的特点能够使其读操作的性能大幅提升。</p>\n</li>\n</ul>\n<p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// ------------------------- 悲观锁的调用方式 -------------------------</span>\n<span class=\"token comment\" spellcheck=\"true\">// synchronized</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 操作同步资源</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// ReentrantLock</span>\n<span class=\"token keyword\">private</span> ReentrantLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 需要保证多个线程使用的是同一个锁</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">modifyPublicResources</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 操作同步资源</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ------------------------- 乐观锁的调用方式 -------------------------</span>\n<span class=\"token keyword\">private</span> AtomicInteger atomicInteger <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 需要保证多个线程使用的是同一个AtomicInteger</span>\natomicInteger<span class=\"token punctuation\">.</span><span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//执行自增1</span></code></pre>\n<p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p>\n<p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p>\n<p>CAS算法涉及到三个操作数：</p>\n<ul>\n<li>当前内存值 V。</li>\n<li>旧的预期值 A。</li>\n<li>即将更新的值 B。</li>\n</ul>\n<p><strong>当且仅当 V (当前内存值) 的值等于 A (旧的预期值)</strong> 时，CAS通过原子方式<strong>用新值B来更新V的值</strong>（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>\n<p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/AtomicInteger%E5%AE%9A%E4%B9%89.png\" alt=\"AtomicInteger定义\"></p>\n</div>\n\n<p>根据定义我们可以看出各属性的作用：</p>\n<ul>\n<li><p>unsafe： 获取并操作内存的数据。</p>\n</li>\n<li><p>valueOffset： 存储value在AtomicInteger中的偏移量。</p>\n</li>\n<li><p>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</p>\n</li>\n</ul>\n<p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// ------------------------- JDK 8 -------------------------</span>\n<span class=\"token comment\" spellcheck=\"true\">// AtomicInteger 自增方法</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">getAndAddInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> valueOffset<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Unsafe.class</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAndAddInt</span><span class=\"token punctuation\">(</span>Object var1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> var2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> var4<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> var5<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n      var5 <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getIntVolatile</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">,</span> var2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">,</span> var2<span class=\"token punctuation\">,</span> var5<span class=\"token punctuation\">,</span> var5 <span class=\"token operator\">+</span> var4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> var5<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ------------------------- OpenJDK 8 -------------------------</span>\n<span class=\"token comment\" spellcheck=\"true\">// Unsafe.java</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAndAddInt</span><span class=\"token punctuation\">(</span>Object o<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> delta<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n       v <span class=\"token operator\">=</span> <span class=\"token function\">getIntVolatile</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">,</span> v <span class=\"token operator\">+</span> delta<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p>\n<p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p>\n<p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p>\n<ol>\n<li><p><strong>ABA问题</strong>。CAS需要在操作值的时候<strong>检查内存值是否发生变化，有发生变化才会更新内存值</strong>。但是<strong>如果内存值原来是A，后来变成了B，然后又变成了A</strong>，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面<strong>添加版本号</strong>，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。  JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</p>\n</li>\n<li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p>\n</li>\n<li><p><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。  Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>\n</li>\n</ol>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"2-自旋锁-VS-适应性自旋锁\"><a href=\"#2-自旋锁-VS-适应性自旋锁\" class=\"headerlink\" title=\"2. 自旋锁 VS 适应性自旋锁\"></a>2. 自旋锁 VS 适应性自旋锁</h3><p>介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p>\n<p><strong>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时</strong>间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>\n<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，<strong>线程挂起和恢复现场的花费可能会让系统得不偿失</strong>。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>\n<p>而为了<strong>让当前线程“稍等一下”，我们需让当前线程进行自旋</strong>，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，<strong>从而避免切换线程的开销</strong>。这就是自旋锁。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E8%87%AA%E6%97%8B%E9%94%81.png\" alt=\"自旋锁.png\"></p>\n</div>\n\n<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。<strong>如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源</strong>。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（<strong>默认是10次</strong>，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>\n<p>自旋锁的<strong>实现原理同样也是CAS</strong>，AtomicInteger中调用unsafe进行<strong>自增操作的源码中的do-while循环就是一个自旋操作</strong>，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/Unsafe%E6%BA%90%E7%A0%81%E8%87%AA%E5%A2%9E.png\" alt=\"Unsafe源码自增\"></p>\n</div>\n自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。\n\n<p>自适应意味着<strong>自旋的时间（次数）不再固定</strong>，而是<em>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</em></p>\n<p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁\"><a href=\"#3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁\" class=\"headerlink\" title=\"3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁\"></a>3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p>\n<p>首先为什么Synchronized能实现线程同步？</p>\n<p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>\n<p>Java对象头</p>\n<p><strong>synchronized是悲观锁</strong>，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p>\n<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>\n<p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>\n<p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>\n<p>Monitor</p>\n<p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>\n<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>\n<p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>\n<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>\n<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>\n<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>\n<table>\n<thead>\n<tr>\n<th>锁状态</th>\n<th>存储特点</th>\n<th>存储内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>无锁</td>\n<td>对象的hashCode、对象分代年龄、是否偏向锁（0）</td>\n<td>01</td>\n</tr>\n<tr>\n<td>偏向锁</td>\n<td>偏向线程ID、偏向时间戳、对象分代年龄、是否偏向锁（1）</td>\n<td>01</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>指向栈中锁记录的指针</td>\n<td>00</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>指向互斥量（重量级锁）的指针</td>\n<td>10</td>\n</tr>\n</tbody></table>\n<p><strong>无锁</strong></p>\n<p><strong>无锁没有对资源进行锁定</strong>，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>\n<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的<strong>CAS原理及应用即是无锁的实现</strong>。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>\n<p><strong>偏向锁</strong></p>\n<p>偏向锁是指<strong>一段同步代码一直被一个线程所访问，那么该线程会自动获取锁</strong>，降低获取锁的代价。</p>\n<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>\n<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>\n<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>\n<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>\n<p><strong>轻量级锁</strong></p>\n<p>是指<strong>当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁</strong>，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>\n<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>\n<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>\n<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>\n<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>\n<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>\n<p>重量级锁</p>\n<p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>\n<p>整体的锁状态升级流程如下：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E9%94%81%E7%8A%B6%E6%80%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.png\" alt=\"锁状态升级流程\"></p>\n</div>\n综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。\n\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"4-公平锁-VS-非公平锁\"><a href=\"#4-公平锁-VS-非公平锁\" class=\"headerlink\" title=\"4. 公平锁 VS 非公平锁\"></a>4. 公平锁 VS 非公平锁</h3><p><strong>公平锁是指多个线程按照申请锁的顺序来获取锁</strong>，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的<strong>线程不会饿死。缺点是整体吞吐效率相对非公平锁要低</strong>，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>\n<p><strong>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待</strong>。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，<strong>所以非公平锁有可能出现后申请锁的线程先获取锁的场景</strong>。非公平锁的<strong>优点是可以减少唤起线程的开销，整体的吞吐效率高，</strong>因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>\n<p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E4%BE%8B%E5%AD%90-1.png\" alt=\"公平锁和非公平锁的例子-1\"></p>\n</div>\n\n<p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p>\n<p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E4%BE%8B%E5%AD%90-2.png\" alt=\"公平锁和非公平锁例子-2\"></p>\n</div>\n接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantLock%E6%BA%90%E7%A0%81.png\" alt=\"ReentrantLock源码\"></p>\n</div>\n根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。\n\n<p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81%E6%BA%90%E7%A0%81.png\" alt=\"公平锁和非公平锁加锁源码\"></p>\n</div>\n通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/hasQueuePredecessors()%E6%BA%90%E7%A0%81.png\" alt=\"hasQueuePredecessors()源码\"></p>\n</div>\n再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。\n\n<p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"5-可重入锁-VS-非可重入锁\"><a href=\"#5-可重入锁-VS-非可重入锁\" class=\"headerlink\" title=\"5. 可重入锁 VS 非可重入锁\"></a>5. 可重入锁 VS 非可重入锁</h3><p>可重入锁又名递归锁，是指在<strong>同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁</strong>（前提锁对象得是同一个对象或者class），<strong>不会因为之前已经获取过还没释放而阻塞</strong>。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Widget</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"方法1执行...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">doOthers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doOthers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"方法2执行...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p>\n<p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>\n<p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p>\n<p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%AE%9E%E4%BE%8B-2.png\" alt=\"可重入锁实例-2\"></p>\n</div>\n但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%AE%9E%E4%BE%8B-3.png\" alt=\"可重入锁实例-3\"></p>\n</div>\n之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。\n\n<p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p>\n<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p>\n<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%AE%9E%E4%BE%8B-4.png\" alt=\"可重入锁实例-4\"></p>\n</div>\n<br><br>\n\n<hr>\n<p><br><br></p>\n<h3 id=\"6-独享锁-VS-共享锁\"><a href=\"#6-独享锁-VS-共享锁\" class=\"headerlink\" title=\"6. 独享锁 VS 共享锁#\"></a>6. 独享锁 VS 共享锁#</h3><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p>\n<p><strong>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有</strong>。如果线程T对数据A加上排它锁后，则<strong>其他线程不能再对A加任何类型的锁</strong>。获得排它锁的线程<strong>既能读数据又能修改数据</strong>。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>\n<p><strong>共享锁是指该锁可被多个线程所持有</strong>。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得<strong>共享锁的线程只能读数据，不能修改数据</strong>。</p>\n<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>\n<p>下图为ReentrantReadWriteLock的部分源码：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantReadWriteLock%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81.png\" alt=\"ReentrantReadWriteLock部分源码\"></p>\n</div>\n我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。\n\n<p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>\n<p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。</p>\n<p>在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p>\n<p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantReadWriteLock%E4%B8%ADstate%E5%8F%98%E9%87%8F.png\" alt=\"ReentrantReadWriteLock中state变量\"></p>\n</div>\n了解了概念之后我们再来看代码，先看写锁的加锁源码：\n\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> acquires<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Thread current <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 取到当前锁的个数</span>\n    <span class=\"token keyword\">int</span> w <span class=\"token operator\">=</span> <span class=\"token function\">exclusiveCount</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 取写锁的个数w</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 如果已经有线程持有了锁(c!=0)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// (Note: if c != 0 and w == 0 then shared count != 0)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>w <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> current <span class=\"token operator\">!=</span> <span class=\"token function\">getExclusiveOwnerThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>w <span class=\"token operator\">+</span> <span class=\"token function\">exclusiveCount</span><span class=\"token punctuation\">(</span>acquires<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> MAX_COUNT<span class=\"token punctuation\">)</span>    <span class=\"token comment\" spellcheck=\"true\">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Maximum lock count exceeded\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Reentrant acquire</span>\n    <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">+</span> acquires<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">writerShouldBlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span><span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> c <span class=\"token operator\">+</span> acquires<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 如果c=0，w=0或者c>0，w>0（重入），则设置当前线程或锁的拥有者</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li><p>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount(c); ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</p>\n</li>\n<li><p>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁（c!=0），则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</p>\n</li>\n<li><p>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</p>\n</li>\n<li><p>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</p>\n</li>\n<li><p>如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</p>\n</li>\n</ul>\n<p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>\n<p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p>\n<p>接着是读锁的代码：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">tryAcquireShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> unused<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Thread current <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">exclusiveCount</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span>\n        <span class=\"token function\">getExclusiveOwnerThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> current<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>                                   <span class=\"token comment\" spellcheck=\"true\">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span>\n    <span class=\"token keyword\">int</span> r <span class=\"token operator\">=</span> <span class=\"token function\">sharedCount</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">readerShouldBlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n        r <span class=\"token operator\">&lt;</span> MAX_COUNT <span class=\"token operator\">&amp;&amp;</span>\n        <span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> c <span class=\"token operator\">+</span> SHARED_UNIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            firstReader <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n            firstReaderHoldCount <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstReader <span class=\"token operator\">==</span> current<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            firstReaderHoldCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            HoldCounter rh <span class=\"token operator\">=</span> cachedHoldCounter<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rh <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> rh<span class=\"token punctuation\">.</span>tid <span class=\"token operator\">!=</span> <span class=\"token function\">getThreadId</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                cachedHoldCounter <span class=\"token operator\">=</span> rh <span class=\"token operator\">=</span> readHolds<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rh<span class=\"token punctuation\">.</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                readHolds<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>rh<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            rh<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fullTryAcquireShared</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>\n<p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantLock%E4%B8%AD%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%BA%90%E7%A0%81.png\" alt=\"ReentrantLock中公平锁和非公平锁的加锁源码\"></p>\n</div>\n我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。\n\n\n<p>结语</p>\n<p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p>\n<p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p>\n<p><br><br></p>\n<p><br><br></p>\n<blockquote>\n<p>版权声明：本文为CSDN博主「美团技术团队」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/MeituanTech/article/details/84138163\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/MeituanTech/article/details/84138163</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p>\n<p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/java%E4%B8%BB%E6%B5%81%E9%94%81.png\" alt=\"java主流锁\"></p>","more":"<h3 id=\"1-乐观锁-VS-悲观锁\"><a href=\"#1-乐观锁-VS-悲观锁\" class=\"headerlink\" title=\"1. 乐观锁 VS 悲观锁\"></a>1. 乐观锁 VS 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p>\n<p>先说概念。对于同一个数据的并发操作，<strong>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改</strong>。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>\n<p><strong>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据</strong>。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（<strong>例如报错或者自动重试</strong>）。</p>\n<p>乐观锁在Java中是通过使用无锁编程来实现，<strong>最常采用的是CAS算法</strong>，Java原子类中的递增操作就通过CAS自旋实现的。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81.png\" alt=\"悲观锁和乐观锁\"></p>\n</div>\n\n<p>根据从上面的概念描述我们可以发现：</p>\n<ul>\n<li><p>悲观锁适合<strong>写操作多</strong>的场景，先加锁可以保证写操作时数据正确。</p>\n</li>\n<li><p>乐观锁适合<strong>读操作多</strong>的场景，不加锁的特点能够使其读操作的性能大幅提升。</p>\n</li>\n</ul>\n<p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：</p>\n<pre><code class=\"java\">// ------------------------- 悲观锁的调用方式 -------------------------\n// synchronized\npublic synchronized void testMethod() {\n    // 操作同步资源\n}\n// ReentrantLock\nprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁\npublic void modifyPublicResources() {\n    lock.lock();\n    // 操作同步资源\n    lock.unlock();\n}\n\n// ------------------------- 乐观锁的调用方式 -------------------------\nprivate AtomicInteger atomicInteger = new AtomicInteger();  // 需要保证多个线程使用的是同一个AtomicInteger\natomicInteger.incrementAndGet(); //执行自增1</code></pre>\n<p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p>\n<p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p>\n<p>CAS算法涉及到三个操作数：</p>\n<ul>\n<li>当前内存值 V。</li>\n<li>旧的预期值 A。</li>\n<li>即将更新的值 B。</li>\n</ul>\n<p><strong>当且仅当 V (当前内存值) 的值等于 A (旧的预期值)</strong> 时，CAS通过原子方式<strong>用新值B来更新V的值</strong>（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>\n<p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/AtomicInteger%E5%AE%9A%E4%B9%89.png\" alt=\"AtomicInteger定义\"></p>\n</div>\n\n<p>根据定义我们可以看出各属性的作用：</p>\n<ul>\n<li><p>unsafe： 获取并操作内存的数据。</p>\n</li>\n<li><p>valueOffset： 存储value在AtomicInteger中的偏移量。</p>\n</li>\n<li><p>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</p>\n</li>\n</ul>\n<p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p>\n<pre><code class=\"java\">// ------------------------- JDK 8 -------------------------\n// AtomicInteger 自增方法\npublic final int incrementAndGet() {\n  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n}\n\n// Unsafe.class\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n  int var5;\n  do {\n      var5 = this.getIntVolatile(var1, var2);\n  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n  return var5;\n}\n\n// ------------------------- OpenJDK 8 -------------------------\n// Unsafe.java\npublic final int getAndAddInt(Object o, long offset, int delta) {\n   int v;\n   do {\n       v = getIntVolatile(o, offset);\n   } while (!compareAndSwapInt(o, offset, v, v + delta));\n   return v;\n}</code></pre>\n<p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p>\n<p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p>\n<p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p>\n<ol>\n<li><p><strong>ABA问题</strong>。CAS需要在操作值的时候<strong>检查内存值是否发生变化，有发生变化才会更新内存值</strong>。但是<strong>如果内存值原来是A，后来变成了B，然后又变成了A</strong>，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面<strong>添加版本号</strong>，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。  JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</p>\n</li>\n<li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p>\n</li>\n<li><p><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。  Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>\n</li>\n</ol>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"2-自旋锁-VS-适应性自旋锁\"><a href=\"#2-自旋锁-VS-适应性自旋锁\" class=\"headerlink\" title=\"2. 自旋锁 VS 适应性自旋锁\"></a>2. 自旋锁 VS 适应性自旋锁</h3><p>介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p>\n<p><strong>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时</strong>间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>\n<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，<strong>线程挂起和恢复现场的花费可能会让系统得不偿失</strong>。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>\n<p>而为了<strong>让当前线程“稍等一下”，我们需让当前线程进行自旋</strong>，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，<strong>从而避免切换线程的开销</strong>。这就是自旋锁。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E8%87%AA%E6%97%8B%E9%94%81.png\" alt=\"自旋锁.png\"></p>\n</div>\n\n<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。<strong>如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源</strong>。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（<strong>默认是10次</strong>，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>\n<p>自旋锁的<strong>实现原理同样也是CAS</strong>，AtomicInteger中调用unsafe进行<strong>自增操作的源码中的do-while循环就是一个自旋操作</strong>，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/Unsafe%E6%BA%90%E7%A0%81%E8%87%AA%E5%A2%9E.png\" alt=\"Unsafe源码自增\"></p>\n</div>\n自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。\n\n<p>自适应意味着<strong>自旋的时间（次数）不再固定</strong>，而是<em>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</em></p>\n<p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁\"><a href=\"#3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁\" class=\"headerlink\" title=\"3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁\"></a>3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p>\n<p>首先为什么Synchronized能实现线程同步？</p>\n<p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>\n<p>Java对象头</p>\n<p><strong>synchronized是悲观锁</strong>，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p>\n<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>\n<p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>\n<p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>\n<p>Monitor</p>\n<p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>\n<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>\n<p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>\n<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>\n<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>\n<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>\n<table>\n<thead>\n<tr>\n<th>锁状态</th>\n<th>存储特点</th>\n<th>存储内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>无锁</td>\n<td>对象的hashCode、对象分代年龄、是否偏向锁（0）</td>\n<td>01</td>\n</tr>\n<tr>\n<td>偏向锁</td>\n<td>偏向线程ID、偏向时间戳、对象分代年龄、是否偏向锁（1）</td>\n<td>01</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>指向栈中锁记录的指针</td>\n<td>00</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>指向互斥量（重量级锁）的指针</td>\n<td>10</td>\n</tr>\n</tbody></table>\n<p><strong>无锁</strong></p>\n<p><strong>无锁没有对资源进行锁定</strong>，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>\n<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的<strong>CAS原理及应用即是无锁的实现</strong>。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>\n<p><strong>偏向锁</strong></p>\n<p>偏向锁是指<strong>一段同步代码一直被一个线程所访问，那么该线程会自动获取锁</strong>，降低获取锁的代价。</p>\n<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>\n<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>\n<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>\n<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>\n<p><strong>轻量级锁</strong></p>\n<p>是指<strong>当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁</strong>，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>\n<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>\n<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>\n<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>\n<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>\n<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>\n<p>重量级锁</p>\n<p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>\n<p>整体的锁状态升级流程如下：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E9%94%81%E7%8A%B6%E6%80%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.png\" alt=\"锁状态升级流程\"></p>\n</div>\n综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。\n\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"4-公平锁-VS-非公平锁\"><a href=\"#4-公平锁-VS-非公平锁\" class=\"headerlink\" title=\"4. 公平锁 VS 非公平锁\"></a>4. 公平锁 VS 非公平锁</h3><p><strong>公平锁是指多个线程按照申请锁的顺序来获取锁</strong>，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的<strong>线程不会饿死。缺点是整体吞吐效率相对非公平锁要低</strong>，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>\n<p><strong>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待</strong>。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，<strong>所以非公平锁有可能出现后申请锁的线程先获取锁的场景</strong>。非公平锁的<strong>优点是可以减少唤起线程的开销，整体的吞吐效率高，</strong>因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>\n<p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E4%BE%8B%E5%AD%90-1.png\" alt=\"公平锁和非公平锁的例子-1\"></p>\n</div>\n\n<p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p>\n<p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E4%BE%8B%E5%AD%90-2.png\" alt=\"公平锁和非公平锁例子-2\"></p>\n</div>\n接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantLock%E6%BA%90%E7%A0%81.png\" alt=\"ReentrantLock源码\"></p>\n</div>\n根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。\n\n<p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8A%A0%E9%94%81%E6%BA%90%E7%A0%81.png\" alt=\"公平锁和非公平锁加锁源码\"></p>\n</div>\n通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/hasQueuePredecessors()%E6%BA%90%E7%A0%81.png\" alt=\"hasQueuePredecessors()源码\"></p>\n</div>\n再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。\n\n<p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"5-可重入锁-VS-非可重入锁\"><a href=\"#5-可重入锁-VS-非可重入锁\" class=\"headerlink\" title=\"5. 可重入锁 VS 非可重入锁\"></a>5. 可重入锁 VS 非可重入锁</h3><p>可重入锁又名递归锁，是指在<strong>同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁</strong>（前提锁对象得是同一个对象或者class），<strong>不会因为之前已经获取过还没释放而阻塞</strong>。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>\n<pre><code class=\"java\">public class Widget {\n    public synchronized void doSomething() {\n        System.out.println(&quot;方法1执行...&quot;);\n        doOthers();\n    }\n\n    public synchronized void doOthers() {\n        System.out.println(&quot;方法2执行...&quot;);\n    }\n}</code></pre>\n<p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p>\n<p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>\n<p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p>\n<p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%AE%9E%E4%BE%8B-2.png\" alt=\"可重入锁实例-2\"></p>\n</div>\n但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%AE%9E%E4%BE%8B-3.png\" alt=\"可重入锁实例-3\"></p>\n</div>\n之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。\n\n<p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p>\n<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p>\n<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%AE%9E%E4%BE%8B-4.png\" alt=\"可重入锁实例-4\"></p>\n</div>\n<br><br>\n\n<hr>\n<p><br><br></p>\n<h3 id=\"6-独享锁-VS-共享锁\"><a href=\"#6-独享锁-VS-共享锁\" class=\"headerlink\" title=\"6. 独享锁 VS 共享锁#\"></a>6. 独享锁 VS 共享锁#</h3><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p>\n<p><strong>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有</strong>。如果线程T对数据A加上排它锁后，则<strong>其他线程不能再对A加任何类型的锁</strong>。获得排它锁的线程<strong>既能读数据又能修改数据</strong>。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>\n<p><strong>共享锁是指该锁可被多个线程所持有</strong>。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得<strong>共享锁的线程只能读数据，不能修改数据</strong>。</p>\n<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>\n<p>下图为ReentrantReadWriteLock的部分源码：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantReadWriteLock%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81.png\" alt=\"ReentrantReadWriteLock部分源码\"></p>\n</div>\n我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。\n\n<p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>\n<p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。</p>\n<p>在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p>\n<p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantReadWriteLock%E4%B8%ADstate%E5%8F%98%E9%87%8F.png\" alt=\"ReentrantReadWriteLock中state变量\"></p>\n</div>\n了解了概念之后我们再来看代码，先看写锁的加锁源码：\n\n<pre><code class=\"java\">protected final boolean tryAcquire(int acquires) {\n    Thread current = Thread.currentThread();\n    int c = getState(); // 取到当前锁的个数\n    int w = exclusiveCount(c); // 取写锁的个数w\n    if (c != 0) { // 如果已经有线程持有了锁(c!=0)\n    // (Note: if c != 0 and w == 0 then shared count != 0)\n        if (w == 0 || current != getExclusiveOwnerThread()) // 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败\n            return false;\n        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)    // 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。\n      throw new Error(&quot;Maximum lock count exceeded&quot;);\n        // Reentrant acquire\n    setState(c + acquires);\n    return true;\n  }\n  if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。\n        return false;\n    setExclusiveOwnerThread(current); // 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者\n    return true;\n}</code></pre>\n<ul>\n<li><p>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount(c); ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</p>\n</li>\n<li><p>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁（c!=0），则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</p>\n</li>\n<li><p>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</p>\n</li>\n<li><p>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</p>\n</li>\n<li><p>如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</p>\n</li>\n</ul>\n<p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>\n<p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p>\n<p>接着是读锁的代码：</p>\n<pre><code class=\"java\">protected final int tryAcquireShared(int unused) {\n    Thread current = Thread.currentThread();\n    int c = getState();\n    if (exclusiveCount(c) != 0 &amp;&amp;\n        getExclusiveOwnerThread() != current)\n        return -1;                                   // 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态\n    int r = sharedCount(c);\n    if (!readerShouldBlock() &amp;&amp;\n        r &lt; MAX_COUNT &amp;&amp;\n        compareAndSetState(c, c + SHARED_UNIT)) {\n        if (r == 0) {\n            firstReader = current;\n            firstReaderHoldCount = 1;\n        } else if (firstReader == current) {\n            firstReaderHoldCount++;\n        } else {\n            HoldCounter rh = cachedHoldCounter;\n            if (rh == null || rh.tid != getThreadId(current))\n                cachedHoldCounter = rh = readHolds.get();\n            else if (rh.count == 0)\n                readHolds.set(rh);\n            rh.count++;\n        }\n        return 1;\n    }\n    return fullTryAcquireShared(current);\n}</code></pre>\n<p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>\n<p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p>\n<div style=\"width: 95%\">\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/ReentrantLock%E4%B8%AD%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%BA%90%E7%A0%81.png\" alt=\"ReentrantLock中公平锁和非公平锁的加锁源码\"></p>\n</div>\n我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。\n\n\n<p>结语</p>\n<p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p>\n<p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p>\n<p><br><br></p>\n<p><br><br></p>\n<blockquote>\n<p>版权声明：本文为CSDN博主「美团技术团队」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/MeituanTech/article/details/84138163\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/MeituanTech/article/details/84138163</a></p>\n</blockquote>"},{"title":"JVM学习笔记(四)——Java内存模型和线程安全","declare":true,"wordCount":true,"abbrlink":"baafd636","date":"2020-07-07T13:40:10.000Z","_content":"\n由于计算机的运算能力十分强大而且和计算机的存储和通信子系统的的速度差距过大，大量时间都花费在I/O、网络通信和数据库访问上，因此让计算机同时处理几项任务是最容易而且也更有效的“压榨”计算机运算能力的手段。\n\n![Java内存模型和线程安全](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200715210838.png)\n\n\n<!-- more -->\n\n处理器至少要与内存交互，如读取数据、存储运算结果等。这个I/O操作是几乎无法消除的。而且由于计算机存储设备和处理器运算速度上相差好几个数量级，因此我们在内存和处理器之间加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存和处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存中同步回内存之中，这样处理器就无须等待缓慢的内存读写了。\n\n## 一、硬件效率一致性\n**缓存一致性问题**：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，处理器、高速缓存、主内存之间的交互关系如下图所示：\n\n![处理器内存缓存交互关系](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/处理器内存缓存交互关系.png)\n\n除增加高速缓存以外，处理器还可能会对输入指令进行乱序执行优化（**指令重排优化**），虽然保证该结果与顺序执行结果一样，但不保证各个语句的执行先后顺序和输入代码中的顺序一致。\n\n<br><br>\n\n***\n\n<br><br>\n\n## 二、Java内存模型\n\n### 2.1 主内存和工作内存\nJava内存模型的主要目标是定义程序中各个变量的访问规则，即虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。\n>此处的变量是指实例字段、静态字段和构成数组对象的元素，但不包括**局部变量**和**方法参数**，因为这些是**线程私有**的，不会被共享，自然也不会被竞争了\n\nJava内存模型规定**所有的变量都存储在主内存，每条线程还有自己的工作内存，其中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能够直接读取主内存的变量**，不同的线程无法直接访问对方工作内存中的变量，线程间变量值的传递需通过主内存来完成。\n\n![Java内存模型](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/Java内存模型.png)\n\n***\n<br>\n\n### 2.2 内存间交互操作\n关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝考到工作内存、如何从工作内存同步回主内存之间具体的实现细节，Java内存模型定义了以下8中操作来完成，Java虚拟机必须保证下面提及的每一种操作都是**原子的**（对于long和double类型来说，load,store,read和write在某些平台上允许有例外）\n\n操作|作用对象|解释\n-|-|-\nlock(锁定)|主内存|把一个变量标识为一条线程独占的状态\nunlock(解锁)|主内存|把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定\nread(读取)|主内存|把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用\nload(载入)|工作内存|把 read 操作从主内存中得到的变量值放入工作内存中\nuse(使用)|工作内存|把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作\nassign(赋值)|工作内存|把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\nstore(存储)|工作内存|把工作内存中的一个变量的值传送到主内存中，以便 write 操作\nwrite(写入)|工作内存|把 store 操作从工作内存中得到的变量的值放入主内存的变量中\n\n>如果要把一个变量从主内存赋值到工作内存，就要**顺序地**执行read(读取)和load(加载)操作     \n>如果要把一个变量从工作内存同步回主内存，就要**顺序地**执行store(存储)和write(写入)操作  \n\n要求以上规则**必须按照顺序执行，而没有保证是连续执行**\n\nJava内存模型规定了执行上述8种规则时，必须要求满足以下规则：\n\n* **不允许read和load、store和write操作之一单独出现**，也就是不允许从主内存读取了变量的值但是工作内存不接收的情况，或者不允许从工作内存将变量的值回写到主内存但是主内存不接收的情况出现\n* 不允许一个线程丢弃最近的assign操作，也就是*不允许线程在自己的工作线程中修改了变量的值却不同步/回写到主内存*\n* **不允许一个线程无缘由的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中**\n* **一个变量只能在主内存中诞生**，不允许在工作内存中直接使用一个未被初始化的变量（load或者assign操作）。换句话说，在执行use、store之前必须对相同的变量执行了load、assign操作\n* **一个变量在同一时刻只允许被一个线程对其进行lock操作**，但**lock操作可以被同一条线程执行重复执行多次**，相应地，执行多次后，**只有执行相同次数的unlock才会被解锁**。\n* **对变量执行lock操作，将会清空工作空间该变量的值**，执行引擎使用这个变量之前，需要**重新load或者assign操作**初始化变量的值\n* **不允许对没有被lock的变量执行unlock操作**，如果一个变量没有被lock操作，那也不能对其执行unlock操作，当然一个线程也不能对被其他线程lock的变量执行unlock操作\n* **对一个变量执行unlock之前，必须先把变量同步回主内存中**（执行store和write操作）\n\n<br>\n\nJava内存模型对于上述8个操作都具有原子性，但对于64位数据类型long和double，在模型中特别定义了一条相对宽松的定义：允许将没有volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即**不保证它们的原子性**。\n\n<br>\n\n***\n<br>\n\n### 2.3 volatile修饰的变量的特殊规则\n\n关键字volatile可以说是java虚拟机中提供的**最轻量级的同步机制**,当一个变量被定义为volatile之后，它将具备两种特性：\n* **保证此变量对所有线程的可见性**\n    >可见性是指**当一个线程修改了这个变量的值**，新值（修改后的值）**对于其他线程来说是立即可以得知的**,普通变量需要通过主内存来同步实现。**当修改volatile变量时，会给cpu发送一个信号告诉其他cpu这个变量已修改**，当其他cpu调用这个变量时，就会先检查是否有收到修改该变量的信号，有则重新从内存中读取。volatile是无锁的，类似于乐观锁的机制。 简单来说，就是volatile变量进行读时，**会有一个主内存到工作内存到拷贝动作**，**进行写后，会有一个工作内存刷新主内存到动作**。\n\n    >虽然volatile变量对所有线程是立即可见的，所以对volatile变量的所有修改(写操作)都立刻能反应到其他线程中，换句话说：volatile变量在各个线程中是一致的，但是**并不能得出**基于volatile变量的运算在并发下是线程安全的。   因为每次使用之前都需要先刷新，所以不存在不一致的情况，但是**Java里面的操作并非原子性**，即使编译出来只有一条字节码指令，但是也并不意味着这条指令就是一个原子操作。\n\n    >由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景下，我们仍然需要对其加锁（通过synchronized或java.util.concurrent中的原子类）来保证原子性\n    > * 运算结果并不依赖当前值，或能够确保只有单一线程来修改变量的值\n    > * 变量不需要与其他的状态变量共同参与不变约束\n\n    >**可见性通过synchronized和final也可以实现**, synchronized是要求对一个变量执行unl之前，必须同步回主内存，final是指被它修饰的变量一旦在构造器中完成，并且构造器没有吧“this”抛出去，那么在其他线程就能够看见final字段的值\n    \n* 禁止指令重排序\n    >普通的变量仅仅会保证在该方法执行的过程中，所有依赖赋值结果的地方都能获取到正确的结果，但不能保证变量赋值的操作顺序和程序代码的顺序一致。详见[ 双检锁/双重校验锁(增加volatile)](https://notecc.ink/posts/1a4b62fe.html#2-5-%E5%8F%8C%E6%A3%80%E9%94%81-%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81-%E5%A2%9E%E5%8A%A0volatile) 从硬件架构上讲，指令重排序是指cpu采用了允许将多条指令不按程序规的顺序分开送给各相应的电路单元处理.\n\n\n在某些情况下，volatile的同步机制性能要优于锁(使用synchronized关键字或者java.util.concurrent包中的锁)。但是现在**由于虚拟机对锁的不断优化和实行的许多消除动作，很难有一个量化的比较。**    \nvolatile变量的读操作和普通变量的读操作几乎没有差异，但是写操作会性能差一些，慢一些，因为要在本地代码中插入许多内存屏障指令来禁止指令重排序，保证处理器不发生代码乱序执行行为。不过即便如此，大多数情境下volatile的开销还是要比锁要低一些，与其选择的依据是volatile的语义事发后能够满足使用场景的需求。\n\n***\n<br>\n\n### 2.4 先行先发生规则\n也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。\n\n\n\n规则|解释\n-|-\n程序次序规则|在一个线程内，代码按照书写的控制流顺序执行\n管程锁定规则|一个 unlock 操作先行发生于后面对同一个锁的 lock 操作\nvolatile 变量规则|volatile 变量的写操作先行发生于后面对这个变量的读操作\n线程启动规则|Thread 对象的 start() 方法先行发生于此线程的每一个动作\n线程终止规则|线程中所有的操作都先行发生于对此线程的终止检测(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)\n线程中断规则|对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生(通过 Thread.interrupted() 方法检测)\n对象终结规则|一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始\n传递性|如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C\n\n\n\n\n\n\n\n\n\n\n\n\n<br><br>\n\n***\n\n<br><br>\n\n## 三、Java与线程\n\n### 3.1 使用内核线程实现\n直接**由操作系统内核支持的线程**，这种线程**由内核完成切换**。程序一般不会直接去使用内核线程，**而是去使用内核线程的一种高级接口** —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。\n\n![内核线程实现](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/内核线程实现.png)\n\n\n**系统调用的代价较高**，需要在用户态和内核态中**来回切换**。\n\n其次，**每一个轻量级进程都需要一个内核线程的支持**，因此轻量级进程要消耗一定内核资源，因此**一个系统支持轻量级进程的数量是有限的**。\n\n>例如synchronized锁的实现就是如此，所以它是一个重量级操作（当然虚拟机会进行一些优化）\n\n***\n<br>\n\n### 3.2 使用用户线程实现\n广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是**完全建立在用户空间的线程库上的并且内核系统不可感知**的实现。**用户进程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。** \n\n![用户线程实现](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/用户线程实现.png)\n\n**优势是操作非常快速并且低消耗的**     \n**劣势在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理**。线程的创建、切换和调度都是需要考虑的问题，因而使用用户线程的程序实现一般都**比较复杂**。\n***\n<br>\n\n### 3.3 使用用户线程夹加轻量级进程混合实现\n\n![混合实现](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/混合实现.png)\n***\n<br>\n\n### 3.4 Java线程的实现\n平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。\n\n***\n<br>\n\n### 3.5 Java线程调度\n线程调度是指系统为线程分配处理器使用权的过程，主要有两种调度方式：\n* 协同式线程调度\n    >**线程执行时间由线程自身控制**，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是**执行时间不可控，容易阻塞**。\n\n* 抢占式线程调度\n    >每个线程由系统来分配执行时间\n\n虽然Java线程调度是系统自己完成的，但是我们也可以通过优先级（Java语言共用10个优先级）让某些线程优先完成，获得更多的执行时间。\n\n不过线程优先级并不是特别可靠，原因是Java的线程是通过映射到系统的原生的线程上来实现的以及优先级可能会被系统所改变，所以线程调度最终还是得取决于操作系统。\n\n### 3.6 线程状态转换\nJava语言一共定义了5种线程状态，在任意一个时间点，一个线程有且只在其中一种状态：\n\n1. 新建(new)\n    >创建后尚未启动的线程。\n\n2. 运行(Runable)\n    >Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。\n\n3. 无限期等待(Waiting)\n    >出于这种状态的线程不会被 CPU 分配时间，它们要等待被其他线程显示地唤醒，以下方法会然线程进入无限期等待状态：\n    > * 没有设置 Timeout 参数的 Object.wait() 方法。\n    > * 没有设置 Timeout 参数的 Thread.join() 方法。\n    > * LookSupport.park() 方法。\n\n4. 限期等待(Timed Waiting)\n    >处于这种状态的线程也不会分配时间，不过无需等待被其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。以下方法会让线程进入限期等待状态：\n    > * Thread.sleep() 方法。\n    > * 设置了 Timeout 参数的 Object.wait() 方法。\n    > * 设置了 Timeout 参数的 Thread.join() 方法。\n    > * LockSupport.parkNanos() 方法。\n    > * LockSupport.parkUntil() 方法。\n\n5. 阻塞(Blocked)\n    >线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。\n\n6. 结束(Terminated)\n    >已终止线程的线程状态,线程已经结束执行\n\n\n<br><br>\n\n***\n\n<br><br>\n\n## 四、线程安全和锁优化\n### 4.1 线程安全\n\n当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。\n\n***\n<br>\n\n### 4.2 线程安全的等级\n#### 4.2.1 不可变\n一定是线程安全的，例如被final修饰的变量或者String类型的变量\n\n#### 4.2.2 绝对线程安全\n“不管运行环境如何，调用者都不需要任何额外的同步措施”，通常需要付出的代价很大，甚至有时候是不切实际的代价\n\n#### 4.2.3 相对线程安全\n即我们**通常意义上讲的线程安全**，在调用时不需要做额外的保障措施，对于一些特定顺序的连续调用， 就可能在调用端使用额外的同步手段来保证调用的正确性。\n\n#### 4.2.4 线程兼容 \n线程兼容是指对象本身不是线程安全的，但是可以通过在调用端使用同步手段来保证对象在并发环境中可以安全地使用\n\n#### 4.2.5 线程对立\n无论是否采用了同步措施，都无法在多线程环境中并发使用的代码\n\n***\n<br>\n\n### 4.3 线程安全的实现方法\n\n#### 4.3.1 互斥同步\n同步：在多个线程访问共享数据时，保证共享数据在同一时刻只被一个线程使用\n互斥；是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现手段，\n\n互斥是方法，同步是目的（互斥的本质也是同步）\n\n1. 最基本的同步互斥手段是synchronized关键字\n>它在经过编译后，会在同步块的前后分**别形成monitorenter和monitoreif这两个字节码指令**，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。     \n>在执行monitorenter时，首先要尝试去获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有此对象的锁时，则将其加1，相应的执行monitoreif时，会将锁减1，当计数器为0时，锁就会被释放。（有一些类似信号量，但是这个在对于一个线程内，因为一个线程可能掉用多次）     \n\n>synchronized**对于同一条线程来说是可重入**的，不会出现自己锁死自己的问题。其次，**同步块在已进入的线程执行完之前，会阻塞后面的线程进入**\n\n2. 重入锁ReetrantLock\n和synchronized一样，都具有线程可重入性\n>可重入性：若一个程序或子程序可以“在**任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错**”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。一**般而言，可重入的函数一定是线程安全的，反之则不一定成立。**\n\n\n相比synchronized，增加了一些高级功能：\n* 等待可中断。 当持有锁的线程长期不释放锁时，正在等待的线程可以放弃等待去做一些其他事情。\n* 可实现公平锁。  ReetrantLock锁默认是非公平锁，但是可以通过带布尔值的构造函数来实现公平锁。\n* 锁绑定多个条件。 一个ReetrantLock对象可以同时绑定多个条件。\n\n\n在JDK1.6之后，**由于虚拟机对锁实现了很多优化，因此，这两者性能差不多**，而且在**未来的性能改进中，也会更加偏向synchronized**，所以优先选择synchronized\n\n\n#### 4.3.2 非阻塞同步\n**互斥与同步属于一种悲观锁，总是认为如果不去做正确的同步措施，就肯定会出现错误**，无论数据是否会出现竞争都会对其进行加锁。因此由于进行线程阻塞和换醒会带来一些性能问题。\n\n随着指令集的发展我们有了另外一种选择：**基于冲突检测的乐观并发策略。即先进行操作，如果共享数据出现争用，产生了冲突，则采取其他的补偿措施**（最常见的就是不断重复，直至成功）\n\n\n#### 4.3.3 无同步方案\n**要保证线程安全，并不一定要进行同步，两者没有因果关系**。（如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性）\n\n***\n<br>\n\n### 4.4 [锁优化](https://notecc.ink/posts/86818cd5.html)\n\n#### 4.4.1 自旋锁和自适应锁\n\n#### 4.4.2 锁消除\n**即时编译器**在运行时，**对一些代码上要求同步，但检测到不可能存在共享数据竞争的锁进行消除**       \n锁消除的判定依据主要来源于**逃逸分析**的数据支持\n\n#### 4.4.3 锁粗化\n如果**一系列的连续操作都对同一个对象反复加锁和解锁**，甚至加锁和解锁都是出现在**循环体**中的，那么即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。**所以会将加锁同步的范围粗化到整个操作序列的外部**。\n\n#### 4.4.4 轻量级锁\n无竞争的情况下使用CAS操作去除同步使用的互斥量\n\n#### 4.4.5 偏向锁\n在无竞争的情况下把整个同步都消除掉。即**偏向于第一个获得的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不会需要再进行同步**\n\n**偏向锁可以提高有同步但无竞争的程序性能，但并不一定总是对程序有利。**如果程序中大多数的锁总是被多个不同的线程访问，那么偏向锁就是多余的。\n\n\n<br><br><br>\n\n***\n\n<br><br><br>\n\n### 参考   \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br> \n[2]<a href=\"https://blog.csdn.net/qq_41701956/article/details/81664921\">https://blog.csdn.net/qq_41701956/article/details/81664921</a><br> \n</div>\n<a href=\"\"></a><br> \n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/code/JVM/JVM学习笔记(四) ——Java内存模型和线程安全.md","raw":"---\ntitle: JVM学习笔记(四)——Java内存模型和线程安全\ncategories: Code\ntags: JVM\ndeclare: true\nwordCount: true\nabbrlink: baafd636\ndate: 2020-07-07 21:40:10\n---\n\n由于计算机的运算能力十分强大而且和计算机的存储和通信子系统的的速度差距过大，大量时间都花费在I/O、网络通信和数据库访问上，因此让计算机同时处理几项任务是最容易而且也更有效的“压榨”计算机运算能力的手段。\n\n![Java内存模型和线程安全](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200715210838.png)\n\n\n<!-- more -->\n\n处理器至少要与内存交互，如读取数据、存储运算结果等。这个I/O操作是几乎无法消除的。而且由于计算机存储设备和处理器运算速度上相差好几个数量级，因此我们在内存和处理器之间加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存和处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存中同步回内存之中，这样处理器就无须等待缓慢的内存读写了。\n\n## 一、硬件效率一致性\n**缓存一致性问题**：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，处理器、高速缓存、主内存之间的交互关系如下图所示：\n\n![处理器内存缓存交互关系](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/处理器内存缓存交互关系.png)\n\n除增加高速缓存以外，处理器还可能会对输入指令进行乱序执行优化（**指令重排优化**），虽然保证该结果与顺序执行结果一样，但不保证各个语句的执行先后顺序和输入代码中的顺序一致。\n\n<br><br>\n\n***\n\n<br><br>\n\n## 二、Java内存模型\n\n### 2.1 主内存和工作内存\nJava内存模型的主要目标是定义程序中各个变量的访问规则，即虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。\n>此处的变量是指实例字段、静态字段和构成数组对象的元素，但不包括**局部变量**和**方法参数**，因为这些是**线程私有**的，不会被共享，自然也不会被竞争了\n\nJava内存模型规定**所有的变量都存储在主内存，每条线程还有自己的工作内存，其中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能够直接读取主内存的变量**，不同的线程无法直接访问对方工作内存中的变量，线程间变量值的传递需通过主内存来完成。\n\n![Java内存模型](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/Java内存模型.png)\n\n***\n<br>\n\n### 2.2 内存间交互操作\n关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝考到工作内存、如何从工作内存同步回主内存之间具体的实现细节，Java内存模型定义了以下8中操作来完成，Java虚拟机必须保证下面提及的每一种操作都是**原子的**（对于long和double类型来说，load,store,read和write在某些平台上允许有例外）\n\n操作|作用对象|解释\n-|-|-\nlock(锁定)|主内存|把一个变量标识为一条线程独占的状态\nunlock(解锁)|主内存|把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定\nread(读取)|主内存|把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用\nload(载入)|工作内存|把 read 操作从主内存中得到的变量值放入工作内存中\nuse(使用)|工作内存|把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作\nassign(赋值)|工作内存|把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\nstore(存储)|工作内存|把工作内存中的一个变量的值传送到主内存中，以便 write 操作\nwrite(写入)|工作内存|把 store 操作从工作内存中得到的变量的值放入主内存的变量中\n\n>如果要把一个变量从主内存赋值到工作内存，就要**顺序地**执行read(读取)和load(加载)操作     \n>如果要把一个变量从工作内存同步回主内存，就要**顺序地**执行store(存储)和write(写入)操作  \n\n要求以上规则**必须按照顺序执行，而没有保证是连续执行**\n\nJava内存模型规定了执行上述8种规则时，必须要求满足以下规则：\n\n* **不允许read和load、store和write操作之一单独出现**，也就是不允许从主内存读取了变量的值但是工作内存不接收的情况，或者不允许从工作内存将变量的值回写到主内存但是主内存不接收的情况出现\n* 不允许一个线程丢弃最近的assign操作，也就是*不允许线程在自己的工作线程中修改了变量的值却不同步/回写到主内存*\n* **不允许一个线程无缘由的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中**\n* **一个变量只能在主内存中诞生**，不允许在工作内存中直接使用一个未被初始化的变量（load或者assign操作）。换句话说，在执行use、store之前必须对相同的变量执行了load、assign操作\n* **一个变量在同一时刻只允许被一个线程对其进行lock操作**，但**lock操作可以被同一条线程执行重复执行多次**，相应地，执行多次后，**只有执行相同次数的unlock才会被解锁**。\n* **对变量执行lock操作，将会清空工作空间该变量的值**，执行引擎使用这个变量之前，需要**重新load或者assign操作**初始化变量的值\n* **不允许对没有被lock的变量执行unlock操作**，如果一个变量没有被lock操作，那也不能对其执行unlock操作，当然一个线程也不能对被其他线程lock的变量执行unlock操作\n* **对一个变量执行unlock之前，必须先把变量同步回主内存中**（执行store和write操作）\n\n<br>\n\nJava内存模型对于上述8个操作都具有原子性，但对于64位数据类型long和double，在模型中特别定义了一条相对宽松的定义：允许将没有volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即**不保证它们的原子性**。\n\n<br>\n\n***\n<br>\n\n### 2.3 volatile修饰的变量的特殊规则\n\n关键字volatile可以说是java虚拟机中提供的**最轻量级的同步机制**,当一个变量被定义为volatile之后，它将具备两种特性：\n* **保证此变量对所有线程的可见性**\n    >可见性是指**当一个线程修改了这个变量的值**，新值（修改后的值）**对于其他线程来说是立即可以得知的**,普通变量需要通过主内存来同步实现。**当修改volatile变量时，会给cpu发送一个信号告诉其他cpu这个变量已修改**，当其他cpu调用这个变量时，就会先检查是否有收到修改该变量的信号，有则重新从内存中读取。volatile是无锁的，类似于乐观锁的机制。 简单来说，就是volatile变量进行读时，**会有一个主内存到工作内存到拷贝动作**，**进行写后，会有一个工作内存刷新主内存到动作**。\n\n    >虽然volatile变量对所有线程是立即可见的，所以对volatile变量的所有修改(写操作)都立刻能反应到其他线程中，换句话说：volatile变量在各个线程中是一致的，但是**并不能得出**基于volatile变量的运算在并发下是线程安全的。   因为每次使用之前都需要先刷新，所以不存在不一致的情况，但是**Java里面的操作并非原子性**，即使编译出来只有一条字节码指令，但是也并不意味着这条指令就是一个原子操作。\n\n    >由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景下，我们仍然需要对其加锁（通过synchronized或java.util.concurrent中的原子类）来保证原子性\n    > * 运算结果并不依赖当前值，或能够确保只有单一线程来修改变量的值\n    > * 变量不需要与其他的状态变量共同参与不变约束\n\n    >**可见性通过synchronized和final也可以实现**, synchronized是要求对一个变量执行unl之前，必须同步回主内存，final是指被它修饰的变量一旦在构造器中完成，并且构造器没有吧“this”抛出去，那么在其他线程就能够看见final字段的值\n    \n* 禁止指令重排序\n    >普通的变量仅仅会保证在该方法执行的过程中，所有依赖赋值结果的地方都能获取到正确的结果，但不能保证变量赋值的操作顺序和程序代码的顺序一致。详见[ 双检锁/双重校验锁(增加volatile)](https://notecc.ink/posts/1a4b62fe.html#2-5-%E5%8F%8C%E6%A3%80%E9%94%81-%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81-%E5%A2%9E%E5%8A%A0volatile) 从硬件架构上讲，指令重排序是指cpu采用了允许将多条指令不按程序规的顺序分开送给各相应的电路单元处理.\n\n\n在某些情况下，volatile的同步机制性能要优于锁(使用synchronized关键字或者java.util.concurrent包中的锁)。但是现在**由于虚拟机对锁的不断优化和实行的许多消除动作，很难有一个量化的比较。**    \nvolatile变量的读操作和普通变量的读操作几乎没有差异，但是写操作会性能差一些，慢一些，因为要在本地代码中插入许多内存屏障指令来禁止指令重排序，保证处理器不发生代码乱序执行行为。不过即便如此，大多数情境下volatile的开销还是要比锁要低一些，与其选择的依据是volatile的语义事发后能够满足使用场景的需求。\n\n***\n<br>\n\n### 2.4 先行先发生规则\n也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。\n\n\n\n规则|解释\n-|-\n程序次序规则|在一个线程内，代码按照书写的控制流顺序执行\n管程锁定规则|一个 unlock 操作先行发生于后面对同一个锁的 lock 操作\nvolatile 变量规则|volatile 变量的写操作先行发生于后面对这个变量的读操作\n线程启动规则|Thread 对象的 start() 方法先行发生于此线程的每一个动作\n线程终止规则|线程中所有的操作都先行发生于对此线程的终止检测(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)\n线程中断规则|对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生(通过 Thread.interrupted() 方法检测)\n对象终结规则|一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始\n传递性|如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C\n\n\n\n\n\n\n\n\n\n\n\n\n<br><br>\n\n***\n\n<br><br>\n\n## 三、Java与线程\n\n### 3.1 使用内核线程实现\n直接**由操作系统内核支持的线程**，这种线程**由内核完成切换**。程序一般不会直接去使用内核线程，**而是去使用内核线程的一种高级接口** —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。\n\n![内核线程实现](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/内核线程实现.png)\n\n\n**系统调用的代价较高**，需要在用户态和内核态中**来回切换**。\n\n其次，**每一个轻量级进程都需要一个内核线程的支持**，因此轻量级进程要消耗一定内核资源，因此**一个系统支持轻量级进程的数量是有限的**。\n\n>例如synchronized锁的实现就是如此，所以它是一个重量级操作（当然虚拟机会进行一些优化）\n\n***\n<br>\n\n### 3.2 使用用户线程实现\n广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是**完全建立在用户空间的线程库上的并且内核系统不可感知**的实现。**用户进程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。** \n\n![用户线程实现](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/用户线程实现.png)\n\n**优势是操作非常快速并且低消耗的**     \n**劣势在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理**。线程的创建、切换和调度都是需要考虑的问题，因而使用用户线程的程序实现一般都**比较复杂**。\n***\n<br>\n\n### 3.3 使用用户线程夹加轻量级进程混合实现\n\n![混合实现](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/混合实现.png)\n***\n<br>\n\n### 3.4 Java线程的实现\n平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。\n\n***\n<br>\n\n### 3.5 Java线程调度\n线程调度是指系统为线程分配处理器使用权的过程，主要有两种调度方式：\n* 协同式线程调度\n    >**线程执行时间由线程自身控制**，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是**执行时间不可控，容易阻塞**。\n\n* 抢占式线程调度\n    >每个线程由系统来分配执行时间\n\n虽然Java线程调度是系统自己完成的，但是我们也可以通过优先级（Java语言共用10个优先级）让某些线程优先完成，获得更多的执行时间。\n\n不过线程优先级并不是特别可靠，原因是Java的线程是通过映射到系统的原生的线程上来实现的以及优先级可能会被系统所改变，所以线程调度最终还是得取决于操作系统。\n\n### 3.6 线程状态转换\nJava语言一共定义了5种线程状态，在任意一个时间点，一个线程有且只在其中一种状态：\n\n1. 新建(new)\n    >创建后尚未启动的线程。\n\n2. 运行(Runable)\n    >Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。\n\n3. 无限期等待(Waiting)\n    >出于这种状态的线程不会被 CPU 分配时间，它们要等待被其他线程显示地唤醒，以下方法会然线程进入无限期等待状态：\n    > * 没有设置 Timeout 参数的 Object.wait() 方法。\n    > * 没有设置 Timeout 参数的 Thread.join() 方法。\n    > * LookSupport.park() 方法。\n\n4. 限期等待(Timed Waiting)\n    >处于这种状态的线程也不会分配时间，不过无需等待被其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。以下方法会让线程进入限期等待状态：\n    > * Thread.sleep() 方法。\n    > * 设置了 Timeout 参数的 Object.wait() 方法。\n    > * 设置了 Timeout 参数的 Thread.join() 方法。\n    > * LockSupport.parkNanos() 方法。\n    > * LockSupport.parkUntil() 方法。\n\n5. 阻塞(Blocked)\n    >线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。\n\n6. 结束(Terminated)\n    >已终止线程的线程状态,线程已经结束执行\n\n\n<br><br>\n\n***\n\n<br><br>\n\n## 四、线程安全和锁优化\n### 4.1 线程安全\n\n当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。\n\n***\n<br>\n\n### 4.2 线程安全的等级\n#### 4.2.1 不可变\n一定是线程安全的，例如被final修饰的变量或者String类型的变量\n\n#### 4.2.2 绝对线程安全\n“不管运行环境如何，调用者都不需要任何额外的同步措施”，通常需要付出的代价很大，甚至有时候是不切实际的代价\n\n#### 4.2.3 相对线程安全\n即我们**通常意义上讲的线程安全**，在调用时不需要做额外的保障措施，对于一些特定顺序的连续调用， 就可能在调用端使用额外的同步手段来保证调用的正确性。\n\n#### 4.2.4 线程兼容 \n线程兼容是指对象本身不是线程安全的，但是可以通过在调用端使用同步手段来保证对象在并发环境中可以安全地使用\n\n#### 4.2.5 线程对立\n无论是否采用了同步措施，都无法在多线程环境中并发使用的代码\n\n***\n<br>\n\n### 4.3 线程安全的实现方法\n\n#### 4.3.1 互斥同步\n同步：在多个线程访问共享数据时，保证共享数据在同一时刻只被一个线程使用\n互斥；是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现手段，\n\n互斥是方法，同步是目的（互斥的本质也是同步）\n\n1. 最基本的同步互斥手段是synchronized关键字\n>它在经过编译后，会在同步块的前后分**别形成monitorenter和monitoreif这两个字节码指令**，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。     \n>在执行monitorenter时，首先要尝试去获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有此对象的锁时，则将其加1，相应的执行monitoreif时，会将锁减1，当计数器为0时，锁就会被释放。（有一些类似信号量，但是这个在对于一个线程内，因为一个线程可能掉用多次）     \n\n>synchronized**对于同一条线程来说是可重入**的，不会出现自己锁死自己的问题。其次，**同步块在已进入的线程执行完之前，会阻塞后面的线程进入**\n\n2. 重入锁ReetrantLock\n和synchronized一样，都具有线程可重入性\n>可重入性：若一个程序或子程序可以“在**任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错**”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。一**般而言，可重入的函数一定是线程安全的，反之则不一定成立。**\n\n\n相比synchronized，增加了一些高级功能：\n* 等待可中断。 当持有锁的线程长期不释放锁时，正在等待的线程可以放弃等待去做一些其他事情。\n* 可实现公平锁。  ReetrantLock锁默认是非公平锁，但是可以通过带布尔值的构造函数来实现公平锁。\n* 锁绑定多个条件。 一个ReetrantLock对象可以同时绑定多个条件。\n\n\n在JDK1.6之后，**由于虚拟机对锁实现了很多优化，因此，这两者性能差不多**，而且在**未来的性能改进中，也会更加偏向synchronized**，所以优先选择synchronized\n\n\n#### 4.3.2 非阻塞同步\n**互斥与同步属于一种悲观锁，总是认为如果不去做正确的同步措施，就肯定会出现错误**，无论数据是否会出现竞争都会对其进行加锁。因此由于进行线程阻塞和换醒会带来一些性能问题。\n\n随着指令集的发展我们有了另外一种选择：**基于冲突检测的乐观并发策略。即先进行操作，如果共享数据出现争用，产生了冲突，则采取其他的补偿措施**（最常见的就是不断重复，直至成功）\n\n\n#### 4.3.3 无同步方案\n**要保证线程安全，并不一定要进行同步，两者没有因果关系**。（如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性）\n\n***\n<br>\n\n### 4.4 [锁优化](https://notecc.ink/posts/86818cd5.html)\n\n#### 4.4.1 自旋锁和自适应锁\n\n#### 4.4.2 锁消除\n**即时编译器**在运行时，**对一些代码上要求同步，但检测到不可能存在共享数据竞争的锁进行消除**       \n锁消除的判定依据主要来源于**逃逸分析**的数据支持\n\n#### 4.4.3 锁粗化\n如果**一系列的连续操作都对同一个对象反复加锁和解锁**，甚至加锁和解锁都是出现在**循环体**中的，那么即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。**所以会将加锁同步的范围粗化到整个操作序列的外部**。\n\n#### 4.4.4 轻量级锁\n无竞争的情况下使用CAS操作去除同步使用的互斥量\n\n#### 4.4.5 偏向锁\n在无竞争的情况下把整个同步都消除掉。即**偏向于第一个获得的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不会需要再进行同步**\n\n**偏向锁可以提高有同步但无竞争的程序性能，但并不一定总是对程序有利。**如果程序中大多数的锁总是被多个不同的线程访问，那么偏向锁就是多余的。\n\n\n<br><br><br>\n\n***\n\n<br><br><br>\n\n### 参考   \n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br> \n[2]<a href=\"https://blog.csdn.net/qq_41701956/article/details/81664921\">https://blog.csdn.net/qq_41701956/article/details/81664921</a><br> \n</div>\n<a href=\"\"></a><br> \n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"code/JVM/JVM学习笔记(四) ——Java内存模型和线程安全","published":1,"updated":"2020-07-24T15:34:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1g700400w7tdpfrbw0y","content":"<p>由于计算机的运算能力十分强大而且和计算机的存储和通信子系统的的速度差距过大，大量时间都花费在I/O、网络通信和数据库访问上，因此让计算机同时处理几项任务是最容易而且也更有效的“压榨”计算机运算能力的手段。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200715210838.png\" alt=\"Java内存模型和线程安全\"></p>\n<a id=\"more\"></a>\n\n<p>处理器至少要与内存交互，如读取数据、存储运算结果等。这个I/O操作是几乎无法消除的。而且由于计算机存储设备和处理器运算速度上相差好几个数量级，因此我们在内存和处理器之间加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存和处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存中同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>\n<h2 id=\"一、硬件效率一致性\"><a href=\"#一、硬件效率一致性\" class=\"headerlink\" title=\"一、硬件效率一致性\"></a>一、硬件效率一致性</h2><p><strong>缓存一致性问题</strong>：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，处理器、高速缓存、主内存之间的交互关系如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%A4%84%E7%90%86%E5%99%A8%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png\" alt=\"处理器内存缓存交互关系\"></p>\n<p>除增加高速缓存以外，处理器还可能会对输入指令进行乱序执行优化（<strong>指令重排优化</strong>），虽然保证该结果与顺序执行结果一样，但不保证各个语句的执行先后顺序和输入代码中的顺序一致。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"二、Java内存模型\"><a href=\"#二、Java内存模型\" class=\"headerlink\" title=\"二、Java内存模型\"></a>二、Java内存模型</h2><h3 id=\"2-1-主内存和工作内存\"><a href=\"#2-1-主内存和工作内存\" class=\"headerlink\" title=\"2.1 主内存和工作内存\"></a>2.1 主内存和工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p>\n<blockquote>\n<p>此处的变量是指实例字段、静态字段和构成数组对象的元素，但不包括<strong>局部变量</strong>和<strong>方法参数</strong>，因为这些是<strong>线程私有</strong>的，不会被共享，自然也不会被竞争了</p>\n</blockquote>\n<p>Java内存模型规定<strong>所有的变量都存储在主内存，每条线程还有自己的工作内存，其中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能够直接读取主内存的变量</strong>，不同的线程无法直接访问对方工作内存中的变量，线程间变量值的传递需通过主内存来完成。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png\" alt=\"Java内存模型\"></p>\n<hr>\n<br>\n\n<h3 id=\"2-2-内存间交互操作\"><a href=\"#2-2-内存间交互操作\" class=\"headerlink\" title=\"2.2 内存间交互操作\"></a>2.2 内存间交互操作</h3><p>关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝考到工作内存、如何从工作内存同步回主内存之间具体的实现细节，Java内存模型定义了以下8中操作来完成，Java虚拟机必须保证下面提及的每一种操作都是<strong>原子的</strong>（对于long和double类型来说，load,store,read和write在某些平台上允许有例外）</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>作用对象</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>lock(锁定)</td>\n<td>主内存</td>\n<td>把一个变量标识为一条线程独占的状态</td>\n</tr>\n<tr>\n<td>unlock(解锁)</td>\n<td>主内存</td>\n<td>把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定</td>\n</tr>\n<tr>\n<td>read(读取)</td>\n<td>主内存</td>\n<td>把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用</td>\n</tr>\n<tr>\n<td>load(载入)</td>\n<td>工作内存</td>\n<td>把 read 操作从主内存中得到的变量值放入工作内存中</td>\n</tr>\n<tr>\n<td>use(使用)</td>\n<td>工作内存</td>\n<td>把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作</td>\n</tr>\n<tr>\n<td>assign(赋值)</td>\n<td>工作内存</td>\n<td>把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td>\n</tr>\n<tr>\n<td>store(存储)</td>\n<td>工作内存</td>\n<td>把工作内存中的一个变量的值传送到主内存中，以便 write 操作</td>\n</tr>\n<tr>\n<td>write(写入)</td>\n<td>工作内存</td>\n<td>把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>如果要把一个变量从主内存赋值到工作内存，就要<strong>顺序地</strong>执行read(读取)和load(加载)操作<br>如果要把一个变量从工作内存同步回主内存，就要<strong>顺序地</strong>执行store(存储)和write(写入)操作  </p>\n</blockquote>\n<p>要求以上规则<strong>必须按照顺序执行，而没有保证是连续执行</strong></p>\n<p>Java内存模型规定了执行上述8种规则时，必须要求满足以下规则：</p>\n<ul>\n<li><strong>不允许read和load、store和write操作之一单独出现</strong>，也就是不允许从主内存读取了变量的值但是工作内存不接收的情况，或者不允许从工作内存将变量的值回写到主内存但是主内存不接收的情况出现</li>\n<li>不允许一个线程丢弃最近的assign操作，也就是<em>不允许线程在自己的工作线程中修改了变量的值却不同步/回写到主内存</em></li>\n<li><strong>不允许一个线程无缘由的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中</strong></li>\n<li><strong>一个变量只能在主内存中诞生</strong>，不允许在工作内存中直接使用一个未被初始化的变量（load或者assign操作）。换句话说，在执行use、store之前必须对相同的变量执行了load、assign操作</li>\n<li><strong>一个变量在同一时刻只允许被一个线程对其进行lock操作</strong>，但<strong>lock操作可以被同一条线程执行重复执行多次</strong>，相应地，执行多次后，<strong>只有执行相同次数的unlock才会被解锁</strong>。</li>\n<li><strong>对变量执行lock操作，将会清空工作空间该变量的值</strong>，执行引擎使用这个变量之前，需要<strong>重新load或者assign操作</strong>初始化变量的值</li>\n<li><strong>不允许对没有被lock的变量执行unlock操作</strong>，如果一个变量没有被lock操作，那也不能对其执行unlock操作，当然一个线程也不能对被其他线程lock的变量执行unlock操作</li>\n<li><strong>对一个变量执行unlock之前，必须先把变量同步回主内存中</strong>（执行store和write操作）</li>\n</ul>\n<br>\n\n<p>Java内存模型对于上述8个操作都具有原子性，但对于64位数据类型long和double，在模型中特别定义了一条相对宽松的定义：允许将没有volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即<strong>不保证它们的原子性</strong>。</p>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"2-3-volatile修饰的变量的特殊规则\"><a href=\"#2-3-volatile修饰的变量的特殊规则\" class=\"headerlink\" title=\"2.3 volatile修饰的变量的特殊规则\"></a>2.3 volatile修饰的变量的特殊规则</h3><p>关键字volatile可以说是java虚拟机中提供的<strong>最轻量级的同步机制</strong>,当一个变量被定义为volatile之后，它将具备两种特性：</p>\n<ul>\n<li><p><strong>保证此变量对所有线程的可见性</strong></p>\n<blockquote>\n<p>可见性是指<strong>当一个线程修改了这个变量的值</strong>，新值（修改后的值）<strong>对于其他线程来说是立即可以得知的</strong>,普通变量需要通过主内存来同步实现。<strong>当修改volatile变量时，会给cpu发送一个信号告诉其他cpu这个变量已修改</strong>，当其他cpu调用这个变量时，就会先检查是否有收到修改该变量的信号，有则重新从内存中读取。volatile是无锁的，类似于乐观锁的机制。 简单来说，就是volatile变量进行读时，<strong>会有一个主内存到工作内存到拷贝动作</strong>，<strong>进行写后，会有一个工作内存刷新主内存到动作</strong>。</p>\n</blockquote>\n<blockquote>\n<p>虽然volatile变量对所有线程是立即可见的，所以对volatile变量的所有修改(写操作)都立刻能反应到其他线程中，换句话说：volatile变量在各个线程中是一致的，但是<strong>并不能得出</strong>基于volatile变量的运算在并发下是线程安全的。   因为每次使用之前都需要先刷新，所以不存在不一致的情况，但是<strong>Java里面的操作并非原子性</strong>，即使编译出来只有一条字节码指令，但是也并不意味着这条指令就是一个原子操作。</p>\n</blockquote>\n<blockquote>\n<p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景下，我们仍然需要对其加锁（通过synchronized或java.util.concurrent中的原子类）来保证原子性</p>\n<ul>\n<li>运算结果并不依赖当前值，或能够确保只有单一线程来修改变量的值</li>\n<li>变量不需要与其他的状态变量共同参与不变约束</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>可见性通过synchronized和final也可以实现</strong>, synchronized是要求对一个变量执行unl之前，必须同步回主内存，final是指被它修饰的变量一旦在构造器中完成，并且构造器没有吧“this”抛出去，那么在其他线程就能够看见final字段的值</p>\n</blockquote>\n</li>\n<li><p>禁止指令重排序</p>\n<blockquote>\n<p>普通的变量仅仅会保证在该方法执行的过程中，所有依赖赋值结果的地方都能获取到正确的结果，但不能保证变量赋值的操作顺序和程序代码的顺序一致。详见<a href=\"https://notecc.ink/posts/1a4b62fe.html#2-5-%E5%8F%8C%E6%A3%80%E9%94%81-%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81-%E5%A2%9E%E5%8A%A0volatile\"> 双检锁/双重校验锁(增加volatile)</a> 从硬件架构上讲，指令重排序是指cpu采用了允许将多条指令不按程序规的顺序分开送给各相应的电路单元处理.</p>\n</blockquote>\n</li>\n</ul>\n<p>在某些情况下，volatile的同步机制性能要优于锁(使用synchronized关键字或者java.util.concurrent包中的锁)。但是现在<strong>由于虚拟机对锁的不断优化和实行的许多消除动作，很难有一个量化的比较。</strong><br>volatile变量的读操作和普通变量的读操作几乎没有差异，但是写操作会性能差一些，慢一些，因为要在本地代码中插入许多内存屏障指令来禁止指令重排序，保证处理器不发生代码乱序执行行为。不过即便如此，大多数情境下volatile的开销还是要比锁要低一些，与其选择的依据是volatile的语义事发后能够满足使用场景的需求。</p>\n<hr>\n<br>\n\n<h3 id=\"2-4-先行先发生规则\"><a href=\"#2-4-先行先发生规则\" class=\"headerlink\" title=\"2.4 先行先发生规则\"></a>2.4 先行先发生规则</h3><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>程序次序规则</td>\n<td>在一个线程内，代码按照书写的控制流顺序执行</td>\n</tr>\n<tr>\n<td>管程锁定规则</td>\n<td>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td>\n</tr>\n<tr>\n<td>volatile 变量规则</td>\n<td>volatile 变量的写操作先行发生于后面对这个变量的读操作</td>\n</tr>\n<tr>\n<td>线程启动规则</td>\n<td>Thread 对象的 start() 方法先行发生于此线程的每一个动作</td>\n</tr>\n<tr>\n<td>线程终止规则</td>\n<td>线程中所有的操作都先行发生于对此线程的终止检测(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)</td>\n</tr>\n<tr>\n<td>线程中断规则</td>\n<td>对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生(通过 Thread.interrupted() 方法检测)</td>\n</tr>\n<tr>\n<td>对象终结规则</td>\n<td>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td>\n</tr>\n<tr>\n<td>传递性</td>\n<td>如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td>\n</tr>\n</tbody></table>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"三、Java与线程\"><a href=\"#三、Java与线程\" class=\"headerlink\" title=\"三、Java与线程\"></a>三、Java与线程</h2><h3 id=\"3-1-使用内核线程实现\"><a href=\"#3-1-使用内核线程实现\" class=\"headerlink\" title=\"3.1 使用内核线程实现\"></a>3.1 使用内核线程实现</h3><p>直接<strong>由操作系统内核支持的线程</strong>，这种线程<strong>由内核完成切换</strong>。程序一般不会直接去使用内核线程，<strong>而是去使用内核线程的一种高级接口</strong> —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png\" alt=\"内核线程实现\"></p>\n<p><strong>系统调用的代价较高</strong>，需要在用户态和内核态中<strong>来回切换</strong>。</p>\n<p>其次，<strong>每一个轻量级进程都需要一个内核线程的支持</strong>，因此轻量级进程要消耗一定内核资源，因此<strong>一个系统支持轻量级进程的数量是有限的</strong>。</p>\n<blockquote>\n<p>例如synchronized锁的实现就是如此，所以它是一个重量级操作（当然虚拟机会进行一些优化）</p>\n</blockquote>\n<hr>\n<br>\n\n<h3 id=\"3-2-使用用户线程实现\"><a href=\"#3-2-使用用户线程实现\" class=\"headerlink\" title=\"3.2 使用用户线程实现\"></a>3.2 使用用户线程实现</h3><p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是<strong>完全建立在用户空间的线程库上的并且内核系统不可感知</strong>的实现。<strong>用户进程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。</strong> </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png\" alt=\"用户线程实现\"></p>\n<p><strong>优势是操作非常快速并且低消耗的</strong><br><strong>劣势在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理</strong>。线程的创建、切换和调度都是需要考虑的问题，因而使用用户线程的程序实现一般都<strong>比较复杂</strong>。</p>\n<hr>\n<br>\n\n<h3 id=\"3-3-使用用户线程夹加轻量级进程混合实现\"><a href=\"#3-3-使用用户线程夹加轻量级进程混合实现\" class=\"headerlink\" title=\"3.3 使用用户线程夹加轻量级进程混合实现\"></a>3.3 使用用户线程夹加轻量级进程混合实现</h3><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0.png\" alt=\"混合实现\"></p>\n<hr>\n<br>\n\n<h3 id=\"3-4-Java线程的实现\"><a href=\"#3-4-Java线程的实现\" class=\"headerlink\" title=\"3.4 Java线程的实现\"></a>3.4 Java线程的实现</h3><p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p>\n<hr>\n<br>\n\n<h3 id=\"3-5-Java线程调度\"><a href=\"#3-5-Java线程调度\" class=\"headerlink\" title=\"3.5 Java线程调度\"></a>3.5 Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要有两种调度方式：</p>\n<ul>\n<li><p>协同式线程调度</p>\n<blockquote>\n<p><strong>线程执行时间由线程自身控制</strong>，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是<strong>执行时间不可控，容易阻塞</strong>。</p>\n</blockquote>\n</li>\n<li><p>抢占式线程调度</p>\n<blockquote>\n<p>每个线程由系统来分配执行时间</p>\n</blockquote>\n</li>\n</ul>\n<p>虽然Java线程调度是系统自己完成的，但是我们也可以通过优先级（Java语言共用10个优先级）让某些线程优先完成，获得更多的执行时间。</p>\n<p>不过线程优先级并不是特别可靠，原因是Java的线程是通过映射到系统的原生的线程上来实现的以及优先级可能会被系统所改变，所以线程调度最终还是得取决于操作系统。</p>\n<h3 id=\"3-6-线程状态转换\"><a href=\"#3-6-线程状态转换\" class=\"headerlink\" title=\"3.6 线程状态转换\"></a>3.6 线程状态转换</h3><p>Java语言一共定义了5种线程状态，在任意一个时间点，一个线程有且只在其中一种状态：</p>\n<ol>\n<li><p>新建(new)</p>\n<blockquote>\n<p>创建后尚未启动的线程。</p>\n</blockquote>\n</li>\n<li><p>运行(Runable)</p>\n<blockquote>\n<p>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p>\n</blockquote>\n</li>\n<li><p>无限期等待(Waiting)</p>\n<blockquote>\n<p>出于这种状态的线程不会被 CPU 分配时间，它们要等待被其他线程显示地唤醒，以下方法会然线程进入无限期等待状态：</p>\n<ul>\n<li>没有设置 Timeout 参数的 Object.wait() 方法。</li>\n<li>没有设置 Timeout 参数的 Thread.join() 方法。</li>\n<li>LookSupport.park() 方法。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>限期等待(Timed Waiting)</p>\n<blockquote>\n<p>处于这种状态的线程也不会分配时间，不过无需等待被其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p>\n<ul>\n<li>Thread.sleep() 方法。</li>\n<li>设置了 Timeout 参数的 Object.wait() 方法。</li>\n<li>设置了 Timeout 参数的 Thread.join() 方法。</li>\n<li>LockSupport.parkNanos() 方法。</li>\n<li>LockSupport.parkUntil() 方法。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>阻塞(Blocked)</p>\n<blockquote>\n<p>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p>\n</blockquote>\n</li>\n<li><p>结束(Terminated)</p>\n<blockquote>\n<p>已终止线程的线程状态,线程已经结束执行</p>\n</blockquote>\n</li>\n</ol>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"四、线程安全和锁优化\"><a href=\"#四、线程安全和锁优化\" class=\"headerlink\" title=\"四、线程安全和锁优化\"></a>四、线程安全和锁优化</h2><h3 id=\"4-1-线程安全\"><a href=\"#4-1-线程安全\" class=\"headerlink\" title=\"4.1 线程安全\"></a>4.1 线程安全</h3><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p>\n<hr>\n<br>\n\n<h3 id=\"4-2-线程安全的等级\"><a href=\"#4-2-线程安全的等级\" class=\"headerlink\" title=\"4.2 线程安全的等级\"></a>4.2 线程安全的等级</h3><h4 id=\"4-2-1-不可变\"><a href=\"#4-2-1-不可变\" class=\"headerlink\" title=\"4.2.1 不可变\"></a>4.2.1 不可变</h4><p>一定是线程安全的，例如被final修饰的变量或者String类型的变量</p>\n<h4 id=\"4-2-2-绝对线程安全\"><a href=\"#4-2-2-绝对线程安全\" class=\"headerlink\" title=\"4.2.2 绝对线程安全\"></a>4.2.2 绝对线程安全</h4><p>“不管运行环境如何，调用者都不需要任何额外的同步措施”，通常需要付出的代价很大，甚至有时候是不切实际的代价</p>\n<h4 id=\"4-2-3-相对线程安全\"><a href=\"#4-2-3-相对线程安全\" class=\"headerlink\" title=\"4.2.3 相对线程安全\"></a>4.2.3 相对线程安全</h4><p>即我们<strong>通常意义上讲的线程安全</strong>，在调用时不需要做额外的保障措施，对于一些特定顺序的连续调用， 就可能在调用端使用额外的同步手段来保证调用的正确性。</p>\n<h4 id=\"4-2-4-线程兼容\"><a href=\"#4-2-4-线程兼容\" class=\"headerlink\" title=\"4.2.4 线程兼容\"></a>4.2.4 线程兼容</h4><p>线程兼容是指对象本身不是线程安全的，但是可以通过在调用端使用同步手段来保证对象在并发环境中可以安全地使用</p>\n<h4 id=\"4-2-5-线程对立\"><a href=\"#4-2-5-线程对立\" class=\"headerlink\" title=\"4.2.5 线程对立\"></a>4.2.5 线程对立</h4><p>无论是否采用了同步措施，都无法在多线程环境中并发使用的代码</p>\n<hr>\n<br>\n\n<h3 id=\"4-3-线程安全的实现方法\"><a href=\"#4-3-线程安全的实现方法\" class=\"headerlink\" title=\"4.3 线程安全的实现方法\"></a>4.3 线程安全的实现方法</h3><h4 id=\"4-3-1-互斥同步\"><a href=\"#4-3-1-互斥同步\" class=\"headerlink\" title=\"4.3.1 互斥同步\"></a>4.3.1 互斥同步</h4><p>同步：在多个线程访问共享数据时，保证共享数据在同一时刻只被一个线程使用<br>互斥；是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现手段，</p>\n<p>互斥是方法，同步是目的（互斥的本质也是同步）</p>\n<ol>\n<li>最基本的同步互斥手段是synchronized关键字<blockquote>\n<p>它在经过编译后，会在同步块的前后分<strong>别形成monitorenter和monitoreif这两个字节码指令</strong>，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。<br>在执行monitorenter时，首先要尝试去获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有此对象的锁时，则将其加1，相应的执行monitoreif时，会将锁减1，当计数器为0时，锁就会被释放。（有一些类似信号量，但是这个在对于一个线程内，因为一个线程可能掉用多次）     </p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>synchronized<strong>对于同一条线程来说是可重入</strong>的，不会出现自己锁死自己的问题。其次，<strong>同步块在已进入的线程执行完之前，会阻塞后面的线程进入</strong></p>\n</blockquote>\n<ol start=\"2\">\n<li>重入锁ReetrantLock<br>和synchronized一样，都具有线程可重入性<blockquote>\n<p>可重入性：若一个程序或子程序可以“在<strong>任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错</strong>”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。一<strong>般而言，可重入的函数一定是线程安全的，反之则不一定成立。</strong></p>\n</blockquote>\n</li>\n</ol>\n<p>相比synchronized，增加了一些高级功能：</p>\n<ul>\n<li>等待可中断。 当持有锁的线程长期不释放锁时，正在等待的线程可以放弃等待去做一些其他事情。</li>\n<li>可实现公平锁。  ReetrantLock锁默认是非公平锁，但是可以通过带布尔值的构造函数来实现公平锁。</li>\n<li>锁绑定多个条件。 一个ReetrantLock对象可以同时绑定多个条件。</li>\n</ul>\n<p>在JDK1.6之后，<strong>由于虚拟机对锁实现了很多优化，因此，这两者性能差不多</strong>，而且在<strong>未来的性能改进中，也会更加偏向synchronized</strong>，所以优先选择synchronized</p>\n<h4 id=\"4-3-2-非阻塞同步\"><a href=\"#4-3-2-非阻塞同步\" class=\"headerlink\" title=\"4.3.2 非阻塞同步\"></a>4.3.2 非阻塞同步</h4><p><strong>互斥与同步属于一种悲观锁，总是认为如果不去做正确的同步措施，就肯定会出现错误</strong>，无论数据是否会出现竞争都会对其进行加锁。因此由于进行线程阻塞和换醒会带来一些性能问题。</p>\n<p>随着指令集的发展我们有了另外一种选择：<strong>基于冲突检测的乐观并发策略。即先进行操作，如果共享数据出现争用，产生了冲突，则采取其他的补偿措施</strong>（最常见的就是不断重复，直至成功）</p>\n<h4 id=\"4-3-3-无同步方案\"><a href=\"#4-3-3-无同步方案\" class=\"headerlink\" title=\"4.3.3 无同步方案\"></a>4.3.3 无同步方案</h4><p><strong>要保证线程安全，并不一定要进行同步，两者没有因果关系</strong>。（如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性）</p>\n<hr>\n<br>\n\n<h3 id=\"4-4-锁优化\"><a href=\"#4-4-锁优化\" class=\"headerlink\" title=\"4.4 锁优化\"></a>4.4 <a href=\"https://notecc.ink/posts/86818cd5.html\">锁优化</a></h3><h4 id=\"4-4-1-自旋锁和自适应锁\"><a href=\"#4-4-1-自旋锁和自适应锁\" class=\"headerlink\" title=\"4.4.1 自旋锁和自适应锁\"></a>4.4.1 自旋锁和自适应锁</h4><h4 id=\"4-4-2-锁消除\"><a href=\"#4-4-2-锁消除\" class=\"headerlink\" title=\"4.4.2 锁消除\"></a>4.4.2 锁消除</h4><p><strong>即时编译器</strong>在运行时，<strong>对一些代码上要求同步，但检测到不可能存在共享数据竞争的锁进行消除</strong><br>锁消除的判定依据主要来源于<strong>逃逸分析</strong>的数据支持</p>\n<h4 id=\"4-4-3-锁粗化\"><a href=\"#4-4-3-锁粗化\" class=\"headerlink\" title=\"4.4.3 锁粗化\"></a>4.4.3 锁粗化</h4><p>如果<strong>一系列的连续操作都对同一个对象反复加锁和解锁</strong>，甚至加锁和解锁都是出现在<strong>循环体</strong>中的，那么即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。<strong>所以会将加锁同步的范围粗化到整个操作序列的外部</strong>。</p>\n<h4 id=\"4-4-4-轻量级锁\"><a href=\"#4-4-4-轻量级锁\" class=\"headerlink\" title=\"4.4.4 轻量级锁\"></a>4.4.4 轻量级锁</h4><p>无竞争的情况下使用CAS操作去除同步使用的互斥量</p>\n<h4 id=\"4-4-5-偏向锁\"><a href=\"#4-4-5-偏向锁\" class=\"headerlink\" title=\"4.4.5 偏向锁\"></a>4.4.5 偏向锁</h4><p>在无竞争的情况下把整个同步都消除掉。即<strong>偏向于第一个获得的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不会需要再进行同步</strong></p>\n<p><strong>偏向锁可以提高有同步但无竞争的程序性能，但并不一定总是对程序有利。</strong>如果程序中大多数的锁总是被多个不同的线程访问，那么偏向锁就是多余的。</p>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><div style=\"margin-left: 5px  font-size:16px;\">\n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br> \n[2]<a href=\"https://blog.csdn.net/qq_41701956/article/details/81664921\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_41701956/article/details/81664921</a><br> \n</div>\n<a href=\"\"></a><br> \n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>由于计算机的运算能力十分强大而且和计算机的存储和通信子系统的的速度差距过大，大量时间都花费在I/O、网络通信和数据库访问上，因此让计算机同时处理几项任务是最容易而且也更有效的“压榨”计算机运算能力的手段。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200715210838.png\" alt=\"Java内存模型和线程安全\"></p>","more":"<p>处理器至少要与内存交互，如读取数据、存储运算结果等。这个I/O操作是几乎无法消除的。而且由于计算机存储设备和处理器运算速度上相差好几个数量级，因此我们在内存和处理器之间加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存和处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存中同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>\n<h2 id=\"一、硬件效率一致性\"><a href=\"#一、硬件效率一致性\" class=\"headerlink\" title=\"一、硬件效率一致性\"></a>一、硬件效率一致性</h2><p><strong>缓存一致性问题</strong>：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，处理器、高速缓存、主内存之间的交互关系如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%A4%84%E7%90%86%E5%99%A8%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png\" alt=\"处理器内存缓存交互关系\"></p>\n<p>除增加高速缓存以外，处理器还可能会对输入指令进行乱序执行优化（<strong>指令重排优化</strong>），虽然保证该结果与顺序执行结果一样，但不保证各个语句的执行先后顺序和输入代码中的顺序一致。</p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"二、Java内存模型\"><a href=\"#二、Java内存模型\" class=\"headerlink\" title=\"二、Java内存模型\"></a>二、Java内存模型</h2><h3 id=\"2-1-主内存和工作内存\"><a href=\"#2-1-主内存和工作内存\" class=\"headerlink\" title=\"2.1 主内存和工作内存\"></a>2.1 主内存和工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p>\n<blockquote>\n<p>此处的变量是指实例字段、静态字段和构成数组对象的元素，但不包括<strong>局部变量</strong>和<strong>方法参数</strong>，因为这些是<strong>线程私有</strong>的，不会被共享，自然也不会被竞争了</p>\n</blockquote>\n<p>Java内存模型规定<strong>所有的变量都存储在主内存，每条线程还有自己的工作内存，其中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能够直接读取主内存的变量</strong>，不同的线程无法直接访问对方工作内存中的变量，线程间变量值的传递需通过主内存来完成。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png\" alt=\"Java内存模型\"></p>\n<hr>\n<br>\n\n<h3 id=\"2-2-内存间交互操作\"><a href=\"#2-2-内存间交互操作\" class=\"headerlink\" title=\"2.2 内存间交互操作\"></a>2.2 内存间交互操作</h3><p>关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝考到工作内存、如何从工作内存同步回主内存之间具体的实现细节，Java内存模型定义了以下8中操作来完成，Java虚拟机必须保证下面提及的每一种操作都是<strong>原子的</strong>（对于long和double类型来说，load,store,read和write在某些平台上允许有例外）</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>作用对象</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>lock(锁定)</td>\n<td>主内存</td>\n<td>把一个变量标识为一条线程独占的状态</td>\n</tr>\n<tr>\n<td>unlock(解锁)</td>\n<td>主内存</td>\n<td>把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定</td>\n</tr>\n<tr>\n<td>read(读取)</td>\n<td>主内存</td>\n<td>把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用</td>\n</tr>\n<tr>\n<td>load(载入)</td>\n<td>工作内存</td>\n<td>把 read 操作从主内存中得到的变量值放入工作内存中</td>\n</tr>\n<tr>\n<td>use(使用)</td>\n<td>工作内存</td>\n<td>把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作</td>\n</tr>\n<tr>\n<td>assign(赋值)</td>\n<td>工作内存</td>\n<td>把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td>\n</tr>\n<tr>\n<td>store(存储)</td>\n<td>工作内存</td>\n<td>把工作内存中的一个变量的值传送到主内存中，以便 write 操作</td>\n</tr>\n<tr>\n<td>write(写入)</td>\n<td>工作内存</td>\n<td>把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>如果要把一个变量从主内存赋值到工作内存，就要<strong>顺序地</strong>执行read(读取)和load(加载)操作<br>如果要把一个变量从工作内存同步回主内存，就要<strong>顺序地</strong>执行store(存储)和write(写入)操作  </p>\n</blockquote>\n<p>要求以上规则<strong>必须按照顺序执行，而没有保证是连续执行</strong></p>\n<p>Java内存模型规定了执行上述8种规则时，必须要求满足以下规则：</p>\n<ul>\n<li><strong>不允许read和load、store和write操作之一单独出现</strong>，也就是不允许从主内存读取了变量的值但是工作内存不接收的情况，或者不允许从工作内存将变量的值回写到主内存但是主内存不接收的情况出现</li>\n<li>不允许一个线程丢弃最近的assign操作，也就是<em>不允许线程在自己的工作线程中修改了变量的值却不同步/回写到主内存</em></li>\n<li><strong>不允许一个线程无缘由的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中</strong></li>\n<li><strong>一个变量只能在主内存中诞生</strong>，不允许在工作内存中直接使用一个未被初始化的变量（load或者assign操作）。换句话说，在执行use、store之前必须对相同的变量执行了load、assign操作</li>\n<li><strong>一个变量在同一时刻只允许被一个线程对其进行lock操作</strong>，但<strong>lock操作可以被同一条线程执行重复执行多次</strong>，相应地，执行多次后，<strong>只有执行相同次数的unlock才会被解锁</strong>。</li>\n<li><strong>对变量执行lock操作，将会清空工作空间该变量的值</strong>，执行引擎使用这个变量之前，需要<strong>重新load或者assign操作</strong>初始化变量的值</li>\n<li><strong>不允许对没有被lock的变量执行unlock操作</strong>，如果一个变量没有被lock操作，那也不能对其执行unlock操作，当然一个线程也不能对被其他线程lock的变量执行unlock操作</li>\n<li><strong>对一个变量执行unlock之前，必须先把变量同步回主内存中</strong>（执行store和write操作）</li>\n</ul>\n<br>\n\n<p>Java内存模型对于上述8个操作都具有原子性，但对于64位数据类型long和double，在模型中特别定义了一条相对宽松的定义：允许将没有volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即<strong>不保证它们的原子性</strong>。</p>\n<br>\n\n<hr>\n<br>\n\n<h3 id=\"2-3-volatile修饰的变量的特殊规则\"><a href=\"#2-3-volatile修饰的变量的特殊规则\" class=\"headerlink\" title=\"2.3 volatile修饰的变量的特殊规则\"></a>2.3 volatile修饰的变量的特殊规则</h3><p>关键字volatile可以说是java虚拟机中提供的<strong>最轻量级的同步机制</strong>,当一个变量被定义为volatile之后，它将具备两种特性：</p>\n<ul>\n<li><p><strong>保证此变量对所有线程的可见性</strong></p>\n<blockquote>\n<p>可见性是指<strong>当一个线程修改了这个变量的值</strong>，新值（修改后的值）<strong>对于其他线程来说是立即可以得知的</strong>,普通变量需要通过主内存来同步实现。<strong>当修改volatile变量时，会给cpu发送一个信号告诉其他cpu这个变量已修改</strong>，当其他cpu调用这个变量时，就会先检查是否有收到修改该变量的信号，有则重新从内存中读取。volatile是无锁的，类似于乐观锁的机制。 简单来说，就是volatile变量进行读时，<strong>会有一个主内存到工作内存到拷贝动作</strong>，<strong>进行写后，会有一个工作内存刷新主内存到动作</strong>。</p>\n</blockquote>\n<blockquote>\n<p>虽然volatile变量对所有线程是立即可见的，所以对volatile变量的所有修改(写操作)都立刻能反应到其他线程中，换句话说：volatile变量在各个线程中是一致的，但是<strong>并不能得出</strong>基于volatile变量的运算在并发下是线程安全的。   因为每次使用之前都需要先刷新，所以不存在不一致的情况，但是<strong>Java里面的操作并非原子性</strong>，即使编译出来只有一条字节码指令，但是也并不意味着这条指令就是一个原子操作。</p>\n</blockquote>\n<blockquote>\n<p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景下，我们仍然需要对其加锁（通过synchronized或java.util.concurrent中的原子类）来保证原子性</p>\n<ul>\n<li>运算结果并不依赖当前值，或能够确保只有单一线程来修改变量的值</li>\n<li>变量不需要与其他的状态变量共同参与不变约束</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>可见性通过synchronized和final也可以实现</strong>, synchronized是要求对一个变量执行unl之前，必须同步回主内存，final是指被它修饰的变量一旦在构造器中完成，并且构造器没有吧“this”抛出去，那么在其他线程就能够看见final字段的值</p>\n</blockquote>\n</li>\n<li><p>禁止指令重排序</p>\n<blockquote>\n<p>普通的变量仅仅会保证在该方法执行的过程中，所有依赖赋值结果的地方都能获取到正确的结果，但不能保证变量赋值的操作顺序和程序代码的顺序一致。详见<a href=\"https://notecc.ink/posts/1a4b62fe.html#2-5-%E5%8F%8C%E6%A3%80%E9%94%81-%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81-%E5%A2%9E%E5%8A%A0volatile\"> 双检锁/双重校验锁(增加volatile)</a> 从硬件架构上讲，指令重排序是指cpu采用了允许将多条指令不按程序规的顺序分开送给各相应的电路单元处理.</p>\n</blockquote>\n</li>\n</ul>\n<p>在某些情况下，volatile的同步机制性能要优于锁(使用synchronized关键字或者java.util.concurrent包中的锁)。但是现在<strong>由于虚拟机对锁的不断优化和实行的许多消除动作，很难有一个量化的比较。</strong><br>volatile变量的读操作和普通变量的读操作几乎没有差异，但是写操作会性能差一些，慢一些，因为要在本地代码中插入许多内存屏障指令来禁止指令重排序，保证处理器不发生代码乱序执行行为。不过即便如此，大多数情境下volatile的开销还是要比锁要低一些，与其选择的依据是volatile的语义事发后能够满足使用场景的需求。</p>\n<hr>\n<br>\n\n<h3 id=\"2-4-先行先发生规则\"><a href=\"#2-4-先行先发生规则\" class=\"headerlink\" title=\"2.4 先行先发生规则\"></a>2.4 先行先发生规则</h3><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>程序次序规则</td>\n<td>在一个线程内，代码按照书写的控制流顺序执行</td>\n</tr>\n<tr>\n<td>管程锁定规则</td>\n<td>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td>\n</tr>\n<tr>\n<td>volatile 变量规则</td>\n<td>volatile 变量的写操作先行发生于后面对这个变量的读操作</td>\n</tr>\n<tr>\n<td>线程启动规则</td>\n<td>Thread 对象的 start() 方法先行发生于此线程的每一个动作</td>\n</tr>\n<tr>\n<td>线程终止规则</td>\n<td>线程中所有的操作都先行发生于对此线程的终止检测(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)</td>\n</tr>\n<tr>\n<td>线程中断规则</td>\n<td>对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生(通过 Thread.interrupted() 方法检测)</td>\n</tr>\n<tr>\n<td>对象终结规则</td>\n<td>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td>\n</tr>\n<tr>\n<td>传递性</td>\n<td>如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td>\n</tr>\n</tbody></table>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"三、Java与线程\"><a href=\"#三、Java与线程\" class=\"headerlink\" title=\"三、Java与线程\"></a>三、Java与线程</h2><h3 id=\"3-1-使用内核线程实现\"><a href=\"#3-1-使用内核线程实现\" class=\"headerlink\" title=\"3.1 使用内核线程实现\"></a>3.1 使用内核线程实现</h3><p>直接<strong>由操作系统内核支持的线程</strong>，这种线程<strong>由内核完成切换</strong>。程序一般不会直接去使用内核线程，<strong>而是去使用内核线程的一种高级接口</strong> —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png\" alt=\"内核线程实现\"></p>\n<p><strong>系统调用的代价较高</strong>，需要在用户态和内核态中<strong>来回切换</strong>。</p>\n<p>其次，<strong>每一个轻量级进程都需要一个内核线程的支持</strong>，因此轻量级进程要消耗一定内核资源，因此<strong>一个系统支持轻量级进程的数量是有限的</strong>。</p>\n<blockquote>\n<p>例如synchronized锁的实现就是如此，所以它是一个重量级操作（当然虚拟机会进行一些优化）</p>\n</blockquote>\n<hr>\n<br>\n\n<h3 id=\"3-2-使用用户线程实现\"><a href=\"#3-2-使用用户线程实现\" class=\"headerlink\" title=\"3.2 使用用户线程实现\"></a>3.2 使用用户线程实现</h3><p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是<strong>完全建立在用户空间的线程库上的并且内核系统不可感知</strong>的实现。<strong>用户进程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。</strong> </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png\" alt=\"用户线程实现\"></p>\n<p><strong>优势是操作非常快速并且低消耗的</strong><br><strong>劣势在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理</strong>。线程的创建、切换和调度都是需要考虑的问题，因而使用用户线程的程序实现一般都<strong>比较复杂</strong>。</p>\n<hr>\n<br>\n\n<h3 id=\"3-3-使用用户线程夹加轻量级进程混合实现\"><a href=\"#3-3-使用用户线程夹加轻量级进程混合实现\" class=\"headerlink\" title=\"3.3 使用用户线程夹加轻量级进程混合实现\"></a>3.3 使用用户线程夹加轻量级进程混合实现</h3><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0.png\" alt=\"混合实现\"></p>\n<hr>\n<br>\n\n<h3 id=\"3-4-Java线程的实现\"><a href=\"#3-4-Java线程的实现\" class=\"headerlink\" title=\"3.4 Java线程的实现\"></a>3.4 Java线程的实现</h3><p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p>\n<hr>\n<br>\n\n<h3 id=\"3-5-Java线程调度\"><a href=\"#3-5-Java线程调度\" class=\"headerlink\" title=\"3.5 Java线程调度\"></a>3.5 Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要有两种调度方式：</p>\n<ul>\n<li><p>协同式线程调度</p>\n<blockquote>\n<p><strong>线程执行时间由线程自身控制</strong>，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是<strong>执行时间不可控，容易阻塞</strong>。</p>\n</blockquote>\n</li>\n<li><p>抢占式线程调度</p>\n<blockquote>\n<p>每个线程由系统来分配执行时间</p>\n</blockquote>\n</li>\n</ul>\n<p>虽然Java线程调度是系统自己完成的，但是我们也可以通过优先级（Java语言共用10个优先级）让某些线程优先完成，获得更多的执行时间。</p>\n<p>不过线程优先级并不是特别可靠，原因是Java的线程是通过映射到系统的原生的线程上来实现的以及优先级可能会被系统所改变，所以线程调度最终还是得取决于操作系统。</p>\n<h3 id=\"3-6-线程状态转换\"><a href=\"#3-6-线程状态转换\" class=\"headerlink\" title=\"3.6 线程状态转换\"></a>3.6 线程状态转换</h3><p>Java语言一共定义了5种线程状态，在任意一个时间点，一个线程有且只在其中一种状态：</p>\n<ol>\n<li><p>新建(new)</p>\n<blockquote>\n<p>创建后尚未启动的线程。</p>\n</blockquote>\n</li>\n<li><p>运行(Runable)</p>\n<blockquote>\n<p>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p>\n</blockquote>\n</li>\n<li><p>无限期等待(Waiting)</p>\n<blockquote>\n<p>出于这种状态的线程不会被 CPU 分配时间，它们要等待被其他线程显示地唤醒，以下方法会然线程进入无限期等待状态：</p>\n<ul>\n<li>没有设置 Timeout 参数的 Object.wait() 方法。</li>\n<li>没有设置 Timeout 参数的 Thread.join() 方法。</li>\n<li>LookSupport.park() 方法。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>限期等待(Timed Waiting)</p>\n<blockquote>\n<p>处于这种状态的线程也不会分配时间，不过无需等待被其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p>\n<ul>\n<li>Thread.sleep() 方法。</li>\n<li>设置了 Timeout 参数的 Object.wait() 方法。</li>\n<li>设置了 Timeout 参数的 Thread.join() 方法。</li>\n<li>LockSupport.parkNanos() 方法。</li>\n<li>LockSupport.parkUntil() 方法。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>阻塞(Blocked)</p>\n<blockquote>\n<p>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p>\n</blockquote>\n</li>\n<li><p>结束(Terminated)</p>\n<blockquote>\n<p>已终止线程的线程状态,线程已经结束执行</p>\n</blockquote>\n</li>\n</ol>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"四、线程安全和锁优化\"><a href=\"#四、线程安全和锁优化\" class=\"headerlink\" title=\"四、线程安全和锁优化\"></a>四、线程安全和锁优化</h2><h3 id=\"4-1-线程安全\"><a href=\"#4-1-线程安全\" class=\"headerlink\" title=\"4.1 线程安全\"></a>4.1 线程安全</h3><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p>\n<hr>\n<br>\n\n<h3 id=\"4-2-线程安全的等级\"><a href=\"#4-2-线程安全的等级\" class=\"headerlink\" title=\"4.2 线程安全的等级\"></a>4.2 线程安全的等级</h3><h4 id=\"4-2-1-不可变\"><a href=\"#4-2-1-不可变\" class=\"headerlink\" title=\"4.2.1 不可变\"></a>4.2.1 不可变</h4><p>一定是线程安全的，例如被final修饰的变量或者String类型的变量</p>\n<h4 id=\"4-2-2-绝对线程安全\"><a href=\"#4-2-2-绝对线程安全\" class=\"headerlink\" title=\"4.2.2 绝对线程安全\"></a>4.2.2 绝对线程安全</h4><p>“不管运行环境如何，调用者都不需要任何额外的同步措施”，通常需要付出的代价很大，甚至有时候是不切实际的代价</p>\n<h4 id=\"4-2-3-相对线程安全\"><a href=\"#4-2-3-相对线程安全\" class=\"headerlink\" title=\"4.2.3 相对线程安全\"></a>4.2.3 相对线程安全</h4><p>即我们<strong>通常意义上讲的线程安全</strong>，在调用时不需要做额外的保障措施，对于一些特定顺序的连续调用， 就可能在调用端使用额外的同步手段来保证调用的正确性。</p>\n<h4 id=\"4-2-4-线程兼容\"><a href=\"#4-2-4-线程兼容\" class=\"headerlink\" title=\"4.2.4 线程兼容\"></a>4.2.4 线程兼容</h4><p>线程兼容是指对象本身不是线程安全的，但是可以通过在调用端使用同步手段来保证对象在并发环境中可以安全地使用</p>\n<h4 id=\"4-2-5-线程对立\"><a href=\"#4-2-5-线程对立\" class=\"headerlink\" title=\"4.2.5 线程对立\"></a>4.2.5 线程对立</h4><p>无论是否采用了同步措施，都无法在多线程环境中并发使用的代码</p>\n<hr>\n<br>\n\n<h3 id=\"4-3-线程安全的实现方法\"><a href=\"#4-3-线程安全的实现方法\" class=\"headerlink\" title=\"4.3 线程安全的实现方法\"></a>4.3 线程安全的实现方法</h3><h4 id=\"4-3-1-互斥同步\"><a href=\"#4-3-1-互斥同步\" class=\"headerlink\" title=\"4.3.1 互斥同步\"></a>4.3.1 互斥同步</h4><p>同步：在多个线程访问共享数据时，保证共享数据在同一时刻只被一个线程使用<br>互斥；是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现手段，</p>\n<p>互斥是方法，同步是目的（互斥的本质也是同步）</p>\n<ol>\n<li>最基本的同步互斥手段是synchronized关键字<blockquote>\n<p>它在经过编译后，会在同步块的前后分<strong>别形成monitorenter和monitoreif这两个字节码指令</strong>，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。<br>在执行monitorenter时，首先要尝试去获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有此对象的锁时，则将其加1，相应的执行monitoreif时，会将锁减1，当计数器为0时，锁就会被释放。（有一些类似信号量，但是这个在对于一个线程内，因为一个线程可能掉用多次）     </p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>synchronized<strong>对于同一条线程来说是可重入</strong>的，不会出现自己锁死自己的问题。其次，<strong>同步块在已进入的线程执行完之前，会阻塞后面的线程进入</strong></p>\n</blockquote>\n<ol start=\"2\">\n<li>重入锁ReetrantLock<br>和synchronized一样，都具有线程可重入性<blockquote>\n<p>可重入性：若一个程序或子程序可以“在<strong>任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错</strong>”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。一<strong>般而言，可重入的函数一定是线程安全的，反之则不一定成立。</strong></p>\n</blockquote>\n</li>\n</ol>\n<p>相比synchronized，增加了一些高级功能：</p>\n<ul>\n<li>等待可中断。 当持有锁的线程长期不释放锁时，正在等待的线程可以放弃等待去做一些其他事情。</li>\n<li>可实现公平锁。  ReetrantLock锁默认是非公平锁，但是可以通过带布尔值的构造函数来实现公平锁。</li>\n<li>锁绑定多个条件。 一个ReetrantLock对象可以同时绑定多个条件。</li>\n</ul>\n<p>在JDK1.6之后，<strong>由于虚拟机对锁实现了很多优化，因此，这两者性能差不多</strong>，而且在<strong>未来的性能改进中，也会更加偏向synchronized</strong>，所以优先选择synchronized</p>\n<h4 id=\"4-3-2-非阻塞同步\"><a href=\"#4-3-2-非阻塞同步\" class=\"headerlink\" title=\"4.3.2 非阻塞同步\"></a>4.3.2 非阻塞同步</h4><p><strong>互斥与同步属于一种悲观锁，总是认为如果不去做正确的同步措施，就肯定会出现错误</strong>，无论数据是否会出现竞争都会对其进行加锁。因此由于进行线程阻塞和换醒会带来一些性能问题。</p>\n<p>随着指令集的发展我们有了另外一种选择：<strong>基于冲突检测的乐观并发策略。即先进行操作，如果共享数据出现争用，产生了冲突，则采取其他的补偿措施</strong>（最常见的就是不断重复，直至成功）</p>\n<h4 id=\"4-3-3-无同步方案\"><a href=\"#4-3-3-无同步方案\" class=\"headerlink\" title=\"4.3.3 无同步方案\"></a>4.3.3 无同步方案</h4><p><strong>要保证线程安全，并不一定要进行同步，两者没有因果关系</strong>。（如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性）</p>\n<hr>\n<br>\n\n<h3 id=\"4-4-锁优化\"><a href=\"#4-4-锁优化\" class=\"headerlink\" title=\"4.4 锁优化\"></a>4.4 <a href=\"https://notecc.ink/posts/86818cd5.html\">锁优化</a></h3><h4 id=\"4-4-1-自旋锁和自适应锁\"><a href=\"#4-4-1-自旋锁和自适应锁\" class=\"headerlink\" title=\"4.4.1 自旋锁和自适应锁\"></a>4.4.1 自旋锁和自适应锁</h4><h4 id=\"4-4-2-锁消除\"><a href=\"#4-4-2-锁消除\" class=\"headerlink\" title=\"4.4.2 锁消除\"></a>4.4.2 锁消除</h4><p><strong>即时编译器</strong>在运行时，<strong>对一些代码上要求同步，但检测到不可能存在共享数据竞争的锁进行消除</strong><br>锁消除的判定依据主要来源于<strong>逃逸分析</strong>的数据支持</p>\n<h4 id=\"4-4-3-锁粗化\"><a href=\"#4-4-3-锁粗化\" class=\"headerlink\" title=\"4.4.3 锁粗化\"></a>4.4.3 锁粗化</h4><p>如果<strong>一系列的连续操作都对同一个对象反复加锁和解锁</strong>，甚至加锁和解锁都是出现在<strong>循环体</strong>中的，那么即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。<strong>所以会将加锁同步的范围粗化到整个操作序列的外部</strong>。</p>\n<h4 id=\"4-4-4-轻量级锁\"><a href=\"#4-4-4-轻量级锁\" class=\"headerlink\" title=\"4.4.4 轻量级锁\"></a>4.4.4 轻量级锁</h4><p>无竞争的情况下使用CAS操作去除同步使用的互斥量</p>\n<h4 id=\"4-4-5-偏向锁\"><a href=\"#4-4-5-偏向锁\" class=\"headerlink\" title=\"4.4.5 偏向锁\"></a>4.4.5 偏向锁</h4><p>在无竞争的情况下把整个同步都消除掉。即<strong>偏向于第一个获得的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不会需要再进行同步</strong></p>\n<p><strong>偏向锁可以提高有同步但无竞争的程序性能，但并不一定总是对程序有利。</strong>如果程序中大多数的锁总是被多个不同的线程访问，那么偏向锁就是多余的。</p>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><div style=\"margin-left: 5px  font-size:16px;\">\n[1]周志明.深入理解Java虚拟机.北京：机械工业出版社<br> \n[2]<a href=\"https://blog.csdn.net/qq_41701956/article/details/81664921\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_41701956/article/details/81664921</a><br> \n</div>\n<a href=\"\"></a><br>"},{"title":"JavaSE容器","photos":["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/121212java.jpg"],"date":"2020-04-30T11:42:10.000Z","abbrlink":"6ea65bec","declare":true,"wordCount":true,"_content":"❄\n<!-- more -->\n\n\n> ➱https://www.cnblogs.com/daimasanjiaomao/p/11005764.html➲<br>\n\nJava容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。\n\n### 常用容器目录\n![常用容器目录](https://img-blog.csdnimg.cn/20190317184953342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70)\n***\n\n### Collection和Collections的区别\n* Collection是**集合类的上层接口**，继承他的接口主要有Set和List\n* Collections是针对于集合类的一个**帮助类**，他提供了一系列的静态方法实现对集合的搜索、排序、线程安全化等操作。 \n***\n\n### map的分类和常见的情况 \n* java.util.Map接口主要用于存储键值对，根据键得到值，**因此不允许键重复，但允许值重复**，它有四个实现类：\n    * Hashmap:根据键的hashCode值存储数据，具有很快的访问速度，**遍历时，具有很快的访问速度，但取得的速度是随机的。Hashmap不支持线程的同步**,多个线程同时读取会导致数据的不一致，**若需要同步，可以使用Collections的synchronizedMap()方法使Hashmap具有同步能力或者使用ConcurrentHashMap**.\n        * ConcurrentHashMap分段锁\n        * HashMap允许任何类型的键和值对象，并**允许将null用作键或值**\n    * Hashtable与HashMap类似，不同的是**它不允许记录的键或值为空，它支持线程同步**， 即任何时候只有一个线程能写Hashtable但也因此**导致了hashtable访问较慢**。\n    * LinkedHashMap是Hashmap的一个子类，**保存了记录的插入顺序，用iterator遍历时先得到的记录肯定是先插入的。遍历速度比HashMap慢**，除非HashMap容量很大但实际数据较少。\n    * TreeMap实现的是SortMap接口，**能够把它保存的记录按照键排序**，用iterator遍历的数据是排过序的。\n        * TreeMap的实现底层实现**基于二叉树的红黑树**，插入的值是按一定顺序排序的。\n    >一般情况下，用的最多的是HashMap，用它插入，删除，定位是最好的选择。但如果按照自然顺序或按照自定义顺序，TreeMap更好，如果要输入输出顺序一样，LinkedHashMap更好。\n***\n\n* HashMap的实现原理\n    * HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>\n    HashMap的数据结构： **在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用）**，所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“**链表散列**”的数据结构，即数组和链表的结合体。<br>\n    当我们往Hashmap中put元素时,**首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。**<br>\n    需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)\n***\n\n### HashSet\n* 实现原理\n    * HashSet底层由HashMap实现，HashSet的值存放于HashMap的Key上，HashMap的**value统一为PRESENT**\n* 特性\n    * 它存储**唯一**元素并**允许空值**\n    * 它由HashMap支持\n    * 它**不保持插入顺序**\n    * 它**不是线程安全**的\n* API\n    * add():可用于**将元素添加到一组**。方法声明只有当元素尚未存在于集合中时才会添加元素。如果成功添加了元素，则该方法返回true，否则返回false。\n    * contains():目的是**检查给定HashSet中是否存在元素**。如果找到该元素，则返回true，否则返回false。\n    * remove():如果存在，该方法将从集合中**删除指定的元素**。如果集合包含指定的元素，则此方法返回true。\n    * clear():当我们打算从集合中**删除所有项目时**，我们使用此方法。底层实现只是清除底层HashMap中的所有元素。\n    *  size():这是API中的基本方法之一。它被大量使用，因为它有助于识别HashSet中存在的元素数量。底层实现只是将计算委托给HashMap的size（）方法。\n    *  isEmpty():我们可以使用此方法来确定**HashSet的给定实例是否为空**。如果集合不包含任何元素，则此方法返回true\n    * Iterator():该方法返回Set中元素的**迭代器**。这些元素**没有特定的顺序**访问，Iterator是fail-fast的。\n***\n\n\n### 数组(Array)和列表(ArrayList)的区别\n* **Array可以包含基本类型或者对象类型，Arraylist只能包含对象类型；**\n* Array大小是固定对的，ArrayList不是。\n* 对于基本数据类型，Array使用自动装箱来减少编码工作量，但当处理固定大小的基本上数据类型时这种方式较慢。\n***\n\n### ArrayList、LinkedList和Vector\n* ArrayList和LinkedList最明显的区别是ArrayList的底层数据结构是**数组，支持随机访问，因此插入慢，读取快**。而LinkedList的底层数据结构是**双向循环链表，不支持随机访问,因此写入块，读取慢**，Array的时间复杂度是O(1),LinkedList是O(n);\n    \n    >随机访问只是读取时索引顺序每次有差别，但是可以保证遍历出来的结果顺序是一样的\n* Vector也是数组方式存储数据，和ArrayList一样数组元素数大于实际存储的数据，不同的是**Vector支持线程安全**，所以性能比ArrayList弱一些。\n***\n\n### [如何实现数组和List之间的转换 ](https://blog.csdn.net/qq_41097354/article/details/90403953)\n* List转为数组：调用list的**toArray()**方法\n* 数组转为List：调用Arrays的**asList**方法    \n* [List合并](https://www.cnblogs.com/Luouy/p/6482733.html)\n***\n\n### 迭代器Iterator\n* 什么是Iterator\n    * 迭代器是一种设计模式，它是一个对象，它可以**遍历并选择序列中的对象**，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“**轻量级**”对象，因为创建它的代价小。\n* 如何使用？有何特点？\n    * Java中的Iterator功能比较简单，并且**只能单向**\n    * *lk--9移动**：\n    * (1) 使用方法iterator()要求容器返回一个Iterator。**第一次调用Iterator的next()方法时，它返回序列的第一个元素**。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。\n    * (2) **使用next()获得序列中的下一个元素。**\n    * (3) **使用hasNext()检查序列中是否还有元素。**\n    * (4) 使用remove()将迭代器**新返回的元素删除**。　\n* Iterator和ListIterator的区别\n    * Iterator可用来**遍历Set和List集合**，但是**ListIterator只能用来遍历List**\n    * Iterator对集合只能是向前遍历，ListIterator**既可以前向也可以后向。**\n* ListIterator实现了Iterator接口，**并包含其他的功能**，比如：**增加元素**，**替换元素**，**获取前一个和后一个元素的索引**，等等。\n\n````java\n        ArrayList<Student> arrays= new ArrayList<>();\n        arrays.add(new Student(\"wang\",21));\n        arrays.add(new Student(\"li\",22));\n        Iterator<Student> iterator=arrays.iterator();\n        while(iterator.hasNext()){\n            System.out.println(iterator.next());\n        }\n````\n\n    \n### Iterator和Enumeration \n* Iterator除了能读取集合的数据之外，也能数据进行删除操作；而**Enumeration只能读取集合的数据，而不能对数据进行修改**。\n* Iterator是基于Enumeration实现的，同时Iterator支持fail-fast机制，所以**Iterator遍历集合时会比Enumeration遍历集合慢一些**。\n\n***\n\n>参考：https://blog.csdn.net/fangchao2011/article/details/89184615\n\n\n\n\n","source":"_posts/code/JavaSE/JavaSE容器.md","raw":"---\ntitle: JavaSE容器\ncategories: Code\ntags: JavaSE\nphotos: [https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/121212java.jpg]\ndate: 2020-04-30 19:42:10\nabbrlink: 6ea65bec\ndeclare: true\nwordCount: true\n---\n❄\n<!-- more -->\n\n\n> ➱https://www.cnblogs.com/daimasanjiaomao/p/11005764.html➲<br>\n\nJava容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。\n\n### 常用容器目录\n![常用容器目录](https://img-blog.csdnimg.cn/20190317184953342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70)\n***\n\n### Collection和Collections的区别\n* Collection是**集合类的上层接口**，继承他的接口主要有Set和List\n* Collections是针对于集合类的一个**帮助类**，他提供了一系列的静态方法实现对集合的搜索、排序、线程安全化等操作。 \n***\n\n### map的分类和常见的情况 \n* java.util.Map接口主要用于存储键值对，根据键得到值，**因此不允许键重复，但允许值重复**，它有四个实现类：\n    * Hashmap:根据键的hashCode值存储数据，具有很快的访问速度，**遍历时，具有很快的访问速度，但取得的速度是随机的。Hashmap不支持线程的同步**,多个线程同时读取会导致数据的不一致，**若需要同步，可以使用Collections的synchronizedMap()方法使Hashmap具有同步能力或者使用ConcurrentHashMap**.\n        * ConcurrentHashMap分段锁\n        * HashMap允许任何类型的键和值对象，并**允许将null用作键或值**\n    * Hashtable与HashMap类似，不同的是**它不允许记录的键或值为空，它支持线程同步**， 即任何时候只有一个线程能写Hashtable但也因此**导致了hashtable访问较慢**。\n    * LinkedHashMap是Hashmap的一个子类，**保存了记录的插入顺序，用iterator遍历时先得到的记录肯定是先插入的。遍历速度比HashMap慢**，除非HashMap容量很大但实际数据较少。\n    * TreeMap实现的是SortMap接口，**能够把它保存的记录按照键排序**，用iterator遍历的数据是排过序的。\n        * TreeMap的实现底层实现**基于二叉树的红黑树**，插入的值是按一定顺序排序的。\n    >一般情况下，用的最多的是HashMap，用它插入，删除，定位是最好的选择。但如果按照自然顺序或按照自定义顺序，TreeMap更好，如果要输入输出顺序一样，LinkedHashMap更好。\n***\n\n* HashMap的实现原理\n    * HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>\n    HashMap的数据结构： **在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用）**，所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“**链表散列**”的数据结构，即数组和链表的结合体。<br>\n    当我们往Hashmap中put元素时,**首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。**<br>\n    需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)\n***\n\n### HashSet\n* 实现原理\n    * HashSet底层由HashMap实现，HashSet的值存放于HashMap的Key上，HashMap的**value统一为PRESENT**\n* 特性\n    * 它存储**唯一**元素并**允许空值**\n    * 它由HashMap支持\n    * 它**不保持插入顺序**\n    * 它**不是线程安全**的\n* API\n    * add():可用于**将元素添加到一组**。方法声明只有当元素尚未存在于集合中时才会添加元素。如果成功添加了元素，则该方法返回true，否则返回false。\n    * contains():目的是**检查给定HashSet中是否存在元素**。如果找到该元素，则返回true，否则返回false。\n    * remove():如果存在，该方法将从集合中**删除指定的元素**。如果集合包含指定的元素，则此方法返回true。\n    * clear():当我们打算从集合中**删除所有项目时**，我们使用此方法。底层实现只是清除底层HashMap中的所有元素。\n    *  size():这是API中的基本方法之一。它被大量使用，因为它有助于识别HashSet中存在的元素数量。底层实现只是将计算委托给HashMap的size（）方法。\n    *  isEmpty():我们可以使用此方法来确定**HashSet的给定实例是否为空**。如果集合不包含任何元素，则此方法返回true\n    * Iterator():该方法返回Set中元素的**迭代器**。这些元素**没有特定的顺序**访问，Iterator是fail-fast的。\n***\n\n\n### 数组(Array)和列表(ArrayList)的区别\n* **Array可以包含基本类型或者对象类型，Arraylist只能包含对象类型；**\n* Array大小是固定对的，ArrayList不是。\n* 对于基本数据类型，Array使用自动装箱来减少编码工作量，但当处理固定大小的基本上数据类型时这种方式较慢。\n***\n\n### ArrayList、LinkedList和Vector\n* ArrayList和LinkedList最明显的区别是ArrayList的底层数据结构是**数组，支持随机访问，因此插入慢，读取快**。而LinkedList的底层数据结构是**双向循环链表，不支持随机访问,因此写入块，读取慢**，Array的时间复杂度是O(1),LinkedList是O(n);\n    \n    >随机访问只是读取时索引顺序每次有差别，但是可以保证遍历出来的结果顺序是一样的\n* Vector也是数组方式存储数据，和ArrayList一样数组元素数大于实际存储的数据，不同的是**Vector支持线程安全**，所以性能比ArrayList弱一些。\n***\n\n### [如何实现数组和List之间的转换 ](https://blog.csdn.net/qq_41097354/article/details/90403953)\n* List转为数组：调用list的**toArray()**方法\n* 数组转为List：调用Arrays的**asList**方法    \n* [List合并](https://www.cnblogs.com/Luouy/p/6482733.html)\n***\n\n### 迭代器Iterator\n* 什么是Iterator\n    * 迭代器是一种设计模式，它是一个对象，它可以**遍历并选择序列中的对象**，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“**轻量级**”对象，因为创建它的代价小。\n* 如何使用？有何特点？\n    * Java中的Iterator功能比较简单，并且**只能单向**\n    * *lk--9移动**：\n    * (1) 使用方法iterator()要求容器返回一个Iterator。**第一次调用Iterator的next()方法时，它返回序列的第一个元素**。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。\n    * (2) **使用next()获得序列中的下一个元素。**\n    * (3) **使用hasNext()检查序列中是否还有元素。**\n    * (4) 使用remove()将迭代器**新返回的元素删除**。　\n* Iterator和ListIterator的区别\n    * Iterator可用来**遍历Set和List集合**，但是**ListIterator只能用来遍历List**\n    * Iterator对集合只能是向前遍历，ListIterator**既可以前向也可以后向。**\n* ListIterator实现了Iterator接口，**并包含其他的功能**，比如：**增加元素**，**替换元素**，**获取前一个和后一个元素的索引**，等等。\n\n````java\n        ArrayList<Student> arrays= new ArrayList<>();\n        arrays.add(new Student(\"wang\",21));\n        arrays.add(new Student(\"li\",22));\n        Iterator<Student> iterator=arrays.iterator();\n        while(iterator.hasNext()){\n            System.out.println(iterator.next());\n        }\n````\n\n    \n### Iterator和Enumeration \n* Iterator除了能读取集合的数据之外，也能数据进行删除操作；而**Enumeration只能读取集合的数据，而不能对数据进行修改**。\n* Iterator是基于Enumeration实现的，同时Iterator支持fail-fast机制，所以**Iterator遍历集合时会比Enumeration遍历集合慢一些**。\n\n***\n\n>参考：https://blog.csdn.net/fangchao2011/article/details/89184615\n\n\n\n\n","slug":"code/JavaSE/JavaSE容器","published":1,"updated":"2020-05-18T15:05:20.000Z","comments":1,"layout":"post","link":"","_id":"cks5dy1g800430w7tgf1ac9t3","content":"<p>❄</p>\n<a id=\"more\"></a>\n\n\n<blockquote>\n<p>➱<a href=\"https://www.cnblogs.com/daimasanjiaomao/p/11005764.html➲\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/daimasanjiaomao/p/11005764.html➲</a><br></p>\n</blockquote>\n<p>Java容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>\n<h3 id=\"常用容器目录\"><a href=\"#常用容器目录\" class=\"headerlink\" title=\"常用容器目录\"></a>常用容器目录</h3><p><img src=\"https://img-blog.csdnimg.cn/20190317184953342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70\" alt=\"常用容器目录\"></p>\n<hr>\n<h3 id=\"Collection和Collections的区别\"><a href=\"#Collection和Collections的区别\" class=\"headerlink\" title=\"Collection和Collections的区别\"></a>Collection和Collections的区别</h3><ul>\n<li>Collection是<strong>集合类的上层接口</strong>，继承他的接口主要有Set和List</li>\n<li>Collections是针对于集合类的一个<strong>帮助类</strong>，他提供了一系列的静态方法实现对集合的搜索、排序、线程安全化等操作。 </li>\n</ul>\n<hr>\n<h3 id=\"map的分类和常见的情况\"><a href=\"#map的分类和常见的情况\" class=\"headerlink\" title=\"map的分类和常见的情况\"></a>map的分类和常见的情况</h3><ul>\n<li>java.util.Map接口主要用于存储键值对，根据键得到值，<strong>因此不允许键重复，但允许值重复</strong>，它有四个实现类：<ul>\n<li>Hashmap:根据键的hashCode值存储数据，具有很快的访问速度，<strong>遍历时，具有很快的访问速度，但取得的速度是随机的。Hashmap不支持线程的同步</strong>,多个线程同时读取会导致数据的不一致，<strong>若需要同步，可以使用Collections的synchronizedMap()方法使Hashmap具有同步能力或者使用ConcurrentHashMap</strong>.<ul>\n<li>ConcurrentHashMap分段锁</li>\n<li>HashMap允许任何类型的键和值对象，并<strong>允许将null用作键或值</strong></li>\n</ul>\n</li>\n<li>Hashtable与HashMap类似，不同的是<strong>它不允许记录的键或值为空，它支持线程同步</strong>， 即任何时候只有一个线程能写Hashtable但也因此<strong>导致了hashtable访问较慢</strong>。</li>\n<li>LinkedHashMap是Hashmap的一个子类，<strong>保存了记录的插入顺序，用iterator遍历时先得到的记录肯定是先插入的。遍历速度比HashMap慢</strong>，除非HashMap容量很大但实际数据较少。</li>\n<li>TreeMap实现的是SortMap接口，<strong>能够把它保存的记录按照键排序</strong>，用iterator遍历的数据是排过序的。<ul>\n<li>TreeMap的实现底层实现<strong>基于二叉树的红黑树</strong>，插入的值是按一定顺序排序的。<blockquote>\n<p>一般情况下，用的最多的是HashMap，用它插入，删除，定位是最好的选择。但如果按照自然顺序或按照自定义顺序，TreeMap更好，如果要输入输出顺序一样，LinkedHashMap更好。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>HashMap的实现原理<ul>\n<li>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br><br>HashMap的数据结构： <strong>在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用）</strong>，所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“<strong>链表散列</strong>”的数据结构，即数组和链表的结合体。<br><br>当我们往Hashmap中put元素时,<strong>首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</strong><br><br>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h3><ul>\n<li>实现原理<ul>\n<li>HashSet底层由HashMap实现，HashSet的值存放于HashMap的Key上，HashMap的<strong>value统一为PRESENT</strong></li>\n</ul>\n</li>\n<li>特性<ul>\n<li>它存储<strong>唯一</strong>元素并<strong>允许空值</strong></li>\n<li>它由HashMap支持</li>\n<li>它<strong>不保持插入顺序</strong></li>\n<li>它<strong>不是线程安全</strong>的</li>\n</ul>\n</li>\n<li>API<ul>\n<li>add():可用于<strong>将元素添加到一组</strong>。方法声明只有当元素尚未存在于集合中时才会添加元素。如果成功添加了元素，则该方法返回true，否则返回false。</li>\n<li>contains():目的是<strong>检查给定HashSet中是否存在元素</strong>。如果找到该元素，则返回true，否则返回false。</li>\n<li>remove():如果存在，该方法将从集合中<strong>删除指定的元素</strong>。如果集合包含指定的元素，则此方法返回true。</li>\n<li>clear():当我们打算从集合中<strong>删除所有项目时</strong>，我们使用此方法。底层实现只是清除底层HashMap中的所有元素。</li>\n<li>size():这是API中的基本方法之一。它被大量使用，因为它有助于识别HashSet中存在的元素数量。底层实现只是将计算委托给HashMap的size（）方法。</li>\n<li>isEmpty():我们可以使用此方法来确定<strong>HashSet的给定实例是否为空</strong>。如果集合不包含任何元素，则此方法返回true</li>\n<li>Iterator():该方法返回Set中元素的<strong>迭代器</strong>。这些元素<strong>没有特定的顺序</strong>访问，Iterator是fail-fast的。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"数组-Array-和列表-ArrayList-的区别\"><a href=\"#数组-Array-和列表-ArrayList-的区别\" class=\"headerlink\" title=\"数组(Array)和列表(ArrayList)的区别\"></a>数组(Array)和列表(ArrayList)的区别</h3><ul>\n<li><strong>Array可以包含基本类型或者对象类型，Arraylist只能包含对象类型；</strong></li>\n<li>Array大小是固定对的，ArrayList不是。</li>\n<li>对于基本数据类型，Array使用自动装箱来减少编码工作量，但当处理固定大小的基本上数据类型时这种方式较慢。</li>\n</ul>\n<hr>\n<h3 id=\"ArrayList、LinkedList和Vector\"><a href=\"#ArrayList、LinkedList和Vector\" class=\"headerlink\" title=\"ArrayList、LinkedList和Vector\"></a>ArrayList、LinkedList和Vector</h3><ul>\n<li><p>ArrayList和LinkedList最明显的区别是ArrayList的底层数据结构是<strong>数组，支持随机访问，因此插入慢，读取快</strong>。而LinkedList的底层数据结构是<strong>双向循环链表，不支持随机访问,因此写入块，读取慢</strong>，Array的时间复杂度是O(1),LinkedList是O(n);</p>\n<blockquote>\n<p>随机访问只是读取时索引顺序每次有差别，但是可以保证遍历出来的结果顺序是一样的</p>\n</blockquote>\n</li>\n<li><p>Vector也是数组方式存储数据，和ArrayList一样数组元素数大于实际存储的数据，不同的是<strong>Vector支持线程安全</strong>，所以性能比ArrayList弱一些。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"如何实现数组和List之间的转换\"><a href=\"#如何实现数组和List之间的转换\" class=\"headerlink\" title=\"如何实现数组和List之间的转换 \"></a><a href=\"https://blog.csdn.net/qq_41097354/article/details/90403953\" target=\"_blank\" rel=\"noopener\">如何实现数组和List之间的转换 </a></h3><ul>\n<li>List转为数组：调用list的<strong>toArray()</strong>方法</li>\n<li>数组转为List：调用Arrays的<strong>asList</strong>方法    </li>\n<li><a href=\"https://www.cnblogs.com/Luouy/p/6482733.html\" target=\"_blank\" rel=\"noopener\">List合并</a></li>\n</ul>\n<hr>\n<h3 id=\"迭代器Iterator\"><a href=\"#迭代器Iterator\" class=\"headerlink\" title=\"迭代器Iterator\"></a>迭代器Iterator</h3><ul>\n<li>什么是Iterator<ul>\n<li>迭代器是一种设计模式，它是一个对象，它可以<strong>遍历并选择序列中的对象</strong>，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“<strong>轻量级</strong>”对象，因为创建它的代价小。</li>\n</ul>\n</li>\n<li>如何使用？有何特点？<ul>\n<li>Java中的Iterator功能比较简单，并且<strong>只能单向</strong></li>\n<li><em>lk–9移动*</em>：</li>\n<li>(1) 使用方法iterator()要求容器返回一个Iterator。<strong>第一次调用Iterator的next()方法时，它返回序列的第一个元素</strong>。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</li>\n<li>(2) <strong>使用next()获得序列中的下一个元素。</strong></li>\n<li>(3) <strong>使用hasNext()检查序列中是否还有元素。</strong></li>\n<li>(4) 使用remove()将迭代器<strong>新返回的元素删除</strong>。　</li>\n</ul>\n</li>\n<li>Iterator和ListIterator的区别<ul>\n<li>Iterator可用来<strong>遍历Set和List集合</strong>，但是<strong>ListIterator只能用来遍历List</strong></li>\n<li>Iterator对集合只能是向前遍历，ListIterator<strong>既可以前向也可以后向。</strong></li>\n</ul>\n</li>\n<li>ListIterator实现了Iterator接口，<strong>并包含其他的功能</strong>，比如：<strong>增加元素</strong>，<strong>替换元素</strong>，<strong>获取前一个和后一个元素的索引</strong>，等等。</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\">        ArrayList<span class=\"token operator\">&lt;</span>Student<span class=\"token operator\">></span> arrays<span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        arrays<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wang\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">21</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        arrays<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"li\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">22</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Iterator<span class=\"token operator\">&lt;</span>Student<span class=\"token operator\">></span> iterator<span class=\"token operator\">=</span>arrays<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"Iterator和Enumeration\"><a href=\"#Iterator和Enumeration\" class=\"headerlink\" title=\"Iterator和Enumeration\"></a>Iterator和Enumeration</h3><ul>\n<li>Iterator除了能读取集合的数据之外，也能数据进行删除操作；而<strong>Enumeration只能读取集合的数据，而不能对数据进行修改</strong>。</li>\n<li>Iterator是基于Enumeration实现的，同时Iterator支持fail-fast机制，所以<strong>Iterator遍历集合时会比Enumeration遍历集合慢一些</strong>。</li>\n</ul>\n<hr>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/fangchao2011/article/details/89184615\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/fangchao2011/article/details/89184615</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>❄</p>","more":"<blockquote>\n<p>➱<a href=\"https://www.cnblogs.com/daimasanjiaomao/p/11005764.html➲\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/daimasanjiaomao/p/11005764.html➲</a><br></p>\n</blockquote>\n<p>Java容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>\n<h3 id=\"常用容器目录\"><a href=\"#常用容器目录\" class=\"headerlink\" title=\"常用容器目录\"></a>常用容器目录</h3><p><img src=\"https://img-blog.csdnimg.cn/20190317184953342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70\" alt=\"常用容器目录\"></p>\n<hr>\n<h3 id=\"Collection和Collections的区别\"><a href=\"#Collection和Collections的区别\" class=\"headerlink\" title=\"Collection和Collections的区别\"></a>Collection和Collections的区别</h3><ul>\n<li>Collection是<strong>集合类的上层接口</strong>，继承他的接口主要有Set和List</li>\n<li>Collections是针对于集合类的一个<strong>帮助类</strong>，他提供了一系列的静态方法实现对集合的搜索、排序、线程安全化等操作。 </li>\n</ul>\n<hr>\n<h3 id=\"map的分类和常见的情况\"><a href=\"#map的分类和常见的情况\" class=\"headerlink\" title=\"map的分类和常见的情况\"></a>map的分类和常见的情况</h3><ul>\n<li>java.util.Map接口主要用于存储键值对，根据键得到值，<strong>因此不允许键重复，但允许值重复</strong>，它有四个实现类：<ul>\n<li>Hashmap:根据键的hashCode值存储数据，具有很快的访问速度，<strong>遍历时，具有很快的访问速度，但取得的速度是随机的。Hashmap不支持线程的同步</strong>,多个线程同时读取会导致数据的不一致，<strong>若需要同步，可以使用Collections的synchronizedMap()方法使Hashmap具有同步能力或者使用ConcurrentHashMap</strong>.<ul>\n<li>ConcurrentHashMap分段锁</li>\n<li>HashMap允许任何类型的键和值对象，并<strong>允许将null用作键或值</strong></li>\n</ul>\n</li>\n<li>Hashtable与HashMap类似，不同的是<strong>它不允许记录的键或值为空，它支持线程同步</strong>， 即任何时候只有一个线程能写Hashtable但也因此<strong>导致了hashtable访问较慢</strong>。</li>\n<li>LinkedHashMap是Hashmap的一个子类，<strong>保存了记录的插入顺序，用iterator遍历时先得到的记录肯定是先插入的。遍历速度比HashMap慢</strong>，除非HashMap容量很大但实际数据较少。</li>\n<li>TreeMap实现的是SortMap接口，<strong>能够把它保存的记录按照键排序</strong>，用iterator遍历的数据是排过序的。<ul>\n<li>TreeMap的实现底层实现<strong>基于二叉树的红黑树</strong>，插入的值是按一定顺序排序的。<blockquote>\n<p>一般情况下，用的最多的是HashMap，用它插入，删除，定位是最好的选择。但如果按照自然顺序或按照自定义顺序，TreeMap更好，如果要输入输出顺序一样，LinkedHashMap更好。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>HashMap的实现原理<ul>\n<li>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br><br>HashMap的数据结构： <strong>在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用）</strong>，所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“<strong>链表散列</strong>”的数据结构，即数组和链表的结合体。<br><br>当我们往Hashmap中put元素时,<strong>首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</strong><br><br>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h3><ul>\n<li>实现原理<ul>\n<li>HashSet底层由HashMap实现，HashSet的值存放于HashMap的Key上，HashMap的<strong>value统一为PRESENT</strong></li>\n</ul>\n</li>\n<li>特性<ul>\n<li>它存储<strong>唯一</strong>元素并<strong>允许空值</strong></li>\n<li>它由HashMap支持</li>\n<li>它<strong>不保持插入顺序</strong></li>\n<li>它<strong>不是线程安全</strong>的</li>\n</ul>\n</li>\n<li>API<ul>\n<li>add():可用于<strong>将元素添加到一组</strong>。方法声明只有当元素尚未存在于集合中时才会添加元素。如果成功添加了元素，则该方法返回true，否则返回false。</li>\n<li>contains():目的是<strong>检查给定HashSet中是否存在元素</strong>。如果找到该元素，则返回true，否则返回false。</li>\n<li>remove():如果存在，该方法将从集合中<strong>删除指定的元素</strong>。如果集合包含指定的元素，则此方法返回true。</li>\n<li>clear():当我们打算从集合中<strong>删除所有项目时</strong>，我们使用此方法。底层实现只是清除底层HashMap中的所有元素。</li>\n<li>size():这是API中的基本方法之一。它被大量使用，因为它有助于识别HashSet中存在的元素数量。底层实现只是将计算委托给HashMap的size（）方法。</li>\n<li>isEmpty():我们可以使用此方法来确定<strong>HashSet的给定实例是否为空</strong>。如果集合不包含任何元素，则此方法返回true</li>\n<li>Iterator():该方法返回Set中元素的<strong>迭代器</strong>。这些元素<strong>没有特定的顺序</strong>访问，Iterator是fail-fast的。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"数组-Array-和列表-ArrayList-的区别\"><a href=\"#数组-Array-和列表-ArrayList-的区别\" class=\"headerlink\" title=\"数组(Array)和列表(ArrayList)的区别\"></a>数组(Array)和列表(ArrayList)的区别</h3><ul>\n<li><strong>Array可以包含基本类型或者对象类型，Arraylist只能包含对象类型；</strong></li>\n<li>Array大小是固定对的，ArrayList不是。</li>\n<li>对于基本数据类型，Array使用自动装箱来减少编码工作量，但当处理固定大小的基本上数据类型时这种方式较慢。</li>\n</ul>\n<hr>\n<h3 id=\"ArrayList、LinkedList和Vector\"><a href=\"#ArrayList、LinkedList和Vector\" class=\"headerlink\" title=\"ArrayList、LinkedList和Vector\"></a>ArrayList、LinkedList和Vector</h3><ul>\n<li><p>ArrayList和LinkedList最明显的区别是ArrayList的底层数据结构是<strong>数组，支持随机访问，因此插入慢，读取快</strong>。而LinkedList的底层数据结构是<strong>双向循环链表，不支持随机访问,因此写入块，读取慢</strong>，Array的时间复杂度是O(1),LinkedList是O(n);</p>\n<blockquote>\n<p>随机访问只是读取时索引顺序每次有差别，但是可以保证遍历出来的结果顺序是一样的</p>\n</blockquote>\n</li>\n<li><p>Vector也是数组方式存储数据，和ArrayList一样数组元素数大于实际存储的数据，不同的是<strong>Vector支持线程安全</strong>，所以性能比ArrayList弱一些。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"如何实现数组和List之间的转换\"><a href=\"#如何实现数组和List之间的转换\" class=\"headerlink\" title=\"如何实现数组和List之间的转换 \"></a><a href=\"https://blog.csdn.net/qq_41097354/article/details/90403953\" target=\"_blank\" rel=\"noopener\">如何实现数组和List之间的转换 </a></h3><ul>\n<li>List转为数组：调用list的<strong>toArray()</strong>方法</li>\n<li>数组转为List：调用Arrays的<strong>asList</strong>方法    </li>\n<li><a href=\"https://www.cnblogs.com/Luouy/p/6482733.html\" target=\"_blank\" rel=\"noopener\">List合并</a></li>\n</ul>\n<hr>\n<h3 id=\"迭代器Iterator\"><a href=\"#迭代器Iterator\" class=\"headerlink\" title=\"迭代器Iterator\"></a>迭代器Iterator</h3><ul>\n<li>什么是Iterator<ul>\n<li>迭代器是一种设计模式，它是一个对象，它可以<strong>遍历并选择序列中的对象</strong>，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“<strong>轻量级</strong>”对象，因为创建它的代价小。</li>\n</ul>\n</li>\n<li>如何使用？有何特点？<ul>\n<li>Java中的Iterator功能比较简单，并且<strong>只能单向</strong></li>\n<li><em>lk–9移动*</em>：</li>\n<li>(1) 使用方法iterator()要求容器返回一个Iterator。<strong>第一次调用Iterator的next()方法时，它返回序列的第一个元素</strong>。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</li>\n<li>(2) <strong>使用next()获得序列中的下一个元素。</strong></li>\n<li>(3) <strong>使用hasNext()检查序列中是否还有元素。</strong></li>\n<li>(4) 使用remove()将迭代器<strong>新返回的元素删除</strong>。　</li>\n</ul>\n</li>\n<li>Iterator和ListIterator的区别<ul>\n<li>Iterator可用来<strong>遍历Set和List集合</strong>，但是<strong>ListIterator只能用来遍历List</strong></li>\n<li>Iterator对集合只能是向前遍历，ListIterator<strong>既可以前向也可以后向。</strong></li>\n</ul>\n</li>\n<li>ListIterator实现了Iterator接口，<strong>并包含其他的功能</strong>，比如：<strong>增加元素</strong>，<strong>替换元素</strong>，<strong>获取前一个和后一个元素的索引</strong>，等等。</li>\n</ul>\n<pre><code class=\"java\">        ArrayList&lt;Student&gt; arrays= new ArrayList&lt;&gt;();\n        arrays.add(new Student(&quot;wang&quot;,21));\n        arrays.add(new Student(&quot;li&quot;,22));\n        Iterator&lt;Student&gt; iterator=arrays.iterator();\n        while(iterator.hasNext()){\n            System.out.println(iterator.next());\n        }</code></pre>\n<h3 id=\"Iterator和Enumeration\"><a href=\"#Iterator和Enumeration\" class=\"headerlink\" title=\"Iterator和Enumeration\"></a>Iterator和Enumeration</h3><ul>\n<li>Iterator除了能读取集合的数据之外，也能数据进行删除操作；而<strong>Enumeration只能读取集合的数据，而不能对数据进行修改</strong>。</li>\n<li>Iterator是基于Enumeration实现的，同时Iterator支持fail-fast机制，所以<strong>Iterator遍历集合时会比Enumeration遍历集合慢一些</strong>。</li>\n</ul>\n<hr>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/fangchao2011/article/details/89184615\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/fangchao2011/article/details/89184615</a></p>\n</blockquote>"},{"title":"JavaSE基础","photos":["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/121212java.jpg"],"abbrlink":"dc174266","date":"2020-04-29T11:38:10.000Z","declare":true,"wordCount":true,"_content":"❄\n<!-- more -->\n\n### JDK和JRE的区别\n\n* JDK:Java开发工具包，提供了Java的**开发环境**和**运行环境**\n* JRE:Java运行环境，提供Java的**运行环境**\n* **JDK包含了JRE,还包含了java源码的编译器javac，以及很多java程序调试分析的工具**，如果只需要运行程序，JRE即可，如果还需要写程序则需要JDK <br>\n***\n\n### Java8新特性\n\n* Date Time API :加强对日期和时间的处理\n* Optional类：用来处理空指针的问题\n* Lambda表达式\n* 优化HashMap,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)\n\n***\n\n### Java的多态\n\n* 多态：一种事物的多种存在形态，比如说男人和女人都是人，人可以分为男人和女人\n* 好处：消除了类之间的**耦合关系**，大大提高了程序的**简洁性**和**可拓展性**\n* 重写Overriding和重载Overloading\n    * 重载：以类统一的方式处理不同数据的一种手段，实质就是**多个具有不同参数个数或者类型的同名函数，且返回类型可随意。**（*动态绑定*）\n    * 重写：父类与子类之间的多态性，**实质就是子类对父类的函数进行重写定义**。子类的访问权限不能小于父类的访问权限。（否则调用的时候可能无法调用）（*静态绑定*）\n        * 重写方法**参数列表、返回类型**必须与被重写的方法相同。\n* 子类对象的多态性\n    * 是**使用父类的引用，指向子类的对象**，然后虚拟方法调用子类重写父类的方法\n\n***\n\n### 数据类型 自动拆装箱\n\n* 8种，**int long short char float double byte boolean**\n* **自动装箱是Java编译器在基本数据类型和对于对象包装类型中做的一个转化**。比如int类型转化为Integer,double类型转为Double等，反之及时自动拆箱。\n\n***\n\n### Java中IO流分为几种\n\n* 按照功能：**输入流**、**输出流**\n* 按照类型:\n    * **字节流**：按**8位传输以字节为单位**输出输出数据\n    * **字符流**：按照**16位传输以字符为单位**输出输入数据\n\n***\n\n### 值传递和引用传递\n\n* 值传递对于基本类型而言的，传递的是该变量的一个副本，改变副本不影响原变量\n* 引用传递对于对象类型而言的，传递的是该对象地址的一个副本，并不是原对象本身，所以对引用对象操作会改变原对象。\n* 一个对象被当做参数传递给一个方法后，此方法可改变它的属性，并返回变化后的结果，那么这里是什么传递？\n    * 值传递。**Java没有引用传递**，方法的参数的值是对象引用（传入的变量）的一个副本，但指向同一个对象，所以在方法中改变对象也会改变原变量的值，因为他的引用的对象改变了。\n\n***\n\n### &和&&的区别\n\n* &：按位于，**两边都要判断**\n\n* &&：短路与，**左边的为true才会判断右边**\n\n* 经常使用短路与，比如用户登陆时判定用户名不是null且不是空字符串时就只能用&&\n    ````java\n    username!=null&&username.equals(\"\")\n    ````\n\n***\n\n### String、StringBuffer和StringBuilder\n\n* 都是可以储存和操作字符串\n* **String是final类型**，每次声明的都是不可变更的对象，然后将指针指向新的String对象\n* StringBuffer，StringBuilder是可变字符继承自AbstractStringBuilder，在原有对象上进行操作\n* **StringBuffer是线程安全的，StringBuilder不是线程安全的**，但性能更高\n* 使用场景：\n    * **并发**必选StringBuffer\n    * **迭代**必选StringBuilder\n    * 普通场景使用String，避免不必要的类型转换开销\n\n***\n\n* Object若不重写hashCode()的话，hashCode()如何计算出来的？\n    * Object的hashCode()方法是一个本地方法，**该方法是直接返回对象的内存地址**\n\n***\n\n### equals和hashcode\n\n* 如果两个对象的引用相同，他们之前互相调用equals()为true即两个对象相同。如果不重写hashCode（）方法，系统默认的hashCode()是本地计算对象的内存地址（经哈希算法），此时不会相同。就会产生矛盾。\n> 两个对象equals相等，则它们的hashcode必须相等，反之则不一定。<br>\n>两个对象=相等，则其hashcode一定相等，反之亦然。<br>\n>两个对象==相等，则其hashcode一定相等，反之不一定成立。 //有可能是Integer对象比较之类的<br>\n>两个对象==相等，则其hashcode一定相等，反之不一定成立。<br>\n\n***\n\n### ==和equals的区别\n\n* ==\n    * **基本类型：比较值是否相同**\n    * **引用类型：比较的引用是否相同**\n* **equals默认情况下是引用比较**，只是**很多类重载了equals()方法 (也可自定义)** ，**比如String、Integer等将它变为值比较**\n\n***\n\n### final和static\n\n* final\n    * final可以修饰属性，**方法，类，局部变量**（静态变量、实例变量和局部变量）；\n    * final修饰的方法**不能被子类重写**，但**可以被继承**；\n    * final修饰的类**不能被继承**，没有子类，**final类中的方法默认是final的**\n    * final**不能**用于修饰构造方法；\n    * 对于基本类型数据，**final会将值变为一个常数（创建后不能被修改）**\n* staic\n    * static表示“全局”或者“静态”的意思，可以用来修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类），static**不可以修饰局部变量**\n    * static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变，并且每个对象都只有一个值，主要强调它们只有一个。\n    * static修饰的属性、方法、代码段跟该类的**具体对象无关**，不创建对象也能调用static修饰的属性、方法等，\n    * static和“this、super”势不两立，因为this、super正好跟具体对象有关。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。\n    * 用public修饰的static属性和方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。\n\n* static final(等价于final staic)\n    * static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。static final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用\n\n***\n\n### 静态代码块与普通代码块的区别\n\n* ````java\n    public class HelloB extends HelloA \n    {\n        public HelloB(){\n        }\n\n        {\n            System.out.println(\"I’m B class\");\n        }\n\n        static{\n            System.out.println(\"static B\");\n        }\n\n        public static void main(String[] args){\n            new HelloB();\n        }\n    }\n    class HelloA\n    {\n        public HelloA(){\n        }\n\n        {\n            System.out.println(\"I’m A class\");\n        }\n  \n        static{\n            System.out.println(\"static A\");\n        }\n    }\n\n    //输出结果\n    static A\n    static B\n    I’m A class\n    I’m B class\n    ````\n    * 执行顺序：\n        1. 父类静态代码块\n        2. 子类静态代码块\n        3. 父类普通代码块\n        4. 父类构造方法\n        5. 子类普通代码块\n        6. 子类构造方法\n\n    * 相同点\n        * 都是在JVM加载类时且**在构造方法执行之前执行**，在类中都可以定义多个，一般在代码块中对一些static变量进行赋值。\n    * 不同点\n        * 静态代码块在非静态代码块之前执行(**静态代码块—>非静态代码块—>构造方法**)。**静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次**。非静态代码块可在普通方法中定义(不过作用不大)；而**静态**代码块不行。\n\n***\n\n### 接口和抽象类有什么区别\n\n* 实现：抽象类的子类使用 **extends** 来继承；接口必须使用 **implements** 来实现接口。\n* 构造函数：抽象类可以有构造函数；**接口不能有**。\n* main 方法：抽象类可以有 main 方法，并且我们能运行它；**接口不能有 main 方法**。\n* 实现数量：**类可以实现很多个接口**；但是**只能继承一个抽象类**。\n* 访问**修饰符**：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n***\n\n### String a=\"i\" 和String b=new String(\"i\")的区别\n\n* 前者，Java虚拟机将其分配到**常量池**中,并把\"i\"的内存地址赋给a,如果还有一个String a1=\"i\",也把\"i\"的内存地址赋给a1，即**a和a1这两个引用的是同一个地址，共享一个内存。**\n* 后者，则会被分配到**堆内存**中，即新创建了一个对象，如果还有一个String b1=new String(\"i\")，相当于又创建了一个对象，然后将其地址赋给b1，**虽然b和b1值相同，但是并不是一个对象。**\n\n***\n\n### String类的常用方法有哪些\n\n* `indexof()`   ：放回指定字符索引\n* `charAt()`    ：返回指定索引处字符\n* `replace()`   ：字符串替换\n* `trim()`      :去除字符串两端空白\n* `spilt()`     ：分割字符串，返回一个分割后的字符串数组\n* `getBytes()`  ：返回字符串的 byte 类型数组。ASCII码\n* `length()`    ：返回字符串长度。\n* `toLowerCase()`：将字符串转成小写字母。\n* `toUpperCase()`：将字符串转成大写字符。\n* substring()   ：截取字符串。\n* equals()      ：字符串比较。\n\n***\n\n### Files的常用方法\n\n* `Files.exists()`      ：    检测文件路径是否存在。\n* `Files.createFile()`  ：创建文件。\n* `Files.createDirectory()`：创建文件夹。\n* `Files.delete()`      ：删除一个文件或目录。\n* `Files.copy()`        ：复制文件。\n* `Files.move()`        ：移动文件。\n* `Files.size()`        ：查看文件个数。\n* `Files.read()`        ：读取文件。\n* `Files.write()`       ：写入文件。\n\n***\n\n### java创建对象的方法\n\n1. 用new语句创建对象，是最常见的创建对象的方法。\n2. 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。\n3. 调用对象的clone()方法。\n4. 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。\n\n***\n\n### assert\n\n* 断言。是在软件开发过程中的一种调试方法。它对一个boolean表达式进行检验。一个正确的程序必须保证这个表达式正确，如果不正确系统则会给出警告或者退出。一般来说，**asset用于保证程序最基本，最关键代码的正确性**。软件发布后，通常assert检查通常是关闭的。\n* \n\n***\n\n###  抽象类\n\n* 抽象类不一定要有抽象方法\n* 抽象类不能使用final,因为被final标记的类不能被继承，但抽象类就是为了让其子类继承的\n* 抽象类和普通类的区别\n    * **抽象类不能实例化**，普通类可以    绝不会拿3e\n    * **普通类不能含有抽象方法**，抽象类可以有抽象方法\n***\n\n### lambda 表达式 \n    * 示例：\n        ```java\n        // 1. 不需要参数,返回值为 5  \n        () -> 5  \n        \n        // 2. 接收一个参数(数字类型),返回其2倍的值  \n        x -> 2 * x  \n        \n        // 3. 接受2个参数(数字),并返回他们的差值  \n        (x, y) -> x – y  \n        \n        // 4. 接收2个int型整数,返回他们的和  \n        (int x, int y) -> x + y  \n        \n        // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  \n        (String s) -> System.out.print(s)\n        ```\n***\n\n\n>参考：https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA","source":"_posts/code/JavaSE/JavaSE基础.md","raw":"---\ntitle: JavaSE基础\ncategories: Code\ntags: JavaSE\nphotos: [https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/121212java.jpg]\nabbrlink: dc174266\ndate: 2020-04-29 19:38:10\ndeclare: true\nwordCount: true\n---\n❄\n<!-- more -->\n\n### JDK和JRE的区别\n\n* JDK:Java开发工具包，提供了Java的**开发环境**和**运行环境**\n* JRE:Java运行环境，提供Java的**运行环境**\n* **JDK包含了JRE,还包含了java源码的编译器javac，以及很多java程序调试分析的工具**，如果只需要运行程序，JRE即可，如果还需要写程序则需要JDK <br>\n***\n\n### Java8新特性\n\n* Date Time API :加强对日期和时间的处理\n* Optional类：用来处理空指针的问题\n* Lambda表达式\n* 优化HashMap,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)\n\n***\n\n### Java的多态\n\n* 多态：一种事物的多种存在形态，比如说男人和女人都是人，人可以分为男人和女人\n* 好处：消除了类之间的**耦合关系**，大大提高了程序的**简洁性**和**可拓展性**\n* 重写Overriding和重载Overloading\n    * 重载：以类统一的方式处理不同数据的一种手段，实质就是**多个具有不同参数个数或者类型的同名函数，且返回类型可随意。**（*动态绑定*）\n    * 重写：父类与子类之间的多态性，**实质就是子类对父类的函数进行重写定义**。子类的访问权限不能小于父类的访问权限。（否则调用的时候可能无法调用）（*静态绑定*）\n        * 重写方法**参数列表、返回类型**必须与被重写的方法相同。\n* 子类对象的多态性\n    * 是**使用父类的引用，指向子类的对象**，然后虚拟方法调用子类重写父类的方法\n\n***\n\n### 数据类型 自动拆装箱\n\n* 8种，**int long short char float double byte boolean**\n* **自动装箱是Java编译器在基本数据类型和对于对象包装类型中做的一个转化**。比如int类型转化为Integer,double类型转为Double等，反之及时自动拆箱。\n\n***\n\n### Java中IO流分为几种\n\n* 按照功能：**输入流**、**输出流**\n* 按照类型:\n    * **字节流**：按**8位传输以字节为单位**输出输出数据\n    * **字符流**：按照**16位传输以字符为单位**输出输入数据\n\n***\n\n### 值传递和引用传递\n\n* 值传递对于基本类型而言的，传递的是该变量的一个副本，改变副本不影响原变量\n* 引用传递对于对象类型而言的，传递的是该对象地址的一个副本，并不是原对象本身，所以对引用对象操作会改变原对象。\n* 一个对象被当做参数传递给一个方法后，此方法可改变它的属性，并返回变化后的结果，那么这里是什么传递？\n    * 值传递。**Java没有引用传递**，方法的参数的值是对象引用（传入的变量）的一个副本，但指向同一个对象，所以在方法中改变对象也会改变原变量的值，因为他的引用的对象改变了。\n\n***\n\n### &和&&的区别\n\n* &：按位于，**两边都要判断**\n\n* &&：短路与，**左边的为true才会判断右边**\n\n* 经常使用短路与，比如用户登陆时判定用户名不是null且不是空字符串时就只能用&&\n    ````java\n    username!=null&&username.equals(\"\")\n    ````\n\n***\n\n### String、StringBuffer和StringBuilder\n\n* 都是可以储存和操作字符串\n* **String是final类型**，每次声明的都是不可变更的对象，然后将指针指向新的String对象\n* StringBuffer，StringBuilder是可变字符继承自AbstractStringBuilder，在原有对象上进行操作\n* **StringBuffer是线程安全的，StringBuilder不是线程安全的**，但性能更高\n* 使用场景：\n    * **并发**必选StringBuffer\n    * **迭代**必选StringBuilder\n    * 普通场景使用String，避免不必要的类型转换开销\n\n***\n\n* Object若不重写hashCode()的话，hashCode()如何计算出来的？\n    * Object的hashCode()方法是一个本地方法，**该方法是直接返回对象的内存地址**\n\n***\n\n### equals和hashcode\n\n* 如果两个对象的引用相同，他们之前互相调用equals()为true即两个对象相同。如果不重写hashCode（）方法，系统默认的hashCode()是本地计算对象的内存地址（经哈希算法），此时不会相同。就会产生矛盾。\n> 两个对象equals相等，则它们的hashcode必须相等，反之则不一定。<br>\n>两个对象=相等，则其hashcode一定相等，反之亦然。<br>\n>两个对象==相等，则其hashcode一定相等，反之不一定成立。 //有可能是Integer对象比较之类的<br>\n>两个对象==相等，则其hashcode一定相等，反之不一定成立。<br>\n\n***\n\n### ==和equals的区别\n\n* ==\n    * **基本类型：比较值是否相同**\n    * **引用类型：比较的引用是否相同**\n* **equals默认情况下是引用比较**，只是**很多类重载了equals()方法 (也可自定义)** ，**比如String、Integer等将它变为值比较**\n\n***\n\n### final和static\n\n* final\n    * final可以修饰属性，**方法，类，局部变量**（静态变量、实例变量和局部变量）；\n    * final修饰的方法**不能被子类重写**，但**可以被继承**；\n    * final修饰的类**不能被继承**，没有子类，**final类中的方法默认是final的**\n    * final**不能**用于修饰构造方法；\n    * 对于基本类型数据，**final会将值变为一个常数（创建后不能被修改）**\n* staic\n    * static表示“全局”或者“静态”的意思，可以用来修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类），static**不可以修饰局部变量**\n    * static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变，并且每个对象都只有一个值，主要强调它们只有一个。\n    * static修饰的属性、方法、代码段跟该类的**具体对象无关**，不创建对象也能调用static修饰的属性、方法等，\n    * static和“this、super”势不两立，因为this、super正好跟具体对象有关。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。\n    * 用public修饰的static属性和方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。\n\n* static final(等价于final staic)\n    * static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。static final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用\n\n***\n\n### 静态代码块与普通代码块的区别\n\n* ````java\n    public class HelloB extends HelloA \n    {\n        public HelloB(){\n        }\n\n        {\n            System.out.println(\"I’m B class\");\n        }\n\n        static{\n            System.out.println(\"static B\");\n        }\n\n        public static void main(String[] args){\n            new HelloB();\n        }\n    }\n    class HelloA\n    {\n        public HelloA(){\n        }\n\n        {\n            System.out.println(\"I’m A class\");\n        }\n  \n        static{\n            System.out.println(\"static A\");\n        }\n    }\n\n    //输出结果\n    static A\n    static B\n    I’m A class\n    I’m B class\n    ````\n    * 执行顺序：\n        1. 父类静态代码块\n        2. 子类静态代码块\n        3. 父类普通代码块\n        4. 父类构造方法\n        5. 子类普通代码块\n        6. 子类构造方法\n\n    * 相同点\n        * 都是在JVM加载类时且**在构造方法执行之前执行**，在类中都可以定义多个，一般在代码块中对一些static变量进行赋值。\n    * 不同点\n        * 静态代码块在非静态代码块之前执行(**静态代码块—>非静态代码块—>构造方法**)。**静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次**。非静态代码块可在普通方法中定义(不过作用不大)；而**静态**代码块不行。\n\n***\n\n### 接口和抽象类有什么区别\n\n* 实现：抽象类的子类使用 **extends** 来继承；接口必须使用 **implements** 来实现接口。\n* 构造函数：抽象类可以有构造函数；**接口不能有**。\n* main 方法：抽象类可以有 main 方法，并且我们能运行它；**接口不能有 main 方法**。\n* 实现数量：**类可以实现很多个接口**；但是**只能继承一个抽象类**。\n* 访问**修饰符**：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n***\n\n### String a=\"i\" 和String b=new String(\"i\")的区别\n\n* 前者，Java虚拟机将其分配到**常量池**中,并把\"i\"的内存地址赋给a,如果还有一个String a1=\"i\",也把\"i\"的内存地址赋给a1，即**a和a1这两个引用的是同一个地址，共享一个内存。**\n* 后者，则会被分配到**堆内存**中，即新创建了一个对象，如果还有一个String b1=new String(\"i\")，相当于又创建了一个对象，然后将其地址赋给b1，**虽然b和b1值相同，但是并不是一个对象。**\n\n***\n\n### String类的常用方法有哪些\n\n* `indexof()`   ：放回指定字符索引\n* `charAt()`    ：返回指定索引处字符\n* `replace()`   ：字符串替换\n* `trim()`      :去除字符串两端空白\n* `spilt()`     ：分割字符串，返回一个分割后的字符串数组\n* `getBytes()`  ：返回字符串的 byte 类型数组。ASCII码\n* `length()`    ：返回字符串长度。\n* `toLowerCase()`：将字符串转成小写字母。\n* `toUpperCase()`：将字符串转成大写字符。\n* substring()   ：截取字符串。\n* equals()      ：字符串比较。\n\n***\n\n### Files的常用方法\n\n* `Files.exists()`      ：    检测文件路径是否存在。\n* `Files.createFile()`  ：创建文件。\n* `Files.createDirectory()`：创建文件夹。\n* `Files.delete()`      ：删除一个文件或目录。\n* `Files.copy()`        ：复制文件。\n* `Files.move()`        ：移动文件。\n* `Files.size()`        ：查看文件个数。\n* `Files.read()`        ：读取文件。\n* `Files.write()`       ：写入文件。\n\n***\n\n### java创建对象的方法\n\n1. 用new语句创建对象，是最常见的创建对象的方法。\n2. 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。\n3. 调用对象的clone()方法。\n4. 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。\n\n***\n\n### assert\n\n* 断言。是在软件开发过程中的一种调试方法。它对一个boolean表达式进行检验。一个正确的程序必须保证这个表达式正确，如果不正确系统则会给出警告或者退出。一般来说，**asset用于保证程序最基本，最关键代码的正确性**。软件发布后，通常assert检查通常是关闭的。\n* \n\n***\n\n###  抽象类\n\n* 抽象类不一定要有抽象方法\n* 抽象类不能使用final,因为被final标记的类不能被继承，但抽象类就是为了让其子类继承的\n* 抽象类和普通类的区别\n    * **抽象类不能实例化**，普通类可以    绝不会拿3e\n    * **普通类不能含有抽象方法**，抽象类可以有抽象方法\n***\n\n### lambda 表达式 \n    * 示例：\n        ```java\n        // 1. 不需要参数,返回值为 5  \n        () -> 5  \n        \n        // 2. 接收一个参数(数字类型),返回其2倍的值  \n        x -> 2 * x  \n        \n        // 3. 接受2个参数(数字),并返回他们的差值  \n        (x, y) -> x – y  \n        \n        // 4. 接收2个int型整数,返回他们的和  \n        (int x, int y) -> x + y  \n        \n        // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  \n        (String s) -> System.out.print(s)\n        ```\n***\n\n\n>参考：https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA","slug":"code/JavaSE/JavaSE基础","published":1,"updated":"2020-07-06T23:43:54.000Z","comments":1,"layout":"post","link":"","_id":"cks5dy1g900460w7td20t3ace","content":"<p>❄</p>\n<a id=\"more\"></a>\n\n<h3 id=\"JDK和JRE的区别\"><a href=\"#JDK和JRE的区别\" class=\"headerlink\" title=\"JDK和JRE的区别\"></a>JDK和JRE的区别</h3><ul>\n<li>JDK:Java开发工具包，提供了Java的<strong>开发环境</strong>和<strong>运行环境</strong></li>\n<li>JRE:Java运行环境，提供Java的<strong>运行环境</strong></li>\n<li><strong>JDK包含了JRE,还包含了java源码的编译器javac，以及很多java程序调试分析的工具</strong>，如果只需要运行程序，JRE即可，如果还需要写程序则需要JDK <br></li>\n</ul>\n<hr>\n<h3 id=\"Java8新特性\"><a href=\"#Java8新特性\" class=\"headerlink\" title=\"Java8新特性\"></a>Java8新特性</h3><ul>\n<li>Date Time API :加强对日期和时间的处理</li>\n<li>Optional类：用来处理空指针的问题</li>\n<li>Lambda表达式</li>\n<li>优化HashMap,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</li>\n</ul>\n<hr>\n<h3 id=\"Java的多态\"><a href=\"#Java的多态\" class=\"headerlink\" title=\"Java的多态\"></a>Java的多态</h3><ul>\n<li>多态：一种事物的多种存在形态，比如说男人和女人都是人，人可以分为男人和女人</li>\n<li>好处：消除了类之间的<strong>耦合关系</strong>，大大提高了程序的<strong>简洁性</strong>和<strong>可拓展性</strong></li>\n<li>重写Overriding和重载Overloading<ul>\n<li>重载：以类统一的方式处理不同数据的一种手段，实质就是<strong>多个具有不同参数个数或者类型的同名函数，且返回类型可随意。</strong>（<em>动态绑定</em>）</li>\n<li>重写：父类与子类之间的多态性，<strong>实质就是子类对父类的函数进行重写定义</strong>。子类的访问权限不能小于父类的访问权限。（否则调用的时候可能无法调用）（<em>静态绑定</em>）<ul>\n<li>重写方法<strong>参数列表、返回类型</strong>必须与被重写的方法相同。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>子类对象的多态性<ul>\n<li>是<strong>使用父类的引用，指向子类的对象</strong>，然后虚拟方法调用子类重写父类的方法</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"数据类型-自动拆装箱\"><a href=\"#数据类型-自动拆装箱\" class=\"headerlink\" title=\"数据类型 自动拆装箱\"></a>数据类型 自动拆装箱</h3><ul>\n<li>8种，<strong>int long short char float double byte boolean</strong></li>\n<li><strong>自动装箱是Java编译器在基本数据类型和对于对象包装类型中做的一个转化</strong>。比如int类型转化为Integer,double类型转为Double等，反之及时自动拆箱。</li>\n</ul>\n<hr>\n<h3 id=\"Java中IO流分为几种\"><a href=\"#Java中IO流分为几种\" class=\"headerlink\" title=\"Java中IO流分为几种\"></a>Java中IO流分为几种</h3><ul>\n<li>按照功能：<strong>输入流</strong>、<strong>输出流</strong></li>\n<li>按照类型:<ul>\n<li><strong>字节流</strong>：按<strong>8位传输以字节为单位</strong>输出输出数据</li>\n<li><strong>字符流</strong>：按照<strong>16位传输以字符为单位</strong>输出输入数据</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"值传递和引用传递\"><a href=\"#值传递和引用传递\" class=\"headerlink\" title=\"值传递和引用传递\"></a>值传递和引用传递</h3><ul>\n<li>值传递对于基本类型而言的，传递的是该变量的一个副本，改变副本不影响原变量</li>\n<li>引用传递对于对象类型而言的，传递的是该对象地址的一个副本，并不是原对象本身，所以对引用对象操作会改变原对象。</li>\n<li>一个对象被当做参数传递给一个方法后，此方法可改变它的属性，并返回变化后的结果，那么这里是什么传递？<ul>\n<li>值传递。<strong>Java没有引用传递</strong>，方法的参数的值是对象引用（传入的变量）的一个副本，但指向同一个对象，所以在方法中改变对象也会改变原变量的值，因为他的引用的对象改变了。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"amp-和-amp-amp-的区别\"><a href=\"#amp-和-amp-amp-的区别\" class=\"headerlink\" title=\"&amp;和&amp;&amp;的区别\"></a>&amp;和&amp;&amp;的区别</h3><ul>\n<li><p>&amp;：按位于，<strong>两边都要判断</strong></p>\n</li>\n<li><p>&amp;&amp;：短路与，<strong>左边的为true才会判断右边</strong></p>\n</li>\n<li><p>经常使用短路与，比如用户登陆时判定用户名不是null且不是空字符串时就只能用&amp;&amp;</p>\n<pre class=\" language-java\"><code class=\"language-java\">  username<span class=\"token operator\">!=</span>null<span class=\"token operator\">&amp;&amp;</span>username<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n</ul>\n<hr>\n<h3 id=\"String、StringBuffer和StringBuilder\"><a href=\"#String、StringBuffer和StringBuilder\" class=\"headerlink\" title=\"String、StringBuffer和StringBuilder\"></a>String、StringBuffer和StringBuilder</h3><ul>\n<li>都是可以储存和操作字符串</li>\n<li><strong>String是final类型</strong>，每次声明的都是不可变更的对象，然后将指针指向新的String对象</li>\n<li>StringBuffer，StringBuilder是可变字符继承自AbstractStringBuilder，在原有对象上进行操作</li>\n<li><strong>StringBuffer是线程安全的，StringBuilder不是线程安全的</strong>，但性能更高</li>\n<li>使用场景：<ul>\n<li><strong>并发</strong>必选StringBuffer</li>\n<li><strong>迭代</strong>必选StringBuilder</li>\n<li>普通场景使用String，避免不必要的类型转换开销</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>Object若不重写hashCode()的话，hashCode()如何计算出来的？<ul>\n<li>Object的hashCode()方法是一个本地方法，<strong>该方法是直接返回对象的内存地址</strong></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"equals和hashcode\"><a href=\"#equals和hashcode\" class=\"headerlink\" title=\"equals和hashcode\"></a>equals和hashcode</h3><ul>\n<li>如果两个对象的引用相同，他们之前互相调用equals()为true即两个对象相同。如果不重写hashCode（）方法，系统默认的hashCode()是本地计算对象的内存地址（经哈希算法），此时不会相同。就会产生矛盾。<blockquote>\n<p>两个对象equals相等，则它们的hashcode必须相等，反之则不一定。<br><br>两个对象=相等，则其hashcode一定相等，反之亦然。<br><br>两个对象==相等，则其hashcode一定相等，反之不一定成立。 //有可能是Integer对象比较之类的<br><br>两个对象==相等，则其hashcode一定相等，反之不一定成立。<br></p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h3 id=\"和equals的区别\"><a href=\"#和equals的区别\" class=\"headerlink\" title=\"==和equals的区别\"></a>==和equals的区别</h3><ul>\n<li>==<ul>\n<li><strong>基本类型：比较值是否相同</strong></li>\n<li><strong>引用类型：比较的引用是否相同</strong></li>\n</ul>\n</li>\n<li><strong>equals默认情况下是引用比较</strong>，只是<strong>很多类重载了equals()方法 (也可自定义)</strong> ，<strong>比如String、Integer等将它变为值比较</strong></li>\n</ul>\n<hr>\n<h3 id=\"final和static\"><a href=\"#final和static\" class=\"headerlink\" title=\"final和static\"></a>final和static</h3><ul>\n<li><p>final</p>\n<ul>\n<li>final可以修饰属性，<strong>方法，类，局部变量</strong>（静态变量、实例变量和局部变量）；</li>\n<li>final修饰的方法<strong>不能被子类重写</strong>，但<strong>可以被继承</strong>；</li>\n<li>final修饰的类<strong>不能被继承</strong>，没有子类，<strong>final类中的方法默认是final的</strong></li>\n<li>final<strong>不能</strong>用于修饰构造方法；</li>\n<li>对于基本类型数据，<strong>final会将值变为一个常数（创建后不能被修改）</strong></li>\n</ul>\n</li>\n<li><p>staic</p>\n<ul>\n<li>static表示“全局”或者“静态”的意思，可以用来修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类），static<strong>不可以修饰局部变量</strong></li>\n<li>static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变，并且每个对象都只有一个值，主要强调它们只有一个。</li>\n<li>static修饰的属性、方法、代码段跟该类的<strong>具体对象无关</strong>，不创建对象也能调用static修饰的属性、方法等，</li>\n<li>static和“this、super”势不两立，因为this、super正好跟具体对象有关。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</li>\n<li>用public修饰的static属性和方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。</li>\n</ul>\n</li>\n<li><p>static final(等价于final staic)</p>\n<ul>\n<li>static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。static final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"静态代码块与普通代码块的区别\"><a href=\"#静态代码块与普通代码块的区别\" class=\"headerlink\" title=\"静态代码块与普通代码块的区别\"></a>静态代码块与普通代码块的区别</h3><ul>\n<li><pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloB</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HelloA</span> \n  <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">public</span> <span class=\"token function\">HelloB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token punctuation\">{</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I’m B class\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">static</span><span class=\"token punctuation\">{</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"static B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">new</span> <span class=\"token class-name\">HelloB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloA</span>\n  <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">public</span> <span class=\"token function\">HelloA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token punctuation\">{</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I’m A class\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">static</span><span class=\"token punctuation\">{</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"static A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">//输出结果</span>\n  <span class=\"token keyword\">static</span> A\n  <span class=\"token keyword\">static</span> B\n  I’m A <span class=\"token keyword\">class</span>\n  <span class=\"token class-name\">I</span>’m B <span class=\"token keyword\">class</span></code></pre>\n<ul>\n<li><p>执行顺序：</p>\n<ol>\n<li>父类静态代码块</li>\n<li>子类静态代码块</li>\n<li>父类普通代码块</li>\n<li>父类构造方法</li>\n<li>子类普通代码块</li>\n<li>子类构造方法</li>\n</ol>\n</li>\n<li><p>相同点</p>\n<ul>\n<li>都是在JVM加载类时且<strong>在构造方法执行之前执行</strong>，在类中都可以定义多个，一般在代码块中对一些static变量进行赋值。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>静态代码块在非静态代码块之前执行(<strong>静态代码块—&gt;非静态代码块—&gt;构造方法</strong>)。<strong>静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次</strong>。非静态代码块可在普通方法中定义(不过作用不大)；而<strong>静态</strong>代码块不行。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"接口和抽象类有什么区别\"><a href=\"#接口和抽象类有什么区别\" class=\"headerlink\" title=\"接口和抽象类有什么区别\"></a>接口和抽象类有什么区别</h3><ul>\n<li>实现：抽象类的子类使用 <strong>extends</strong> 来继承；接口必须使用 <strong>implements</strong> 来实现接口。</li>\n<li>构造函数：抽象类可以有构造函数；<strong>接口不能有</strong>。</li>\n<li>main 方法：抽象类可以有 main 方法，并且我们能运行它；<strong>接口不能有 main 方法</strong>。</li>\n<li>实现数量：<strong>类可以实现很多个接口</strong>；但是<strong>只能继承一个抽象类</strong>。</li>\n<li>访问<strong>修饰符</strong>：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>\n</ul>\n<hr>\n<h3 id=\"String-a-”i”-和String-b-new-String-“i”-的区别\"><a href=\"#String-a-”i”-和String-b-new-String-“i”-的区别\" class=\"headerlink\" title=\"String a=”i” 和String b=new String(“i”)的区别\"></a>String a=”i” 和String b=new String(“i”)的区别</h3><ul>\n<li>前者，Java虚拟机将其分配到<strong>常量池</strong>中,并把”i”的内存地址赋给a,如果还有一个String a1=”i”,也把”i”的内存地址赋给a1，即<strong>a和a1这两个引用的是同一个地址，共享一个内存。</strong></li>\n<li>后者，则会被分配到<strong>堆内存</strong>中，即新创建了一个对象，如果还有一个String b1=new String(“i”)，相当于又创建了一个对象，然后将其地址赋给b1，<strong>虽然b和b1值相同，但是并不是一个对象。</strong></li>\n</ul>\n<hr>\n<h3 id=\"String类的常用方法有哪些\"><a href=\"#String类的常用方法有哪些\" class=\"headerlink\" title=\"String类的常用方法有哪些\"></a>String类的常用方法有哪些</h3><ul>\n<li><code>indexof()</code>   ：放回指定字符索引</li>\n<li><code>charAt()</code>    ：返回指定索引处字符</li>\n<li><code>replace()</code>   ：字符串替换</li>\n<li><code>trim()</code>      :去除字符串两端空白</li>\n<li><code>spilt()</code>     ：分割字符串，返回一个分割后的字符串数组</li>\n<li><code>getBytes()</code>  ：返回字符串的 byte 类型数组。ASCII码</li>\n<li><code>length()</code>    ：返回字符串长度。</li>\n<li><code>toLowerCase()</code>：将字符串转成小写字母。</li>\n<li><code>toUpperCase()</code>：将字符串转成大写字符。</li>\n<li>substring()   ：截取字符串。</li>\n<li>equals()      ：字符串比较。</li>\n</ul>\n<hr>\n<h3 id=\"Files的常用方法\"><a href=\"#Files的常用方法\" class=\"headerlink\" title=\"Files的常用方法\"></a>Files的常用方法</h3><ul>\n<li><code>Files.exists()</code>      ：    检测文件路径是否存在。</li>\n<li><code>Files.createFile()</code>  ：创建文件。</li>\n<li><code>Files.createDirectory()</code>：创建文件夹。</li>\n<li><code>Files.delete()</code>      ：删除一个文件或目录。</li>\n<li><code>Files.copy()</code>        ：复制文件。</li>\n<li><code>Files.move()</code>        ：移动文件。</li>\n<li><code>Files.size()</code>        ：查看文件个数。</li>\n<li><code>Files.read()</code>        ：读取文件。</li>\n<li><code>Files.write()</code>       ：写入文件。</li>\n</ul>\n<hr>\n<h3 id=\"java创建对象的方法\"><a href=\"#java创建对象的方法\" class=\"headerlink\" title=\"java创建对象的方法\"></a>java创建对象的方法</h3><ol>\n<li>用new语句创建对象，是最常见的创建对象的方法。</li>\n<li>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li>\n<li>调用对象的clone()方法。</li>\n<li>运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</li>\n</ol>\n<hr>\n<h3 id=\"assert\"><a href=\"#assert\" class=\"headerlink\" title=\"assert\"></a>assert</h3><ul>\n<li>断言。是在软件开发过程中的一种调试方法。它对一个boolean表达式进行检验。一个正确的程序必须保证这个表达式正确，如果不正确系统则会给出警告或者退出。一般来说，<strong>asset用于保证程序最基本，最关键代码的正确性</strong>。软件发布后，通常assert检查通常是关闭的。</li>\n<li></li>\n</ul>\n<hr>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>抽象类不一定要有抽象方法</li>\n<li>抽象类不能使用final,因为被final标记的类不能被继承，但抽象类就是为了让其子类继承的</li>\n<li>抽象类和普通类的区别<ul>\n<li><strong>抽象类不能实例化</strong>，普通类可以    绝不会拿3e</li>\n<li><strong>普通类不能含有抽象方法</strong>，抽象类可以有抽象方法</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"lambda-表达式\"><a href=\"#lambda-表达式\" class=\"headerlink\" title=\"lambda 表达式\"></a>lambda 表达式</h3><pre><code>* 示例：\n    ```java\n    // 1. 不需要参数,返回值为 5  \n    () -&gt; 5  \n\n    // 2. 接收一个参数(数字类型),返回其2倍的值  \n    x -&gt; 2 * x  \n\n    // 3. 接受2个参数(数字),并返回他们的差值  \n    (x, y) -&gt; x – y  \n\n    // 4. 接收2个int型整数,返回他们的和  \n    (int x, int y) -&gt; x + y  \n\n    // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  \n    (String s) -&gt; System.out.print(s)\n    ```</code></pre><hr>\n<blockquote>\n<p>参考：<a href=\"https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>❄</p>","more":"<h3 id=\"JDK和JRE的区别\"><a href=\"#JDK和JRE的区别\" class=\"headerlink\" title=\"JDK和JRE的区别\"></a>JDK和JRE的区别</h3><ul>\n<li>JDK:Java开发工具包，提供了Java的<strong>开发环境</strong>和<strong>运行环境</strong></li>\n<li>JRE:Java运行环境，提供Java的<strong>运行环境</strong></li>\n<li><strong>JDK包含了JRE,还包含了java源码的编译器javac，以及很多java程序调试分析的工具</strong>，如果只需要运行程序，JRE即可，如果还需要写程序则需要JDK <br></li>\n</ul>\n<hr>\n<h3 id=\"Java8新特性\"><a href=\"#Java8新特性\" class=\"headerlink\" title=\"Java8新特性\"></a>Java8新特性</h3><ul>\n<li>Date Time API :加强对日期和时间的处理</li>\n<li>Optional类：用来处理空指针的问题</li>\n<li>Lambda表达式</li>\n<li>优化HashMap,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</li>\n</ul>\n<hr>\n<h3 id=\"Java的多态\"><a href=\"#Java的多态\" class=\"headerlink\" title=\"Java的多态\"></a>Java的多态</h3><ul>\n<li>多态：一种事物的多种存在形态，比如说男人和女人都是人，人可以分为男人和女人</li>\n<li>好处：消除了类之间的<strong>耦合关系</strong>，大大提高了程序的<strong>简洁性</strong>和<strong>可拓展性</strong></li>\n<li>重写Overriding和重载Overloading<ul>\n<li>重载：以类统一的方式处理不同数据的一种手段，实质就是<strong>多个具有不同参数个数或者类型的同名函数，且返回类型可随意。</strong>（<em>动态绑定</em>）</li>\n<li>重写：父类与子类之间的多态性，<strong>实质就是子类对父类的函数进行重写定义</strong>。子类的访问权限不能小于父类的访问权限。（否则调用的时候可能无法调用）（<em>静态绑定</em>）<ul>\n<li>重写方法<strong>参数列表、返回类型</strong>必须与被重写的方法相同。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>子类对象的多态性<ul>\n<li>是<strong>使用父类的引用，指向子类的对象</strong>，然后虚拟方法调用子类重写父类的方法</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"数据类型-自动拆装箱\"><a href=\"#数据类型-自动拆装箱\" class=\"headerlink\" title=\"数据类型 自动拆装箱\"></a>数据类型 自动拆装箱</h3><ul>\n<li>8种，<strong>int long short char float double byte boolean</strong></li>\n<li><strong>自动装箱是Java编译器在基本数据类型和对于对象包装类型中做的一个转化</strong>。比如int类型转化为Integer,double类型转为Double等，反之及时自动拆箱。</li>\n</ul>\n<hr>\n<h3 id=\"Java中IO流分为几种\"><a href=\"#Java中IO流分为几种\" class=\"headerlink\" title=\"Java中IO流分为几种\"></a>Java中IO流分为几种</h3><ul>\n<li>按照功能：<strong>输入流</strong>、<strong>输出流</strong></li>\n<li>按照类型:<ul>\n<li><strong>字节流</strong>：按<strong>8位传输以字节为单位</strong>输出输出数据</li>\n<li><strong>字符流</strong>：按照<strong>16位传输以字符为单位</strong>输出输入数据</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"值传递和引用传递\"><a href=\"#值传递和引用传递\" class=\"headerlink\" title=\"值传递和引用传递\"></a>值传递和引用传递</h3><ul>\n<li>值传递对于基本类型而言的，传递的是该变量的一个副本，改变副本不影响原变量</li>\n<li>引用传递对于对象类型而言的，传递的是该对象地址的一个副本，并不是原对象本身，所以对引用对象操作会改变原对象。</li>\n<li>一个对象被当做参数传递给一个方法后，此方法可改变它的属性，并返回变化后的结果，那么这里是什么传递？<ul>\n<li>值传递。<strong>Java没有引用传递</strong>，方法的参数的值是对象引用（传入的变量）的一个副本，但指向同一个对象，所以在方法中改变对象也会改变原变量的值，因为他的引用的对象改变了。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"amp-和-amp-amp-的区别\"><a href=\"#amp-和-amp-amp-的区别\" class=\"headerlink\" title=\"&amp;和&amp;&amp;的区别\"></a>&amp;和&amp;&amp;的区别</h3><ul>\n<li><p>&amp;：按位于，<strong>两边都要判断</strong></p>\n</li>\n<li><p>&amp;&amp;：短路与，<strong>左边的为true才会判断右边</strong></p>\n</li>\n<li><p>经常使用短路与，比如用户登陆时判定用户名不是null且不是空字符串时就只能用&amp;&amp;</p>\n<pre><code class=\"java\">  username!=null&amp;&amp;username.equals(&quot;&quot;)</code></pre>\n</li>\n</ul>\n<hr>\n<h3 id=\"String、StringBuffer和StringBuilder\"><a href=\"#String、StringBuffer和StringBuilder\" class=\"headerlink\" title=\"String、StringBuffer和StringBuilder\"></a>String、StringBuffer和StringBuilder</h3><ul>\n<li>都是可以储存和操作字符串</li>\n<li><strong>String是final类型</strong>，每次声明的都是不可变更的对象，然后将指针指向新的String对象</li>\n<li>StringBuffer，StringBuilder是可变字符继承自AbstractStringBuilder，在原有对象上进行操作</li>\n<li><strong>StringBuffer是线程安全的，StringBuilder不是线程安全的</strong>，但性能更高</li>\n<li>使用场景：<ul>\n<li><strong>并发</strong>必选StringBuffer</li>\n<li><strong>迭代</strong>必选StringBuilder</li>\n<li>普通场景使用String，避免不必要的类型转换开销</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>Object若不重写hashCode()的话，hashCode()如何计算出来的？<ul>\n<li>Object的hashCode()方法是一个本地方法，<strong>该方法是直接返回对象的内存地址</strong></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"equals和hashcode\"><a href=\"#equals和hashcode\" class=\"headerlink\" title=\"equals和hashcode\"></a>equals和hashcode</h3><ul>\n<li>如果两个对象的引用相同，他们之前互相调用equals()为true即两个对象相同。如果不重写hashCode（）方法，系统默认的hashCode()是本地计算对象的内存地址（经哈希算法），此时不会相同。就会产生矛盾。<blockquote>\n<p>两个对象equals相等，则它们的hashcode必须相等，反之则不一定。<br><br>两个对象=相等，则其hashcode一定相等，反之亦然。<br><br>两个对象==相等，则其hashcode一定相等，反之不一定成立。 //有可能是Integer对象比较之类的<br><br>两个对象==相等，则其hashcode一定相等，反之不一定成立。<br></p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h3 id=\"和equals的区别\"><a href=\"#和equals的区别\" class=\"headerlink\" title=\"==和equals的区别\"></a>==和equals的区别</h3><ul>\n<li>==<ul>\n<li><strong>基本类型：比较值是否相同</strong></li>\n<li><strong>引用类型：比较的引用是否相同</strong></li>\n</ul>\n</li>\n<li><strong>equals默认情况下是引用比较</strong>，只是<strong>很多类重载了equals()方法 (也可自定义)</strong> ，<strong>比如String、Integer等将它变为值比较</strong></li>\n</ul>\n<hr>\n<h3 id=\"final和static\"><a href=\"#final和static\" class=\"headerlink\" title=\"final和static\"></a>final和static</h3><ul>\n<li><p>final</p>\n<ul>\n<li>final可以修饰属性，<strong>方法，类，局部变量</strong>（静态变量、实例变量和局部变量）；</li>\n<li>final修饰的方法<strong>不能被子类重写</strong>，但<strong>可以被继承</strong>；</li>\n<li>final修饰的类<strong>不能被继承</strong>，没有子类，<strong>final类中的方法默认是final的</strong></li>\n<li>final<strong>不能</strong>用于修饰构造方法；</li>\n<li>对于基本类型数据，<strong>final会将值变为一个常数（创建后不能被修改）</strong></li>\n</ul>\n</li>\n<li><p>staic</p>\n<ul>\n<li>static表示“全局”或者“静态”的意思，可以用来修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类），static<strong>不可以修饰局部变量</strong></li>\n<li>static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变，并且每个对象都只有一个值，主要强调它们只有一个。</li>\n<li>static修饰的属性、方法、代码段跟该类的<strong>具体对象无关</strong>，不创建对象也能调用static修饰的属性、方法等，</li>\n<li>static和“this、super”势不两立，因为this、super正好跟具体对象有关。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</li>\n<li>用public修饰的static属性和方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。</li>\n</ul>\n</li>\n<li><p>static final(等价于final staic)</p>\n<ul>\n<li>static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。static final也可以修饰方法，表示该方法不能重写，可以在不new对象的情况下调用</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"静态代码块与普通代码块的区别\"><a href=\"#静态代码块与普通代码块的区别\" class=\"headerlink\" title=\"静态代码块与普通代码块的区别\"></a>静态代码块与普通代码块的区别</h3><ul>\n<li><pre><code class=\"java\">  public class HelloB extends HelloA \n  {\n      public HelloB(){\n      }\n\n      {\n          System.out.println(&quot;I’m B class&quot;);\n      }\n\n      static{\n          System.out.println(&quot;static B&quot;);\n      }\n\n      public static void main(String[] args){\n          new HelloB();\n      }\n  }\n  class HelloA\n  {\n      public HelloA(){\n      }\n\n      {\n          System.out.println(&quot;I’m A class&quot;);\n      }\n\n      static{\n          System.out.println(&quot;static A&quot;);\n      }\n  }\n\n  //输出结果\n  static A\n  static B\n  I’m A class\n  I’m B class</code></pre>\n<ul>\n<li><p>执行顺序：</p>\n<ol>\n<li>父类静态代码块</li>\n<li>子类静态代码块</li>\n<li>父类普通代码块</li>\n<li>父类构造方法</li>\n<li>子类普通代码块</li>\n<li>子类构造方法</li>\n</ol>\n</li>\n<li><p>相同点</p>\n<ul>\n<li>都是在JVM加载类时且<strong>在构造方法执行之前执行</strong>，在类中都可以定义多个，一般在代码块中对一些static变量进行赋值。</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>静态代码块在非静态代码块之前执行(<strong>静态代码块—&gt;非静态代码块—&gt;构造方法</strong>)。<strong>静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次</strong>。非静态代码块可在普通方法中定义(不过作用不大)；而<strong>静态</strong>代码块不行。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"接口和抽象类有什么区别\"><a href=\"#接口和抽象类有什么区别\" class=\"headerlink\" title=\"接口和抽象类有什么区别\"></a>接口和抽象类有什么区别</h3><ul>\n<li>实现：抽象类的子类使用 <strong>extends</strong> 来继承；接口必须使用 <strong>implements</strong> 来实现接口。</li>\n<li>构造函数：抽象类可以有构造函数；<strong>接口不能有</strong>。</li>\n<li>main 方法：抽象类可以有 main 方法，并且我们能运行它；<strong>接口不能有 main 方法</strong>。</li>\n<li>实现数量：<strong>类可以实现很多个接口</strong>；但是<strong>只能继承一个抽象类</strong>。</li>\n<li>访问<strong>修饰符</strong>：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>\n</ul>\n<hr>\n<h3 id=\"String-a-”i”-和String-b-new-String-“i”-的区别\"><a href=\"#String-a-”i”-和String-b-new-String-“i”-的区别\" class=\"headerlink\" title=\"String a=”i” 和String b=new String(“i”)的区别\"></a>String a=”i” 和String b=new String(“i”)的区别</h3><ul>\n<li>前者，Java虚拟机将其分配到<strong>常量池</strong>中,并把”i”的内存地址赋给a,如果还有一个String a1=”i”,也把”i”的内存地址赋给a1，即<strong>a和a1这两个引用的是同一个地址，共享一个内存。</strong></li>\n<li>后者，则会被分配到<strong>堆内存</strong>中，即新创建了一个对象，如果还有一个String b1=new String(“i”)，相当于又创建了一个对象，然后将其地址赋给b1，<strong>虽然b和b1值相同，但是并不是一个对象。</strong></li>\n</ul>\n<hr>\n<h3 id=\"String类的常用方法有哪些\"><a href=\"#String类的常用方法有哪些\" class=\"headerlink\" title=\"String类的常用方法有哪些\"></a>String类的常用方法有哪些</h3><ul>\n<li><code>indexof()</code>   ：放回指定字符索引</li>\n<li><code>charAt()</code>    ：返回指定索引处字符</li>\n<li><code>replace()</code>   ：字符串替换</li>\n<li><code>trim()</code>      :去除字符串两端空白</li>\n<li><code>spilt()</code>     ：分割字符串，返回一个分割后的字符串数组</li>\n<li><code>getBytes()</code>  ：返回字符串的 byte 类型数组。ASCII码</li>\n<li><code>length()</code>    ：返回字符串长度。</li>\n<li><code>toLowerCase()</code>：将字符串转成小写字母。</li>\n<li><code>toUpperCase()</code>：将字符串转成大写字符。</li>\n<li>substring()   ：截取字符串。</li>\n<li>equals()      ：字符串比较。</li>\n</ul>\n<hr>\n<h3 id=\"Files的常用方法\"><a href=\"#Files的常用方法\" class=\"headerlink\" title=\"Files的常用方法\"></a>Files的常用方法</h3><ul>\n<li><code>Files.exists()</code>      ：    检测文件路径是否存在。</li>\n<li><code>Files.createFile()</code>  ：创建文件。</li>\n<li><code>Files.createDirectory()</code>：创建文件夹。</li>\n<li><code>Files.delete()</code>      ：删除一个文件或目录。</li>\n<li><code>Files.copy()</code>        ：复制文件。</li>\n<li><code>Files.move()</code>        ：移动文件。</li>\n<li><code>Files.size()</code>        ：查看文件个数。</li>\n<li><code>Files.read()</code>        ：读取文件。</li>\n<li><code>Files.write()</code>       ：写入文件。</li>\n</ul>\n<hr>\n<h3 id=\"java创建对象的方法\"><a href=\"#java创建对象的方法\" class=\"headerlink\" title=\"java创建对象的方法\"></a>java创建对象的方法</h3><ol>\n<li>用new语句创建对象，是最常见的创建对象的方法。</li>\n<li>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li>\n<li>调用对象的clone()方法。</li>\n<li>运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</li>\n</ol>\n<hr>\n<h3 id=\"assert\"><a href=\"#assert\" class=\"headerlink\" title=\"assert\"></a>assert</h3><ul>\n<li>断言。是在软件开发过程中的一种调试方法。它对一个boolean表达式进行检验。一个正确的程序必须保证这个表达式正确，如果不正确系统则会给出警告或者退出。一般来说，<strong>asset用于保证程序最基本，最关键代码的正确性</strong>。软件发布后，通常assert检查通常是关闭的。</li>\n<li></li>\n</ul>\n<hr>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>抽象类不一定要有抽象方法</li>\n<li>抽象类不能使用final,因为被final标记的类不能被继承，但抽象类就是为了让其子类继承的</li>\n<li>抽象类和普通类的区别<ul>\n<li><strong>抽象类不能实例化</strong>，普通类可以    绝不会拿3e</li>\n<li><strong>普通类不能含有抽象方法</strong>，抽象类可以有抽象方法</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"lambda-表达式\"><a href=\"#lambda-表达式\" class=\"headerlink\" title=\"lambda 表达式\"></a>lambda 表达式</h3><pre><code>* 示例：\n    ```java\n    // 1. 不需要参数,返回值为 5  \n    () -&gt; 5  \n\n    // 2. 接收一个参数(数字类型),返回其2倍的值  \n    x -&gt; 2 * x  \n\n    // 3. 接受2个参数(数字),并返回他们的差值  \n    (x, y) -&gt; x – y  \n\n    // 4. 接收2个int型整数,返回他们的和  \n    (int x, int y) -&gt; x + y  \n\n    // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  \n    (String s) -&gt; System.out.print(s)\n    ```</code></pre><hr>\n<blockquote>\n<p>参考：<a href=\"https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA</a></p>\n</blockquote>"},{"title":"Java获取文件信息","declare":true,"wordCount":true,"abbrlink":"af03e16b","date":"2020-05-18T12:19:10.000Z","_content":"\n### readAttributes方法获取文件属性\n```java\n\n    Path path = Paths.get(\"C:/Users/LetGo/Desktop/\", \"16.png\");\n    SimpleDateFormat format=new SimpleDateFormat(\"yy-MM-dd HH:mm:ss\");\n\n    BasicFileAttributes a= Files.readAttributes(path, BasicFileAttributes.class);\n    System.out.println(a.size());\n    System.out.println( \"创建日期\"+format.format(new Date(a.creationTime().toMillis())) );\n    System.out.println(\"最后访问时间:\"+format.format(new Date(a.lastAccessTime().toMillis())));\n    System.out.println(\"最后修改时间:\"+format.format(new Date(a.lastModifiedTime().toMillis())));\n\n    System.out.println(\"是否为目录\"+a.isDirectory());\n    System.out.println(\"是否为其他\"+a.isOther());\n    System.out.println(\"是否为常规文件\"+a.isRegularFile());\n    System.out.println(\"是否为连接\"+a.isSymbolicLink());\n\n```\n\n\n### 获取文件大小\n```java\npublic class FileSizeUtil {\n\n    public static String getPrintSize(File  file) {\n        long size=file.length();\n        // 如果字节数少于1024，则直接以B为单位，否则先除于1024，后3位因太少无意义\n        if (size < 1024) {\n            return String.valueOf(size) + \"B\";\n        } else {\n            size = size / 1024;\n        }\n        // 如果原字节数除于1024之后，少于1024，则可以直接以KB作为单位\n        // 因为还没有到达要使用另一个单位的时候\n        // 接下去以此类推\n        if (size < 1024) {\n            return String.valueOf(size) + \"KB\";\n        } else {\n            size = size / 1024;\n        }\n        if (size < 1024) {\n            // 因为如果以MB为单位的话，要保留最后1位小数，\n            // 因此，把此数乘以100之后再取余\n            size = size * 100;\n            return String.valueOf((size / 100)) + \".\" + String.valueOf((size % 100)) + \"MB\";\n        } else {\n            // 否则如果要以GB为单位的，先除于1024再作同样的处理\n            size = size * 100 / 1024;\n            return String.valueOf((size / 100)) + \".\" + String.valueOf((size % 100)) + \"GB\";\n        }\n    }\n}\n\n\n```\n\n参考\n> https://blog.csdn.net/lichongxyz/article/details/88925249\n> https://www.tah1986.com/2298.html","source":"_posts/code/JavaSE/Java计算文件大小.md","raw":"---\ntitle: Java获取文件信息\ncategories: Code\ntags:\n  - 工具类\ndeclare: true\nwordCount: true\nabbrlink: af03e16b\ndate: 2020-05-18 20:19:10\n---\n\n### readAttributes方法获取文件属性\n```java\n\n    Path path = Paths.get(\"C:/Users/LetGo/Desktop/\", \"16.png\");\n    SimpleDateFormat format=new SimpleDateFormat(\"yy-MM-dd HH:mm:ss\");\n\n    BasicFileAttributes a= Files.readAttributes(path, BasicFileAttributes.class);\n    System.out.println(a.size());\n    System.out.println( \"创建日期\"+format.format(new Date(a.creationTime().toMillis())) );\n    System.out.println(\"最后访问时间:\"+format.format(new Date(a.lastAccessTime().toMillis())));\n    System.out.println(\"最后修改时间:\"+format.format(new Date(a.lastModifiedTime().toMillis())));\n\n    System.out.println(\"是否为目录\"+a.isDirectory());\n    System.out.println(\"是否为其他\"+a.isOther());\n    System.out.println(\"是否为常规文件\"+a.isRegularFile());\n    System.out.println(\"是否为连接\"+a.isSymbolicLink());\n\n```\n\n\n### 获取文件大小\n```java\npublic class FileSizeUtil {\n\n    public static String getPrintSize(File  file) {\n        long size=file.length();\n        // 如果字节数少于1024，则直接以B为单位，否则先除于1024，后3位因太少无意义\n        if (size < 1024) {\n            return String.valueOf(size) + \"B\";\n        } else {\n            size = size / 1024;\n        }\n        // 如果原字节数除于1024之后，少于1024，则可以直接以KB作为单位\n        // 因为还没有到达要使用另一个单位的时候\n        // 接下去以此类推\n        if (size < 1024) {\n            return String.valueOf(size) + \"KB\";\n        } else {\n            size = size / 1024;\n        }\n        if (size < 1024) {\n            // 因为如果以MB为单位的话，要保留最后1位小数，\n            // 因此，把此数乘以100之后再取余\n            size = size * 100;\n            return String.valueOf((size / 100)) + \".\" + String.valueOf((size % 100)) + \"MB\";\n        } else {\n            // 否则如果要以GB为单位的，先除于1024再作同样的处理\n            size = size * 100 / 1024;\n            return String.valueOf((size / 100)) + \".\" + String.valueOf((size % 100)) + \"GB\";\n        }\n    }\n}\n\n\n```\n\n参考\n> https://blog.csdn.net/lichongxyz/article/details/88925249\n> https://www.tah1986.com/2298.html","slug":"code/JavaSE/Java计算文件大小","published":1,"updated":"2020-05-19T12:42:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gb004a0w7t035odcpg","content":"<h3 id=\"readAttributes方法获取文件属性\"><a href=\"#readAttributes方法获取文件属性\" class=\"headerlink\" title=\"readAttributes方法获取文件属性\"></a>readAttributes方法获取文件属性</h3><pre class=\" language-java\"><code class=\"language-java\">\n    Path path <span class=\"token operator\">=</span> Paths<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"C:/Users/LetGo/Desktop/\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"16.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    SimpleDateFormat format<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yy-MM-dd HH:mm:ss\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    BasicFileAttributes a<span class=\"token operator\">=</span> Files<span class=\"token punctuation\">.</span><span class=\"token function\">readAttributes</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span> BasicFileAttributes<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"创建日期\"</span><span class=\"token operator\">+</span>format<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">creationTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"最后访问时间:\"</span><span class=\"token operator\">+</span>format<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">lastAccessTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"最后修改时间:\"</span><span class=\"token operator\">+</span>format<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">lastModifiedTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"是否为目录\"</span><span class=\"token operator\">+</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">isDirectory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"是否为其他\"</span><span class=\"token operator\">+</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">isOther</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"是否为常规文件\"</span><span class=\"token operator\">+</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">isRegularFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"是否为连接\"</span><span class=\"token operator\">+</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">isSymbolicLink</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3 id=\"获取文件大小\"><a href=\"#获取文件大小\" class=\"headerlink\" title=\"获取文件大小\"></a>获取文件大小</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FileSizeUtil</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">getPrintSize</span><span class=\"token punctuation\">(</span>File  file<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">long</span> size<span class=\"token operator\">=</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果字节数少于1024，则直接以B为单位，否则先除于1024，后3位因太少无意义</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">&lt;</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            size <span class=\"token operator\">=</span> size <span class=\"token operator\">/</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果原字节数除于1024之后，少于1024，则可以直接以KB作为单位</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 因为还没有到达要使用另一个单位的时候</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 接下去以此类推</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">&lt;</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"KB\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            size <span class=\"token operator\">=</span> size <span class=\"token operator\">/</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">&lt;</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 因为如果以MB为单位的话，要保留最后1位小数，</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 因此，把此数乘以100之后再取余</span>\n            size <span class=\"token operator\">=</span> size <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">/</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\".\"</span> <span class=\"token operator\">+</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">%</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"MB\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 否则如果要以GB为单位的，先除于1024再作同样的处理</span>\n            size <span class=\"token operator\">=</span> size <span class=\"token operator\">*</span> <span class=\"token number\">100</span> <span class=\"token operator\">/</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">/</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\".\"</span> <span class=\"token operator\">+</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">%</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"GB\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>参考</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/lichongxyz/article/details/88925249\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lichongxyz/article/details/88925249</a><br><a href=\"https://www.tah1986.com/2298.html\" target=\"_blank\" rel=\"noopener\">https://www.tah1986.com/2298.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"readAttributes方法获取文件属性\"><a href=\"#readAttributes方法获取文件属性\" class=\"headerlink\" title=\"readAttributes方法获取文件属性\"></a>readAttributes方法获取文件属性</h3><pre><code class=\"java\">\n    Path path = Paths.get(&quot;C:/Users/LetGo/Desktop/&quot;, &quot;16.png&quot;);\n    SimpleDateFormat format=new SimpleDateFormat(&quot;yy-MM-dd HH:mm:ss&quot;);\n\n    BasicFileAttributes a= Files.readAttributes(path, BasicFileAttributes.class);\n    System.out.println(a.size());\n    System.out.println( &quot;创建日期&quot;+format.format(new Date(a.creationTime().toMillis())) );\n    System.out.println(&quot;最后访问时间:&quot;+format.format(new Date(a.lastAccessTime().toMillis())));\n    System.out.println(&quot;最后修改时间:&quot;+format.format(new Date(a.lastModifiedTime().toMillis())));\n\n    System.out.println(&quot;是否为目录&quot;+a.isDirectory());\n    System.out.println(&quot;是否为其他&quot;+a.isOther());\n    System.out.println(&quot;是否为常规文件&quot;+a.isRegularFile());\n    System.out.println(&quot;是否为连接&quot;+a.isSymbolicLink());\n</code></pre>\n<h3 id=\"获取文件大小\"><a href=\"#获取文件大小\" class=\"headerlink\" title=\"获取文件大小\"></a>获取文件大小</h3><pre><code class=\"java\">public class FileSizeUtil {\n\n    public static String getPrintSize(File  file) {\n        long size=file.length();\n        // 如果字节数少于1024，则直接以B为单位，否则先除于1024，后3位因太少无意义\n        if (size &lt; 1024) {\n            return String.valueOf(size) + &quot;B&quot;;\n        } else {\n            size = size / 1024;\n        }\n        // 如果原字节数除于1024之后，少于1024，则可以直接以KB作为单位\n        // 因为还没有到达要使用另一个单位的时候\n        // 接下去以此类推\n        if (size &lt; 1024) {\n            return String.valueOf(size) + &quot;KB&quot;;\n        } else {\n            size = size / 1024;\n        }\n        if (size &lt; 1024) {\n            // 因为如果以MB为单位的话，要保留最后1位小数，\n            // 因此，把此数乘以100之后再取余\n            size = size * 100;\n            return String.valueOf((size / 100)) + &quot;.&quot; + String.valueOf((size % 100)) + &quot;MB&quot;;\n        } else {\n            // 否则如果要以GB为单位的，先除于1024再作同样的处理\n            size = size * 100 / 1024;\n            return String.valueOf((size / 100)) + &quot;.&quot; + String.valueOf((size % 100)) + &quot;GB&quot;;\n        }\n    }\n}\n\n</code></pre>\n<p>参考</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/lichongxyz/article/details/88925249\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lichongxyz/article/details/88925249</a><br><a href=\"https://www.tah1986.com/2298.html\" target=\"_blank\" rel=\"noopener\">https://www.tah1986.com/2298.html</a></p>\n</blockquote>\n"},{"title":"Java 逐行读取文件","declare":true,"wordCount":true,"abbrlink":"af03e16b","date":"2020-05-18T11:38:10.000Z","_content":"\n\n\n```java\n BufferedReader br = new BufferedReader(\n     new InputStreamReader(new FileInputStream(new File(\"C:/Users/LetGo/Desktop/messages\")\n     ),StandardCharsets.UTF_8));\nString s=br.readLine() != null);\n```\n> File -> FileInputStream ->InputStreamReader -> BufferedReader\n\n```java\n    InputStream stream = getClass().getClassLoader().getResourceAsStream(\n        \"messages\");\n    assert stream != null;\n    BufferedReader br = new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8));\n    String s=br.readline();\n```\n> **只能读取当前工程下文件**\n","source":"_posts/code/JavaSE/Java逐行读取文件.md","raw":"---\ntitle: Java 逐行读取文件\ncategories: Code\ntags:\n  - 工具类\ndeclare: true\nwordCount: true\nabbrlink: af03e16b\ndate: 2020-05-18 19:38:10\n---\n\n\n\n```java\n BufferedReader br = new BufferedReader(\n     new InputStreamReader(new FileInputStream(new File(\"C:/Users/LetGo/Desktop/messages\")\n     ),StandardCharsets.UTF_8));\nString s=br.readLine() != null);\n```\n> File -> FileInputStream ->InputStreamReader -> BufferedReader\n\n```java\n    InputStream stream = getClass().getClassLoader().getResourceAsStream(\n        \"messages\");\n    assert stream != null;\n    BufferedReader br = new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8));\n    String s=br.readline();\n```\n> **只能读取当前工程下文件**\n","slug":"code/JavaSE/Java逐行读取文件","published":1,"updated":"2020-05-18T11:26:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gc004d0w7tad7gcw4w","content":"<pre class=\" language-java\"><code class=\"language-java\"> BufferedReader br <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span>\n     <span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"C:/Users/LetGo/Desktop/messages\"</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>StandardCharsets<span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nString s<span class=\"token operator\">=</span>br<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>File -&gt; FileInputStream -&gt;InputStreamReader -&gt; BufferedReader</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\">    InputStream stream <span class=\"token operator\">=</span> <span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getResourceAsStream</span><span class=\"token punctuation\">(</span>\n        <span class=\"token string\">\"messages\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">assert</span> stream <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span>\n    BufferedReader br <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span>stream<span class=\"token punctuation\">,</span> StandardCharsets<span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    String s<span class=\"token operator\">=</span>br<span class=\"token punctuation\">.</span><span class=\"token function\">readline</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p><strong>只能读取当前工程下文件</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<pre><code class=\"java\"> BufferedReader br = new BufferedReader(\n     new InputStreamReader(new FileInputStream(new File(&quot;C:/Users/LetGo/Desktop/messages&quot;)\n     ),StandardCharsets.UTF_8));\nString s=br.readLine() != null);</code></pre>\n<blockquote>\n<p>File -&gt; FileInputStream -&gt;InputStreamReader -&gt; BufferedReader</p>\n</blockquote>\n<pre><code class=\"java\">    InputStream stream = getClass().getClassLoader().getResourceAsStream(\n        &quot;messages&quot;);\n    assert stream != null;\n    BufferedReader br = new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8));\n    String s=br.readline();</code></pre>\n<blockquote>\n<p><strong>只能读取当前工程下文件</strong></p>\n</blockquote>\n"},{"title":"JavaSE线程","photos":["https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/121212java.jpg"],"abbrlink":"e930d1ea","date":"2020-04-30T11:53:10.000Z","declare":true,"wordCount":true,"_content":"❄\n<!-- more -->\n\n### 创建进程的方式\n* 继承Thread类创建线程类\n    1. **定义Thread类的子类**，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。\n    2. 创建Thread子类的实例，即创建了线程对象。\n    3. 调用线程对象的start()方法来启动该线程。<br>\n\n* 通过Runnable接口创建线程类\n    1. 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。\n    2. 创建 Runnable实现类的实例，并依此实例**作为Thread的target**来创建Thread对象，该Thread对象才是真正的线程对象。\n    3. 调用线程对象的start()方法来启动该线程。\n* 通过Callable和Future创建线程\n    1. 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。\n    2. 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。\n    3. 使用FutureTask对象作为Thread对象的target创建并启动新线程。\n    4. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。\n***\n\n### 线程的状态\n* **创建状态**。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。\n* **就绪状态**。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。\n* **运行状态**。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。\n* **阻塞状态**。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。\n* **死亡状态**。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 \n***\n\n### 并行和并发的区别\n* 并行是指两个或者多个事件在**同一时刻**发生；\n* 并发是指两个或多个事件在**同一时间间隔**发生。\n* 并行是在**不同实体**上的多个事件\n* 并发是在**同一实体**上的多个事件\n***\n\n### synchronized\n* 被它修饰的方法**使其只能每次被单一的线程存取**。\n* ~~修饰方法、对象、代码块~~\n***\n\n### synchronized 和 volatile 的区别\n* volatile本质是在**告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取**； synchronized则是**锁定当前变量**，只有当前线程可以访问该变量，其他线程被阻塞住。\n* volatile仅能使用在**变量级别**；synchronized则可以使用在变量、方法、和类级别的。\n* volatile仅能实现变量的修改可见性，**不能保证原子性**；而synchronized则可以保证变量的修改可见性和原子性。\n* volatile**不会造成线程的阻塞**；synchronized可能会造成线程的阻塞。\n* volatile**标记的变量不会被编译器优化**；synchronized标记的变量可以被编译器优化。\n***\n\n### synchronized 和 Lock 的区别\n* 首先synchronized是**java内置关键字**，在jvm层面，**Lock是个java类**；\n* **synchronized无法判断是否获取锁的状态**，**Lock可以判断是否获取到锁**；\n* synchronized会**自动释放锁**(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中**手工释放锁**（unlock()方法释放锁），否则容易造成线程死锁；\n* 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。**如果线程1阻塞，线程2则会一直等待下去**，而Lock锁就不一定会等待下去，如果**尝试获取不到锁，线程可以不用一直等待就结束了**；\n* Lock锁**适合大量同步的代码**的同步问题，synchronized锁适合代码少量的同步问题。\n* synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；\n***\n\n### 线程和进程\n* **进程是资源分配**的最小单元，**线程是CPU调度**的最小单元\n    \n    >进程=火车 线程=车厢\n* **线程在进程下进行**\n* 一个进程可以包含多个线程\n* 不同进程间数据很难共享\n>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。**进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源**，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。\n***\n\n### 守护线程\n* 守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。\n***\n\n### runable和callable的区别\n* Runnable接口中的**run()方法的返回值是void**，它做的事情只是**纯粹地去执行**run()方法中的代码而已；\n* Callable接口中的**call()方法是有返回值的**，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。\n***\n\n### sleep和wait的区别\n![sleep和wait](https://i.loli.net/2020/04/06/ekJtWQjuX1a6MgZ.png)\n* sleep()：方法是**线程类（Thread）的静态方法**，让调用线程**进入睡眠状态，让出执行机会给其他线程**，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程**虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象**。\n* wait()：**wait()是Object类的方法**，当一个线程执行到wait方法时，它就**进入**到一个和该对象相关的**等待池**，**同时释放对象的机锁**，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程\n***\n\n### 线程的 run()和 start()的区别\n>每个线程都是通过某个特定target对象所对应的方法**run()来完成其操作**的，**方法run()称为线程体**。通过调用Thread类的start()方法来启动一个线程。\n>**start()方法来启动一个线程，**真正实现了多线程运行。这时**无需等待run方法体代码执行完毕，可以直接继续执行下面的代码**； 这时此线程是**处于就绪状态， 并没有运行**。 然后通过此Thread类**调用方法run()来完成其运行状态**， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。\n>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。\n***\n\n### 线程池\n* <u><https://www.jianshu.com/p/7726c70cdc40></u>\n***\n\n### java程序中怎么保证多线程的运行安全\n* 线程安全在三个方面体现：\n    * 原子性：提供互斥访问，**同一时刻只能有一个线程对数据进行操作**\n    * 可见性：**一个线程对主内存的修改可以及时地被其他线程看到**，一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序\n    * 有序性：指程序在执行的时候，**程序的代码执行顺序和语句的顺序是一致的**\n***\n\n### 多线程锁的升级原理是什么\n* 在Java中，锁共有4种状态，级别从低到高依次为：**无状态锁，偏向锁，轻量级锁和重量级锁**状态，这几个状态会随着竞争情况逐渐升级。锁**可以升级但不能降级**。\n* 锁升级状态 [详解各种锁](http://ifeve.com/java-synchronized/)\n![锁升级状态](https://img-blog.csdnimg.cn/20190317183206697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70)\n***\n\n### Java的锁\n* [Java中的各种锁详细介绍](https://www.cnblogs.com/jyroy/p/11365935.html)\n    ![Java锁](https://img-blog.csdnimg.cn/20181122101753671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F4aWFvYm9nZQ==,size_16,color_FFFFFF,t_70)\n* 乐观锁 VS 悲观锁\n* 自旋锁 VS 适应性自旋锁\n* 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁\n* 公平锁 VS 非公平锁\n* 可重入锁 VS 非可重入锁\n* 独享锁 VS 共享锁#\n***\n\n### 什么是死锁\n* 死锁是指两个或两个以上的进程在执行过程中，**由于竞争资源或者由于彼此通信而造成的一种阻塞的现象**，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是**操作系统层面的一个错误**，是进程死锁的简称，\n* 死锁产生的四个必要条件：\n    * 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源\n    * 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放\n    * 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放\n    *环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系\n\n* 如何防止死锁\n        * 参照产生的四个必要条件，只要不满足其一，就可防止死锁\n***\n\n\n### ThreadLocal \n* **线程局部变量**是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。\n\n* [详解ThreadLocal](https://www.jianshu.com/p/3c5d7f09dfbd)\n***\n\n * **Servlet是线程不安全的**，在Servlet类中可能会定义共享的类变量，这样在并发的多线程访问的情况下，不同的线程对成员变量的修改会引发错误\n***\n\n### 同步和异步\n* 同步：如果数据在线程间共享，例如正在写的数据可能被另外一个线程读到，或者正在读的数据可能被另外一个线程写过了，那么这些数据就是共享数据，必须同步存取\n* 异步：当应用程序在对象上调用了一个需要花很长时间来执行的方法，并且不希望让程序等待方法的返回是，就应该使用异步编程，往往异步编程更有效率。\n***\n### 并行和并发\n* 并行是指多个事件在**同时刻**发生，并发是指多个事件在**同一时间间隔内**发生 \n* 并行是在**不同实体上的多个事件**，并发是指在**同一实体上的多个事件**\n    \n* 并发编程的目的是充分利用处理器的每一个核，以达到最高的处理性能。\n***\n\n\n\n>参考：https://blog.csdn.net/fangchao2011/article/details/89184943","source":"_posts/code/JavaSE/JavaSE线程.md","raw":"---\ntitle: JavaSE线程\ncategories: Code\ntags: JavaSE\nphotos:\n  - >-\n    https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/121212java.jpg\nabbrlink: e930d1ea\ndate: 2020-04-30 19:53:10\ndeclare: true\nwordCount: true\n---\n❄\n<!-- more -->\n\n### 创建进程的方式\n* 继承Thread类创建线程类\n    1. **定义Thread类的子类**，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。\n    2. 创建Thread子类的实例，即创建了线程对象。\n    3. 调用线程对象的start()方法来启动该线程。<br>\n\n* 通过Runnable接口创建线程类\n    1. 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。\n    2. 创建 Runnable实现类的实例，并依此实例**作为Thread的target**来创建Thread对象，该Thread对象才是真正的线程对象。\n    3. 调用线程对象的start()方法来启动该线程。\n* 通过Callable和Future创建线程\n    1. 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。\n    2. 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。\n    3. 使用FutureTask对象作为Thread对象的target创建并启动新线程。\n    4. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。\n***\n\n### 线程的状态\n* **创建状态**。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。\n* **就绪状态**。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。\n* **运行状态**。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。\n* **阻塞状态**。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。\n* **死亡状态**。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 \n***\n\n### 并行和并发的区别\n* 并行是指两个或者多个事件在**同一时刻**发生；\n* 并发是指两个或多个事件在**同一时间间隔**发生。\n* 并行是在**不同实体**上的多个事件\n* 并发是在**同一实体**上的多个事件\n***\n\n### synchronized\n* 被它修饰的方法**使其只能每次被单一的线程存取**。\n* ~~修饰方法、对象、代码块~~\n***\n\n### synchronized 和 volatile 的区别\n* volatile本质是在**告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取**； synchronized则是**锁定当前变量**，只有当前线程可以访问该变量，其他线程被阻塞住。\n* volatile仅能使用在**变量级别**；synchronized则可以使用在变量、方法、和类级别的。\n* volatile仅能实现变量的修改可见性，**不能保证原子性**；而synchronized则可以保证变量的修改可见性和原子性。\n* volatile**不会造成线程的阻塞**；synchronized可能会造成线程的阻塞。\n* volatile**标记的变量不会被编译器优化**；synchronized标记的变量可以被编译器优化。\n***\n\n### synchronized 和 Lock 的区别\n* 首先synchronized是**java内置关键字**，在jvm层面，**Lock是个java类**；\n* **synchronized无法判断是否获取锁的状态**，**Lock可以判断是否获取到锁**；\n* synchronized会**自动释放锁**(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中**手工释放锁**（unlock()方法释放锁），否则容易造成线程死锁；\n* 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。**如果线程1阻塞，线程2则会一直等待下去**，而Lock锁就不一定会等待下去，如果**尝试获取不到锁，线程可以不用一直等待就结束了**；\n* Lock锁**适合大量同步的代码**的同步问题，synchronized锁适合代码少量的同步问题。\n* synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；\n***\n\n### 线程和进程\n* **进程是资源分配**的最小单元，**线程是CPU调度**的最小单元\n    \n    >进程=火车 线程=车厢\n* **线程在进程下进行**\n* 一个进程可以包含多个线程\n* 不同进程间数据很难共享\n>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。**进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源**，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。\n***\n\n### 守护线程\n* 守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。\n***\n\n### runable和callable的区别\n* Runnable接口中的**run()方法的返回值是void**，它做的事情只是**纯粹地去执行**run()方法中的代码而已；\n* Callable接口中的**call()方法是有返回值的**，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。\n***\n\n### sleep和wait的区别\n![sleep和wait](https://i.loli.net/2020/04/06/ekJtWQjuX1a6MgZ.png)\n* sleep()：方法是**线程类（Thread）的静态方法**，让调用线程**进入睡眠状态，让出执行机会给其他线程**，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程**虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象**。\n* wait()：**wait()是Object类的方法**，当一个线程执行到wait方法时，它就**进入**到一个和该对象相关的**等待池**，**同时释放对象的机锁**，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程\n***\n\n### 线程的 run()和 start()的区别\n>每个线程都是通过某个特定target对象所对应的方法**run()来完成其操作**的，**方法run()称为线程体**。通过调用Thread类的start()方法来启动一个线程。\n>**start()方法来启动一个线程，**真正实现了多线程运行。这时**无需等待run方法体代码执行完毕，可以直接继续执行下面的代码**； 这时此线程是**处于就绪状态， 并没有运行**。 然后通过此Thread类**调用方法run()来完成其运行状态**， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。\n>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。\n***\n\n### 线程池\n* <u><https://www.jianshu.com/p/7726c70cdc40></u>\n***\n\n### java程序中怎么保证多线程的运行安全\n* 线程安全在三个方面体现：\n    * 原子性：提供互斥访问，**同一时刻只能有一个线程对数据进行操作**\n    * 可见性：**一个线程对主内存的修改可以及时地被其他线程看到**，一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序\n    * 有序性：指程序在执行的时候，**程序的代码执行顺序和语句的顺序是一致的**\n***\n\n### 多线程锁的升级原理是什么\n* 在Java中，锁共有4种状态，级别从低到高依次为：**无状态锁，偏向锁，轻量级锁和重量级锁**状态，这几个状态会随着竞争情况逐渐升级。锁**可以升级但不能降级**。\n* 锁升级状态 [详解各种锁](http://ifeve.com/java-synchronized/)\n![锁升级状态](https://img-blog.csdnimg.cn/20190317183206697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70)\n***\n\n### Java的锁\n* [Java中的各种锁详细介绍](https://www.cnblogs.com/jyroy/p/11365935.html)\n    ![Java锁](https://img-blog.csdnimg.cn/20181122101753671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F4aWFvYm9nZQ==,size_16,color_FFFFFF,t_70)\n* 乐观锁 VS 悲观锁\n* 自旋锁 VS 适应性自旋锁\n* 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁\n* 公平锁 VS 非公平锁\n* 可重入锁 VS 非可重入锁\n* 独享锁 VS 共享锁#\n***\n\n### 什么是死锁\n* 死锁是指两个或两个以上的进程在执行过程中，**由于竞争资源或者由于彼此通信而造成的一种阻塞的现象**，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是**操作系统层面的一个错误**，是进程死锁的简称，\n* 死锁产生的四个必要条件：\n    * 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源\n    * 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放\n    * 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放\n    *环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系\n\n* 如何防止死锁\n        * 参照产生的四个必要条件，只要不满足其一，就可防止死锁\n***\n\n\n### ThreadLocal \n* **线程局部变量**是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。\n\n* [详解ThreadLocal](https://www.jianshu.com/p/3c5d7f09dfbd)\n***\n\n * **Servlet是线程不安全的**，在Servlet类中可能会定义共享的类变量，这样在并发的多线程访问的情况下，不同的线程对成员变量的修改会引发错误\n***\n\n### 同步和异步\n* 同步：如果数据在线程间共享，例如正在写的数据可能被另外一个线程读到，或者正在读的数据可能被另外一个线程写过了，那么这些数据就是共享数据，必须同步存取\n* 异步：当应用程序在对象上调用了一个需要花很长时间来执行的方法，并且不希望让程序等待方法的返回是，就应该使用异步编程，往往异步编程更有效率。\n***\n### 并行和并发\n* 并行是指多个事件在**同时刻**发生，并发是指多个事件在**同一时间间隔内**发生 \n* 并行是在**不同实体上的多个事件**，并发是指在**同一实体上的多个事件**\n    \n* 并发编程的目的是充分利用处理器的每一个核，以达到最高的处理性能。\n***\n\n\n\n>参考：https://blog.csdn.net/fangchao2011/article/details/89184943","slug":"code/JavaSE/JavaSE线程","published":1,"updated":"2020-05-01T12:11:10.000Z","comments":1,"layout":"post","link":"","_id":"cks5dy1gd004g0w7tdi3150d5","content":"<p>❄</p>\n<a id=\"more\"></a>\n\n<h3 id=\"创建进程的方式\"><a href=\"#创建进程的方式\" class=\"headerlink\" title=\"创建进程的方式\"></a>创建进程的方式</h3><ul>\n<li><p>继承Thread类创建线程类</p>\n<ol>\n<li><strong>定义Thread类的子类</strong>，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>\n<li>创建Thread子类的实例，即创建了线程对象。</li>\n<li>调用线程对象的start()方法来启动该线程。<br></li>\n</ol>\n</li>\n<li><p>通过Runnable接口创建线程类</p>\n<ol>\n<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>\n<li>创建 Runnable实现类的实例，并依此实例<strong>作为Thread的target</strong>来创建Thread对象，该Thread对象才是真正的线程对象。</li>\n<li>调用线程对象的start()方法来启动该线程。</li>\n</ol>\n</li>\n<li><p>通过Callable和Future创建线程</p>\n<ol>\n<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>\n<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>\n<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>\n<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><ul>\n<li><strong>创建状态</strong>。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</li>\n<li><strong>就绪状态</strong>。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li>\n<li><strong>运行状态</strong>。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>\n<li><strong>阻塞状态</strong>。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li>\n<li><strong>死亡状态</strong>。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 </li>\n</ul>\n<hr>\n<h3 id=\"并行和并发的区别\"><a href=\"#并行和并发的区别\" class=\"headerlink\" title=\"并行和并发的区别\"></a>并行和并发的区别</h3><ul>\n<li>并行是指两个或者多个事件在<strong>同一时刻</strong>发生；</li>\n<li>并发是指两个或多个事件在<strong>同一时间间隔</strong>发生。</li>\n<li>并行是在<strong>不同实体</strong>上的多个事件</li>\n<li>并发是在<strong>同一实体</strong>上的多个事件</li>\n</ul>\n<hr>\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><ul>\n<li>被它修饰的方法<strong>使其只能每次被单一的线程存取</strong>。</li>\n<li><del>修饰方法、对象、代码块</del></li>\n</ul>\n<hr>\n<h3 id=\"synchronized-和-volatile-的区别\"><a href=\"#synchronized-和-volatile-的区别\" class=\"headerlink\" title=\"synchronized 和 volatile 的区别\"></a>synchronized 和 volatile 的区别</h3><ul>\n<li>volatile本质是在<strong>告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取</strong>； synchronized则是<strong>锁定当前变量</strong>，只有当前线程可以访问该变量，其他线程被阻塞住。</li>\n<li>volatile仅能使用在<strong>变量级别</strong>；synchronized则可以使用在变量、方法、和类级别的。</li>\n<li>volatile仅能实现变量的修改可见性，<strong>不能保证原子性</strong>；而synchronized则可以保证变量的修改可见性和原子性。</li>\n<li>volatile<strong>不会造成线程的阻塞</strong>；synchronized可能会造成线程的阻塞。</li>\n<li>volatile<strong>标记的变量不会被编译器优化</strong>；synchronized标记的变量可以被编译器优化。</li>\n</ul>\n<hr>\n<h3 id=\"synchronized-和-Lock-的区别\"><a href=\"#synchronized-和-Lock-的区别\" class=\"headerlink\" title=\"synchronized 和 Lock 的区别\"></a>synchronized 和 Lock 的区别</h3><ul>\n<li>首先synchronized是<strong>java内置关键字</strong>，在jvm层面，<strong>Lock是个java类</strong>；</li>\n<li><strong>synchronized无法判断是否获取锁的状态</strong>，<strong>Lock可以判断是否获取到锁</strong>；</li>\n<li>synchronized会<strong>自动释放锁</strong>(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中<strong>手工释放锁</strong>（unlock()方法释放锁），否则容易造成线程死锁；</li>\n<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。<strong>如果线程1阻塞，线程2则会一直等待下去</strong>，而Lock锁就不一定会等待下去，如果<strong>尝试获取不到锁，线程可以不用一直等待就结束了</strong>；</li>\n<li>Lock锁<strong>适合大量同步的代码</strong>的同步问题，synchronized锁适合代码少量的同步问题。</li>\n<li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li>\n</ul>\n<hr>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><ul>\n<li><p><strong>进程是资源分配</strong>的最小单元，<strong>线程是CPU调度</strong>的最小单元</p>\n<blockquote>\n<p>进程=火车 线程=车厢</p>\n</blockquote>\n</li>\n<li><p><strong>线程在进程下进行</strong></p>\n</li>\n<li><p>一个进程可以包含多个线程</p>\n</li>\n<li><p>不同进程间数据很难共享</p>\n<blockquote>\n<p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。<strong>进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源</strong>，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><ul>\n<li>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</li>\n</ul>\n<hr>\n<h3 id=\"runable和callable的区别\"><a href=\"#runable和callable的区别\" class=\"headerlink\" title=\"runable和callable的区别\"></a>runable和callable的区别</h3><ul>\n<li>Runnable接口中的<strong>run()方法的返回值是void</strong>，它做的事情只是<strong>纯粹地去执行</strong>run()方法中的代码而已；</li>\n<li>Callable接口中的<strong>call()方法是有返回值的</strong>，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li>\n</ul>\n<hr>\n<h3 id=\"sleep和wait的区别\"><a href=\"#sleep和wait的区别\" class=\"headerlink\" title=\"sleep和wait的区别\"></a>sleep和wait的区别</h3><p><img src=\"https://i.loli.net/2020/04/06/ekJtWQjuX1a6MgZ.png\" alt=\"sleep和wait\"></p>\n<ul>\n<li>sleep()：方法是<strong>线程类（Thread）的静态方法</strong>，让调用线程<strong>进入睡眠状态，让出执行机会给其他线程</strong>，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程<strong>虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象</strong>。</li>\n<li>wait()：<strong>wait()是Object类的方法</strong>，当一个线程执行到wait方法时，它就<strong>进入</strong>到一个和该对象相关的<strong>等待池</strong>，<strong>同时释放对象的机锁</strong>，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</li>\n</ul>\n<hr>\n<h3 id=\"线程的-run-和-start-的区别\"><a href=\"#线程的-run-和-start-的区别\" class=\"headerlink\" title=\"线程的 run()和 start()的区别\"></a>线程的 run()和 start()的区别</h3><blockquote>\n<p>每个线程都是通过某个特定target对象所对应的方法<strong>run()来完成其操作</strong>的，<strong>方法run()称为线程体</strong>。通过调用Thread类的start()方法来启动一个线程。<br><strong>start()方法来启动一个线程，</strong>真正实现了多线程运行。这时<strong>无需等待run方法体代码执行完毕，可以直接继续执行下面的代码</strong>； 这时此线程是<strong>处于就绪状态， 并没有运行</strong>。 然后通过此Thread类<strong>调用方法run()来完成其运行状态</strong>， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>\n</blockquote>\n<hr>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><ul>\n<li><u><a href=\"https://www.jianshu.com/p/7726c70cdc40\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/7726c70cdc40</a></u></li>\n</ul>\n<hr>\n<h3 id=\"java程序中怎么保证多线程的运行安全\"><a href=\"#java程序中怎么保证多线程的运行安全\" class=\"headerlink\" title=\"java程序中怎么保证多线程的运行安全\"></a>java程序中怎么保证多线程的运行安全</h3><ul>\n<li>线程安全在三个方面体现：<ul>\n<li>原子性：提供互斥访问，<strong>同一时刻只能有一个线程对数据进行操作</strong></li>\n<li>可见性：<strong>一个线程对主内存的修改可以及时地被其他线程看到</strong>，一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序</li>\n<li>有序性：指程序在执行的时候，<strong>程序的代码执行顺序和语句的顺序是一致的</strong></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"多线程锁的升级原理是什么\"><a href=\"#多线程锁的升级原理是什么\" class=\"headerlink\" title=\"多线程锁的升级原理是什么\"></a>多线程锁的升级原理是什么</h3><ul>\n<li>在Java中，锁共有4种状态，级别从低到高依次为：<strong>无状态锁，偏向锁，轻量级锁和重量级锁</strong>状态，这几个状态会随着竞争情况逐渐升级。锁<strong>可以升级但不能降级</strong>。</li>\n<li>锁升级状态 <a href=\"http://ifeve.com/java-synchronized/\" target=\"_blank\" rel=\"noopener\">详解各种锁</a><br><img src=\"https://img-blog.csdnimg.cn/20190317183206697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70\" alt=\"锁升级状态\"></li>\n</ul>\n<hr>\n<h3 id=\"Java的锁\"><a href=\"#Java的锁\" class=\"headerlink\" title=\"Java的锁\"></a>Java的锁</h3><ul>\n<li><a href=\"https://www.cnblogs.com/jyroy/p/11365935.html\" target=\"_blank\" rel=\"noopener\">Java中的各种锁详细介绍</a><br>  <img src=\"https://img-blog.csdnimg.cn/20181122101753671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F4aWFvYm9nZQ==,size_16,color_FFFFFF,t_70\" alt=\"Java锁\"></li>\n<li>乐观锁 VS 悲观锁</li>\n<li>自旋锁 VS 适应性自旋锁</li>\n<li>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</li>\n<li>公平锁 VS 非公平锁</li>\n<li>可重入锁 VS 非可重入锁</li>\n<li>独享锁 VS 共享锁#</li>\n</ul>\n<hr>\n<h3 id=\"什么是死锁\"><a href=\"#什么是死锁\" class=\"headerlink\" title=\"什么是死锁\"></a>什么是死锁</h3><ul>\n<li><p>死锁是指两个或两个以上的进程在执行过程中，<strong>由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</strong>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是<strong>操作系统层面的一个错误</strong>，是进程死锁的简称，</p>\n</li>\n<li><p>死锁产生的四个必要条件：</p>\n<ul>\n<li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li>\n<li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li>\n<li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li>\n<li>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li>\n</ul>\n</li>\n<li><p>如何防止死锁</p>\n<pre><code>  * 参照产生的四个必要条件，只要不满足其一，就可防止死锁</code></pre></li>\n</ul>\n<hr>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><ul>\n<li><p><strong>线程局部变量</strong>是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/3c5d7f09dfbd\" target=\"_blank\" rel=\"noopener\">详解ThreadLocal</a></p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><strong>Servlet是线程不安全的</strong>，在Servlet类中可能会定义共享的类变量，这样在并发的多线程访问的情况下，不同的线程对成员变量的修改会引发错误</li>\n</ul>\n<hr>\n<h3 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h3><ul>\n<li>同步：如果数据在线程间共享，例如正在写的数据可能被另外一个线程读到，或者正在读的数据可能被另外一个线程写过了，那么这些数据就是共享数据，必须同步存取</li>\n<li>异步：当应用程序在对象上调用了一个需要花很长时间来执行的方法，并且不希望让程序等待方法的返回是，就应该使用异步编程，往往异步编程更有效率。</li>\n</ul>\n<hr>\n<h3 id=\"并行和并发\"><a href=\"#并行和并发\" class=\"headerlink\" title=\"并行和并发\"></a>并行和并发</h3><ul>\n<li><p>并行是指多个事件在<strong>同时刻</strong>发生，并发是指多个事件在<strong>同一时间间隔内</strong>发生 </p>\n</li>\n<li><p>并行是在<strong>不同实体上的多个事件</strong>，并发是指在<strong>同一实体上的多个事件</strong></p>\n</li>\n<li><p>并发编程的目的是充分利用处理器的每一个核，以达到最高的处理性能。</p>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/fangchao2011/article/details/89184943\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/fangchao2011/article/details/89184943</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>❄</p>","more":"<h3 id=\"创建进程的方式\"><a href=\"#创建进程的方式\" class=\"headerlink\" title=\"创建进程的方式\"></a>创建进程的方式</h3><ul>\n<li><p>继承Thread类创建线程类</p>\n<ol>\n<li><strong>定义Thread类的子类</strong>，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>\n<li>创建Thread子类的实例，即创建了线程对象。</li>\n<li>调用线程对象的start()方法来启动该线程。<br></li>\n</ol>\n</li>\n<li><p>通过Runnable接口创建线程类</p>\n<ol>\n<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>\n<li>创建 Runnable实现类的实例，并依此实例<strong>作为Thread的target</strong>来创建Thread对象，该Thread对象才是真正的线程对象。</li>\n<li>调用线程对象的start()方法来启动该线程。</li>\n</ol>\n</li>\n<li><p>通过Callable和Future创建线程</p>\n<ol>\n<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>\n<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>\n<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>\n<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h3><ul>\n<li><strong>创建状态</strong>。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</li>\n<li><strong>就绪状态</strong>。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li>\n<li><strong>运行状态</strong>。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>\n<li><strong>阻塞状态</strong>。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li>\n<li><strong>死亡状态</strong>。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 </li>\n</ul>\n<hr>\n<h3 id=\"并行和并发的区别\"><a href=\"#并行和并发的区别\" class=\"headerlink\" title=\"并行和并发的区别\"></a>并行和并发的区别</h3><ul>\n<li>并行是指两个或者多个事件在<strong>同一时刻</strong>发生；</li>\n<li>并发是指两个或多个事件在<strong>同一时间间隔</strong>发生。</li>\n<li>并行是在<strong>不同实体</strong>上的多个事件</li>\n<li>并发是在<strong>同一实体</strong>上的多个事件</li>\n</ul>\n<hr>\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><ul>\n<li>被它修饰的方法<strong>使其只能每次被单一的线程存取</strong>。</li>\n<li><del>修饰方法、对象、代码块</del></li>\n</ul>\n<hr>\n<h3 id=\"synchronized-和-volatile-的区别\"><a href=\"#synchronized-和-volatile-的区别\" class=\"headerlink\" title=\"synchronized 和 volatile 的区别\"></a>synchronized 和 volatile 的区别</h3><ul>\n<li>volatile本质是在<strong>告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取</strong>； synchronized则是<strong>锁定当前变量</strong>，只有当前线程可以访问该变量，其他线程被阻塞住。</li>\n<li>volatile仅能使用在<strong>变量级别</strong>；synchronized则可以使用在变量、方法、和类级别的。</li>\n<li>volatile仅能实现变量的修改可见性，<strong>不能保证原子性</strong>；而synchronized则可以保证变量的修改可见性和原子性。</li>\n<li>volatile<strong>不会造成线程的阻塞</strong>；synchronized可能会造成线程的阻塞。</li>\n<li>volatile<strong>标记的变量不会被编译器优化</strong>；synchronized标记的变量可以被编译器优化。</li>\n</ul>\n<hr>\n<h3 id=\"synchronized-和-Lock-的区别\"><a href=\"#synchronized-和-Lock-的区别\" class=\"headerlink\" title=\"synchronized 和 Lock 的区别\"></a>synchronized 和 Lock 的区别</h3><ul>\n<li>首先synchronized是<strong>java内置关键字</strong>，在jvm层面，<strong>Lock是个java类</strong>；</li>\n<li><strong>synchronized无法判断是否获取锁的状态</strong>，<strong>Lock可以判断是否获取到锁</strong>；</li>\n<li>synchronized会<strong>自动释放锁</strong>(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中<strong>手工释放锁</strong>（unlock()方法释放锁），否则容易造成线程死锁；</li>\n<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。<strong>如果线程1阻塞，线程2则会一直等待下去</strong>，而Lock锁就不一定会等待下去，如果<strong>尝试获取不到锁，线程可以不用一直等待就结束了</strong>；</li>\n<li>Lock锁<strong>适合大量同步的代码</strong>的同步问题，synchronized锁适合代码少量的同步问题。</li>\n<li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li>\n</ul>\n<hr>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><ul>\n<li><p><strong>进程是资源分配</strong>的最小单元，<strong>线程是CPU调度</strong>的最小单元</p>\n<blockquote>\n<p>进程=火车 线程=车厢</p>\n</blockquote>\n</li>\n<li><p><strong>线程在进程下进行</strong></p>\n</li>\n<li><p>一个进程可以包含多个线程</p>\n</li>\n<li><p>不同进程间数据很难共享</p>\n<blockquote>\n<p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。<strong>进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源</strong>，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><ul>\n<li>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</li>\n</ul>\n<hr>\n<h3 id=\"runable和callable的区别\"><a href=\"#runable和callable的区别\" class=\"headerlink\" title=\"runable和callable的区别\"></a>runable和callable的区别</h3><ul>\n<li>Runnable接口中的<strong>run()方法的返回值是void</strong>，它做的事情只是<strong>纯粹地去执行</strong>run()方法中的代码而已；</li>\n<li>Callable接口中的<strong>call()方法是有返回值的</strong>，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li>\n</ul>\n<hr>\n<h3 id=\"sleep和wait的区别\"><a href=\"#sleep和wait的区别\" class=\"headerlink\" title=\"sleep和wait的区别\"></a>sleep和wait的区别</h3><p><img src=\"https://i.loli.net/2020/04/06/ekJtWQjuX1a6MgZ.png\" alt=\"sleep和wait\"></p>\n<ul>\n<li>sleep()：方法是<strong>线程类（Thread）的静态方法</strong>，让调用线程<strong>进入睡眠状态，让出执行机会给其他线程</strong>，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程<strong>虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象</strong>。</li>\n<li>wait()：<strong>wait()是Object类的方法</strong>，当一个线程执行到wait方法时，它就<strong>进入</strong>到一个和该对象相关的<strong>等待池</strong>，<strong>同时释放对象的机锁</strong>，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</li>\n</ul>\n<hr>\n<h3 id=\"线程的-run-和-start-的区别\"><a href=\"#线程的-run-和-start-的区别\" class=\"headerlink\" title=\"线程的 run()和 start()的区别\"></a>线程的 run()和 start()的区别</h3><blockquote>\n<p>每个线程都是通过某个特定target对象所对应的方法<strong>run()来完成其操作</strong>的，<strong>方法run()称为线程体</strong>。通过调用Thread类的start()方法来启动一个线程。<br><strong>start()方法来启动一个线程，</strong>真正实现了多线程运行。这时<strong>无需等待run方法体代码执行完毕，可以直接继续执行下面的代码</strong>； 这时此线程是<strong>处于就绪状态， 并没有运行</strong>。 然后通过此Thread类<strong>调用方法run()来完成其运行状态</strong>， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>\n</blockquote>\n<hr>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><ul>\n<li><u><a href=\"https://www.jianshu.com/p/7726c70cdc40\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/7726c70cdc40</a></u></li>\n</ul>\n<hr>\n<h3 id=\"java程序中怎么保证多线程的运行安全\"><a href=\"#java程序中怎么保证多线程的运行安全\" class=\"headerlink\" title=\"java程序中怎么保证多线程的运行安全\"></a>java程序中怎么保证多线程的运行安全</h3><ul>\n<li>线程安全在三个方面体现：<ul>\n<li>原子性：提供互斥访问，<strong>同一时刻只能有一个线程对数据进行操作</strong></li>\n<li>可见性：<strong>一个线程对主内存的修改可以及时地被其他线程看到</strong>，一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序</li>\n<li>有序性：指程序在执行的时候，<strong>程序的代码执行顺序和语句的顺序是一致的</strong></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"多线程锁的升级原理是什么\"><a href=\"#多线程锁的升级原理是什么\" class=\"headerlink\" title=\"多线程锁的升级原理是什么\"></a>多线程锁的升级原理是什么</h3><ul>\n<li>在Java中，锁共有4种状态，级别从低到高依次为：<strong>无状态锁，偏向锁，轻量级锁和重量级锁</strong>状态，这几个状态会随着竞争情况逐渐升级。锁<strong>可以升级但不能降级</strong>。</li>\n<li>锁升级状态 <a href=\"http://ifeve.com/java-synchronized/\" target=\"_blank\" rel=\"noopener\">详解各种锁</a><br><img src=\"https://img-blog.csdnimg.cn/20190317183206697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70\" alt=\"锁升级状态\"></li>\n</ul>\n<hr>\n<h3 id=\"Java的锁\"><a href=\"#Java的锁\" class=\"headerlink\" title=\"Java的锁\"></a>Java的锁</h3><ul>\n<li><a href=\"https://www.cnblogs.com/jyroy/p/11365935.html\" target=\"_blank\" rel=\"noopener\">Java中的各种锁详细介绍</a><br>  <img src=\"https://img-blog.csdnimg.cn/20181122101753671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F4aWFvYm9nZQ==,size_16,color_FFFFFF,t_70\" alt=\"Java锁\"></li>\n<li>乐观锁 VS 悲观锁</li>\n<li>自旋锁 VS 适应性自旋锁</li>\n<li>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</li>\n<li>公平锁 VS 非公平锁</li>\n<li>可重入锁 VS 非可重入锁</li>\n<li>独享锁 VS 共享锁#</li>\n</ul>\n<hr>\n<h3 id=\"什么是死锁\"><a href=\"#什么是死锁\" class=\"headerlink\" title=\"什么是死锁\"></a>什么是死锁</h3><ul>\n<li><p>死锁是指两个或两个以上的进程在执行过程中，<strong>由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</strong>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是<strong>操作系统层面的一个错误</strong>，是进程死锁的简称，</p>\n</li>\n<li><p>死锁产生的四个必要条件：</p>\n<ul>\n<li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li>\n<li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li>\n<li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li>\n<li>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li>\n</ul>\n</li>\n<li><p>如何防止死锁</p>\n<pre><code>  * 参照产生的四个必要条件，只要不满足其一，就可防止死锁</code></pre></li>\n</ul>\n<hr>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><ul>\n<li><p><strong>线程局部变量</strong>是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/3c5d7f09dfbd\" target=\"_blank\" rel=\"noopener\">详解ThreadLocal</a></p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><strong>Servlet是线程不安全的</strong>，在Servlet类中可能会定义共享的类变量，这样在并发的多线程访问的情况下，不同的线程对成员变量的修改会引发错误</li>\n</ul>\n<hr>\n<h3 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h3><ul>\n<li>同步：如果数据在线程间共享，例如正在写的数据可能被另外一个线程读到，或者正在读的数据可能被另外一个线程写过了，那么这些数据就是共享数据，必须同步存取</li>\n<li>异步：当应用程序在对象上调用了一个需要花很长时间来执行的方法，并且不希望让程序等待方法的返回是，就应该使用异步编程，往往异步编程更有效率。</li>\n</ul>\n<hr>\n<h3 id=\"并行和并发\"><a href=\"#并行和并发\" class=\"headerlink\" title=\"并行和并发\"></a>并行和并发</h3><ul>\n<li><p>并行是指多个事件在<strong>同时刻</strong>发生，并发是指多个事件在<strong>同一时间间隔内</strong>发生 </p>\n</li>\n<li><p>并行是在<strong>不同实体上的多个事件</strong>，并发是指在<strong>同一实体上的多个事件</strong></p>\n</li>\n<li><p>并发编程的目的是充分利用处理器的每一个核，以达到最高的处理性能。</p>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/fangchao2011/article/details/89184943\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/fangchao2011/article/details/89184943</a></p>\n</blockquote>"},{"title":"数组复制","declare":true,"wordCount":true,"abbrlink":"f135954a","date":"2020-12-05T14:37:10.000Z","_content":"\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/12/05/h3a7d4mZgMJquIU.png\" alt=\"数组复制\" width=\"66%\"/>\n</div>\n\n<!-- more -->\n\n在谈数组复制之前，先回忆一下浅拷贝和深拷贝：    \n- 浅拷贝是指**将引用复制给一个变量，即只是增加一个指针指向目标内存地址**     \n- 深拷贝是指**用新开辟的内存空间拷贝目标对象后，让变量指向这个新的内存地址**       \n\n所以，浅拷贝后，**如果新旧任一变量对应的对象发生变动时，另一变量也将变动**，而深拷贝不会，因为指向的是不同的对象。   \n\n首先无论是对于基本类型数组还是对象类型数组，**一般是不能够使用`=`直接复制的**，因为这样只是将引用复制给变量，**指向的还是同一个数组。**\n\nJava中对于基本类型的数组复制时，复制时因为没有对象的概念，所以不必考虑深拷贝还是浅拷贝，**复制后都是两个变量指向不同的数组对象。** 当然是实际上**都是深拷贝**。\n\n而对于对象类型的数组时，则**都是浅拷贝**，因为设计时，深拷贝的使用场景相对较少而且性能很差，如果的确需要深拷贝时，单独实现即可。\n> 特别的，对于String类，由于其不可变性，String类型的数组的拷贝可以理解为都是**深拷贝**。\n\nJava数组的复制有如下四种方式：\n## 1. Object.clone()\n此方法是数组对象从Object类继承过来的。\n```java\n    int[] arr1 = {1, 2, 3};\n    int[] arr2 = arr1.clone();\n```\n\n## 2. System.arraycopy()\n此方法内部调用的是一个native方法          \n`public static native void arraycopy(Object src, int  srcPos,Object dest, int destPos, int length);`      \n内部参数分别为 源数组、 拷贝开始位置、 目标数组、 粘贴开始位置、 拷贝个数\n```java\n    int[] arr3 = {1, 2, 3};\n    int[] arr4 = new int[3];\n    System.arraycopy(arr3, 0, arr4, 0, arr3.length);\n```\n\n## 3. Arrays.copyOf()\n此方法内部也是调用了`System.arraycopy()`方法    \n`public static int[] copyOf(int[] original, int newLength) {}`, 第一个参数为源数组，第二个参数为拷贝长度。\n```java\n    int[] arr5 = {1, 2, 3};\n    int[] arr6 = Arrays.copyOf(arr5, arr5.length);\n```\n\n## 4. Arrays.copyOfRange()\n内部同样也是调用了`System.arraycopy()`方法    \n`public static int[] copyOfRange(int[] original, int from, int to){}`,第一个参数为源数组，第二个参数为拷贝起始位置，第三个参数为拷贝结束位置（不包含）。\n```java\n    int[] arr7 = {1, 2, 3};\n    int[] arr8 = Arrays.copyOfRange(arr7, 0, arr7.length); //左闭右开\n```\n\n\n\n","source":"_posts/code/JavaSE/数组复制.md","raw":"---\ntitle: 数组复制\ncategories: Code\ntags: JavaSE\ndeclare: true\nwordCount: true\nabbrlink: f135954a\ndate: 2020-12-05 22:37:10\n---\n\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/12/05/h3a7d4mZgMJquIU.png\" alt=\"数组复制\" width=\"66%\"/>\n</div>\n\n<!-- more -->\n\n在谈数组复制之前，先回忆一下浅拷贝和深拷贝：    \n- 浅拷贝是指**将引用复制给一个变量，即只是增加一个指针指向目标内存地址**     \n- 深拷贝是指**用新开辟的内存空间拷贝目标对象后，让变量指向这个新的内存地址**       \n\n所以，浅拷贝后，**如果新旧任一变量对应的对象发生变动时，另一变量也将变动**，而深拷贝不会，因为指向的是不同的对象。   \n\n首先无论是对于基本类型数组还是对象类型数组，**一般是不能够使用`=`直接复制的**，因为这样只是将引用复制给变量，**指向的还是同一个数组。**\n\nJava中对于基本类型的数组复制时，复制时因为没有对象的概念，所以不必考虑深拷贝还是浅拷贝，**复制后都是两个变量指向不同的数组对象。** 当然是实际上**都是深拷贝**。\n\n而对于对象类型的数组时，则**都是浅拷贝**，因为设计时，深拷贝的使用场景相对较少而且性能很差，如果的确需要深拷贝时，单独实现即可。\n> 特别的，对于String类，由于其不可变性，String类型的数组的拷贝可以理解为都是**深拷贝**。\n\nJava数组的复制有如下四种方式：\n## 1. Object.clone()\n此方法是数组对象从Object类继承过来的。\n```java\n    int[] arr1 = {1, 2, 3};\n    int[] arr2 = arr1.clone();\n```\n\n## 2. System.arraycopy()\n此方法内部调用的是一个native方法          \n`public static native void arraycopy(Object src, int  srcPos,Object dest, int destPos, int length);`      \n内部参数分别为 源数组、 拷贝开始位置、 目标数组、 粘贴开始位置、 拷贝个数\n```java\n    int[] arr3 = {1, 2, 3};\n    int[] arr4 = new int[3];\n    System.arraycopy(arr3, 0, arr4, 0, arr3.length);\n```\n\n## 3. Arrays.copyOf()\n此方法内部也是调用了`System.arraycopy()`方法    \n`public static int[] copyOf(int[] original, int newLength) {}`, 第一个参数为源数组，第二个参数为拷贝长度。\n```java\n    int[] arr5 = {1, 2, 3};\n    int[] arr6 = Arrays.copyOf(arr5, arr5.length);\n```\n\n## 4. Arrays.copyOfRange()\n内部同样也是调用了`System.arraycopy()`方法    \n`public static int[] copyOfRange(int[] original, int from, int to){}`,第一个参数为源数组，第二个参数为拷贝起始位置，第三个参数为拷贝结束位置（不包含）。\n```java\n    int[] arr7 = {1, 2, 3};\n    int[] arr8 = Arrays.copyOfRange(arr7, 0, arr7.length); //左闭右开\n```\n\n\n\n","slug":"code/JavaSE/数组复制","published":1,"updated":"2020-12-06T05:27:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gd004j0w7tepk61d4r","content":"<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/12/05/h3a7d4mZgMJquIU.png\" alt=\"数组复制\" width=\"66%\"/>\n</div>\n\n<a id=\"more\"></a>\n\n<p>在谈数组复制之前，先回忆一下浅拷贝和深拷贝：    </p>\n<ul>\n<li>浅拷贝是指<strong>将引用复制给一个变量，即只是增加一个指针指向目标内存地址</strong>     </li>\n<li>深拷贝是指<strong>用新开辟的内存空间拷贝目标对象后，让变量指向这个新的内存地址</strong>       </li>\n</ul>\n<p>所以，浅拷贝后，<strong>如果新旧任一变量对应的对象发生变动时，另一变量也将变动</strong>，而深拷贝不会，因为指向的是不同的对象。   </p>\n<p>首先无论是对于基本类型数组还是对象类型数组，<strong>一般是不能够使用<code>=</code>直接复制的</strong>，因为这样只是将引用复制给变量，<strong>指向的还是同一个数组。</strong></p>\n<p>Java中对于基本类型的数组复制时，复制时因为没有对象的概念，所以不必考虑深拷贝还是浅拷贝，<strong>复制后都是两个变量指向不同的数组对象。</strong> 当然是实际上<strong>都是深拷贝</strong>。</p>\n<p>而对于对象类型的数组时，则<strong>都是浅拷贝</strong>，因为设计时，深拷贝的使用场景相对较少而且性能很差，如果的确需要深拷贝时，单独实现即可。</p>\n<blockquote>\n<p>特别的，对于String类，由于其不可变性，String类型的数组的拷贝可以理解为都是<strong>深拷贝</strong>。</p>\n</blockquote>\n<p>Java数组的复制有如下四种方式：</p>\n<h2 id=\"1-Object-clone\"><a href=\"#1-Object-clone\" class=\"headerlink\" title=\"1. Object.clone()\"></a>1. Object.clone()</h2><p>此方法是数组对象从Object类继承过来的。</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr2 <span class=\"token operator\">=</span> arr1<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"2-System-arraycopy\"><a href=\"#2-System-arraycopy\" class=\"headerlink\" title=\"2. System.arraycopy()\"></a>2. System.arraycopy()</h2><p>此方法内部调用的是一个native方法<br><code>public static native void arraycopy(Object src, int  srcPos,Object dest, int destPos, int length);</code><br>内部参数分别为 源数组、 拷贝开始位置、 目标数组、 粘贴开始位置、 拷贝个数</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>arr3<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> arr4<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> arr3<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"3-Arrays-copyOf\"><a href=\"#3-Arrays-copyOf\" class=\"headerlink\" title=\"3. Arrays.copyOf()\"></a>3. Arrays.copyOf()</h2><p>此方法内部也是调用了<code>System.arraycopy()</code>方法<br><code>public static int[] copyOf(int[] original, int newLength) {}</code>, 第一个参数为源数组，第二个参数为拷贝长度。</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr5 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr6 <span class=\"token operator\">=</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>arr5<span class=\"token punctuation\">,</span> arr5<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"4-Arrays-copyOfRange\"><a href=\"#4-Arrays-copyOfRange\" class=\"headerlink\" title=\"4. Arrays.copyOfRange()\"></a>4. Arrays.copyOfRange()</h2><p>内部同样也是调用了<code>System.arraycopy()</code>方法<br><code>public static int[] copyOfRange(int[] original, int from, int to){}</code>,第一个参数为源数组，第二个参数为拷贝起始位置，第三个参数为拷贝结束位置（不包含）。</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr7 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr8 <span class=\"token operator\">=</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">copyOfRange</span><span class=\"token punctuation\">(</span>arr7<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> arr7<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//左闭右开</span></code></pre>\n","site":{"data":{}},"excerpt":"<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/12/05/h3a7d4mZgMJquIU.png\" alt=\"数组复制\" width=\"66%\"/>\n</div>","more":"<p>在谈数组复制之前，先回忆一下浅拷贝和深拷贝：    </p>\n<ul>\n<li>浅拷贝是指<strong>将引用复制给一个变量，即只是增加一个指针指向目标内存地址</strong>     </li>\n<li>深拷贝是指<strong>用新开辟的内存空间拷贝目标对象后，让变量指向这个新的内存地址</strong>       </li>\n</ul>\n<p>所以，浅拷贝后，<strong>如果新旧任一变量对应的对象发生变动时，另一变量也将变动</strong>，而深拷贝不会，因为指向的是不同的对象。   </p>\n<p>首先无论是对于基本类型数组还是对象类型数组，<strong>一般是不能够使用<code>=</code>直接复制的</strong>，因为这样只是将引用复制给变量，<strong>指向的还是同一个数组。</strong></p>\n<p>Java中对于基本类型的数组复制时，复制时因为没有对象的概念，所以不必考虑深拷贝还是浅拷贝，<strong>复制后都是两个变量指向不同的数组对象。</strong> 当然是实际上<strong>都是深拷贝</strong>。</p>\n<p>而对于对象类型的数组时，则<strong>都是浅拷贝</strong>，因为设计时，深拷贝的使用场景相对较少而且性能很差，如果的确需要深拷贝时，单独实现即可。</p>\n<blockquote>\n<p>特别的，对于String类，由于其不可变性，String类型的数组的拷贝可以理解为都是<strong>深拷贝</strong>。</p>\n</blockquote>\n<p>Java数组的复制有如下四种方式：</p>\n<h2 id=\"1-Object-clone\"><a href=\"#1-Object-clone\" class=\"headerlink\" title=\"1. Object.clone()\"></a>1. Object.clone()</h2><p>此方法是数组对象从Object类继承过来的。</p>\n<pre><code class=\"java\">    int[] arr1 = {1, 2, 3};\n    int[] arr2 = arr1.clone();</code></pre>\n<h2 id=\"2-System-arraycopy\"><a href=\"#2-System-arraycopy\" class=\"headerlink\" title=\"2. System.arraycopy()\"></a>2. System.arraycopy()</h2><p>此方法内部调用的是一个native方法<br><code>public static native void arraycopy(Object src, int  srcPos,Object dest, int destPos, int length);</code><br>内部参数分别为 源数组、 拷贝开始位置、 目标数组、 粘贴开始位置、 拷贝个数</p>\n<pre><code class=\"java\">    int[] arr3 = {1, 2, 3};\n    int[] arr4 = new int[3];\n    System.arraycopy(arr3, 0, arr4, 0, arr3.length);</code></pre>\n<h2 id=\"3-Arrays-copyOf\"><a href=\"#3-Arrays-copyOf\" class=\"headerlink\" title=\"3. Arrays.copyOf()\"></a>3. Arrays.copyOf()</h2><p>此方法内部也是调用了<code>System.arraycopy()</code>方法<br><code>public static int[] copyOf(int[] original, int newLength) {}</code>, 第一个参数为源数组，第二个参数为拷贝长度。</p>\n<pre><code class=\"java\">    int[] arr5 = {1, 2, 3};\n    int[] arr6 = Arrays.copyOf(arr5, arr5.length);</code></pre>\n<h2 id=\"4-Arrays-copyOfRange\"><a href=\"#4-Arrays-copyOfRange\" class=\"headerlink\" title=\"4. Arrays.copyOfRange()\"></a>4. Arrays.copyOfRange()</h2><p>内部同样也是调用了<code>System.arraycopy()</code>方法<br><code>public static int[] copyOfRange(int[] original, int from, int to){}</code>,第一个参数为源数组，第二个参数为拷贝起始位置，第三个参数为拷贝结束位置（不包含）。</p>\n<pre><code class=\"java\">    int[] arr7 = {1, 2, 3};\n    int[] arr8 = Arrays.copyOfRange(arr7, 0, arr7.length); //左闭右开</code></pre>"},{"title":"重写HashCode()","data":"2020-4-24 23:15","abbrlink":60908,"declare":true,"wordCount":true,"_content":"重写HashCode方法并无绝对的标准答案，只要满足一个原则即可，即**相同对象的Hashcode必须相同**。\n\n<br>\n<!-- more -->\n    \n### 重写原因\n* SpringBoot Data Jpa domian类设置关联主键时需要重写hashcode()和equals()方法   \n* 判断两个两个对象相等时需要重写hashcode()和equals()方法。\n    * 因为如果两个对象的引用相同，他们之前互相调用equals()为true即两个对象相同。如果不重写hashCode()方法，系统默认的hashCode()是本地计算对象的内存地址（经哈希算法），此时不会相同。就会产生矛盾。\n\n        >两个对象equals相等，则它们的hashcode必须相等，反之则不一定。\n        >两个对象=相等，则其hashcode一定相等，反之亦然。\n        >两个对象\\==相等，则其hashcode一定相等，反之不一定成立。 //有可能是Integer对象比较之类的\n        >两个对象==相等，则其hashcode一定相等，反之不一定成立。\n\n### 重写方法\n* 第一步：取一个初值，一般取17\n    `int code=17;`\n* 第二步：解析类中与equals()相关的字段(如果某些字段值都相同，则没必要计算)\n    * 字段a类型为boolean 则`[hashCode] = a ? 1 : 0;`\n    * 字段b类型为byte/short/int/char, 则`[hashCode] = (int)b;`\n    * 字段c类型为long， 则`[hashCode] = (int) (c ^ c>>>32);`\n    * 字段d类型为float, 则`[hashCode] = d.hashCode()`(内部调用的是Float.hashCode(d)， 而该静态方法内部调用的另一个静态方法是Float.floatToIntBits(d))\n    * 字段e类型为double, 则`[hashCode] = e.hashCode()`(内部调用的是Double.hashCode(e)， 而该静态方法内部调用的另一个静态方法是Double.doubleToLongBits(e),得到一个long类型的值之后，跟情况三进行类似的操作，得到一个int类型的值)\n    * 引用类型，若为null则hashCode为0,否则`递归调用该引用类型的hashCode()`。\n    * 数组类型。(要获取数组类型的hashCode,可采用如下方法：`s[0]*31 ^ (n-1) + s[1] * 31 ^ (n-2) + ..... + s[n-1]`， 该方法正是String类的hashCode实现所采用的算法）\n* 第三步：整合\n    * `code = code * 31 + [hashCode]`;\n<br>\n\n### 注意\n* **如果重写hashcode方法是用到了对象类型，那么该对象类型也必须要重写hashcode()方法**，否则每次得到的hashcode值不一定一致，那么重写hashcode方法的意义就不大了\n* 如果初始值result不取17而取0的话，则对于hashCode为0的字段来说就没有区分度了，这样更容易产生冲突。比如两个自定义类中，一个类比另一个类多出来一个或者几个字段，其余字段全部一样，分别new出来2个对象，这2个对象共有的字段的值全是一样的，而对于多来的那些字段的值正好都是0,并且在计算hashCode时这些多出来的字段又是最先计算的，这样的话，则这两个对象的hashCode就会产生冲突。\n    >多出来的字段hashCode为0，且先计算则 多出来的字段哈希和为 0*31+hashcode(多出字段的值)= 0 (初始code为0)，这样加上共同对象产生的计算结果和较少字段那个对象冲突\n* **不能包含equals方法中没有的字段**，否则会导致相等的对象可能会有不同的哈希值。（即对类中每一个重要字段，也就是影响对象的值的字段，也就是equals方法里有比较的字段，进行操作）\n* String对象和Bigdecimal对象已经重写了hashcode方法，这些类型的值可以直接用于重写hashcode方法；(上述的是Java八中基本数据类型，这两个是封装类型)\n* `code = 31 code + (dishCode !=null ?dishCode.hashCode() : 0);`，这里面为啥用个31来计算，而且很多人都是这么写的，这是因为**31是个神奇的数字，任何数n*31都可以被jvm优化为(n<<5)-n，移位和减法的操作效率比乘法的操作效率高很多**.\n* Google首席Java架构师Joshua Bloch在他的著作《Effective Java》中提出了一种简单通用的hashCode算法：\n\n    * 初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;\n\n    * 如果是对象应用（例如有String类型的字段），如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候（即 String a = null 时），那么hashCode值为0\n\n \n### demo\n```java\n    Class User {\n        private String name;\n        private String password;\n\n        //get() \n        //set()方法\n\n        @Override\n            public boolean equals(Object o) {\n            if (this == o) return true; //如果两个直接相等，就不用比较了\n            if (o == null || getClass() != o.getClass()) return false; //o.getClass() 因为Object 是类似接口（父类） 所以判断o是否是User类，\n            UserWrite userWrite = (UserWrite) o;\n            return Objects.equals(name, userWrite.name) &&\n                    Objects.equals(password, userWrite.password);\n        }\n\n        @Override\n        public int hashCode() {\n            int code = 17;\n            code = code * 31 + (name != null ? name.hashCode() : 0);\n            code = code * 31 + (password != null ? password.hashCode() : 0);\n            return code;\n        }\n    }\n```\n\n参考:\n1. <https://www.cnblogs.com/stitchZsx/p/9558843.html>\n2. <https://blog.csdn.net/zhengchao1991/article/details/78916471>","source":"_posts/code/JavaSE/Overwriter HashCode().md","raw":"---\ntitle: 重写HashCode()\ndata: '2020-4-24 23:15'\ncategories: Code\ntags: JavaSE\n# photos:\n#   - - 'https://i.loli.net/2020/04/26/5lHToksgpxCIK9m.png'\nabbrlink: 60908\ndeclare: true\nwordCount: true\n---\n重写HashCode方法并无绝对的标准答案，只要满足一个原则即可，即**相同对象的Hashcode必须相同**。\n\n<br>\n<!-- more -->\n    \n### 重写原因\n* SpringBoot Data Jpa domian类设置关联主键时需要重写hashcode()和equals()方法   \n* 判断两个两个对象相等时需要重写hashcode()和equals()方法。\n    * 因为如果两个对象的引用相同，他们之前互相调用equals()为true即两个对象相同。如果不重写hashCode()方法，系统默认的hashCode()是本地计算对象的内存地址（经哈希算法），此时不会相同。就会产生矛盾。\n\n        >两个对象equals相等，则它们的hashcode必须相等，反之则不一定。\n        >两个对象=相等，则其hashcode一定相等，反之亦然。\n        >两个对象\\==相等，则其hashcode一定相等，反之不一定成立。 //有可能是Integer对象比较之类的\n        >两个对象==相等，则其hashcode一定相等，反之不一定成立。\n\n### 重写方法\n* 第一步：取一个初值，一般取17\n    `int code=17;`\n* 第二步：解析类中与equals()相关的字段(如果某些字段值都相同，则没必要计算)\n    * 字段a类型为boolean 则`[hashCode] = a ? 1 : 0;`\n    * 字段b类型为byte/short/int/char, 则`[hashCode] = (int)b;`\n    * 字段c类型为long， 则`[hashCode] = (int) (c ^ c>>>32);`\n    * 字段d类型为float, 则`[hashCode] = d.hashCode()`(内部调用的是Float.hashCode(d)， 而该静态方法内部调用的另一个静态方法是Float.floatToIntBits(d))\n    * 字段e类型为double, 则`[hashCode] = e.hashCode()`(内部调用的是Double.hashCode(e)， 而该静态方法内部调用的另一个静态方法是Double.doubleToLongBits(e),得到一个long类型的值之后，跟情况三进行类似的操作，得到一个int类型的值)\n    * 引用类型，若为null则hashCode为0,否则`递归调用该引用类型的hashCode()`。\n    * 数组类型。(要获取数组类型的hashCode,可采用如下方法：`s[0]*31 ^ (n-1) + s[1] * 31 ^ (n-2) + ..... + s[n-1]`， 该方法正是String类的hashCode实现所采用的算法）\n* 第三步：整合\n    * `code = code * 31 + [hashCode]`;\n<br>\n\n### 注意\n* **如果重写hashcode方法是用到了对象类型，那么该对象类型也必须要重写hashcode()方法**，否则每次得到的hashcode值不一定一致，那么重写hashcode方法的意义就不大了\n* 如果初始值result不取17而取0的话，则对于hashCode为0的字段来说就没有区分度了，这样更容易产生冲突。比如两个自定义类中，一个类比另一个类多出来一个或者几个字段，其余字段全部一样，分别new出来2个对象，这2个对象共有的字段的值全是一样的，而对于多来的那些字段的值正好都是0,并且在计算hashCode时这些多出来的字段又是最先计算的，这样的话，则这两个对象的hashCode就会产生冲突。\n    >多出来的字段hashCode为0，且先计算则 多出来的字段哈希和为 0*31+hashcode(多出字段的值)= 0 (初始code为0)，这样加上共同对象产生的计算结果和较少字段那个对象冲突\n* **不能包含equals方法中没有的字段**，否则会导致相等的对象可能会有不同的哈希值。（即对类中每一个重要字段，也就是影响对象的值的字段，也就是equals方法里有比较的字段，进行操作）\n* String对象和Bigdecimal对象已经重写了hashcode方法，这些类型的值可以直接用于重写hashcode方法；(上述的是Java八中基本数据类型，这两个是封装类型)\n* `code = 31 code + (dishCode !=null ?dishCode.hashCode() : 0);`，这里面为啥用个31来计算，而且很多人都是这么写的，这是因为**31是个神奇的数字，任何数n*31都可以被jvm优化为(n<<5)-n，移位和减法的操作效率比乘法的操作效率高很多**.\n* Google首席Java架构师Joshua Bloch在他的著作《Effective Java》中提出了一种简单通用的hashCode算法：\n\n    * 初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;\n\n    * 如果是对象应用（例如有String类型的字段），如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候（即 String a = null 时），那么hashCode值为0\n\n \n### demo\n```java\n    Class User {\n        private String name;\n        private String password;\n\n        //get() \n        //set()方法\n\n        @Override\n            public boolean equals(Object o) {\n            if (this == o) return true; //如果两个直接相等，就不用比较了\n            if (o == null || getClass() != o.getClass()) return false; //o.getClass() 因为Object 是类似接口（父类） 所以判断o是否是User类，\n            UserWrite userWrite = (UserWrite) o;\n            return Objects.equals(name, userWrite.name) &&\n                    Objects.equals(password, userWrite.password);\n        }\n\n        @Override\n        public int hashCode() {\n            int code = 17;\n            code = code * 31 + (name != null ? name.hashCode() : 0);\n            code = code * 31 + (password != null ? password.hashCode() : 0);\n            return code;\n        }\n    }\n```\n\n参考:\n1. <https://www.cnblogs.com/stitchZsx/p/9558843.html>\n2. <https://blog.csdn.net/zhengchao1991/article/details/78916471>","slug":"code/JavaSE/Overwriter HashCode()","published":1,"date":"2021-08-09T10:06:58.803Z","updated":"2020-10-06T17:19:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gf004n0w7t1keh49wy","content":"<p>重写HashCode方法并无绝对的标准答案，只要满足一个原则即可，即<strong>相同对象的Hashcode必须相同</strong>。</p>\n<br>\n<a id=\"more\"></a>\n\n<h3 id=\"重写原因\"><a href=\"#重写原因\" class=\"headerlink\" title=\"重写原因\"></a>重写原因</h3><ul>\n<li><p>SpringBoot Data Jpa domian类设置关联主键时需要重写hashcode()和equals()方法   </p>\n</li>\n<li><p>判断两个两个对象相等时需要重写hashcode()和equals()方法。</p>\n<ul>\n<li><p>因为如果两个对象的引用相同，他们之前互相调用equals()为true即两个对象相同。如果不重写hashCode()方法，系统默认的hashCode()是本地计算对象的内存地址（经哈希算法），此时不会相同。就会产生矛盾。</p>\n<blockquote>\n<p>两个对象equals相等，则它们的hashcode必须相等，反之则不一定。<br>两个对象=相等，则其hashcode一定相等，反之亦然。<br>两个对象==相等，则其hashcode一定相等，反之不一定成立。 //有可能是Integer对象比较之类的<br>两个对象==相等，则其hashcode一定相等，反之不一定成立。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"重写方法\"><a href=\"#重写方法\" class=\"headerlink\" title=\"重写方法\"></a>重写方法</h3><ul>\n<li>第一步：取一个初值，一般取17<br>  <code>int code=17;</code></li>\n<li>第二步：解析类中与equals()相关的字段(如果某些字段值都相同，则没必要计算)<ul>\n<li>字段a类型为boolean 则<code>[hashCode] = a ? 1 : 0;</code></li>\n<li>字段b类型为byte/short/int/char, 则<code>[hashCode] = (int)b;</code></li>\n<li>字段c类型为long， 则<code>[hashCode] = (int) (c ^ c&gt;&gt;&gt;32);</code></li>\n<li>字段d类型为float, 则<code>[hashCode] = d.hashCode()</code>(内部调用的是Float.hashCode(d)， 而该静态方法内部调用的另一个静态方法是Float.floatToIntBits(d))</li>\n<li>字段e类型为double, 则<code>[hashCode] = e.hashCode()</code>(内部调用的是Double.hashCode(e)， 而该静态方法内部调用的另一个静态方法是Double.doubleToLongBits(e),得到一个long类型的值之后，跟情况三进行类似的操作，得到一个int类型的值)</li>\n<li>引用类型，若为null则hashCode为0,否则<code>递归调用该引用类型的hashCode()</code>。</li>\n<li>数组类型。(要获取数组类型的hashCode,可采用如下方法：<code>s[0]*31 ^ (n-1) + s[1] * 31 ^ (n-2) + ..... + s[n-1]</code>， 该方法正是String类的hashCode实现所采用的算法）</li>\n</ul>\n</li>\n<li>第三步：整合<ul>\n<li><code>code = code * 31 + [hashCode]</code>;<br>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ul>\n<li><p><strong>如果重写hashcode方法是用到了对象类型，那么该对象类型也必须要重写hashcode()方法</strong>，否则每次得到的hashcode值不一定一致，那么重写hashcode方法的意义就不大了</p>\n</li>\n<li><p>如果初始值result不取17而取0的话，则对于hashCode为0的字段来说就没有区分度了，这样更容易产生冲突。比如两个自定义类中，一个类比另一个类多出来一个或者几个字段，其余字段全部一样，分别new出来2个对象，这2个对象共有的字段的值全是一样的，而对于多来的那些字段的值正好都是0,并且在计算hashCode时这些多出来的字段又是最先计算的，这样的话，则这两个对象的hashCode就会产生冲突。</p>\n<blockquote>\n<p>多出来的字段hashCode为0，且先计算则 多出来的字段哈希和为 0*31+hashcode(多出字段的值)= 0 (初始code为0)，这样加上共同对象产生的计算结果和较少字段那个对象冲突</p>\n</blockquote>\n</li>\n<li><p><strong>不能包含equals方法中没有的字段</strong>，否则会导致相等的对象可能会有不同的哈希值。（即对类中每一个重要字段，也就是影响对象的值的字段，也就是equals方法里有比较的字段，进行操作）</p>\n</li>\n<li><p>String对象和Bigdecimal对象已经重写了hashcode方法，这些类型的值可以直接用于重写hashcode方法；(上述的是Java八中基本数据类型，这两个是封装类型)</p>\n</li>\n<li><p><code>code = 31 code + (dishCode !=null ?dishCode.hashCode() : 0);</code>，这里面为啥用个31来计算，而且很多人都是这么写的，这是因为<strong>31是个神奇的数字，任何数n*31都可以被jvm优化为(n&lt;&lt;5)-n，移位和减法的操作效率比乘法的操作效率高很多</strong>.</p>\n</li>\n<li><p>Google首席Java架构师Joshua Bloch在他的著作《Effective Java》中提出了一种简单通用的hashCode算法：</p>\n<ul>\n<li><p>初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;</p>\n</li>\n<li><p>如果是对象应用（例如有String类型的字段），如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候（即 String a = null 时），那么hashCode值为0</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><pre class=\" language-java\"><code class=\"language-java\">    Class <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> String name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> String password<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//get() </span>\n        <span class=\"token comment\" spellcheck=\"true\">//set()方法</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>Object o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> o<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//如果两个直接相等，就不用比较了</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> <span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> o<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//o.getClass() 因为Object 是类似接口（父类） 所以判断o是否是User类，</span>\n            UserWrite userWrite <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>UserWrite<span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> Objects<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> userWrite<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n                    Objects<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>password<span class=\"token punctuation\">,</span> userWrite<span class=\"token punctuation\">.</span>password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> code <span class=\"token operator\">=</span> <span class=\"token number\">17</span><span class=\"token punctuation\">;</span>\n            code <span class=\"token operator\">=</span> code <span class=\"token operator\">*</span> <span class=\"token number\">31</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>name <span class=\"token operator\">!=</span> null <span class=\"token operator\">?</span> name<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            code <span class=\"token operator\">=</span> code <span class=\"token operator\">*</span> <span class=\"token number\">31</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>password <span class=\"token operator\">!=</span> null <span class=\"token operator\">?</span> password<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> code<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>参考:</p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/stitchZsx/p/9558843.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/stitchZsx/p/9558843.html</a></li>\n<li><a href=\"https://blog.csdn.net/zhengchao1991/article/details/78916471\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhengchao1991/article/details/78916471</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>重写HashCode方法并无绝对的标准答案，只要满足一个原则即可，即<strong>相同对象的Hashcode必须相同</strong>。</p>\n<br>","more":"<h3 id=\"重写原因\"><a href=\"#重写原因\" class=\"headerlink\" title=\"重写原因\"></a>重写原因</h3><ul>\n<li><p>SpringBoot Data Jpa domian类设置关联主键时需要重写hashcode()和equals()方法   </p>\n</li>\n<li><p>判断两个两个对象相等时需要重写hashcode()和equals()方法。</p>\n<ul>\n<li><p>因为如果两个对象的引用相同，他们之前互相调用equals()为true即两个对象相同。如果不重写hashCode()方法，系统默认的hashCode()是本地计算对象的内存地址（经哈希算法），此时不会相同。就会产生矛盾。</p>\n<blockquote>\n<p>两个对象equals相等，则它们的hashcode必须相等，反之则不一定。<br>两个对象=相等，则其hashcode一定相等，反之亦然。<br>两个对象==相等，则其hashcode一定相等，反之不一定成立。 //有可能是Integer对象比较之类的<br>两个对象==相等，则其hashcode一定相等，反之不一定成立。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"重写方法\"><a href=\"#重写方法\" class=\"headerlink\" title=\"重写方法\"></a>重写方法</h3><ul>\n<li>第一步：取一个初值，一般取17<br>  <code>int code=17;</code></li>\n<li>第二步：解析类中与equals()相关的字段(如果某些字段值都相同，则没必要计算)<ul>\n<li>字段a类型为boolean 则<code>[hashCode] = a ? 1 : 0;</code></li>\n<li>字段b类型为byte/short/int/char, 则<code>[hashCode] = (int)b;</code></li>\n<li>字段c类型为long， 则<code>[hashCode] = (int) (c ^ c&gt;&gt;&gt;32);</code></li>\n<li>字段d类型为float, 则<code>[hashCode] = d.hashCode()</code>(内部调用的是Float.hashCode(d)， 而该静态方法内部调用的另一个静态方法是Float.floatToIntBits(d))</li>\n<li>字段e类型为double, 则<code>[hashCode] = e.hashCode()</code>(内部调用的是Double.hashCode(e)， 而该静态方法内部调用的另一个静态方法是Double.doubleToLongBits(e),得到一个long类型的值之后，跟情况三进行类似的操作，得到一个int类型的值)</li>\n<li>引用类型，若为null则hashCode为0,否则<code>递归调用该引用类型的hashCode()</code>。</li>\n<li>数组类型。(要获取数组类型的hashCode,可采用如下方法：<code>s[0]*31 ^ (n-1) + s[1] * 31 ^ (n-2) + ..... + s[n-1]</code>， 该方法正是String类的hashCode实现所采用的算法）</li>\n</ul>\n</li>\n<li>第三步：整合<ul>\n<li><code>code = code * 31 + [hashCode]</code>;<br>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ul>\n<li><p><strong>如果重写hashcode方法是用到了对象类型，那么该对象类型也必须要重写hashcode()方法</strong>，否则每次得到的hashcode值不一定一致，那么重写hashcode方法的意义就不大了</p>\n</li>\n<li><p>如果初始值result不取17而取0的话，则对于hashCode为0的字段来说就没有区分度了，这样更容易产生冲突。比如两个自定义类中，一个类比另一个类多出来一个或者几个字段，其余字段全部一样，分别new出来2个对象，这2个对象共有的字段的值全是一样的，而对于多来的那些字段的值正好都是0,并且在计算hashCode时这些多出来的字段又是最先计算的，这样的话，则这两个对象的hashCode就会产生冲突。</p>\n<blockquote>\n<p>多出来的字段hashCode为0，且先计算则 多出来的字段哈希和为 0*31+hashcode(多出字段的值)= 0 (初始code为0)，这样加上共同对象产生的计算结果和较少字段那个对象冲突</p>\n</blockquote>\n</li>\n<li><p><strong>不能包含equals方法中没有的字段</strong>，否则会导致相等的对象可能会有不同的哈希值。（即对类中每一个重要字段，也就是影响对象的值的字段，也就是equals方法里有比较的字段，进行操作）</p>\n</li>\n<li><p>String对象和Bigdecimal对象已经重写了hashcode方法，这些类型的值可以直接用于重写hashcode方法；(上述的是Java八中基本数据类型，这两个是封装类型)</p>\n</li>\n<li><p><code>code = 31 code + (dishCode !=null ?dishCode.hashCode() : 0);</code>，这里面为啥用个31来计算，而且很多人都是这么写的，这是因为<strong>31是个神奇的数字，任何数n*31都可以被jvm优化为(n&lt;&lt;5)-n，移位和减法的操作效率比乘法的操作效率高很多</strong>.</p>\n</li>\n<li><p>Google首席Java架构师Joshua Bloch在他的著作《Effective Java》中提出了一种简单通用的hashCode算法：</p>\n<ul>\n<li><p>初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;</p>\n</li>\n<li><p>如果是对象应用（例如有String类型的字段），如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候（即 String a = null 时），那么hashCode值为0</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><pre><code class=\"java\">    Class User {\n        private String name;\n        private String password;\n\n        //get() \n        //set()方法\n\n        @Override\n            public boolean equals(Object o) {\n            if (this == o) return true; //如果两个直接相等，就不用比较了\n            if (o == null || getClass() != o.getClass()) return false; //o.getClass() 因为Object 是类似接口（父类） 所以判断o是否是User类，\n            UserWrite userWrite = (UserWrite) o;\n            return Objects.equals(name, userWrite.name) &amp;&amp;\n                    Objects.equals(password, userWrite.password);\n        }\n\n        @Override\n        public int hashCode() {\n            int code = 17;\n            code = code * 31 + (name != null ? name.hashCode() : 0);\n            code = code * 31 + (password != null ? password.hashCode() : 0);\n            return code;\n        }\n    }</code></pre>\n<p>参考:</p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/stitchZsx/p/9558843.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/stitchZsx/p/9558843.html</a></li>\n<li><a href=\"https://blog.csdn.net/zhengchao1991/article/details/78916471\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhengchao1991/article/details/78916471</a></li>\n</ol>"},{"title":"【转载】java按位与、按位或、异或、移位、按位非","declare":false,"wordCount":true,"abbrlink":"51267ed9","date":"2020-07-16T14:20:10.000Z","_content":"\n* 按位与：**&**\n* 按位或：***|***\n* 异或：**^**\n* 有符号移位：**>>、<<**\n* 无符号移位：**>>>、<<<**\n* 按位非：**~**\n\n<!-- more -->\n```java\n    /**\n     * 测试按位与、按位或、异或、移位、按位非\n     */\n    @Test\n    public void testYiWei() {\n        int i = 3; //对应二进制 ...11\n        int j = 2; //对应二进制 ...10\n        int k = -3; //对应二进制 10000000 00000000 00000000 00000011(原码)\n\n        //按位与& 从高位开始两个都为1 为1，否则 为0\n        System.out.println(i & j); //10（2进制） -> 2（10进制）\n\n        //按位或| 从高位开始只要1个为1 为1，否则 为0\n        System.out.println(i | j); //11（2进制） -> 3（10进制）\n\n        //异或^= 从高位开始相同为0，否则 为1\n        System.out.println(i ^ j); //01（2进制） -> 1（10进制）\n\n        //左移位<<1 向左移位1位，最低位补0，原来的第二高位现在成为最高位\n        System.out.println(i << 1); //0011 移位后 0110，对应10进制的6\n\n        //右移位>>1 向右移位1位，最高位补上符号位，且不变\n        /*\n            移位前 11111111 11111111 11111111 11111101(补码)\n            移位后 11111111 11111111 11111111 11111110(补码)，\n            对应原码 10000000 00000000 00000000 00000010\n        */\n        System.out.println(k >> 1); //-2(10进制)\n\n        //无视符号右移位>>>1 向右移位1位，最高位补上0\n        /*\n            移位前 11111111 11111111 11111111 11111101(补码)\n            移位后 01111111 11111111 11111111 11111110(补码)，\n            对应原码 01111111 11111111 11111111 11111110\n        */\n        System.out.println(k >>> 1); //2147483646即2^31-1-1(10进制)\n\n        /*\n            按位非的流程:\n            00000000 00000000 00000000 00000010  1.2的2进制（这里是补码，因为是正数，所以和原码一样）\n            11111111 11111111 11111111 11111101  2.位非\n            11111111 11111111 11111111 11111100  3.取原码  （-1）\n            10000000 00000000 00000000 00000011  3.取原码  （取反）\n        */\n        System.out.println(~j); //-3（10进制）\n    }\n\n复制代码\n```\n\n\n>转载自：https://www.cnblogs.com/lujiannt/p/9242297.html","source":"_posts/code/JavaSE/java按位与、按位或、异或、移位、按位非.md","raw":"---\ntitle: 【转载】java按位与、按位或、异或、移位、按位非\ncategories: Code\ntags: JavaSE\ndeclare: false\nwordCount: true\nabbrlink: 51267ed9\ndate: 2020-07-16 22:20:10\n---\n\n* 按位与：**&**\n* 按位或：***|***\n* 异或：**^**\n* 有符号移位：**>>、<<**\n* 无符号移位：**>>>、<<<**\n* 按位非：**~**\n\n<!-- more -->\n```java\n    /**\n     * 测试按位与、按位或、异或、移位、按位非\n     */\n    @Test\n    public void testYiWei() {\n        int i = 3; //对应二进制 ...11\n        int j = 2; //对应二进制 ...10\n        int k = -3; //对应二进制 10000000 00000000 00000000 00000011(原码)\n\n        //按位与& 从高位开始两个都为1 为1，否则 为0\n        System.out.println(i & j); //10（2进制） -> 2（10进制）\n\n        //按位或| 从高位开始只要1个为1 为1，否则 为0\n        System.out.println(i | j); //11（2进制） -> 3（10进制）\n\n        //异或^= 从高位开始相同为0，否则 为1\n        System.out.println(i ^ j); //01（2进制） -> 1（10进制）\n\n        //左移位<<1 向左移位1位，最低位补0，原来的第二高位现在成为最高位\n        System.out.println(i << 1); //0011 移位后 0110，对应10进制的6\n\n        //右移位>>1 向右移位1位，最高位补上符号位，且不变\n        /*\n            移位前 11111111 11111111 11111111 11111101(补码)\n            移位后 11111111 11111111 11111111 11111110(补码)，\n            对应原码 10000000 00000000 00000000 00000010\n        */\n        System.out.println(k >> 1); //-2(10进制)\n\n        //无视符号右移位>>>1 向右移位1位，最高位补上0\n        /*\n            移位前 11111111 11111111 11111111 11111101(补码)\n            移位后 01111111 11111111 11111111 11111110(补码)，\n            对应原码 01111111 11111111 11111111 11111110\n        */\n        System.out.println(k >>> 1); //2147483646即2^31-1-1(10进制)\n\n        /*\n            按位非的流程:\n            00000000 00000000 00000000 00000010  1.2的2进制（这里是补码，因为是正数，所以和原码一样）\n            11111111 11111111 11111111 11111101  2.位非\n            11111111 11111111 11111111 11111100  3.取原码  （-1）\n            10000000 00000000 00000000 00000011  3.取原码  （取反）\n        */\n        System.out.println(~j); //-3（10进制）\n    }\n\n复制代码\n```\n\n\n>转载自：https://www.cnblogs.com/lujiannt/p/9242297.html","slug":"code/JavaSE/java按位与、按位或、异或、移位、按位非","published":1,"updated":"2020-07-16T14:24:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gf004q0w7t0wjo0r0c","content":"<ul>\n<li>按位与：<strong>&amp;</strong></li>\n<li>按位或：<strong><em>|</em></strong></li>\n<li>异或：<strong>^</strong></li>\n<li>有符号移位：<strong>&gt;&gt;、&lt;&lt;</strong></li>\n<li>无符号移位：<strong>&gt;&gt;&gt;、&lt;&lt;&lt;</strong></li>\n<li>按位非：<strong>~</strong></li>\n</ul>\n<a id=\"more\"></a>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 测试按位与、按位或、异或、移位、按位非\n     */</span>\n    <span class=\"token annotation punctuation\">@Test</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testYiWei</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//对应二进制 ...11</span>\n        <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//对应二进制 ...10</span>\n        <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//对应二进制 10000000 00000000 00000000 00000011(原码)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//按位与&amp; 从高位开始两个都为1 为1，否则 为0</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&amp;</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//10（2进制） -> 2（10进制）</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//按位或| 从高位开始只要1个为1 为1，否则 为0</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">|</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//11（2进制） -> 3（10进制）</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//异或^= 从高位开始相同为0，否则 为1</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">^</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//01（2进制） -> 1（10进制）</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//左移位&lt;&lt;1 向左移位1位，最低位补0，原来的第二高位现在成为最高位</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//0011 移位后 0110，对应10进制的6</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//右移位>>1 向右移位1位，最高位补上符号位，且不变</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n            移位前 11111111 11111111 11111111 11111101(补码)\n            移位后 11111111 11111111 11111111 11111110(补码)，\n            对应原码 10000000 00000000 00000000 00000010\n        */</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//-2(10进制)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//无视符号右移位>>>1 向右移位1位，最高位补上0</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n            移位前 11111111 11111111 11111111 11111101(补码)\n            移位后 01111111 11111111 11111111 11111110(补码)，\n            对应原码 01111111 11111111 11111111 11111110\n        */</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">>>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//2147483646即2^31-1-1(10进制)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">/*\n            按位非的流程:\n            00000000 00000000 00000000 00000010  1.2的2进制（这里是补码，因为是正数，所以和原码一样）\n            11111111 11111111 11111111 11111101  2.位非\n            11111111 11111111 11111111 11111100  3.取原码  （-1）\n            10000000 00000000 00000000 00000011  3.取原码  （取反）\n        */</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token operator\">~</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//-3（10进制）</span>\n    <span class=\"token punctuation\">}</span>\n\n复制代码</code></pre>\n<blockquote>\n<p>转载自：<a href=\"https://www.cnblogs.com/lujiannt/p/9242297.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lujiannt/p/9242297.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<ul>\n<li>按位与：<strong>&amp;</strong></li>\n<li>按位或：<strong><em>|</em></strong></li>\n<li>异或：<strong>^</strong></li>\n<li>有符号移位：<strong>&gt;&gt;、&lt;&lt;</strong></li>\n<li>无符号移位：<strong>&gt;&gt;&gt;、&lt;&lt;&lt;</strong></li>\n<li>按位非：<strong>~</strong></li>\n</ul>","more":"<pre><code class=\"java\">    /**\n     * 测试按位与、按位或、异或、移位、按位非\n     */\n    @Test\n    public void testYiWei() {\n        int i = 3; //对应二进制 ...11\n        int j = 2; //对应二进制 ...10\n        int k = -3; //对应二进制 10000000 00000000 00000000 00000011(原码)\n\n        //按位与&amp; 从高位开始两个都为1 为1，否则 为0\n        System.out.println(i &amp; j); //10（2进制） -&gt; 2（10进制）\n\n        //按位或| 从高位开始只要1个为1 为1，否则 为0\n        System.out.println(i | j); //11（2进制） -&gt; 3（10进制）\n\n        //异或^= 从高位开始相同为0，否则 为1\n        System.out.println(i ^ j); //01（2进制） -&gt; 1（10进制）\n\n        //左移位&lt;&lt;1 向左移位1位，最低位补0，原来的第二高位现在成为最高位\n        System.out.println(i &lt;&lt; 1); //0011 移位后 0110，对应10进制的6\n\n        //右移位&gt;&gt;1 向右移位1位，最高位补上符号位，且不变\n        /*\n            移位前 11111111 11111111 11111111 11111101(补码)\n            移位后 11111111 11111111 11111111 11111110(补码)，\n            对应原码 10000000 00000000 00000000 00000010\n        */\n        System.out.println(k &gt;&gt; 1); //-2(10进制)\n\n        //无视符号右移位&gt;&gt;&gt;1 向右移位1位，最高位补上0\n        /*\n            移位前 11111111 11111111 11111111 11111101(补码)\n            移位后 01111111 11111111 11111111 11111110(补码)，\n            对应原码 01111111 11111111 11111111 11111110\n        */\n        System.out.println(k &gt;&gt;&gt; 1); //2147483646即2^31-1-1(10进制)\n\n        /*\n            按位非的流程:\n            00000000 00000000 00000000 00000010  1.2的2进制（这里是补码，因为是正数，所以和原码一样）\n            11111111 11111111 11111111 11111101  2.位非\n            11111111 11111111 11111111 11111100  3.取原码  （-1）\n            10000000 00000000 00000000 00000011  3.取原码  （取反）\n        */\n        System.out.println(~j); //-3（10进制）\n    }\n\n复制代码</code></pre>\n<blockquote>\n<p>转载自：<a href=\"https://www.cnblogs.com/lujiannt/p/9242297.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lujiannt/p/9242297.html</a></p>\n</blockquote>"},{"title":"基本类型转换","declare":true,"wordCount":true,"abbrlink":"8a529bb2","date":"2020-10-06T13:07:10.000Z","_content":"* 字符串与数值类型互转\n* char和String互转\n* 其他类型互转\n* 英文字母与ASCII码数值范围\n\n<br>\n<!-- more -->\n\n## 一、字符类转化为整型\n* 字符串转double：<br>\n```java\nstring s = \"124\";    double x = Double.parseDouble(s);\n```\n* 字符串转float：<br>\n```java\nstring s = \"124\";   float f = Float.parseFloat(s);\n```\n\n* 字符串转int：<br>\n```java\nstring s = \"124\";   int i = Float.parseFloat(s);\n```\n* 字符串转short：<br>\n```java\nstring s = \"124\";   short sh = Short.parseFloat(s);\n```\n* 字符串转long：<br>\n```java\nstring s = \"124\";   long l = Long.parseLong(s);\n```\n* 字符串转byte：<br>\n```java\nstring s = \"124\";   byte b = Long.parseByte(s);\n```\n* 字符串转char：<br>\n```java\nString s = \"1\";\nchar c = s.charAt(0);\n```\n* char转字符串\n```java\nchar c = 'a';\nString s = String.valueOf(c);\n```\n\n* char\n\n\n## 二、数字类型转字符串\n```java \nint a = 127;\nString s = String.valueOf(a);\ndouble d = 127;\nString s = String.valueOf(d);\n……\n\n/**\n    * Returns the string representation of the {@code Object} argument.\n    *\n    * @param   obj   an {@code Object}.\n    * @return  if the argument is {@code null}, then a string equal to\n    *          {@code \"null\"}; otherwise, the value of\n    *          {@code obj.toString()} is returned.\n    * @see     java.lang.Object#toString()\n    */\npublic static String valueOf(Object obj) {\n    return (obj == null) ? \"null\" : obj.toString();\n}\n```\n\n## 三、其他类型转换\n### 3.1 Double转其他类型\n```java\n//其它类型同下\npublic byte byteValue() {\n    return (byte)value;\n}\npublic short shortValue() {\n    return (short)value;\n}\npublic int intValue() {\n    return (int)value;\n}\npublic long longValue() {\n    return (long)value;\n}\npublic float floatValue() {\n    return (float)value;\n}\npublic double doubleValue() {\n    return value;\n}\n\n//double 转 int\ndouble d = 127.0;\nint i1 = new Double(d).intValue();\n\n//取整\nint i2 = Math.ceil(d);\nint i3 = Math.floor(d);\nint i2 = Math.round(d);\n```\n### 3.2 数值类型转二进制\n```java\n//int类型\nint i = 12;\nString s = Integer.toBinaryString(i);\n//long类型\nlong l = 12;\nString s = Long.toBinaryString(l);\n//short类型\nshort s = 12;\nString st = Short.toBinaryString(s);\n```\n### 3.3 char类型与数值转换\n```java\n//a~z 97~122\n//A~Z 65~90\nchar c = 97;\nSystem.out.println(c);\n\nint a = '9' - '0';\nSystem.out.println(a);\n```","source":"_posts/code/JavaSE/类型转换.md","raw":"---\ntitle: 基本类型转换\ncategories: Code\ntags: JavaSE\ndeclare: true\nwordCount: true\nabbrlink: 8a529bb2\ndate: 2020-10-06 21:07:10\n---\n* 字符串与数值类型互转\n* char和String互转\n* 其他类型互转\n* 英文字母与ASCII码数值范围\n\n<br>\n<!-- more -->\n\n## 一、字符类转化为整型\n* 字符串转double：<br>\n```java\nstring s = \"124\";    double x = Double.parseDouble(s);\n```\n* 字符串转float：<br>\n```java\nstring s = \"124\";   float f = Float.parseFloat(s);\n```\n\n* 字符串转int：<br>\n```java\nstring s = \"124\";   int i = Float.parseFloat(s);\n```\n* 字符串转short：<br>\n```java\nstring s = \"124\";   short sh = Short.parseFloat(s);\n```\n* 字符串转long：<br>\n```java\nstring s = \"124\";   long l = Long.parseLong(s);\n```\n* 字符串转byte：<br>\n```java\nstring s = \"124\";   byte b = Long.parseByte(s);\n```\n* 字符串转char：<br>\n```java\nString s = \"1\";\nchar c = s.charAt(0);\n```\n* char转字符串\n```java\nchar c = 'a';\nString s = String.valueOf(c);\n```\n\n* char\n\n\n## 二、数字类型转字符串\n```java \nint a = 127;\nString s = String.valueOf(a);\ndouble d = 127;\nString s = String.valueOf(d);\n……\n\n/**\n    * Returns the string representation of the {@code Object} argument.\n    *\n    * @param   obj   an {@code Object}.\n    * @return  if the argument is {@code null}, then a string equal to\n    *          {@code \"null\"}; otherwise, the value of\n    *          {@code obj.toString()} is returned.\n    * @see     java.lang.Object#toString()\n    */\npublic static String valueOf(Object obj) {\n    return (obj == null) ? \"null\" : obj.toString();\n}\n```\n\n## 三、其他类型转换\n### 3.1 Double转其他类型\n```java\n//其它类型同下\npublic byte byteValue() {\n    return (byte)value;\n}\npublic short shortValue() {\n    return (short)value;\n}\npublic int intValue() {\n    return (int)value;\n}\npublic long longValue() {\n    return (long)value;\n}\npublic float floatValue() {\n    return (float)value;\n}\npublic double doubleValue() {\n    return value;\n}\n\n//double 转 int\ndouble d = 127.0;\nint i1 = new Double(d).intValue();\n\n//取整\nint i2 = Math.ceil(d);\nint i3 = Math.floor(d);\nint i2 = Math.round(d);\n```\n### 3.2 数值类型转二进制\n```java\n//int类型\nint i = 12;\nString s = Integer.toBinaryString(i);\n//long类型\nlong l = 12;\nString s = Long.toBinaryString(l);\n//short类型\nshort s = 12;\nString st = Short.toBinaryString(s);\n```\n### 3.3 char类型与数值转换\n```java\n//a~z 97~122\n//A~Z 65~90\nchar c = 97;\nSystem.out.println(c);\n\nint a = '9' - '0';\nSystem.out.println(a);\n```","slug":"code/JavaSE/类型转换","published":1,"updated":"2020-11-28T04:53:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gh004u0w7t1ct77zun","content":"<ul>\n<li>字符串与数值类型互转</li>\n<li>char和String互转</li>\n<li>其他类型互转</li>\n<li>英文字母与ASCII码数值范围</li>\n</ul>\n<br>\n<a id=\"more\"></a>\n\n<h2 id=\"一、字符类转化为整型\"><a href=\"#一、字符类转化为整型\" class=\"headerlink\" title=\"一、字符类转化为整型\"></a>一、字符类转化为整型</h2><ul>\n<li><p>字符串转double：<br></p>\n<pre class=\" language-java\"><code class=\"language-java\">string s <span class=\"token operator\">=</span> <span class=\"token string\">\"124\"</span><span class=\"token punctuation\">;</span>    <span class=\"token keyword\">double</span> x <span class=\"token operator\">=</span> Double<span class=\"token punctuation\">.</span><span class=\"token function\">parseDouble</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>字符串转float：<br></p>\n<pre class=\" language-java\"><code class=\"language-java\">string s <span class=\"token operator\">=</span> <span class=\"token string\">\"124\"</span><span class=\"token punctuation\">;</span>   <span class=\"token keyword\">float</span> f <span class=\"token operator\">=</span> Float<span class=\"token punctuation\">.</span><span class=\"token function\">parseFloat</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>字符串转int：<br></p>\n<pre class=\" language-java\"><code class=\"language-java\">string s <span class=\"token operator\">=</span> <span class=\"token string\">\"124\"</span><span class=\"token punctuation\">;</span>   <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> Float<span class=\"token punctuation\">.</span><span class=\"token function\">parseFloat</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>字符串转short：<br></p>\n<pre class=\" language-java\"><code class=\"language-java\">string s <span class=\"token operator\">=</span> <span class=\"token string\">\"124\"</span><span class=\"token punctuation\">;</span>   <span class=\"token keyword\">short</span> sh <span class=\"token operator\">=</span> Short<span class=\"token punctuation\">.</span><span class=\"token function\">parseFloat</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>字符串转long：<br></p>\n<pre class=\" language-java\"><code class=\"language-java\">string s <span class=\"token operator\">=</span> <span class=\"token string\">\"124\"</span><span class=\"token punctuation\">;</span>   <span class=\"token keyword\">long</span> l <span class=\"token operator\">=</span> Long<span class=\"token punctuation\">.</span><span class=\"token function\">parseLong</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>字符串转byte：<br></p>\n<pre class=\" language-java\"><code class=\"language-java\">string s <span class=\"token operator\">=</span> <span class=\"token string\">\"124\"</span><span class=\"token punctuation\">;</span>   <span class=\"token keyword\">byte</span> b <span class=\"token operator\">=</span> Long<span class=\"token punctuation\">.</span><span class=\"token function\">parseByte</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>字符串转char：<br></p>\n<pre class=\" language-java\"><code class=\"language-java\">String s <span class=\"token operator\">=</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> c <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>char转字符串</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">char</span> c <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span>\nString s <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>char</p>\n</li>\n</ul>\n<h2 id=\"二、数字类型转字符串\"><a href=\"#二、数字类型转字符串\" class=\"headerlink\" title=\"二、数字类型转字符串\"></a>二、数字类型转字符串</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">127</span><span class=\"token punctuation\">;</span>\nString s <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">127</span><span class=\"token punctuation\">;</span>\nString s <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n……\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n    * Returns the string representation of the {@code Object} argument.\n    *\n    * @param   obj   an {@code Object}.\n    * @return  if the argument is {@code null}, then a string equal to\n    *          {@code \"null\"}; otherwise, the value of\n    *          {@code obj.toString()} is returned.\n    * @see     java.lang.Object#toString()\n    */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>Object obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>obj <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"null\"</span> <span class=\"token operator\">:</span> obj<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"三、其他类型转换\"><a href=\"#三、其他类型转换\" class=\"headerlink\" title=\"三、其他类型转换\"></a>三、其他类型转换</h2><h3 id=\"3-1-Double转其他类型\"><a href=\"#3-1-Double转其他类型\" class=\"headerlink\" title=\"3.1 Double转其他类型\"></a>3.1 Double转其他类型</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//其它类型同下</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">byte</span> <span class=\"token function\">byteValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">)</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">short</span> <span class=\"token function\">shortValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">short</span><span class=\"token punctuation\">)</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">intValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> <span class=\"token function\">longValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">float</span> <span class=\"token function\">floatValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">doubleValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//double 转 int</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">127.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> i1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Double</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">intValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//取整</span>\n<span class=\"token keyword\">int</span> i2 <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">ceil</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> i3 <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> i2 <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"3-2-数值类型转二进制\"><a href=\"#3-2-数值类型转二进制\" class=\"headerlink\" title=\"3.2 数值类型转二进制\"></a>3.2 数值类型转二进制</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//int类型</span>\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\nString s <span class=\"token operator\">=</span> Integer<span class=\"token punctuation\">.</span><span class=\"token function\">toBinaryString</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//long类型</span>\n<span class=\"token keyword\">long</span> l <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\nString s <span class=\"token operator\">=</span> Long<span class=\"token punctuation\">.</span><span class=\"token function\">toBinaryString</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//short类型</span>\n<span class=\"token keyword\">short</span> s <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\nString st <span class=\"token operator\">=</span> Short<span class=\"token punctuation\">.</span><span class=\"token function\">toBinaryString</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"3-3-char类型与数值转换\"><a href=\"#3-3-char类型与数值转换\" class=\"headerlink\" title=\"3.3 char类型与数值转换\"></a>3.3 char类型与数值转换</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//a~z 97~122</span>\n<span class=\"token comment\" spellcheck=\"true\">//A~Z 65~90</span>\n<span class=\"token keyword\">char</span> c <span class=\"token operator\">=</span> <span class=\"token number\">97</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token string\">'9'</span> <span class=\"token operator\">-</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n","site":{"data":{}},"excerpt":"<ul>\n<li>字符串与数值类型互转</li>\n<li>char和String互转</li>\n<li>其他类型互转</li>\n<li>英文字母与ASCII码数值范围</li>\n</ul>\n<br>","more":"<h2 id=\"一、字符类转化为整型\"><a href=\"#一、字符类转化为整型\" class=\"headerlink\" title=\"一、字符类转化为整型\"></a>一、字符类转化为整型</h2><ul>\n<li><p>字符串转double：<br></p>\n<pre><code class=\"java\">string s = &quot;124&quot;;    double x = Double.parseDouble(s);</code></pre>\n</li>\n<li><p>字符串转float：<br></p>\n<pre><code class=\"java\">string s = &quot;124&quot;;   float f = Float.parseFloat(s);</code></pre>\n</li>\n<li><p>字符串转int：<br></p>\n<pre><code class=\"java\">string s = &quot;124&quot;;   int i = Float.parseFloat(s);</code></pre>\n</li>\n<li><p>字符串转short：<br></p>\n<pre><code class=\"java\">string s = &quot;124&quot;;   short sh = Short.parseFloat(s);</code></pre>\n</li>\n<li><p>字符串转long：<br></p>\n<pre><code class=\"java\">string s = &quot;124&quot;;   long l = Long.parseLong(s);</code></pre>\n</li>\n<li><p>字符串转byte：<br></p>\n<pre><code class=\"java\">string s = &quot;124&quot;;   byte b = Long.parseByte(s);</code></pre>\n</li>\n<li><p>字符串转char：<br></p>\n<pre><code class=\"java\">String s = &quot;1&quot;;\nchar c = s.charAt(0);</code></pre>\n</li>\n<li><p>char转字符串</p>\n<pre><code class=\"java\">char c = &#39;a&#39;;\nString s = String.valueOf(c);</code></pre>\n</li>\n<li><p>char</p>\n</li>\n</ul>\n<h2 id=\"二、数字类型转字符串\"><a href=\"#二、数字类型转字符串\" class=\"headerlink\" title=\"二、数字类型转字符串\"></a>二、数字类型转字符串</h2><pre><code class=\"java\">int a = 127;\nString s = String.valueOf(a);\ndouble d = 127;\nString s = String.valueOf(d);\n……\n\n/**\n    * Returns the string representation of the {@code Object} argument.\n    *\n    * @param   obj   an {@code Object}.\n    * @return  if the argument is {@code null}, then a string equal to\n    *          {@code &quot;null&quot;}; otherwise, the value of\n    *          {@code obj.toString()} is returned.\n    * @see     java.lang.Object#toString()\n    */\npublic static String valueOf(Object obj) {\n    return (obj == null) ? &quot;null&quot; : obj.toString();\n}</code></pre>\n<h2 id=\"三、其他类型转换\"><a href=\"#三、其他类型转换\" class=\"headerlink\" title=\"三、其他类型转换\"></a>三、其他类型转换</h2><h3 id=\"3-1-Double转其他类型\"><a href=\"#3-1-Double转其他类型\" class=\"headerlink\" title=\"3.1 Double转其他类型\"></a>3.1 Double转其他类型</h3><pre><code class=\"java\">//其它类型同下\npublic byte byteValue() {\n    return (byte)value;\n}\npublic short shortValue() {\n    return (short)value;\n}\npublic int intValue() {\n    return (int)value;\n}\npublic long longValue() {\n    return (long)value;\n}\npublic float floatValue() {\n    return (float)value;\n}\npublic double doubleValue() {\n    return value;\n}\n\n//double 转 int\ndouble d = 127.0;\nint i1 = new Double(d).intValue();\n\n//取整\nint i2 = Math.ceil(d);\nint i3 = Math.floor(d);\nint i2 = Math.round(d);</code></pre>\n<h3 id=\"3-2-数值类型转二进制\"><a href=\"#3-2-数值类型转二进制\" class=\"headerlink\" title=\"3.2 数值类型转二进制\"></a>3.2 数值类型转二进制</h3><pre><code class=\"java\">//int类型\nint i = 12;\nString s = Integer.toBinaryString(i);\n//long类型\nlong l = 12;\nString s = Long.toBinaryString(l);\n//short类型\nshort s = 12;\nString st = Short.toBinaryString(s);</code></pre>\n<h3 id=\"3-3-char类型与数值转换\"><a href=\"#3-3-char类型与数值转换\" class=\"headerlink\" title=\"3.3 char类型与数值转换\"></a>3.3 char类型与数值转换</h3><pre><code class=\"java\">//a~z 97~122\n//A~Z 65~90\nchar c = 97;\nSystem.out.println(c);\n\nint a = &#39;9&#39; - &#39;0&#39;;\nSystem.out.println(a);</code></pre>"},{"title":"Java时间日期处理","declare":true,"wordCount":true,"abbrlink":"1fd66a56","date":"2020-05-06T16:07:10.000Z","_content":"\n在java.util包中提供了Date和Calendar两个类用来封装日期和时间有关的信息\n\n## 1.Date类\n在java中日期用代表**毫微秒**的一个厂整数镜像存储表示，也就是日期时间相对**格林威治时间**（GMT)1970年1月1日零点整数过去的毫微秒数。\n<!-- more -->\n### 1.1 日期的构造方法如下：\n```java\n    Date date=new Date();   //创建一个当前日期\n    Date date=new DateDate(long millisec)(); //根据距离格林威时间的毫微秒数构造\n```\n### 1.2常用方法\n```java\n    boolean after(Date date); //如果调用Date对象包含或晚于指定的日期则返回true，否则，返回false。\n    boolean before(Date date);//如果调用Date对象包含或早于日期指定的日期返回true，否则，返回false。\n    int compareTo(Date date);//调用对象的值与日期比较。如果这两个值相等返回0。如果调用对象是早于日期返回一个负值。如果调用对象迟于日期返回正值。\n    long getTime( );//返回自1970年1月1日起已经过的毫秒数。\n    void setTime(long time);//设置所指定的时间，这表示从1970年1月1日从午夜的时间和日期以毫秒为单位经过的时间。\n    String toString();//调用Date对象转换为字符串，并返回结果。\n```\n### 1.3时间日期格式化\n\n| 字符 | 描述 |  例子 |  \n|-|-|-\n|   | 时代指示器 | AD |\n| y | 四位数年份 | 2001 |\n| M | 年中的月份 | July or 07 |\n| d | 月份中日期 | 10 |\n| h | 时间 A.M./P.M.(1~12) | 12 |\n| H | 天中的小时 (0~23) | 22 |\n| m | 小时中的分钟 | 30 |\n| s | 分钟中的秒钟 | 55 |\n| S | 毫秒 | 234 |\n| E | 星期中的天 | Tuesday |\n| M | 年中的天 | July or 07 |\n| D | 年中的月份 | 360 |\n| a | A.M./P.M. 标记 | A.M./P.M. 标记 |\n| w | 年中的星期 | 40 |\n| W | 月中的星期 | 1 |\n| k | 天中的小时(1~24) | 24 |\n| K | 小时A.M./P.M. (0~11) | 10 |\n| z | 时区 |  \t东部标准时间 |\n| ' | 脱离文本 | 分隔符 |\n| \" | 单引号 | ` |\n\n### 1.4字符串转换日期\nSimpleDateFormat类有一些额外的方法，如parse()，它试图根据存储在给定SimpleDateFormat的对象的格式来转换字符串。\n\n```java\n    public static void main(String[] args) {\n\n        SimpleDateFormat format = new SimpleDateFormat(\"yy-MM-dd HH:mm:ss\");\n\n        String str = \"2020-05-6 23:45:48\";\n\n        Date date;\n        try {\n\n            date = format.parse(str);\n            System.out.println(date); //Wed May 06 23:45:48 CST 2020\n        } catch (ParseException e) {\n            System.out.println(\"cannot parsable using \" + format);\n        }\n    }\n```\n\n### 1.5 日期转字符串\n```java\n    SimpleDateFormat format=new SimpleDateFormat(\"yyyy-MM-dd\"); //yyyy 四位数年份 2019  yy两位数年份 19\n    String dateString=format.format(date);\n```\n\n## 2.Calendar类\n### 2.1获取当前日期\n* Calendar类主要用于日期与年，月，日等整数值的转换，Calendar是一个抽象类，**不能直接创建对象**。但是可以使用静态方法**getInstance()获得代表当前日期的日历对象**。\n\n### 2.1设置指定日期\n* 通过该对象可以调用如下方法将日历翻到指定的一个时间：\n```java\n    Calendar c = Calendar.getInstance();\n    c.set(2020,5,6);\n```\n### 2.3从日历中获取有关信息\n* 要从日历中获取有关年份、月份、星期、小时等的信息，可以通过**int get(int filed)**方法得到。其中参数field的值由Calender类的静态常量决定：YEAR代表年,MONTH代表月份,DAY_OF_WEEK代表星期几，HOUR代表小时,MINUTE代表分钟,SECOND代表秒。例如：\n```java\n    Calendar c = Calendar.getInstance();\n    String str = c.get(Calendar.YEAR) + \"-\" + (c.get(Calendar.MONTH) + 1) + \"-\" + c.get(Calendar.DATE);\n    System.out.println(str);    \n```\n> 如果`get(Calendar.MONTH)`返回值为0代表当前日历为一月份，如果返回1代表二月份，以此类推。\n\n### 2.4Date与Calendar互相转换\n```java\n    //Calendar转Date\n    Calendar cal1 = Calendar.getInstance();\n    Date date1 = cal1.getTime();\n    System.out.println(cal1);\n    System.out.println(\"-------------------------------\");\n    System.out.println(date1);\n    System.out.println(\"-------------------------------\");\n\n    //Date转Calendar\n    Date date2 = new Date();\n    Calendar cal2 = Calendar.getInstance();\n    cal2.setTime(date2);\n    System.out.println(cal2);\n    System.out.println(\"-------------------------------\");\n    System.out.println(date2);\n    System.out.println(date2);\n\n    /*\n    java.util.GregorianCalendar[time=1588781792372,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=7,DAY_OF_YEAR=128,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=16,SECOND=32,MILLISECOND=372,ZONE_OFFSET=28800000,DST_OFFSET=0]\n    -------------------------------\n    Thu May 07 00:16:32 CST 2020\n    -------------------------------\n    java.util.GregorianCalendar[time=1588781792385,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=7,DAY_OF_YEAR=128,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=16,SECOND=32,MILLISECOND=385,ZONE_OFFSET=28800000,DST_OFFSET=0]\n    -------------------------------\n    Thu May 07 00:16:32 CST 2020\n    */\n```\n\n\n\n\n\n\n\n\n\n\n\n>参考：https://www.cnblogs.com/coder-wzr/p/8416659.html\n","source":"_posts/code/JavaSE/时间日期.md","raw":"---\ntitle: Java时间日期处理\ncategories: Code\ntags: JavaSE\ndeclare: true\nwordCount: true\nabbrlink: 1fd66a56\ndate: 2020-05-07 00:07:10\n---\n\n在java.util包中提供了Date和Calendar两个类用来封装日期和时间有关的信息\n\n## 1.Date类\n在java中日期用代表**毫微秒**的一个厂整数镜像存储表示，也就是日期时间相对**格林威治时间**（GMT)1970年1月1日零点整数过去的毫微秒数。\n<!-- more -->\n### 1.1 日期的构造方法如下：\n```java\n    Date date=new Date();   //创建一个当前日期\n    Date date=new DateDate(long millisec)(); //根据距离格林威时间的毫微秒数构造\n```\n### 1.2常用方法\n```java\n    boolean after(Date date); //如果调用Date对象包含或晚于指定的日期则返回true，否则，返回false。\n    boolean before(Date date);//如果调用Date对象包含或早于日期指定的日期返回true，否则，返回false。\n    int compareTo(Date date);//调用对象的值与日期比较。如果这两个值相等返回0。如果调用对象是早于日期返回一个负值。如果调用对象迟于日期返回正值。\n    long getTime( );//返回自1970年1月1日起已经过的毫秒数。\n    void setTime(long time);//设置所指定的时间，这表示从1970年1月1日从午夜的时间和日期以毫秒为单位经过的时间。\n    String toString();//调用Date对象转换为字符串，并返回结果。\n```\n### 1.3时间日期格式化\n\n| 字符 | 描述 |  例子 |  \n|-|-|-\n|   | 时代指示器 | AD |\n| y | 四位数年份 | 2001 |\n| M | 年中的月份 | July or 07 |\n| d | 月份中日期 | 10 |\n| h | 时间 A.M./P.M.(1~12) | 12 |\n| H | 天中的小时 (0~23) | 22 |\n| m | 小时中的分钟 | 30 |\n| s | 分钟中的秒钟 | 55 |\n| S | 毫秒 | 234 |\n| E | 星期中的天 | Tuesday |\n| M | 年中的天 | July or 07 |\n| D | 年中的月份 | 360 |\n| a | A.M./P.M. 标记 | A.M./P.M. 标记 |\n| w | 年中的星期 | 40 |\n| W | 月中的星期 | 1 |\n| k | 天中的小时(1~24) | 24 |\n| K | 小时A.M./P.M. (0~11) | 10 |\n| z | 时区 |  \t东部标准时间 |\n| ' | 脱离文本 | 分隔符 |\n| \" | 单引号 | ` |\n\n### 1.4字符串转换日期\nSimpleDateFormat类有一些额外的方法，如parse()，它试图根据存储在给定SimpleDateFormat的对象的格式来转换字符串。\n\n```java\n    public static void main(String[] args) {\n\n        SimpleDateFormat format = new SimpleDateFormat(\"yy-MM-dd HH:mm:ss\");\n\n        String str = \"2020-05-6 23:45:48\";\n\n        Date date;\n        try {\n\n            date = format.parse(str);\n            System.out.println(date); //Wed May 06 23:45:48 CST 2020\n        } catch (ParseException e) {\n            System.out.println(\"cannot parsable using \" + format);\n        }\n    }\n```\n\n### 1.5 日期转字符串\n```java\n    SimpleDateFormat format=new SimpleDateFormat(\"yyyy-MM-dd\"); //yyyy 四位数年份 2019  yy两位数年份 19\n    String dateString=format.format(date);\n```\n\n## 2.Calendar类\n### 2.1获取当前日期\n* Calendar类主要用于日期与年，月，日等整数值的转换，Calendar是一个抽象类，**不能直接创建对象**。但是可以使用静态方法**getInstance()获得代表当前日期的日历对象**。\n\n### 2.1设置指定日期\n* 通过该对象可以调用如下方法将日历翻到指定的一个时间：\n```java\n    Calendar c = Calendar.getInstance();\n    c.set(2020,5,6);\n```\n### 2.3从日历中获取有关信息\n* 要从日历中获取有关年份、月份、星期、小时等的信息，可以通过**int get(int filed)**方法得到。其中参数field的值由Calender类的静态常量决定：YEAR代表年,MONTH代表月份,DAY_OF_WEEK代表星期几，HOUR代表小时,MINUTE代表分钟,SECOND代表秒。例如：\n```java\n    Calendar c = Calendar.getInstance();\n    String str = c.get(Calendar.YEAR) + \"-\" + (c.get(Calendar.MONTH) + 1) + \"-\" + c.get(Calendar.DATE);\n    System.out.println(str);    \n```\n> 如果`get(Calendar.MONTH)`返回值为0代表当前日历为一月份，如果返回1代表二月份，以此类推。\n\n### 2.4Date与Calendar互相转换\n```java\n    //Calendar转Date\n    Calendar cal1 = Calendar.getInstance();\n    Date date1 = cal1.getTime();\n    System.out.println(cal1);\n    System.out.println(\"-------------------------------\");\n    System.out.println(date1);\n    System.out.println(\"-------------------------------\");\n\n    //Date转Calendar\n    Date date2 = new Date();\n    Calendar cal2 = Calendar.getInstance();\n    cal2.setTime(date2);\n    System.out.println(cal2);\n    System.out.println(\"-------------------------------\");\n    System.out.println(date2);\n    System.out.println(date2);\n\n    /*\n    java.util.GregorianCalendar[time=1588781792372,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=7,DAY_OF_YEAR=128,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=16,SECOND=32,MILLISECOND=372,ZONE_OFFSET=28800000,DST_OFFSET=0]\n    -------------------------------\n    Thu May 07 00:16:32 CST 2020\n    -------------------------------\n    java.util.GregorianCalendar[time=1588781792385,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=7,DAY_OF_YEAR=128,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=16,SECOND=32,MILLISECOND=385,ZONE_OFFSET=28800000,DST_OFFSET=0]\n    -------------------------------\n    Thu May 07 00:16:32 CST 2020\n    */\n```\n\n\n\n\n\n\n\n\n\n\n\n>参考：https://www.cnblogs.com/coder-wzr/p/8416659.html\n","slug":"code/JavaSE/时间日期","published":1,"updated":"2021-05-03T07:31:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gj004x0w7td6ck2txs","content":"<p>在java.util包中提供了Date和Calendar两个类用来封装日期和时间有关的信息</p>\n<h2 id=\"1-Date类\"><a href=\"#1-Date类\" class=\"headerlink\" title=\"1.Date类\"></a>1.Date类</h2><p>在java中日期用代表<strong>毫微秒</strong>的一个厂整数镜像存储表示，也就是日期时间相对<strong>格林威治时间</strong>（GMT)1970年1月1日零点整数过去的毫微秒数。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-1-日期的构造方法如下：\"><a href=\"#1-1-日期的构造方法如下：\" class=\"headerlink\" title=\"1.1 日期的构造方法如下：\"></a>1.1 日期的构造方法如下：</h3><pre class=\" language-java\"><code class=\"language-java\">    Date date<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//创建一个当前日期</span>\n    Date date<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">DateDate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> millisec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//根据距离格林威时间的毫微秒数构造</span></code></pre>\n<h3 id=\"1-2常用方法\"><a href=\"#1-2常用方法\" class=\"headerlink\" title=\"1.2常用方法\"></a>1.2常用方法</h3><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">boolean</span> <span class=\"token function\">after</span><span class=\"token punctuation\">(</span>Date date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//如果调用Date对象包含或晚于指定的日期则返回true，否则，返回false。</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">before</span><span class=\"token punctuation\">(</span>Date date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//如果调用Date对象包含或早于日期指定的日期返回true，否则，返回false。</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>Date date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//调用对象的值与日期比较。如果这两个值相等返回0。如果调用对象是早于日期返回一个负值。如果调用对象迟于日期返回正值。</span>\n    <span class=\"token keyword\">long</span> <span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//返回自1970年1月1日起已经过的毫秒数。</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">setTime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//设置所指定的时间，这表示从1970年1月1日从午夜的时间和日期以毫秒为单位经过的时间。</span>\n    String <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//调用Date对象转换为字符串，并返回结果。</span></code></pre>\n<h3 id=\"1-3时间日期格式化\"><a href=\"#1-3时间日期格式化\" class=\"headerlink\" title=\"1.3时间日期格式化\"></a>1.3时间日期格式化</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>时代指示器</td>\n<td>AD</td>\n</tr>\n<tr>\n<td>y</td>\n<td>四位数年份</td>\n<td>2001</td>\n</tr>\n<tr>\n<td>M</td>\n<td>年中的月份</td>\n<td>July or 07</td>\n</tr>\n<tr>\n<td>d</td>\n<td>月份中日期</td>\n<td>10</td>\n</tr>\n<tr>\n<td>h</td>\n<td>时间 A.M./P.M.(1~12)</td>\n<td>12</td>\n</tr>\n<tr>\n<td>H</td>\n<td>天中的小时 (0~23)</td>\n<td>22</td>\n</tr>\n<tr>\n<td>m</td>\n<td>小时中的分钟</td>\n<td>30</td>\n</tr>\n<tr>\n<td>s</td>\n<td>分钟中的秒钟</td>\n<td>55</td>\n</tr>\n<tr>\n<td>S</td>\n<td>毫秒</td>\n<td>234</td>\n</tr>\n<tr>\n<td>E</td>\n<td>星期中的天</td>\n<td>Tuesday</td>\n</tr>\n<tr>\n<td>M</td>\n<td>年中的天</td>\n<td>July or 07</td>\n</tr>\n<tr>\n<td>D</td>\n<td>年中的月份</td>\n<td>360</td>\n</tr>\n<tr>\n<td>a</td>\n<td>A.M./P.M. 标记</td>\n<td>A.M./P.M. 标记</td>\n</tr>\n<tr>\n<td>w</td>\n<td>年中的星期</td>\n<td>40</td>\n</tr>\n<tr>\n<td>W</td>\n<td>月中的星期</td>\n<td>1</td>\n</tr>\n<tr>\n<td>k</td>\n<td>天中的小时(1~24)</td>\n<td>24</td>\n</tr>\n<tr>\n<td>K</td>\n<td>小时A.M./P.M. (0~11)</td>\n<td>10</td>\n</tr>\n<tr>\n<td>z</td>\n<td>时区</td>\n<td>东部标准时间</td>\n</tr>\n<tr>\n<td>‘</td>\n<td>脱离文本</td>\n<td>分隔符</td>\n</tr>\n<tr>\n<td>“</td>\n<td>单引号</td>\n<td>`</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-4字符串转换日期\"><a href=\"#1-4字符串转换日期\" class=\"headerlink\" title=\"1.4字符串转换日期\"></a>1.4字符串转换日期</h3><p>SimpleDateFormat类有一些额外的方法，如parse()，它试图根据存储在给定SimpleDateFormat的对象的格式来转换字符串。</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        SimpleDateFormat format <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yy-MM-dd HH:mm:ss\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        String str <span class=\"token operator\">=</span> <span class=\"token string\">\"2020-05-6 23:45:48\"</span><span class=\"token punctuation\">;</span>\n\n        Date date<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n\n            date <span class=\"token operator\">=</span> format<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//Wed May 06 23:45:48 CST 2020</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ParseException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cannot parsable using \"</span> <span class=\"token operator\">+</span> format<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"1-5-日期转字符串\"><a href=\"#1-5-日期转字符串\" class=\"headerlink\" title=\"1.5 日期转字符串\"></a>1.5 日期转字符串</h3><pre class=\" language-java\"><code class=\"language-java\">    SimpleDateFormat format<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yyyy-MM-dd\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//yyyy 四位数年份 2019  yy两位数年份 19</span>\n    String dateString<span class=\"token operator\">=</span>format<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"2-Calendar类\"><a href=\"#2-Calendar类\" class=\"headerlink\" title=\"2.Calendar类\"></a>2.Calendar类</h2><h3 id=\"2-1获取当前日期\"><a href=\"#2-1获取当前日期\" class=\"headerlink\" title=\"2.1获取当前日期\"></a>2.1获取当前日期</h3><ul>\n<li>Calendar类主要用于日期与年，月，日等整数值的转换，Calendar是一个抽象类，<strong>不能直接创建对象</strong>。但是可以使用静态方法<strong>getInstance()获得代表当前日期的日历对象</strong>。</li>\n</ul>\n<h3 id=\"2-1设置指定日期\"><a href=\"#2-1设置指定日期\" class=\"headerlink\" title=\"2.1设置指定日期\"></a>2.1设置指定日期</h3><ul>\n<li>通过该对象可以调用如下方法将日历翻到指定的一个时间：<pre class=\" language-java\"><code class=\"language-java\">  Calendar c <span class=\"token operator\">=</span> Calendar<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  c<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token number\">2020</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"2-3从日历中获取有关信息\"><a href=\"#2-3从日历中获取有关信息\" class=\"headerlink\" title=\"2.3从日历中获取有关信息\"></a>2.3从日历中获取有关信息</h3></li>\n<li>要从日历中获取有关年份、月份、星期、小时等的信息，可以通过<strong>int get(int filed)</strong>方法得到。其中参数field的值由Calender类的静态常量决定：YEAR代表年,MONTH代表月份,DAY_OF_WEEK代表星期几，HOUR代表小时,MINUTE代表分钟,SECOND代表秒。例如：<pre class=\" language-java\"><code class=\"language-java\">  Calendar c <span class=\"token operator\">=</span> Calendar<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  String str <span class=\"token operator\">=</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Calendar<span class=\"token punctuation\">.</span>YEAR<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"-\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Calendar<span class=\"token punctuation\">.</span>MONTH<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"-\"</span> <span class=\"token operator\">+</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Calendar<span class=\"token punctuation\">.</span>DATE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </code></pre>\n<blockquote>\n<p>如果<code>get(Calendar.MONTH)</code>返回值为0代表当前日历为一月份，如果返回1代表二月份，以此类推。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2-4Date与Calendar互相转换\"><a href=\"#2-4Date与Calendar互相转换\" class=\"headerlink\" title=\"2.4Date与Calendar互相转换\"></a>2.4Date与Calendar互相转换</h3><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token comment\" spellcheck=\"true\">//Calendar转Date</span>\n    Calendar cal1 <span class=\"token operator\">=</span> Calendar<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Date date1 <span class=\"token operator\">=</span> cal1<span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>cal1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-------------------------------\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>date1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-------------------------------\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//Date转Calendar</span>\n    Date date2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Calendar cal2 <span class=\"token operator\">=</span> Calendar<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cal2<span class=\"token punctuation\">.</span><span class=\"token function\">setTime</span><span class=\"token punctuation\">(</span>date2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>cal2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-------------------------------\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>date2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>date2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    java.util.GregorianCalendar[time=1588781792372,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=7,DAY_OF_YEAR=128,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=16,SECOND=32,MILLISECOND=372,ZONE_OFFSET=28800000,DST_OFFSET=0]\n    -------------------------------\n    Thu May 07 00:16:32 CST 2020\n    -------------------------------\n    java.util.GregorianCalendar[time=1588781792385,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=7,DAY_OF_YEAR=128,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=16,SECOND=32,MILLISECOND=385,ZONE_OFFSET=28800000,DST_OFFSET=0]\n    -------------------------------\n    Thu May 07 00:16:32 CST 2020\n    */</span></code></pre>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/coder-wzr/p/8416659.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/coder-wzr/p/8416659.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>在java.util包中提供了Date和Calendar两个类用来封装日期和时间有关的信息</p>\n<h2 id=\"1-Date类\"><a href=\"#1-Date类\" class=\"headerlink\" title=\"1.Date类\"></a>1.Date类</h2><p>在java中日期用代表<strong>毫微秒</strong>的一个厂整数镜像存储表示，也就是日期时间相对<strong>格林威治时间</strong>（GMT)1970年1月1日零点整数过去的毫微秒数。</p>","more":"<h3 id=\"1-1-日期的构造方法如下：\"><a href=\"#1-1-日期的构造方法如下：\" class=\"headerlink\" title=\"1.1 日期的构造方法如下：\"></a>1.1 日期的构造方法如下：</h3><pre><code class=\"java\">    Date date=new Date();   //创建一个当前日期\n    Date date=new DateDate(long millisec)(); //根据距离格林威时间的毫微秒数构造</code></pre>\n<h3 id=\"1-2常用方法\"><a href=\"#1-2常用方法\" class=\"headerlink\" title=\"1.2常用方法\"></a>1.2常用方法</h3><pre><code class=\"java\">    boolean after(Date date); //如果调用Date对象包含或晚于指定的日期则返回true，否则，返回false。\n    boolean before(Date date);//如果调用Date对象包含或早于日期指定的日期返回true，否则，返回false。\n    int compareTo(Date date);//调用对象的值与日期比较。如果这两个值相等返回0。如果调用对象是早于日期返回一个负值。如果调用对象迟于日期返回正值。\n    long getTime( );//返回自1970年1月1日起已经过的毫秒数。\n    void setTime(long time);//设置所指定的时间，这表示从1970年1月1日从午夜的时间和日期以毫秒为单位经过的时间。\n    String toString();//调用Date对象转换为字符串，并返回结果。</code></pre>\n<h3 id=\"1-3时间日期格式化\"><a href=\"#1-3时间日期格式化\" class=\"headerlink\" title=\"1.3时间日期格式化\"></a>1.3时间日期格式化</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>时代指示器</td>\n<td>AD</td>\n</tr>\n<tr>\n<td>y</td>\n<td>四位数年份</td>\n<td>2001</td>\n</tr>\n<tr>\n<td>M</td>\n<td>年中的月份</td>\n<td>July or 07</td>\n</tr>\n<tr>\n<td>d</td>\n<td>月份中日期</td>\n<td>10</td>\n</tr>\n<tr>\n<td>h</td>\n<td>时间 A.M./P.M.(1~12)</td>\n<td>12</td>\n</tr>\n<tr>\n<td>H</td>\n<td>天中的小时 (0~23)</td>\n<td>22</td>\n</tr>\n<tr>\n<td>m</td>\n<td>小时中的分钟</td>\n<td>30</td>\n</tr>\n<tr>\n<td>s</td>\n<td>分钟中的秒钟</td>\n<td>55</td>\n</tr>\n<tr>\n<td>S</td>\n<td>毫秒</td>\n<td>234</td>\n</tr>\n<tr>\n<td>E</td>\n<td>星期中的天</td>\n<td>Tuesday</td>\n</tr>\n<tr>\n<td>M</td>\n<td>年中的天</td>\n<td>July or 07</td>\n</tr>\n<tr>\n<td>D</td>\n<td>年中的月份</td>\n<td>360</td>\n</tr>\n<tr>\n<td>a</td>\n<td>A.M./P.M. 标记</td>\n<td>A.M./P.M. 标记</td>\n</tr>\n<tr>\n<td>w</td>\n<td>年中的星期</td>\n<td>40</td>\n</tr>\n<tr>\n<td>W</td>\n<td>月中的星期</td>\n<td>1</td>\n</tr>\n<tr>\n<td>k</td>\n<td>天中的小时(1~24)</td>\n<td>24</td>\n</tr>\n<tr>\n<td>K</td>\n<td>小时A.M./P.M. (0~11)</td>\n<td>10</td>\n</tr>\n<tr>\n<td>z</td>\n<td>时区</td>\n<td>东部标准时间</td>\n</tr>\n<tr>\n<td>‘</td>\n<td>脱离文本</td>\n<td>分隔符</td>\n</tr>\n<tr>\n<td>“</td>\n<td>单引号</td>\n<td>`</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-4字符串转换日期\"><a href=\"#1-4字符串转换日期\" class=\"headerlink\" title=\"1.4字符串转换日期\"></a>1.4字符串转换日期</h3><p>SimpleDateFormat类有一些额外的方法，如parse()，它试图根据存储在给定SimpleDateFormat的对象的格式来转换字符串。</p>\n<pre><code class=\"java\">    public static void main(String[] args) {\n\n        SimpleDateFormat format = new SimpleDateFormat(&quot;yy-MM-dd HH:mm:ss&quot;);\n\n        String str = &quot;2020-05-6 23:45:48&quot;;\n\n        Date date;\n        try {\n\n            date = format.parse(str);\n            System.out.println(date); //Wed May 06 23:45:48 CST 2020\n        } catch (ParseException e) {\n            System.out.println(&quot;cannot parsable using &quot; + format);\n        }\n    }</code></pre>\n<h3 id=\"1-5-日期转字符串\"><a href=\"#1-5-日期转字符串\" class=\"headerlink\" title=\"1.5 日期转字符串\"></a>1.5 日期转字符串</h3><pre><code class=\"java\">    SimpleDateFormat format=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); //yyyy 四位数年份 2019  yy两位数年份 19\n    String dateString=format.format(date);</code></pre>\n<h2 id=\"2-Calendar类\"><a href=\"#2-Calendar类\" class=\"headerlink\" title=\"2.Calendar类\"></a>2.Calendar类</h2><h3 id=\"2-1获取当前日期\"><a href=\"#2-1获取当前日期\" class=\"headerlink\" title=\"2.1获取当前日期\"></a>2.1获取当前日期</h3><ul>\n<li>Calendar类主要用于日期与年，月，日等整数值的转换，Calendar是一个抽象类，<strong>不能直接创建对象</strong>。但是可以使用静态方法<strong>getInstance()获得代表当前日期的日历对象</strong>。</li>\n</ul>\n<h3 id=\"2-1设置指定日期\"><a href=\"#2-1设置指定日期\" class=\"headerlink\" title=\"2.1设置指定日期\"></a>2.1设置指定日期</h3><ul>\n<li>通过该对象可以调用如下方法将日历翻到指定的一个时间：<pre><code class=\"java\">  Calendar c = Calendar.getInstance();\n  c.set(2020,5,6);</code></pre>\n<h3 id=\"2-3从日历中获取有关信息\"><a href=\"#2-3从日历中获取有关信息\" class=\"headerlink\" title=\"2.3从日历中获取有关信息\"></a>2.3从日历中获取有关信息</h3></li>\n<li>要从日历中获取有关年份、月份、星期、小时等的信息，可以通过<strong>int get(int filed)</strong>方法得到。其中参数field的值由Calender类的静态常量决定：YEAR代表年,MONTH代表月份,DAY_OF_WEEK代表星期几，HOUR代表小时,MINUTE代表分钟,SECOND代表秒。例如：<pre><code class=\"java\">  Calendar c = Calendar.getInstance();\n  String str = c.get(Calendar.YEAR) + &quot;-&quot; + (c.get(Calendar.MONTH) + 1) + &quot;-&quot; + c.get(Calendar.DATE);\n  System.out.println(str);    </code></pre>\n<blockquote>\n<p>如果<code>get(Calendar.MONTH)</code>返回值为0代表当前日历为一月份，如果返回1代表二月份，以此类推。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2-4Date与Calendar互相转换\"><a href=\"#2-4Date与Calendar互相转换\" class=\"headerlink\" title=\"2.4Date与Calendar互相转换\"></a>2.4Date与Calendar互相转换</h3><pre><code class=\"java\">    //Calendar转Date\n    Calendar cal1 = Calendar.getInstance();\n    Date date1 = cal1.getTime();\n    System.out.println(cal1);\n    System.out.println(&quot;-------------------------------&quot;);\n    System.out.println(date1);\n    System.out.println(&quot;-------------------------------&quot;);\n\n    //Date转Calendar\n    Date date2 = new Date();\n    Calendar cal2 = Calendar.getInstance();\n    cal2.setTime(date2);\n    System.out.println(cal2);\n    System.out.println(&quot;-------------------------------&quot;);\n    System.out.println(date2);\n    System.out.println(date2);\n\n    /*\n    java.util.GregorianCalendar[time=1588781792372,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=&quot;Asia/Shanghai&quot;,offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=7,DAY_OF_YEAR=128,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=16,SECOND=32,MILLISECOND=372,ZONE_OFFSET=28800000,DST_OFFSET=0]\n    -------------------------------\n    Thu May 07 00:16:32 CST 2020\n    -------------------------------\n    java.util.GregorianCalendar[time=1588781792385,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=&quot;Asia/Shanghai&quot;,offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=7,DAY_OF_YEAR=128,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=16,SECOND=32,MILLISECOND=385,ZONE_OFFSET=28800000,DST_OFFSET=0]\n    -------------------------------\n    Thu May 07 00:16:32 CST 2020\n    */</code></pre>\n<blockquote>\n<p>参考：<a href=\"https://www.cnblogs.com/coder-wzr/p/8416659.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/coder-wzr/p/8416659.html</a></p>\n</blockquote>"},{"title":"JavaWeb异常汇总","abbrlink":"93780083","data":"2020-04-27T14:37:10.000Z","_content":"* SpringBoot\n    * Spring Data Jpa\n\n<!-- more -->\n## SpringBoot\n\n\n### Spring Data Jpa\n* 在一定情况下使用Mysql主键varchar字节数过长或者没有设置默认为255时,会有一定几率报错。\n    > ➱https://blog.csdn.net/kaizi_1992/article/details/103842869➲","source":"_posts/code/JavaWeb/JavaWeb异常汇总.md","raw":"---\ntitle: JavaWeb异常汇总\ncategories: Code\ntags: JavaWeb Exception\n# photos:\n#   - - 'https://i.loli.net/2020/04/27/c92MfQJstFzrwRy.png'\nabbrlink: '93780083'\ndata: 2020-04-27 22:37:10\n---\n* SpringBoot\n    * Spring Data Jpa\n\n<!-- more -->\n## SpringBoot\n\n\n### Spring Data Jpa\n* 在一定情况下使用Mysql主键varchar字节数过长或者没有设置默认为255时,会有一定几率报错。\n    > ➱https://blog.csdn.net/kaizi_1992/article/details/103842869➲","slug":"code/JavaWeb/JavaWeb异常汇总","published":1,"date":"2021-08-09T10:06:58.818Z","updated":"2020-05-03T17:02:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gk00510w7tegzm2trr","content":"<ul>\n<li>SpringBoot<ul>\n<li>Spring Data Jpa</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h2><h3 id=\"Spring-Data-Jpa\"><a href=\"#Spring-Data-Jpa\" class=\"headerlink\" title=\"Spring Data Jpa\"></a>Spring Data Jpa</h3><ul>\n<li>在一定情况下使用Mysql主键varchar字节数过长或者没有设置默认为255时,会有一定几率报错。<blockquote>\n<p>➱<a href=\"https://blog.csdn.net/kaizi_1992/article/details/103842869➲\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kaizi_1992/article/details/103842869➲</a></p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>SpringBoot<ul>\n<li>Spring Data Jpa</li>\n</ul>\n</li>\n</ul>","more":"<h2 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h2><h3 id=\"Spring-Data-Jpa\"><a href=\"#Spring-Data-Jpa\" class=\"headerlink\" title=\"Spring Data Jpa\"></a>Spring Data Jpa</h3><ul>\n<li>在一定情况下使用Mysql主键varchar字节数过长或者没有设置默认为255时,会有一定几率报错。<blockquote>\n<p>➱<a href=\"https://blog.csdn.net/kaizi_1992/article/details/103842869➲\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kaizi_1992/article/details/103842869➲</a></p>\n</blockquote>\n</li>\n</ul>"},{"title":"Spring Data Jpa模糊查询","declare":true,"wordCount":true,"abbrlink":"b1de1f1","date":"2020-05-03T15:55:10.000Z","_content":"\n晚上在用Spring Data Jpa做一个复杂查询的时候，用到了模糊查询，遇到了一个坑，花了很多时间，严重打击了我的积极性... ，可能也是很多人即使看了官方文档也容易忽略的地方。\n\n* Spring Data JPa模糊查询\n```java\n    List<MoveInfo> moveInfoList2=moveInfoService.findByLocationLike(\"%\"+location+\"%\");\n```\n \n**需要注意的是一定要在要在`location`左右加`%`!!!**    \n说实话用了`findByLocationLike`还需要手动写%,确实不怎么合理，希望未来版本官方会改进吧。\n<!-- more -->\n\n\n","source":"_posts/code/JavaWeb/Spring Data Jpa模糊查询.md","raw":"---\ntitle: Spring Data Jpa模糊查询\ncategories: Code\ntags:\n  - JavaWeb\n  - ORM\n  - JPA\ndeclare: true\nwordCount: true\nabbrlink: b1de1f1\ndate: 2020-05-03 23:55:10\n---\n\n晚上在用Spring Data Jpa做一个复杂查询的时候，用到了模糊查询，遇到了一个坑，花了很多时间，严重打击了我的积极性... ，可能也是很多人即使看了官方文档也容易忽略的地方。\n\n* Spring Data JPa模糊查询\n```java\n    List<MoveInfo> moveInfoList2=moveInfoService.findByLocationLike(\"%\"+location+\"%\");\n```\n \n**需要注意的是一定要在要在`location`左右加`%`!!!**    \n说实话用了`findByLocationLike`还需要手动写%,确实不怎么合理，希望未来版本官方会改进吧。\n<!-- more -->\n\n\n","slug":"code/JavaWeb/Spring Data Jpa模糊查询","published":1,"updated":"2020-05-22T03:59:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gl00540w7t9ngia1gp","content":"<p>晚上在用Spring Data Jpa做一个复杂查询的时候，用到了模糊查询，遇到了一个坑，花了很多时间，严重打击了我的积极性… ，可能也是很多人即使看了官方文档也容易忽略的地方。</p>\n<ul>\n<li>Spring Data JPa模糊查询<pre class=\" language-java\"><code class=\"language-java\">  List<span class=\"token operator\">&lt;</span>MoveInfo<span class=\"token operator\">></span> moveInfoList2<span class=\"token operator\">=</span>moveInfoService<span class=\"token punctuation\">.</span><span class=\"token function\">findByLocationLike</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%\"</span><span class=\"token operator\">+</span>location<span class=\"token operator\">+</span><span class=\"token string\">\"%\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n<p><strong>需要注意的是一定要在要在<code>location</code>左右加<code>%</code>!!!</strong><br>说实话用了<code>findByLocationLike</code>还需要手动写%,确实不怎么合理，希望未来版本官方会改进吧。</p>\n<a id=\"more\"></a>\n\n\n","site":{"data":{}},"excerpt":"<p>晚上在用Spring Data Jpa做一个复杂查询的时候，用到了模糊查询，遇到了一个坑，花了很多时间，严重打击了我的积极性… ，可能也是很多人即使看了官方文档也容易忽略的地方。</p>\n<ul>\n<li>Spring Data JPa模糊查询<pre><code class=\"java\">  List&lt;MoveInfo&gt; moveInfoList2=moveInfoService.findByLocationLike(&quot;%&quot;+location+&quot;%&quot;);</code></pre>\n</li>\n</ul>\n<p><strong>需要注意的是一定要在要在<code>location</code>左右加<code>%</code>!!!</strong><br>说实话用了<code>findByLocationLike</code>还需要手动写%,确实不怎么合理，希望未来版本官方会改进吧。</p>","more":""},{"title":"Spring Data JPA分页查询","declare":true,"wordCount":true,"abbrlink":"2d8953d4","date":"2020-05-22T04:10:10.000Z","_content":"\n### 控制层\n```java\n    @RequestMapping(\"/allUser\")\n    public ModelAndView listByPages(@RequestParam(value = \"pageNum\", defaultValue = \"1\") Integer pageNum) {\n        ModelAndView mav = new ModelAndView();\n        Sort sort = Sort.by(Sort.Direction.ASC, \"id\");\n        Pageable pageable = PageRequest.of(pageNum - 1, 4, sort); //页数、每页大小、排序方法\n        Page<User> users = userService.findAll(pageable);\n        mav.addObject(\"allUser\", users);\n        mav.setViewName(\"allUser\");\n        return mav;\n\n    }\n```\n### 业务层\n```java\n    @Override\n    public Page<User> findAll(Pageable pageable) {\n        return userDao.findAll(pageable);\n    }\n```","source":"_posts/code/JavaWeb/Spring Data JPA分页查询.md","raw":"---\ntitle: Spring Data JPA分页查询\ncategories: Code\ntags:\n  - JavaWeb\n  - ORM\n  - JPA\ndeclare: true\nwordCount: true\nabbrlink: 2d8953d4\ndate: 2020-05-22 12:10:10\n---\n\n### 控制层\n```java\n    @RequestMapping(\"/allUser\")\n    public ModelAndView listByPages(@RequestParam(value = \"pageNum\", defaultValue = \"1\") Integer pageNum) {\n        ModelAndView mav = new ModelAndView();\n        Sort sort = Sort.by(Sort.Direction.ASC, \"id\");\n        Pageable pageable = PageRequest.of(pageNum - 1, 4, sort); //页数、每页大小、排序方法\n        Page<User> users = userService.findAll(pageable);\n        mav.addObject(\"allUser\", users);\n        mav.setViewName(\"allUser\");\n        return mav;\n\n    }\n```\n### 业务层\n```java\n    @Override\n    public Page<User> findAll(Pageable pageable) {\n        return userDao.findAll(pageable);\n    }\n```","slug":"code/JavaWeb/Spring Data JPA分页查询","published":1,"updated":"2020-05-22T03:59:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gm00580w7t62cs75ns","content":"<h3 id=\"控制层\"><a href=\"#控制层\" class=\"headerlink\" title=\"控制层\"></a>控制层</h3><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/allUser\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> ModelAndView <span class=\"token function\">listByPages</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestParam</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"pageNum\"</span><span class=\"token punctuation\">,</span> defaultValue <span class=\"token operator\">=</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span> Integer pageNum<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ModelAndView mav <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ModelAndView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Sort sort <span class=\"token operator\">=</span> Sort<span class=\"token punctuation\">.</span><span class=\"token function\">by</span><span class=\"token punctuation\">(</span>Sort<span class=\"token punctuation\">.</span>Direction<span class=\"token punctuation\">.</span>ASC<span class=\"token punctuation\">,</span> <span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Pageable pageable <span class=\"token operator\">=</span> PageRequest<span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>pageNum <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> sort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//页数、每页大小、排序方法</span>\n        Page<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> users <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span>pageable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mav<span class=\"token punctuation\">.</span><span class=\"token function\">addObject</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"allUser\"</span><span class=\"token punctuation\">,</span> users<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mav<span class=\"token punctuation\">.</span><span class=\"token function\">setViewName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"allUser\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> mav<span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"业务层\"><a href=\"#业务层\" class=\"headerlink\" title=\"业务层\"></a>业务层</h3><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Page<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span>Pageable pageable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> userDao<span class=\"token punctuation\">.</span><span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span>pageable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"控制层\"><a href=\"#控制层\" class=\"headerlink\" title=\"控制层\"></a>控制层</h3><pre><code class=\"java\">    @RequestMapping(&quot;/allUser&quot;)\n    public ModelAndView listByPages(@RequestParam(value = &quot;pageNum&quot;, defaultValue = &quot;1&quot;) Integer pageNum) {\n        ModelAndView mav = new ModelAndView();\n        Sort sort = Sort.by(Sort.Direction.ASC, &quot;id&quot;);\n        Pageable pageable = PageRequest.of(pageNum - 1, 4, sort); //页数、每页大小、排序方法\n        Page&lt;User&gt; users = userService.findAll(pageable);\n        mav.addObject(&quot;allUser&quot;, users);\n        mav.setViewName(&quot;allUser&quot;);\n        return mav;\n\n    }</code></pre>\n<h3 id=\"业务层\"><a href=\"#业务层\" class=\"headerlink\" title=\"业务层\"></a>业务层</h3><pre><code class=\"java\">    @Override\n    public Page&lt;User&gt; findAll(Pageable pageable) {\n        return userDao.findAll(pageable);\n    }</code></pre>\n"},{"title":"Hibernate基础","abbrlink":30225,"data":"2020-04-21T17:40:10.000Z","declare":true,"wordCount":true,"_content":"\n❄    \n<!--more -->\n\n### Hibernate\n\n#### 初识\n* 加载过程\n    ![加载过程](https://i.loli.net/2020/04/16/v7NnVpWlyCYFaJB.png)\n\n* Hibernate全局配置文件\n    ```xml\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE hibernate-configuration PUBLIC\n                \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n                \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n        <hibernate-configuration>\n            <session-factory>\n                <!-- 设置数据库驱动 -->\n                <property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n                <!-- 设置数据库URL -->\n                <property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/hibernate?useUnicode=true&amp;characterEncoding=utf-8</property>\n                <!-- 数据库用户名 -->\n                <property name=\"hibernate.connection.username\">root</property>\n                <!-- 数据库密码 -->\n                <property name=\"hibernate.connection.password\">369cc</property>\n                <!-- 指定对应数据库的方言，hibernate为了更好适配各种关系数据库，针对每种数据库都指定了一个方言dialect -->\n                <property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n                <!--显示sql语句 -->\n                <property name=\"hibernate.show_sql\">true</property>\n                <!--格式化sql语句 -->\n                <property name=\"format_sql\">true</property>\n                <!--自动生成表 -->\n                <property name=\"hibernate.hbm2ddl.auto\">update</property>\n                <!-- 映射文件 -->\n                <mapping resource=\"hbm/User.hbm.xml\"/>\n                <mapping resource=\"hbm/Order1.hbm.xml\"/>\n                <mapping resource=\"hbm/Customer.hbm.xml\"/>\n            </session-factory>\n        </hibernate-configuration>\n    ```\n* Hibernate映射文件\n    ```xml\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <!DOCTYPE hibernate-mapping PUBLIC\n                \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n                \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n        <hibernate-mapping>\n            <!-- class配置了对象和表的关系 -->\n            <class name=\"com.smart.zero.domain.Order1\"\n                table=\"orders\">  <!-- id元素是用来配置主键字段和属性关系的   name:属性名   column:字段名   type:两者者之间转换时使用的类型   -->\n                <id name=\"id\" type=\"integer\" column=\"oid\">\n                    <generator class=\"native\"/><!-- 用来指明主键生成方式 -->\n                </id>\n                <!-- property元素是用来配置普通字段和属性关系的 -->\n                <property name=\"address\" length=\"50\" type=\"string\" column=\"address\"/>\n                <property name=\"price\" type=\"double\" column=\"price\"/>\n                <!-- 配置映射 -->\n                <!-- <many-to-one>标签    name  :关联对象的属性的名称.    column :表中的外键名称.    class :关联对象类的全路径   -->\n                <many-to-one name=\"customer\" column=\"cno\" class=\"com.smart.zero.domain.Customer\"/>\n            </class>\n        </hibernate-mapping>\n\n    ```\n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n#### Hibernate持久化对象的三种状态\n* ![Hibernate持久化对象的三种状态](https://i.loli.net/2020/04/16/2W9I6hqOXo4mrla.png)\n    * 瞬时态\n        >由java的new命令开辟内存空间的java对象也就是普通的java对象，如果没有变量引用它它将会被JVM收回。**临时对象在内存中是孤立存在的，它的意义是携带信息载体，不和数据库中的数据有任何的关联**。通过Session的save（）方法和saveOrUpdate（）方法可以**把一个临时对象和数据库相关联，并把临时对象携带的信息通过配置文件所做的映射插入数据库中**，这个临时对象就成为持久化对象。\n    * 持久态\n        >**持久化对象在数据库中有相应的记录，持久化对象可以是刚被保存的，或者刚被加载的,但都是在相关联的session声明周期中保存这个状态**。如果是直接数据库查询所返回的数据对象，则这些对象和数据库中的字段相关联，具有相同的id，它们马上变成持久化对象。如果一个临时对象被持久化对象引用，也立马变为持久化对象。\n\n        >如果使用delete（）方法，持久化对象变为临时对象，并且删除数据库中相应的记录，这个对象不再与数据库有任何的联系。\n\n        >持久化对象总是与Session和Transaction关联在一起，在一个session中，对持久化对象的操作不会立即写到数据库，只有当Transaction（事务）结束时，才真正的对数据库更新，从而完成持久化对象和数据库的同步。在同步之前的持久化对象成为脏对象。\n\n        >当一个session()执行close()、clear()、或evict()之后，持久化对象就变为离线对象，这时对象的id虽然拥有数据库的识别值，但已经不在Hibernate持久层的管理下，他和临时对象基本上一样的，**只不过比临时对象多了数据库标识id**。没有任何变量引用时，jvm将其回收。\n\n    * 游离态\n        >**Session关闭之后，与此Session关联的持久化对象就变成为脱管对象**，可以继续对这个对象进行修改，如果脱管对象被重新关联到某个新的Session上，会在此转成持久对象。\n\n脱管对象虽然拥有用户的标识id，所以通过update（）、saveOrUpdate（）等方法，再次与持久层关联。\n\n下面我们就通过使用hibernate，实现对数据库的增删改查来体现三种状态之间的转换过程。\n\n* 状态转换\n    * ![图片.png](https://i.loli.net/2020/04/16/cJtdRTGMy2XsjOg.png)\n\n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n#### 一级缓存\n* [Hibernate一级缓存](https://www.cnblogs.com/QianYue111/p/9747723.html)\n* 缓存\n    >缓存介于应用程序和永久性数据存储源之间，其作用是**降低应用程序直接读写永久性数据存储源的概率**，从而**提高应用程序的运行性能**，缓存的物理介质通常是内存；\n* 一级缓存\n    >hibernate的缓存分为一级和二级缓存，两者都位于持久化层,**存储的都是数据库数据的备份**，其中一级缓存为hibernate的内置缓存，不能卸载\n\n    >hibernate的一级缓存就是指session缓存，session缓存是一块存储空间用来存放相互管理的Java对象，在使用hibernate查询对象的时候，**首先会使用对象属性的oid值在session缓存中查找，如果找到了就会直接从session中提取，不会再查询数据库如果没有找到匹配的，则回去数据库查询，并且把找到的数据存入session缓存中**。一级缓存就是为了减少对熟虑库的访问次数。\n\n    >在Session 接口的实现中**包含一系列的Java集合**，这些Java集合构成了Sesion 缓存。只要Session实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。固一级缓存也被称为是Session基本的缓存。\n    *  Hibernate的一级缓存有如下特点:\n        1. 当应用程序调用Session接口的save(）、update（）、 saveOrUpdate 时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。\n        2. 当调用Session接目的load()、get()方法， 以及Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询对象，再去数据库中查询对应对象，并添加到一级缓存中。\n        3. 如果调用了session的close()方法，则缓存会被清空\n\n* 快照\n    >Hibemate向一级缓存放入数据时，**同时复制一份数据放入到Hibernate快照中**，当**使用commit()方法提交事务时**，同时会清理Session的一级缓存， 这时会**使用oid判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照:如果一致，则不执行update语句。**\n    * Hibermate快照的作用就是**确保一级缓存中的数据和数据库中的数据一致**\n    * 快照的根本作用是保证数据一致性，保证数据一致的另一种做法是，commit之前把堆内存中的数据直接与数据库中的对应记录进行对比，显而易见这样的效率是灰常低下的，而采用快照技术，因为快照是一定和数据库中记录一致的，快照也在堆内存中，所以**速度不是一般的快**。(如果没有变化的话,堆内存的数据于同在堆内存的快照比较的速度肯定要比堆内存的数据于数据库)\n\n* 常见操作\n    * `clear()`：**清除session中的缓存数据**（不管缓存与数据库的同步）。\n    * `flush()`：**将session的缓存中的数据与数据库同步**。\n        >执行完session.flush()时，并不意味着数据就肯定持久化到数据库中的，因为事务控制着数据库，如果事务提交失败了，缓存中的数据还是照样会被回滚的。\n    * `refresh()`：reflush操作会**使数据库记录与session缓存记录保持一致**，也就是是说会强制向数据库发送一条select语句。 \n\n \n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n#### hibernate控制反转\n* [hibernate控制反转](https://blog.csdn.net/u013488838/article/details/50068745)\n* [inverse 控制反转](https://blog.csdn.net/qq_29331365/article/details/100151742?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)\n\n    >何为控制反转, 比如 Poeple(人) 和 Address(地址)  :一个人可以拥有多个地址,那么在配置的时候 在Poeple.hbm,xml 中 设置 one-To-Many (先不考虑Address配置文件) 那么Ok 当我们向People对象 添加 新的地址时  调用代码 \n    ```java\n        People p = new People(“王三”);\n\n        Address address = new Address(\"公司地址\");\n\n        p.getAddress().add(address) ;\n\n        save(p);\n\n        save(address);\n    ```\n    >当我们查看 控制台输出的语句会发现   **有两个insert 语句 和一个 update 语句 显然这是非常消耗性能的** ，正确的应该是 只有两个 insert \n    >现在我们分析下 hibernate 的操作 先保存了People 之后 保存了 Address 最后又修改了 Address 的 关联的peopleId 外键属性 这是由于Address 的外键值是由Poeple来控制的\n    >现在我们在People 的 配置文件中 加上 inverse=\"true\" 在执行上诉步骤 会发现 只有两条Insert 语句\n\n<br>\n\n***\n\n<br>\n\n\n#### 查询\n\n* 导航对象图检索\n    * **根据已加载的对象导航到其他对象**。利用类与类之间的关系来检索对象。\n    ```java\n        Order order=(Order)session.get(Order.class);\n        Customer customer=order.get(Customer);\n    \n    ```\n\n\n\n* 投影查询\n    * 查询对象部分属性\n    ```java\n        String HQL=\"select u.name,u.password from User as u\"//此时必须要select\n        Query query=session.createQuery(HQL);\n        List<Object[]> list=query.list()//注意list存放的是Object数组\n    ```\n\n* 动态实例查询\n    * 在投影查询时，返回的查询对象是一个对象数组，操作起来并不是很方便。所以将投影查询的返回结果重新组成一个实体的实例，这就是动态实例化查询。\n    ```java\n        Strng HQL=\"selct new User(u.name,u.password) from User as u\";\n        Query query=session.createQuery(HQL);\n        List<User> list=query.list();\n\n        //必须要有相应的构造方法\n        public User(String name,String password){\n            super();\n            this.name=name;\n            this.password=password;\n        }\n\n    ```\n\n* 条件查询\n    * 使用`where,like`等\n        * 按参数位置查询\n            * **使用 `?` 来定义参数的位置**，然后利用Query对象的Setter方法为其赋值，类似于JDBC的PrepareStatement对象的参数绑定方法。\n            ```java\n                String HQL=\"from User where name=? and id=?\";\n                Query query=session.createQuery(HQL);\n                query.setString(0,\"JONE\");\n                query.setInteger(1,3);\n                User user=(User)query.uniqueResult();\n\n                ////\n\n                String HQL=\"form Uesr where name like ?\";\n                Query query=session.createQuery(HQL);\n                query.setString(0,\"%o%\")//模糊查询\n                List<User> list=query.list();\n\n            ```\n        * 按参数名称查询\n           * 在HQL中自定义\n            ```java\n                String HQL=\"form Uesr where name=:name and id=:id\"; \n                Query query=session.createQuery(HQL);\n                query.setParameter(\"name\",\"Kity\")\n                query.setParameter(\"id\",\"5\")\n                List<User> list=query.list();\n            ```\n\n* 分页查询\n    * `setFirstResult(int firstResult);` 设定查询位置\n    * `setMaxResult(int maxReslut);` 设定插叙数目\n    ```java\n        String HQL=\"form Uesr\"; \n        Query query=session.createQuery(HQL);\n        query.setFirstResult(2);//从第3条数据开始查询\n        query.setMaxResult(3);//查询3条记录\n        List<User> list=query.list();\n    ```\n\n* 报表查询\n    ```java\n        String HQL=\"select u.gender,count(u) form Uesr as u group by u.gender\"; \n        Query query=session.createQuery(HQL);\n        List<User> list=query.list();\n        Iterator iter=list.iterator();\n        while(iter.hasNext()){\n            Object[] objct=(Object[])iter.next();\n            Sy\n        }\n\n\n    ```\n\n* QBC查询\n    * 组合查询\n        * 通过Restrictions工具类的相应方法     \n        |方法|说明|    \n        |---|---|    \n        |1|1|   \n\n\n        ```java\n            Criteria criteria=session.createCriteria(User.class);\n            criteria.add(Restrictions.and(Restrictions.eq(\"\")))\n\n            ////\n\n            Criteria criteria=session.createCriteria(User.class);\n            Criterion criterion=Restrictions.or(Restrictions.eq(\"id\",1),Restrictions.eq(\"name\",\"Kitty\"));\n\n\n        ```\n    * 分页查询\n        * `setFirstResult(int firstResult);` \n        * `setMaxResult(int maxReslut);`\n\n        ```java\n            Criteria criteria=\n            criteria.setFirstResult(2);\n            criteria.setMaxResult(3);\n        ```\n\n\n\n### Spring\n\n#### 基础知识\n* 以**IOC(Inverse Of Control 控制反转)** 和 **AOP(Aspect Oriented Programming 面向切面)** 为内核\n* 三层\n    * 表示层(web)\n    * 业务逻辑(service)\n    * 持久层(dao)\n* 优点\n    * 简化开发\n    * 方便测试\n    * 松耦合\n    * AOP编程的支持(权限拦截，任务监控)\n    * 方便集成各种优秀框架\n    * 降低JavaEE API的使用难度\n* Spring的体系结构\n    * ![]()\n    * Core Container(核心容器)\n        * Beans 提供了BeanFactory\n        * Core\n        * Context 建立在core和Beans模块基础之上\n        * Expression Language 运行时查询和操作对象\n\n    * Data Access/Integration(数据访问/集成)\n        * JDBC\n        * ORM\n        * OXM\n        * JMS:Java消息\n        * Transaction\n    * Web模块\n        * web 提供基本的Web开发集成特性\n        * Servlet\n        * Struts\n        * Portlet\n    * 其他模块\n        * AOP\n        * Aspects\n        * Instrumentation\n        * Test 指出Spring组件，使用JUnit或者TestNG进行测试\n    \n* Spring的IOC容器\n    * Spring容器会负责程序之间的关系，而不是有程序代码直接控制，这样控制权由应用代码转移到外部容器，控制权发生了反转，这就是Spring的IOC(控制反转)思想\n        * BeanFactory\n        * ApplicatonContext\n\n\n\n\n\n\n\n\n\n\n\n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n### RESTful风格\n* [RESTful风格](https://www.jianshu.com/p/73d2415956bd)\n","source":"_posts/code/JavaWeb/Java Web框架.md","raw":"---\ntitle: Hibernate基础\ncategories: Code\ntags: JavaWeb\n# photos:\n#   - - 'https://i.loli.net/2020/04/26/frib5vCqmy1tUOE.png'\nabbrlink: 30225\ndata: 2020-04-22 01:40:10\ndeclare: true\nwordCount: true\n---\n\n❄    \n<!--more -->\n\n### Hibernate\n\n#### 初识\n* 加载过程\n    ![加载过程](https://i.loli.net/2020/04/16/v7NnVpWlyCYFaJB.png)\n\n* Hibernate全局配置文件\n    ```xml\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE hibernate-configuration PUBLIC\n                \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n                \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n        <hibernate-configuration>\n            <session-factory>\n                <!-- 设置数据库驱动 -->\n                <property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n                <!-- 设置数据库URL -->\n                <property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/hibernate?useUnicode=true&amp;characterEncoding=utf-8</property>\n                <!-- 数据库用户名 -->\n                <property name=\"hibernate.connection.username\">root</property>\n                <!-- 数据库密码 -->\n                <property name=\"hibernate.connection.password\">369cc</property>\n                <!-- 指定对应数据库的方言，hibernate为了更好适配各种关系数据库，针对每种数据库都指定了一个方言dialect -->\n                <property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n                <!--显示sql语句 -->\n                <property name=\"hibernate.show_sql\">true</property>\n                <!--格式化sql语句 -->\n                <property name=\"format_sql\">true</property>\n                <!--自动生成表 -->\n                <property name=\"hibernate.hbm2ddl.auto\">update</property>\n                <!-- 映射文件 -->\n                <mapping resource=\"hbm/User.hbm.xml\"/>\n                <mapping resource=\"hbm/Order1.hbm.xml\"/>\n                <mapping resource=\"hbm/Customer.hbm.xml\"/>\n            </session-factory>\n        </hibernate-configuration>\n    ```\n* Hibernate映射文件\n    ```xml\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <!DOCTYPE hibernate-mapping PUBLIC\n                \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n                \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n        <hibernate-mapping>\n            <!-- class配置了对象和表的关系 -->\n            <class name=\"com.smart.zero.domain.Order1\"\n                table=\"orders\">  <!-- id元素是用来配置主键字段和属性关系的   name:属性名   column:字段名   type:两者者之间转换时使用的类型   -->\n                <id name=\"id\" type=\"integer\" column=\"oid\">\n                    <generator class=\"native\"/><!-- 用来指明主键生成方式 -->\n                </id>\n                <!-- property元素是用来配置普通字段和属性关系的 -->\n                <property name=\"address\" length=\"50\" type=\"string\" column=\"address\"/>\n                <property name=\"price\" type=\"double\" column=\"price\"/>\n                <!-- 配置映射 -->\n                <!-- <many-to-one>标签    name  :关联对象的属性的名称.    column :表中的外键名称.    class :关联对象类的全路径   -->\n                <many-to-one name=\"customer\" column=\"cno\" class=\"com.smart.zero.domain.Customer\"/>\n            </class>\n        </hibernate-mapping>\n\n    ```\n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n#### Hibernate持久化对象的三种状态\n* ![Hibernate持久化对象的三种状态](https://i.loli.net/2020/04/16/2W9I6hqOXo4mrla.png)\n    * 瞬时态\n        >由java的new命令开辟内存空间的java对象也就是普通的java对象，如果没有变量引用它它将会被JVM收回。**临时对象在内存中是孤立存在的，它的意义是携带信息载体，不和数据库中的数据有任何的关联**。通过Session的save（）方法和saveOrUpdate（）方法可以**把一个临时对象和数据库相关联，并把临时对象携带的信息通过配置文件所做的映射插入数据库中**，这个临时对象就成为持久化对象。\n    * 持久态\n        >**持久化对象在数据库中有相应的记录，持久化对象可以是刚被保存的，或者刚被加载的,但都是在相关联的session声明周期中保存这个状态**。如果是直接数据库查询所返回的数据对象，则这些对象和数据库中的字段相关联，具有相同的id，它们马上变成持久化对象。如果一个临时对象被持久化对象引用，也立马变为持久化对象。\n\n        >如果使用delete（）方法，持久化对象变为临时对象，并且删除数据库中相应的记录，这个对象不再与数据库有任何的联系。\n\n        >持久化对象总是与Session和Transaction关联在一起，在一个session中，对持久化对象的操作不会立即写到数据库，只有当Transaction（事务）结束时，才真正的对数据库更新，从而完成持久化对象和数据库的同步。在同步之前的持久化对象成为脏对象。\n\n        >当一个session()执行close()、clear()、或evict()之后，持久化对象就变为离线对象，这时对象的id虽然拥有数据库的识别值，但已经不在Hibernate持久层的管理下，他和临时对象基本上一样的，**只不过比临时对象多了数据库标识id**。没有任何变量引用时，jvm将其回收。\n\n    * 游离态\n        >**Session关闭之后，与此Session关联的持久化对象就变成为脱管对象**，可以继续对这个对象进行修改，如果脱管对象被重新关联到某个新的Session上，会在此转成持久对象。\n\n脱管对象虽然拥有用户的标识id，所以通过update（）、saveOrUpdate（）等方法，再次与持久层关联。\n\n下面我们就通过使用hibernate，实现对数据库的增删改查来体现三种状态之间的转换过程。\n\n* 状态转换\n    * ![图片.png](https://i.loli.net/2020/04/16/cJtdRTGMy2XsjOg.png)\n\n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n#### 一级缓存\n* [Hibernate一级缓存](https://www.cnblogs.com/QianYue111/p/9747723.html)\n* 缓存\n    >缓存介于应用程序和永久性数据存储源之间，其作用是**降低应用程序直接读写永久性数据存储源的概率**，从而**提高应用程序的运行性能**，缓存的物理介质通常是内存；\n* 一级缓存\n    >hibernate的缓存分为一级和二级缓存，两者都位于持久化层,**存储的都是数据库数据的备份**，其中一级缓存为hibernate的内置缓存，不能卸载\n\n    >hibernate的一级缓存就是指session缓存，session缓存是一块存储空间用来存放相互管理的Java对象，在使用hibernate查询对象的时候，**首先会使用对象属性的oid值在session缓存中查找，如果找到了就会直接从session中提取，不会再查询数据库如果没有找到匹配的，则回去数据库查询，并且把找到的数据存入session缓存中**。一级缓存就是为了减少对熟虑库的访问次数。\n\n    >在Session 接口的实现中**包含一系列的Java集合**，这些Java集合构成了Sesion 缓存。只要Session实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。固一级缓存也被称为是Session基本的缓存。\n    *  Hibernate的一级缓存有如下特点:\n        1. 当应用程序调用Session接口的save(）、update（）、 saveOrUpdate 时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。\n        2. 当调用Session接目的load()、get()方法， 以及Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询对象，再去数据库中查询对应对象，并添加到一级缓存中。\n        3. 如果调用了session的close()方法，则缓存会被清空\n\n* 快照\n    >Hibemate向一级缓存放入数据时，**同时复制一份数据放入到Hibernate快照中**，当**使用commit()方法提交事务时**，同时会清理Session的一级缓存， 这时会**使用oid判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照:如果一致，则不执行update语句。**\n    * Hibermate快照的作用就是**确保一级缓存中的数据和数据库中的数据一致**\n    * 快照的根本作用是保证数据一致性，保证数据一致的另一种做法是，commit之前把堆内存中的数据直接与数据库中的对应记录进行对比，显而易见这样的效率是灰常低下的，而采用快照技术，因为快照是一定和数据库中记录一致的，快照也在堆内存中，所以**速度不是一般的快**。(如果没有变化的话,堆内存的数据于同在堆内存的快照比较的速度肯定要比堆内存的数据于数据库)\n\n* 常见操作\n    * `clear()`：**清除session中的缓存数据**（不管缓存与数据库的同步）。\n    * `flush()`：**将session的缓存中的数据与数据库同步**。\n        >执行完session.flush()时，并不意味着数据就肯定持久化到数据库中的，因为事务控制着数据库，如果事务提交失败了，缓存中的数据还是照样会被回滚的。\n    * `refresh()`：reflush操作会**使数据库记录与session缓存记录保持一致**，也就是是说会强制向数据库发送一条select语句。 \n\n \n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n#### hibernate控制反转\n* [hibernate控制反转](https://blog.csdn.net/u013488838/article/details/50068745)\n* [inverse 控制反转](https://blog.csdn.net/qq_29331365/article/details/100151742?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)\n\n    >何为控制反转, 比如 Poeple(人) 和 Address(地址)  :一个人可以拥有多个地址,那么在配置的时候 在Poeple.hbm,xml 中 设置 one-To-Many (先不考虑Address配置文件) 那么Ok 当我们向People对象 添加 新的地址时  调用代码 \n    ```java\n        People p = new People(“王三”);\n\n        Address address = new Address(\"公司地址\");\n\n        p.getAddress().add(address) ;\n\n        save(p);\n\n        save(address);\n    ```\n    >当我们查看 控制台输出的语句会发现   **有两个insert 语句 和一个 update 语句 显然这是非常消耗性能的** ，正确的应该是 只有两个 insert \n    >现在我们分析下 hibernate 的操作 先保存了People 之后 保存了 Address 最后又修改了 Address 的 关联的peopleId 外键属性 这是由于Address 的外键值是由Poeple来控制的\n    >现在我们在People 的 配置文件中 加上 inverse=\"true\" 在执行上诉步骤 会发现 只有两条Insert 语句\n\n<br>\n\n***\n\n<br>\n\n\n#### 查询\n\n* 导航对象图检索\n    * **根据已加载的对象导航到其他对象**。利用类与类之间的关系来检索对象。\n    ```java\n        Order order=(Order)session.get(Order.class);\n        Customer customer=order.get(Customer);\n    \n    ```\n\n\n\n* 投影查询\n    * 查询对象部分属性\n    ```java\n        String HQL=\"select u.name,u.password from User as u\"//此时必须要select\n        Query query=session.createQuery(HQL);\n        List<Object[]> list=query.list()//注意list存放的是Object数组\n    ```\n\n* 动态实例查询\n    * 在投影查询时，返回的查询对象是一个对象数组，操作起来并不是很方便。所以将投影查询的返回结果重新组成一个实体的实例，这就是动态实例化查询。\n    ```java\n        Strng HQL=\"selct new User(u.name,u.password) from User as u\";\n        Query query=session.createQuery(HQL);\n        List<User> list=query.list();\n\n        //必须要有相应的构造方法\n        public User(String name,String password){\n            super();\n            this.name=name;\n            this.password=password;\n        }\n\n    ```\n\n* 条件查询\n    * 使用`where,like`等\n        * 按参数位置查询\n            * **使用 `?` 来定义参数的位置**，然后利用Query对象的Setter方法为其赋值，类似于JDBC的PrepareStatement对象的参数绑定方法。\n            ```java\n                String HQL=\"from User where name=? and id=?\";\n                Query query=session.createQuery(HQL);\n                query.setString(0,\"JONE\");\n                query.setInteger(1,3);\n                User user=(User)query.uniqueResult();\n\n                ////\n\n                String HQL=\"form Uesr where name like ?\";\n                Query query=session.createQuery(HQL);\n                query.setString(0,\"%o%\")//模糊查询\n                List<User> list=query.list();\n\n            ```\n        * 按参数名称查询\n           * 在HQL中自定义\n            ```java\n                String HQL=\"form Uesr where name=:name and id=:id\"; \n                Query query=session.createQuery(HQL);\n                query.setParameter(\"name\",\"Kity\")\n                query.setParameter(\"id\",\"5\")\n                List<User> list=query.list();\n            ```\n\n* 分页查询\n    * `setFirstResult(int firstResult);` 设定查询位置\n    * `setMaxResult(int maxReslut);` 设定插叙数目\n    ```java\n        String HQL=\"form Uesr\"; \n        Query query=session.createQuery(HQL);\n        query.setFirstResult(2);//从第3条数据开始查询\n        query.setMaxResult(3);//查询3条记录\n        List<User> list=query.list();\n    ```\n\n* 报表查询\n    ```java\n        String HQL=\"select u.gender,count(u) form Uesr as u group by u.gender\"; \n        Query query=session.createQuery(HQL);\n        List<User> list=query.list();\n        Iterator iter=list.iterator();\n        while(iter.hasNext()){\n            Object[] objct=(Object[])iter.next();\n            Sy\n        }\n\n\n    ```\n\n* QBC查询\n    * 组合查询\n        * 通过Restrictions工具类的相应方法     \n        |方法|说明|    \n        |---|---|    \n        |1|1|   \n\n\n        ```java\n            Criteria criteria=session.createCriteria(User.class);\n            criteria.add(Restrictions.and(Restrictions.eq(\"\")))\n\n            ////\n\n            Criteria criteria=session.createCriteria(User.class);\n            Criterion criterion=Restrictions.or(Restrictions.eq(\"id\",1),Restrictions.eq(\"name\",\"Kitty\"));\n\n\n        ```\n    * 分页查询\n        * `setFirstResult(int firstResult);` \n        * `setMaxResult(int maxReslut);`\n\n        ```java\n            Criteria criteria=\n            criteria.setFirstResult(2);\n            criteria.setMaxResult(3);\n        ```\n\n\n\n### Spring\n\n#### 基础知识\n* 以**IOC(Inverse Of Control 控制反转)** 和 **AOP(Aspect Oriented Programming 面向切面)** 为内核\n* 三层\n    * 表示层(web)\n    * 业务逻辑(service)\n    * 持久层(dao)\n* 优点\n    * 简化开发\n    * 方便测试\n    * 松耦合\n    * AOP编程的支持(权限拦截，任务监控)\n    * 方便集成各种优秀框架\n    * 降低JavaEE API的使用难度\n* Spring的体系结构\n    * ![]()\n    * Core Container(核心容器)\n        * Beans 提供了BeanFactory\n        * Core\n        * Context 建立在core和Beans模块基础之上\n        * Expression Language 运行时查询和操作对象\n\n    * Data Access/Integration(数据访问/集成)\n        * JDBC\n        * ORM\n        * OXM\n        * JMS:Java消息\n        * Transaction\n    * Web模块\n        * web 提供基本的Web开发集成特性\n        * Servlet\n        * Struts\n        * Portlet\n    * 其他模块\n        * AOP\n        * Aspects\n        * Instrumentation\n        * Test 指出Spring组件，使用JUnit或者TestNG进行测试\n    \n* Spring的IOC容器\n    * Spring容器会负责程序之间的关系，而不是有程序代码直接控制，这样控制权由应用代码转移到外部容器，控制权发生了反转，这就是Spring的IOC(控制反转)思想\n        * BeanFactory\n        * ApplicatonContext\n\n\n\n\n\n\n\n\n\n\n\n<br>\n<br>\n\n***\n\n<br>\n<br>\n\n### RESTful风格\n* [RESTful风格](https://www.jianshu.com/p/73d2415956bd)\n","slug":"code/JavaWeb/Java Web框架","published":1,"date":"2021-08-09T10:06:58.816Z","updated":"2020-10-06T10:51:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gn005b0w7t4v6vdvt5","content":"<p>❄    </p>\n<a id=\"more\"></a>\n\n<h3 id=\"Hibernate\"><a href=\"#Hibernate\" class=\"headerlink\" title=\"Hibernate\"></a>Hibernate</h3><h4 id=\"初识\"><a href=\"#初识\" class=\"headerlink\" title=\"初识\"></a>初识</h4><ul>\n<li><p>加载过程<br>  <img src=\"https://i.loli.net/2020/04/16/v7NnVpWlyCYFaJB.png\" alt=\"加载过程\"></p>\n</li>\n<li><p>Hibernate全局配置文件</p>\n<pre class=\" language-xml\"><code class=\"language-xml\">      <span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n      <span class=\"token doctype\">&lt;!DOCTYPE hibernate-configuration PUBLIC\n              \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n              \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>hibernate-configuration</span><span class=\"token punctuation\">></span></span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>session-factory</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 设置数据库驱动 --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hibernate.connection.driver_class<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>com.mysql.jdbc.Driver<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>property</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 设置数据库URL --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hibernate.connection.url<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>jdbc:mysql://localhost:3306/hibernate?useUnicode=true<span class=\"token entity\" title=\"&amp;\">&amp;amp;</span>characterEncoding=utf-8<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>property</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 数据库用户名 --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hibernate.connection.username<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>root<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>property</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 数据库密码 --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hibernate.connection.password<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>369cc<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>property</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 指定对应数据库的方言，hibernate为了更好适配各种关系数据库，针对每种数据库都指定了一个方言dialect --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hibernate.dialect<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>org.hibernate.dialect.MySQLDialect<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>property</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!--显示sql语句 --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hibernate.show_sql<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>true<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>property</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!--格式化sql语句 --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>format_sql<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>true<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>property</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!--自动生成表 --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hibernate.hbm2ddl.auto<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>update<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>property</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 映射文件 --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>mapping</span> <span class=\"token attr-name\">resource</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hbm/User.hbm.xml<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>mapping</span> <span class=\"token attr-name\">resource</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hbm/Order1.hbm.xml<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>mapping</span> <span class=\"token attr-name\">resource</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hbm/Customer.hbm.xml<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>session-factory</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>hibernate-configuration</span><span class=\"token punctuation\">></span></span></code></pre>\n</li>\n<li><p>Hibernate映射文件</p>\n<pre class=\" language-xml\"><code class=\"language-xml\">      <span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n      <span class=\"token doctype\">&lt;!DOCTYPE hibernate-mapping PUBLIC\n              \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n              \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>hibernate-mapping</span><span class=\"token punctuation\">></span></span>\n          <span class=\"token comment\" spellcheck=\"true\">&lt;!-- class配置了对象和表的关系 --></span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>class</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.smart.zero.domain.Order1<span class=\"token punctuation\">\"</span></span>\n              <span class=\"token attr-name\">table</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>orders<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>  <span class=\"token comment\" spellcheck=\"true\">&lt;!-- id元素是用来配置主键字段和属性关系的   name:属性名   column:字段名   type:两者者之间转换时使用的类型   --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>id</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>id<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>integer<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">column</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>oid<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n                  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>generator</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>native<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span><span class=\"token comment\" spellcheck=\"true\">&lt;!-- 用来指明主键生成方式 --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>id</span><span class=\"token punctuation\">></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!-- property元素是用来配置普通字段和属性关系的 --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>address<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">length</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>50<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>string<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">column</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>address<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>price<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>double<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">column</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>price<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 配置映射 --></span>\n              <span class=\"token comment\" spellcheck=\"true\">&lt;!-- &lt;many-to-one>标签    name  :关联对象的属性的名称.    column :表中的外键名称.    class :关联对象类的全路径   --></span>\n              <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>many-to-one</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>customer<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">column</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>cno<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.smart.zero.domain.Customer<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>class</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>hibernate-mapping</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<br>\n<br>\n\n</li>\n</ul>\n<hr>\n<br>\n<br>\n\n<h4 id=\"Hibernate持久化对象的三种状态\"><a href=\"#Hibernate持久化对象的三种状态\" class=\"headerlink\" title=\"Hibernate持久化对象的三种状态\"></a>Hibernate持久化对象的三种状态</h4><ul>\n<li><p><img src=\"https://i.loli.net/2020/04/16/2W9I6hqOXo4mrla.png\" alt=\"Hibernate持久化对象的三种状态\"></p>\n<ul>\n<li><p>瞬时态</p>\n<blockquote>\n<p>由java的new命令开辟内存空间的java对象也就是普通的java对象，如果没有变量引用它它将会被JVM收回。<strong>临时对象在内存中是孤立存在的，它的意义是携带信息载体，不和数据库中的数据有任何的关联</strong>。通过Session的save（）方法和saveOrUpdate（）方法可以<strong>把一个临时对象和数据库相关联，并把临时对象携带的信息通过配置文件所做的映射插入数据库中</strong>，这个临时对象就成为持久化对象。</p>\n</blockquote>\n</li>\n<li><p>持久态</p>\n<blockquote>\n<p><strong>持久化对象在数据库中有相应的记录，持久化对象可以是刚被保存的，或者刚被加载的,但都是在相关联的session声明周期中保存这个状态</strong>。如果是直接数据库查询所返回的数据对象，则这些对象和数据库中的字段相关联，具有相同的id，它们马上变成持久化对象。如果一个临时对象被持久化对象引用，也立马变为持久化对象。</p>\n</blockquote>\n<blockquote>\n<p>如果使用delete（）方法，持久化对象变为临时对象，并且删除数据库中相应的记录，这个对象不再与数据库有任何的联系。</p>\n</blockquote>\n<blockquote>\n<p>持久化对象总是与Session和Transaction关联在一起，在一个session中，对持久化对象的操作不会立即写到数据库，只有当Transaction（事务）结束时，才真正的对数据库更新，从而完成持久化对象和数据库的同步。在同步之前的持久化对象成为脏对象。</p>\n</blockquote>\n<blockquote>\n<p>当一个session()执行close()、clear()、或evict()之后，持久化对象就变为离线对象，这时对象的id虽然拥有数据库的识别值，但已经不在Hibernate持久层的管理下，他和临时对象基本上一样的，<strong>只不过比临时对象多了数据库标识id</strong>。没有任何变量引用时，jvm将其回收。</p>\n</blockquote>\n</li>\n<li><p>游离态</p>\n<blockquote>\n<p><strong>Session关闭之后，与此Session关联的持久化对象就变成为脱管对象</strong>，可以继续对这个对象进行修改，如果脱管对象被重新关联到某个新的Session上，会在此转成持久对象。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>脱管对象虽然拥有用户的标识id，所以通过update（）、saveOrUpdate（）等方法，再次与持久层关联。</p>\n<p>下面我们就通过使用hibernate，实现对数据库的增删改查来体现三种状态之间的转换过程。</p>\n<ul>\n<li>状态转换<ul>\n<li><img src=\"https://i.loli.net/2020/04/16/cJtdRTGMy2XsjOg.png\" alt=\"图片.png\"></li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n\n<hr>\n<br>\n<br>\n\n<h4 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/QianYue111/p/9747723.html\" target=\"_blank\" rel=\"noopener\">Hibernate一级缓存</a></p>\n</li>\n<li><p>缓存</p>\n<blockquote>\n<p>缓存介于应用程序和永久性数据存储源之间，其作用是<strong>降低应用程序直接读写永久性数据存储源的概率</strong>，从而<strong>提高应用程序的运行性能</strong>，缓存的物理介质通常是内存；</p>\n</blockquote>\n</li>\n<li><p>一级缓存</p>\n<blockquote>\n<p>hibernate的缓存分为一级和二级缓存，两者都位于持久化层,<strong>存储的都是数据库数据的备份</strong>，其中一级缓存为hibernate的内置缓存，不能卸载</p>\n</blockquote>\n<blockquote>\n<p>hibernate的一级缓存就是指session缓存，session缓存是一块存储空间用来存放相互管理的Java对象，在使用hibernate查询对象的时候，<strong>首先会使用对象属性的oid值在session缓存中查找，如果找到了就会直接从session中提取，不会再查询数据库如果没有找到匹配的，则回去数据库查询，并且把找到的数据存入session缓存中</strong>。一级缓存就是为了减少对熟虑库的访问次数。</p>\n</blockquote>\n<blockquote>\n<p>在Session 接口的实现中<strong>包含一系列的Java集合</strong>，这些Java集合构成了Sesion 缓存。只要Session实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。固一级缓存也被称为是Session基本的缓存。</p>\n</blockquote>\n<ul>\n<li>Hibernate的一级缓存有如下特点:<ol>\n<li>当应用程序调用Session接口的save(）、update（）、 saveOrUpdate 时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。</li>\n<li>当调用Session接目的load()、get()方法， 以及Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询对象，再去数据库中查询对应对象，并添加到一级缓存中。</li>\n<li>如果调用了session的close()方法，则缓存会被清空</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>快照</p>\n<blockquote>\n<p>Hibemate向一级缓存放入数据时，<strong>同时复制一份数据放入到Hibernate快照中</strong>，当<strong>使用commit()方法提交事务时</strong>，同时会清理Session的一级缓存， 这时会<strong>使用oid判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照:如果一致，则不执行update语句。</strong></p>\n</blockquote>\n<ul>\n<li>Hibermate快照的作用就是<strong>确保一级缓存中的数据和数据库中的数据一致</strong></li>\n<li>快照的根本作用是保证数据一致性，保证数据一致的另一种做法是，commit之前把堆内存中的数据直接与数据库中的对应记录进行对比，显而易见这样的效率是灰常低下的，而采用快照技术，因为快照是一定和数据库中记录一致的，快照也在堆内存中，所以<strong>速度不是一般的快</strong>。(如果没有变化的话,堆内存的数据于同在堆内存的快照比较的速度肯定要比堆内存的数据于数据库)</li>\n</ul>\n</li>\n<li><p>常见操作</p>\n<ul>\n<li><code>clear()</code>：<strong>清除session中的缓存数据</strong>（不管缓存与数据库的同步）。</li>\n<li><code>flush()</code>：<strong>将session的缓存中的数据与数据库同步</strong>。<blockquote>\n<p>执行完session.flush()时，并不意味着数据就肯定持久化到数据库中的，因为事务控制着数据库，如果事务提交失败了，缓存中的数据还是照样会被回滚的。</p>\n</blockquote>\n</li>\n<li><code>refresh()</code>：reflush操作会<strong>使数据库记录与session缓存记录保持一致</strong>，也就是是说会强制向数据库发送一条select语句。 </li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n\n<hr>\n<br>\n<br>\n\n<h4 id=\"hibernate控制反转\"><a href=\"#hibernate控制反转\" class=\"headerlink\" title=\"hibernate控制反转\"></a>hibernate控制反转</h4><ul>\n<li><p><a href=\"https://blog.csdn.net/u013488838/article/details/50068745\" target=\"_blank\" rel=\"noopener\">hibernate控制反转</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_29331365/article/details/100151742?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1\" target=\"_blank\" rel=\"noopener\">inverse 控制反转</a></p>\n<blockquote>\n<p>何为控制反转, 比如 Poeple(人) 和 Address(地址)  :一个人可以拥有多个地址,那么在配置的时候 在Poeple.hbm,xml 中 设置 one-To-Many (先不考虑Address配置文件) 那么Ok 当我们向People对象 添加 新的地址时  调用代码 </p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\">      People p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">People</span><span class=\"token punctuation\">(</span>“王三”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      Address address <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Address</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"公司地址\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      p<span class=\"token punctuation\">.</span><span class=\"token function\">getAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n\n      <span class=\"token function\">save</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token function\">save</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>当我们查看 控制台输出的语句会发现   <strong>有两个insert 语句 和一个 update 语句 显然这是非常消耗性能的</strong> ，正确的应该是 只有两个 insert<br>现在我们分析下 hibernate 的操作 先保存了People 之后 保存了 Address 最后又修改了 Address 的 关联的peopleId 外键属性 这是由于Address 的外键值是由Poeple来控制的<br>现在我们在People 的 配置文件中 加上 inverse=”true” 在执行上诉步骤 会发现 只有两条Insert 语句</p>\n</blockquote>\n</li>\n</ul>\n<br>\n\n<hr>\n<br>\n\n\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><ul>\n<li><p>导航对象图检索</p>\n<ul>\n<li><p><strong>根据已加载的对象导航到其他对象</strong>。利用类与类之间的关系来检索对象。</p>\n<pre class=\" language-java\"><code class=\"language-java\">  Order order<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>Order<span class=\"token punctuation\">)</span>session<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Order<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  Customer customer<span class=\"token operator\">=</span>order<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Customer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>投影查询</p>\n<ul>\n<li>查询对象部分属性<pre class=\" language-java\"><code class=\"language-java\">  String HQL<span class=\"token operator\">=</span><span class=\"token string\">\"select u.name,u.password from User as u\"</span><span class=\"token comment\" spellcheck=\"true\">//此时必须要select</span>\n  Query query<span class=\"token operator\">=</span>session<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span>HQL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  List<span class=\"token operator\">&lt;</span>Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span> list<span class=\"token operator\">=</span>query<span class=\"token punctuation\">.</span><span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//注意list存放的是Object数组</span></code></pre>\n</li>\n</ul>\n</li>\n<li><p>动态实例查询</p>\n<ul>\n<li><p>在投影查询时，返回的查询对象是一个对象数组，操作起来并不是很方便。所以将投影查询的返回结果重新组成一个实体的实例，这就是动态实例化查询。</p>\n<pre class=\" language-java\"><code class=\"language-java\">  Strng HQL<span class=\"token operator\">=</span><span class=\"token string\">\"selct new User(u.name,u.password) from User as u\"</span><span class=\"token punctuation\">;</span>\n  Query query<span class=\"token operator\">=</span>session<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span>HQL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> list<span class=\"token operator\">=</span>query<span class=\"token punctuation\">.</span><span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">//必须要有相应的构造方法</span>\n  <span class=\"token keyword\">public</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span>String name<span class=\"token punctuation\">,</span>String password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>password<span class=\"token operator\">=</span>password<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>条件查询</p>\n<ul>\n<li><p>使用<code>where,like</code>等</p>\n<ul>\n<li><p>按参数位置查询</p>\n<ul>\n<li><p><strong>使用 <code>?</code> 来定义参数的位置</strong>，然后利用Query对象的Setter方法为其赋值，类似于JDBC的PrepareStatement对象的参数绑定方法。</p>\n<pre class=\" language-java\"><code class=\"language-java\">  String HQL<span class=\"token operator\">=</span><span class=\"token string\">\"from User where name=? and id=?\"</span><span class=\"token punctuation\">;</span>\n  Query query<span class=\"token operator\">=</span>session<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span>HQL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  query<span class=\"token punctuation\">.</span><span class=\"token function\">setString</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"JONE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  query<span class=\"token punctuation\">.</span><span class=\"token function\">setInteger</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  User user<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>User<span class=\"token punctuation\">)</span>query<span class=\"token punctuation\">.</span><span class=\"token function\">uniqueResult</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">////</span>\n\n  String HQL<span class=\"token operator\">=</span><span class=\"token string\">\"form Uesr where name like ?\"</span><span class=\"token punctuation\">;</span>\n  Query query<span class=\"token operator\">=</span>session<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span>HQL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  query<span class=\"token punctuation\">.</span><span class=\"token function\">setString</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"%o%\"</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">//模糊查询</span>\n  List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> list<span class=\"token operator\">=</span>query<span class=\"token punctuation\">.</span><span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>按参数名称查询</p>\n<ul>\n<li>在HQL中自定义<pre class=\" language-java\"><code class=\"language-java\">   String HQL<span class=\"token operator\">=</span><span class=\"token string\">\"form Uesr where name=:name and id=:id\"</span><span class=\"token punctuation\">;</span> \n   Query query<span class=\"token operator\">=</span>session<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span>HQL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   query<span class=\"token punctuation\">.</span><span class=\"token function\">setParameter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Kity\"</span><span class=\"token punctuation\">)</span>\n   query<span class=\"token punctuation\">.</span><span class=\"token function\">setParameter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"5\"</span><span class=\"token punctuation\">)</span>\n   List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> list<span class=\"token operator\">=</span>query<span class=\"token punctuation\">.</span><span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分页查询</p>\n<ul>\n<li><code>setFirstResult(int firstResult);</code> 设定查询位置</li>\n<li><code>setMaxResult(int maxReslut);</code> 设定插叙数目<pre class=\" language-java\"><code class=\"language-java\">  String HQL<span class=\"token operator\">=</span><span class=\"token string\">\"form Uesr\"</span><span class=\"token punctuation\">;</span> \n  Query query<span class=\"token operator\">=</span>session<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span>HQL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  query<span class=\"token punctuation\">.</span><span class=\"token function\">setFirstResult</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//从第3条数据开始查询</span>\n  query<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxResult</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//查询3条记录</span>\n  List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> list<span class=\"token operator\">=</span>query<span class=\"token punctuation\">.</span><span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n</li>\n<li><p>报表查询</p>\n<pre class=\" language-java\"><code class=\"language-java\">      String HQL<span class=\"token operator\">=</span><span class=\"token string\">\"select u.gender,count(u) form Uesr as u group by u.gender\"</span><span class=\"token punctuation\">;</span> \n      Query query<span class=\"token operator\">=</span>session<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span>HQL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> list<span class=\"token operator\">=</span>query<span class=\"token punctuation\">.</span><span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      Iterator iter<span class=\"token operator\">=</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>iter<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> objct<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          Sy\n      <span class=\"token punctuation\">}</span>\n\n</code></pre>\n</li>\n</ul>\n<pre><code>```</code></pre><ul>\n<li>QBC查询<ul>\n<li>组合查询<ul>\n<li>通过Restrictions工具类的相应方法     <table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>    ```java\n        Criteria criteria=session.createCriteria(User.class);\n        criteria.add(Restrictions.and(Restrictions.eq(&quot;&quot;)))\n\n        ////\n\n        Criteria criteria=session.createCriteria(User.class);\n        Criterion criterion=Restrictions.or(Restrictions.eq(&quot;id&quot;,1),Restrictions.eq(&quot;name&quot;,&quot;Kitty&quot;));\n\n\n    ```\n* 分页查询\n    * `setFirstResult(int firstResult);` \n    * `setMaxResult(int maxReslut);`\n\n    ```java\n        Criteria criteria=\n        criteria.setFirstResult(2);\n        criteria.setMaxResult(3);\n    ```</code></pre><h3 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h3><h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><ul>\n<li><p>以<strong>IOC(Inverse Of Control 控制反转)</strong> 和 <strong>AOP(Aspect Oriented Programming 面向切面)</strong> 为内核</p>\n</li>\n<li><p>三层</p>\n<ul>\n<li>表示层(web)</li>\n<li>业务逻辑(service)</li>\n<li>持久层(dao)</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>简化开发</li>\n<li>方便测试</li>\n<li>松耦合</li>\n<li>AOP编程的支持(权限拦截，任务监控)</li>\n<li>方便集成各种优秀框架</li>\n<li>降低JavaEE API的使用难度</li>\n</ul>\n</li>\n<li><p>Spring的体系结构</p>\n<ul>\n<li><p><img src=\"\" alt=\"\"></p>\n</li>\n<li><p>Core Container(核心容器)</p>\n<ul>\n<li>Beans 提供了BeanFactory</li>\n<li>Core</li>\n<li>Context 建立在core和Beans模块基础之上</li>\n<li>Expression Language 运行时查询和操作对象</li>\n</ul>\n</li>\n<li><p>Data Access/Integration(数据访问/集成)</p>\n<ul>\n<li>JDBC</li>\n<li>ORM</li>\n<li>OXM</li>\n<li>JMS:Java消息</li>\n<li>Transaction</li>\n</ul>\n</li>\n<li><p>Web模块</p>\n<ul>\n<li>web 提供基本的Web开发集成特性</li>\n<li>Servlet</li>\n<li>Struts</li>\n<li>Portlet</li>\n</ul>\n</li>\n<li><p>其他模块</p>\n<ul>\n<li>AOP</li>\n<li>Aspects</li>\n<li>Instrumentation</li>\n<li>Test 指出Spring组件，使用JUnit或者TestNG进行测试</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Spring的IOC容器</p>\n<ul>\n<li>Spring容器会负责程序之间的关系，而不是有程序代码直接控制，这样控制权由应用代码转移到外部容器，控制权发生了反转，这就是Spring的IOC(控制反转)思想<ul>\n<li>BeanFactory</li>\n<li>ApplicatonContext</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n\n<hr>\n<br>\n<br>\n\n<h3 id=\"RESTful风格\"><a href=\"#RESTful风格\" class=\"headerlink\" title=\"RESTful风格\"></a>RESTful风格</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/73d2415956bd\" target=\"_blank\" rel=\"noopener\">RESTful风格</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>❄    </p>","more":"<h3 id=\"Hibernate\"><a href=\"#Hibernate\" class=\"headerlink\" title=\"Hibernate\"></a>Hibernate</h3><h4 id=\"初识\"><a href=\"#初识\" class=\"headerlink\" title=\"初识\"></a>初识</h4><ul>\n<li><p>加载过程<br>  <img src=\"https://i.loli.net/2020/04/16/v7NnVpWlyCYFaJB.png\" alt=\"加载过程\"></p>\n</li>\n<li><p>Hibernate全局配置文件</p>\n<pre><code class=\"xml\">      &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n      &lt;!DOCTYPE hibernate-configuration PUBLIC\n              &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;\n              &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;\n      &lt;hibernate-configuration&gt;\n          &lt;session-factory&gt;\n              &lt;!-- 设置数据库驱动 --&gt;\n              &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;\n              &lt;!-- 设置数据库URL --&gt;\n              &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/hibernate?useUnicode=true&amp;amp;characterEncoding=utf-8&lt;/property&gt;\n              &lt;!-- 数据库用户名 --&gt;\n              &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt;\n              &lt;!-- 数据库密码 --&gt;\n              &lt;property name=&quot;hibernate.connection.password&quot;&gt;369cc&lt;/property&gt;\n              &lt;!-- 指定对应数据库的方言，hibernate为了更好适配各种关系数据库，针对每种数据库都指定了一个方言dialect --&gt;\n              &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;\n              &lt;!--显示sql语句 --&gt;\n              &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;\n              &lt;!--格式化sql语句 --&gt;\n              &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt;\n              &lt;!--自动生成表 --&gt;\n              &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;\n              &lt;!-- 映射文件 --&gt;\n              &lt;mapping resource=&quot;hbm/User.hbm.xml&quot;/&gt;\n              &lt;mapping resource=&quot;hbm/Order1.hbm.xml&quot;/&gt;\n              &lt;mapping resource=&quot;hbm/Customer.hbm.xml&quot;/&gt;\n          &lt;/session-factory&gt;\n      &lt;/hibernate-configuration&gt;</code></pre>\n</li>\n<li><p>Hibernate映射文件</p>\n<pre><code class=\"xml\">      &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n      &lt;!DOCTYPE hibernate-mapping PUBLIC\n              &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;\n              &quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;\n      &lt;hibernate-mapping&gt;\n          &lt;!-- class配置了对象和表的关系 --&gt;\n          &lt;class name=&quot;com.smart.zero.domain.Order1&quot;\n              table=&quot;orders&quot;&gt;  &lt;!-- id元素是用来配置主键字段和属性关系的   name:属性名   column:字段名   type:两者者之间转换时使用的类型   --&gt;\n              &lt;id name=&quot;id&quot; type=&quot;integer&quot; column=&quot;oid&quot;&gt;\n                  &lt;generator class=&quot;native&quot;/&gt;&lt;!-- 用来指明主键生成方式 --&gt;\n              &lt;/id&gt;\n              &lt;!-- property元素是用来配置普通字段和属性关系的 --&gt;\n              &lt;property name=&quot;address&quot; length=&quot;50&quot; type=&quot;string&quot; column=&quot;address&quot;/&gt;\n              &lt;property name=&quot;price&quot; type=&quot;double&quot; column=&quot;price&quot;/&gt;\n              &lt;!-- 配置映射 --&gt;\n              &lt;!-- &lt;many-to-one&gt;标签    name  :关联对象的属性的名称.    column :表中的外键名称.    class :关联对象类的全路径   --&gt;\n              &lt;many-to-one name=&quot;customer&quot; column=&quot;cno&quot; class=&quot;com.smart.zero.domain.Customer&quot;/&gt;\n          &lt;/class&gt;\n      &lt;/hibernate-mapping&gt;\n</code></pre>\n<br>\n<br>\n\n</li>\n</ul>\n<hr>\n<br>\n<br>\n\n<h4 id=\"Hibernate持久化对象的三种状态\"><a href=\"#Hibernate持久化对象的三种状态\" class=\"headerlink\" title=\"Hibernate持久化对象的三种状态\"></a>Hibernate持久化对象的三种状态</h4><ul>\n<li><p><img src=\"https://i.loli.net/2020/04/16/2W9I6hqOXo4mrla.png\" alt=\"Hibernate持久化对象的三种状态\"></p>\n<ul>\n<li><p>瞬时态</p>\n<blockquote>\n<p>由java的new命令开辟内存空间的java对象也就是普通的java对象，如果没有变量引用它它将会被JVM收回。<strong>临时对象在内存中是孤立存在的，它的意义是携带信息载体，不和数据库中的数据有任何的关联</strong>。通过Session的save（）方法和saveOrUpdate（）方法可以<strong>把一个临时对象和数据库相关联，并把临时对象携带的信息通过配置文件所做的映射插入数据库中</strong>，这个临时对象就成为持久化对象。</p>\n</blockquote>\n</li>\n<li><p>持久态</p>\n<blockquote>\n<p><strong>持久化对象在数据库中有相应的记录，持久化对象可以是刚被保存的，或者刚被加载的,但都是在相关联的session声明周期中保存这个状态</strong>。如果是直接数据库查询所返回的数据对象，则这些对象和数据库中的字段相关联，具有相同的id，它们马上变成持久化对象。如果一个临时对象被持久化对象引用，也立马变为持久化对象。</p>\n</blockquote>\n<blockquote>\n<p>如果使用delete（）方法，持久化对象变为临时对象，并且删除数据库中相应的记录，这个对象不再与数据库有任何的联系。</p>\n</blockquote>\n<blockquote>\n<p>持久化对象总是与Session和Transaction关联在一起，在一个session中，对持久化对象的操作不会立即写到数据库，只有当Transaction（事务）结束时，才真正的对数据库更新，从而完成持久化对象和数据库的同步。在同步之前的持久化对象成为脏对象。</p>\n</blockquote>\n<blockquote>\n<p>当一个session()执行close()、clear()、或evict()之后，持久化对象就变为离线对象，这时对象的id虽然拥有数据库的识别值，但已经不在Hibernate持久层的管理下，他和临时对象基本上一样的，<strong>只不过比临时对象多了数据库标识id</strong>。没有任何变量引用时，jvm将其回收。</p>\n</blockquote>\n</li>\n<li><p>游离态</p>\n<blockquote>\n<p><strong>Session关闭之后，与此Session关联的持久化对象就变成为脱管对象</strong>，可以继续对这个对象进行修改，如果脱管对象被重新关联到某个新的Session上，会在此转成持久对象。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>脱管对象虽然拥有用户的标识id，所以通过update（）、saveOrUpdate（）等方法，再次与持久层关联。</p>\n<p>下面我们就通过使用hibernate，实现对数据库的增删改查来体现三种状态之间的转换过程。</p>\n<ul>\n<li>状态转换<ul>\n<li><img src=\"https://i.loli.net/2020/04/16/cJtdRTGMy2XsjOg.png\" alt=\"图片.png\"></li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n\n<hr>\n<br>\n<br>\n\n<h4 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/QianYue111/p/9747723.html\" target=\"_blank\" rel=\"noopener\">Hibernate一级缓存</a></p>\n</li>\n<li><p>缓存</p>\n<blockquote>\n<p>缓存介于应用程序和永久性数据存储源之间，其作用是<strong>降低应用程序直接读写永久性数据存储源的概率</strong>，从而<strong>提高应用程序的运行性能</strong>，缓存的物理介质通常是内存；</p>\n</blockquote>\n</li>\n<li><p>一级缓存</p>\n<blockquote>\n<p>hibernate的缓存分为一级和二级缓存，两者都位于持久化层,<strong>存储的都是数据库数据的备份</strong>，其中一级缓存为hibernate的内置缓存，不能卸载</p>\n</blockquote>\n<blockquote>\n<p>hibernate的一级缓存就是指session缓存，session缓存是一块存储空间用来存放相互管理的Java对象，在使用hibernate查询对象的时候，<strong>首先会使用对象属性的oid值在session缓存中查找，如果找到了就会直接从session中提取，不会再查询数据库如果没有找到匹配的，则回去数据库查询，并且把找到的数据存入session缓存中</strong>。一级缓存就是为了减少对熟虑库的访问次数。</p>\n</blockquote>\n<blockquote>\n<p>在Session 接口的实现中<strong>包含一系列的Java集合</strong>，这些Java集合构成了Sesion 缓存。只要Session实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。固一级缓存也被称为是Session基本的缓存。</p>\n</blockquote>\n<ul>\n<li>Hibernate的一级缓存有如下特点:<ol>\n<li>当应用程序调用Session接口的save(）、update（）、 saveOrUpdate 时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。</li>\n<li>当调用Session接目的load()、get()方法， 以及Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询对象，再去数据库中查询对应对象，并添加到一级缓存中。</li>\n<li>如果调用了session的close()方法，则缓存会被清空</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>快照</p>\n<blockquote>\n<p>Hibemate向一级缓存放入数据时，<strong>同时复制一份数据放入到Hibernate快照中</strong>，当<strong>使用commit()方法提交事务时</strong>，同时会清理Session的一级缓存， 这时会<strong>使用oid判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的属性发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照:如果一致，则不执行update语句。</strong></p>\n</blockquote>\n<ul>\n<li>Hibermate快照的作用就是<strong>确保一级缓存中的数据和数据库中的数据一致</strong></li>\n<li>快照的根本作用是保证数据一致性，保证数据一致的另一种做法是，commit之前把堆内存中的数据直接与数据库中的对应记录进行对比，显而易见这样的效率是灰常低下的，而采用快照技术，因为快照是一定和数据库中记录一致的，快照也在堆内存中，所以<strong>速度不是一般的快</strong>。(如果没有变化的话,堆内存的数据于同在堆内存的快照比较的速度肯定要比堆内存的数据于数据库)</li>\n</ul>\n</li>\n<li><p>常见操作</p>\n<ul>\n<li><code>clear()</code>：<strong>清除session中的缓存数据</strong>（不管缓存与数据库的同步）。</li>\n<li><code>flush()</code>：<strong>将session的缓存中的数据与数据库同步</strong>。<blockquote>\n<p>执行完session.flush()时，并不意味着数据就肯定持久化到数据库中的，因为事务控制着数据库，如果事务提交失败了，缓存中的数据还是照样会被回滚的。</p>\n</blockquote>\n</li>\n<li><code>refresh()</code>：reflush操作会<strong>使数据库记录与session缓存记录保持一致</strong>，也就是是说会强制向数据库发送一条select语句。 </li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n\n<hr>\n<br>\n<br>\n\n<h4 id=\"hibernate控制反转\"><a href=\"#hibernate控制反转\" class=\"headerlink\" title=\"hibernate控制反转\"></a>hibernate控制反转</h4><ul>\n<li><p><a href=\"https://blog.csdn.net/u013488838/article/details/50068745\" target=\"_blank\" rel=\"noopener\">hibernate控制反转</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_29331365/article/details/100151742?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1\" target=\"_blank\" rel=\"noopener\">inverse 控制反转</a></p>\n<blockquote>\n<p>何为控制反转, 比如 Poeple(人) 和 Address(地址)  :一个人可以拥有多个地址,那么在配置的时候 在Poeple.hbm,xml 中 设置 one-To-Many (先不考虑Address配置文件) 那么Ok 当我们向People对象 添加 新的地址时  调用代码 </p>\n</blockquote>\n<pre><code class=\"java\">      People p = new People(“王三”);\n\n      Address address = new Address(&quot;公司地址&quot;);\n\n      p.getAddress().add(address) ;\n\n      save(p);\n\n      save(address);</code></pre>\n<blockquote>\n<p>当我们查看 控制台输出的语句会发现   <strong>有两个insert 语句 和一个 update 语句 显然这是非常消耗性能的</strong> ，正确的应该是 只有两个 insert<br>现在我们分析下 hibernate 的操作 先保存了People 之后 保存了 Address 最后又修改了 Address 的 关联的peopleId 外键属性 这是由于Address 的外键值是由Poeple来控制的<br>现在我们在People 的 配置文件中 加上 inverse=”true” 在执行上诉步骤 会发现 只有两条Insert 语句</p>\n</blockquote>\n</li>\n</ul>\n<br>\n\n<hr>\n<br>\n\n\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><ul>\n<li><p>导航对象图检索</p>\n<ul>\n<li><p><strong>根据已加载的对象导航到其他对象</strong>。利用类与类之间的关系来检索对象。</p>\n<pre><code class=\"java\">  Order order=(Order)session.get(Order.class);\n  Customer customer=order.get(Customer);\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>投影查询</p>\n<ul>\n<li>查询对象部分属性<pre><code class=\"java\">  String HQL=&quot;select u.name,u.password from User as u&quot;//此时必须要select\n  Query query=session.createQuery(HQL);\n  List&lt;Object[]&gt; list=query.list()//注意list存放的是Object数组</code></pre>\n</li>\n</ul>\n</li>\n<li><p>动态实例查询</p>\n<ul>\n<li><p>在投影查询时，返回的查询对象是一个对象数组，操作起来并不是很方便。所以将投影查询的返回结果重新组成一个实体的实例，这就是动态实例化查询。</p>\n<pre><code class=\"java\">  Strng HQL=&quot;selct new User(u.name,u.password) from User as u&quot;;\n  Query query=session.createQuery(HQL);\n  List&lt;User&gt; list=query.list();\n\n  //必须要有相应的构造方法\n  public User(String name,String password){\n      super();\n      this.name=name;\n      this.password=password;\n  }\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>条件查询</p>\n<ul>\n<li><p>使用<code>where,like</code>等</p>\n<ul>\n<li><p>按参数位置查询</p>\n<ul>\n<li><p><strong>使用 <code>?</code> 来定义参数的位置</strong>，然后利用Query对象的Setter方法为其赋值，类似于JDBC的PrepareStatement对象的参数绑定方法。</p>\n<pre><code class=\"java\">  String HQL=&quot;from User where name=? and id=?&quot;;\n  Query query=session.createQuery(HQL);\n  query.setString(0,&quot;JONE&quot;);\n  query.setInteger(1,3);\n  User user=(User)query.uniqueResult();\n\n  ////\n\n  String HQL=&quot;form Uesr where name like ?&quot;;\n  Query query=session.createQuery(HQL);\n  query.setString(0,&quot;%o%&quot;)//模糊查询\n  List&lt;User&gt; list=query.list();\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>按参数名称查询</p>\n<ul>\n<li>在HQL中自定义<pre><code class=\"java\">   String HQL=&quot;form Uesr where name=:name and id=:id&quot;; \n   Query query=session.createQuery(HQL);\n   query.setParameter(&quot;name&quot;,&quot;Kity&quot;)\n   query.setParameter(&quot;id&quot;,&quot;5&quot;)\n   List&lt;User&gt; list=query.list();</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分页查询</p>\n<ul>\n<li><code>setFirstResult(int firstResult);</code> 设定查询位置</li>\n<li><code>setMaxResult(int maxReslut);</code> 设定插叙数目<pre><code class=\"java\">  String HQL=&quot;form Uesr&quot;; \n  Query query=session.createQuery(HQL);\n  query.setFirstResult(2);//从第3条数据开始查询\n  query.setMaxResult(3);//查询3条记录\n  List&lt;User&gt; list=query.list();</code></pre>\n</li>\n</ul>\n</li>\n<li><p>报表查询</p>\n<pre><code class=\"java\">      String HQL=&quot;select u.gender,count(u) form Uesr as u group by u.gender&quot;; \n      Query query=session.createQuery(HQL);\n      List&lt;User&gt; list=query.list();\n      Iterator iter=list.iterator();\n      while(iter.hasNext()){\n          Object[] objct=(Object[])iter.next();\n          Sy\n      }\n\n</code></pre>\n</li>\n</ul>\n<pre><code>```</code></pre><ul>\n<li>QBC查询<ul>\n<li>组合查询<ul>\n<li>通过Restrictions工具类的相应方法     <table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>    ```java\n        Criteria criteria=session.createCriteria(User.class);\n        criteria.add(Restrictions.and(Restrictions.eq(&quot;&quot;)))\n\n        ////\n\n        Criteria criteria=session.createCriteria(User.class);\n        Criterion criterion=Restrictions.or(Restrictions.eq(&quot;id&quot;,1),Restrictions.eq(&quot;name&quot;,&quot;Kitty&quot;));\n\n\n    ```\n* 分页查询\n    * `setFirstResult(int firstResult);` \n    * `setMaxResult(int maxReslut);`\n\n    ```java\n        Criteria criteria=\n        criteria.setFirstResult(2);\n        criteria.setMaxResult(3);\n    ```</code></pre><h3 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h3><h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><ul>\n<li><p>以<strong>IOC(Inverse Of Control 控制反转)</strong> 和 <strong>AOP(Aspect Oriented Programming 面向切面)</strong> 为内核</p>\n</li>\n<li><p>三层</p>\n<ul>\n<li>表示层(web)</li>\n<li>业务逻辑(service)</li>\n<li>持久层(dao)</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>简化开发</li>\n<li>方便测试</li>\n<li>松耦合</li>\n<li>AOP编程的支持(权限拦截，任务监控)</li>\n<li>方便集成各种优秀框架</li>\n<li>降低JavaEE API的使用难度</li>\n</ul>\n</li>\n<li><p>Spring的体系结构</p>\n<ul>\n<li><p><img src=\"\" alt=\"\"></p>\n</li>\n<li><p>Core Container(核心容器)</p>\n<ul>\n<li>Beans 提供了BeanFactory</li>\n<li>Core</li>\n<li>Context 建立在core和Beans模块基础之上</li>\n<li>Expression Language 运行时查询和操作对象</li>\n</ul>\n</li>\n<li><p>Data Access/Integration(数据访问/集成)</p>\n<ul>\n<li>JDBC</li>\n<li>ORM</li>\n<li>OXM</li>\n<li>JMS:Java消息</li>\n<li>Transaction</li>\n</ul>\n</li>\n<li><p>Web模块</p>\n<ul>\n<li>web 提供基本的Web开发集成特性</li>\n<li>Servlet</li>\n<li>Struts</li>\n<li>Portlet</li>\n</ul>\n</li>\n<li><p>其他模块</p>\n<ul>\n<li>AOP</li>\n<li>Aspects</li>\n<li>Instrumentation</li>\n<li>Test 指出Spring组件，使用JUnit或者TestNG进行测试</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Spring的IOC容器</p>\n<ul>\n<li>Spring容器会负责程序之间的关系，而不是有程序代码直接控制，这样控制权由应用代码转移到外部容器，控制权发生了反转，这就是Spring的IOC(控制反转)思想<ul>\n<li>BeanFactory</li>\n<li>ApplicatonContext</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n\n<hr>\n<br>\n<br>\n\n<h3 id=\"RESTful风格\"><a href=\"#RESTful风格\" class=\"headerlink\" title=\"RESTful风格\"></a>RESTful风格</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/73d2415956bd\" target=\"_blank\" rel=\"noopener\">RESTful风格</a></li>\n</ul>"},{"title":"Spring Boot集成Druid","declare":true,"wordCount":true,"abbrlink":"3570abc7","date":"2020-05-19T13:10:10.000Z","_content":"[Druid官方文档](https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)\nDruid是阿里巴巴计算平台事业部出品，为监控而生的一个数据库连接池。它在监控、可扩展、稳定性和性能方面具有明显的优势，通过其提供的监控功能可以观察数据库连接池和SQL查询功能，使用Driud连接池可以提高数据库的访问性能。以下介绍一下Spring Boot如何简单集成Druid.\n\n<!-- more -->\n\n### 1.引入依赖\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid-spring-boot-starter</artifactId>\n    <version>1.1.9</version>\n</dependency>\n```\n\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.1.4</version>\n</dependency>\n```\n以上有两种依赖，但是根据我的测试第二种也是很多书籍中的用到的，在Spring Boot的pom.xml中还是会报异常，无法正常使用，而使用第一种不会。我查询资料和询问多方后，基本可以理解Spring Boot中使用第一种就好，因为那不是写着`druid-spring-boot-starter`吗。。。。 至于为啥书籍中为什么用的第二种，我猜测可能是以前spring boot老版本还是能够兼容druid，或者是我的用法可能出错，此处暂不深究。\n\n<br>\n<br>\n<br>\n\n### 2.Druid配置\n\n* 在`application.yml`添加  \n   \n```yml\nspring:\n  datasource:\n    #  Mysql连接信息\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/hibernate?characterEncoding=utf-8\n    username: root\n    password: \n    #  数据源类别\n    type: com.alibaba.druid.pool.DruidDataSource\n    #  初始化大小\n    druid:\n      min-idle: 5\n      initial-size: 5\n      max-active: 20\n      #      配置获取连接等待超时的时间（毫秒）\n      max-wait: 60000\n      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接（毫秒）\n      time-between-eviction-runs-millis: 60000\n      # 配置一个连接在池中最小的生存时间（毫秒）\n      min-evictable-idle-time-millis: 30000\n      validation-query: SELECT 1 FROM DUAL\n      test-while-idle: true\n      test-on-borrow: false\n      test-on-return: false\n      # 打开PSCache ，并指定每个连接上PSCache的大小\n      pool-prepared-statements: true\n      max-pool-prepared-statement-per-connection-size: 20\n      # 配置监控统计拦截的filters\n\n      filters: stat,wall\n```\n\n<br>\n<br>\n<br>\n\n### 3.开启监控功能\n* 开启监控的方法有很多种，这里介绍在工程`/src/main/java/com.smart.demo.filter`下新建一个配置类DruidConfiguration.java,代码如下：\n```java\n@Configuration\npublic class DruidConfiguration {\n\n    @Bean\n    public ServletRegistrationBean druidStatViewServlet() {\n        ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\");\n        // 白名单 也可添加黑名单 第一个参数改为“deny”即可(deny优先级高于allow)\n        servletRegistrationBean.addInitParameter(\"allow\", \"127.0.0.1\");\n        // 监控页面登陆账号\n        servletRegistrationBean.addInitParameter(\"loginUsername\", \"admin\");\n        // 监控页面登陆密码\n        servletRegistrationBean.addInitParameter(\"loginPassword\", \"1111\");\n        servletRegistrationBean.addInitParameter\n        // 是否能够重置数据\n        (\"resetEnable\", \"false\");\n        return servletRegistrationBean;\n    }\n\n    @Bean\n    public FilterRegistrationBean druidStatFilter() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter());\n        // 添加过滤规则\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        // 添加需要忽略的格式\n        filterRegistrationBean.addInitParameter(\"/exclusions\", \"*.js,*.jpg,*.png,*/css,/druid/*\");\n        return filterRegistrationBean;\n    }\n}\n```\n\n<br>\n<br>\n<br>\n\n### 4.测试\n写好以上配置后，重启一下项目，访问`http://localhost:8080/druid/index.html`,输入在上面配置的账号和密码，即可进入监控页面。\n<br>\n![登陆页面](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200519211112.png)\n![监控](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200519211156.png)\n\n\n<br>\n<br>\n<br>\n<br>\n<br>\n\n参考\n* [1]黄文毅.一步一步学Spring Boot。北京：清华大学出版社，2019.","source":"_posts/code/JavaWeb/Spring Boot集成Druid.md","raw":"---\ntitle: Spring Boot集成Druid\ncategories: Code\ntags:\n  - JavaWeb\ndeclare: true\nwordCount: true\nabbrlink: 3570abc7\ndate: 2020-05-19 21:10:10\n---\n[Druid官方文档](https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)\nDruid是阿里巴巴计算平台事业部出品，为监控而生的一个数据库连接池。它在监控、可扩展、稳定性和性能方面具有明显的优势，通过其提供的监控功能可以观察数据库连接池和SQL查询功能，使用Driud连接池可以提高数据库的访问性能。以下介绍一下Spring Boot如何简单集成Druid.\n\n<!-- more -->\n\n### 1.引入依赖\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid-spring-boot-starter</artifactId>\n    <version>1.1.9</version>\n</dependency>\n```\n\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.1.4</version>\n</dependency>\n```\n以上有两种依赖，但是根据我的测试第二种也是很多书籍中的用到的，在Spring Boot的pom.xml中还是会报异常，无法正常使用，而使用第一种不会。我查询资料和询问多方后，基本可以理解Spring Boot中使用第一种就好，因为那不是写着`druid-spring-boot-starter`吗。。。。 至于为啥书籍中为什么用的第二种，我猜测可能是以前spring boot老版本还是能够兼容druid，或者是我的用法可能出错，此处暂不深究。\n\n<br>\n<br>\n<br>\n\n### 2.Druid配置\n\n* 在`application.yml`添加  \n   \n```yml\nspring:\n  datasource:\n    #  Mysql连接信息\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/hibernate?characterEncoding=utf-8\n    username: root\n    password: \n    #  数据源类别\n    type: com.alibaba.druid.pool.DruidDataSource\n    #  初始化大小\n    druid:\n      min-idle: 5\n      initial-size: 5\n      max-active: 20\n      #      配置获取连接等待超时的时间（毫秒）\n      max-wait: 60000\n      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接（毫秒）\n      time-between-eviction-runs-millis: 60000\n      # 配置一个连接在池中最小的生存时间（毫秒）\n      min-evictable-idle-time-millis: 30000\n      validation-query: SELECT 1 FROM DUAL\n      test-while-idle: true\n      test-on-borrow: false\n      test-on-return: false\n      # 打开PSCache ，并指定每个连接上PSCache的大小\n      pool-prepared-statements: true\n      max-pool-prepared-statement-per-connection-size: 20\n      # 配置监控统计拦截的filters\n\n      filters: stat,wall\n```\n\n<br>\n<br>\n<br>\n\n### 3.开启监控功能\n* 开启监控的方法有很多种，这里介绍在工程`/src/main/java/com.smart.demo.filter`下新建一个配置类DruidConfiguration.java,代码如下：\n```java\n@Configuration\npublic class DruidConfiguration {\n\n    @Bean\n    public ServletRegistrationBean druidStatViewServlet() {\n        ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\");\n        // 白名单 也可添加黑名单 第一个参数改为“deny”即可(deny优先级高于allow)\n        servletRegistrationBean.addInitParameter(\"allow\", \"127.0.0.1\");\n        // 监控页面登陆账号\n        servletRegistrationBean.addInitParameter(\"loginUsername\", \"admin\");\n        // 监控页面登陆密码\n        servletRegistrationBean.addInitParameter(\"loginPassword\", \"1111\");\n        servletRegistrationBean.addInitParameter\n        // 是否能够重置数据\n        (\"resetEnable\", \"false\");\n        return servletRegistrationBean;\n    }\n\n    @Bean\n    public FilterRegistrationBean druidStatFilter() {\n        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter());\n        // 添加过滤规则\n        filterRegistrationBean.addUrlPatterns(\"/*\");\n        // 添加需要忽略的格式\n        filterRegistrationBean.addInitParameter(\"/exclusions\", \"*.js,*.jpg,*.png,*/css,/druid/*\");\n        return filterRegistrationBean;\n    }\n}\n```\n\n<br>\n<br>\n<br>\n\n### 4.测试\n写好以上配置后，重启一下项目，访问`http://localhost:8080/druid/index.html`,输入在上面配置的账号和密码，即可进入监控页面。\n<br>\n![登陆页面](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200519211112.png)\n![监控](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200519211156.png)\n\n\n<br>\n<br>\n<br>\n<br>\n<br>\n\n参考\n* [1]黄文毅.一步一步学Spring Boot。北京：清华大学出版社，2019.","slug":"code/JavaWeb/Spring Boot集成Druid","published":1,"updated":"2020-05-21T04:35:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1go005f0w7teudmf09k","content":"<p><a href=\"https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\" target=\"_blank\" rel=\"noopener\">Druid官方文档</a><br>Druid是阿里巴巴计算平台事业部出品，为监控而生的一个数据库连接池。它在监控、可扩展、稳定性和性能方面具有明显的优势，通过其提供的监控功能可以观察数据库连接池和SQL查询功能，使用Driud连接池可以提高数据库的访问性能。以下介绍一下Spring Boot如何简单集成Druid.</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-引入依赖\"><a href=\"#1-引入依赖\" class=\"headerlink\" title=\"1.引入依赖\"></a>1.引入依赖</h3><pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.alibaba<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>druid-spring-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>1.1.9<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></code></pre>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.alibaba<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>druid<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>1.1.4<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>以上有两种依赖，但是根据我的测试第二种也是很多书籍中的用到的，在Spring Boot的pom.xml中还是会报异常，无法正常使用，而使用第一种不会。我查询资料和询问多方后，基本可以理解Spring Boot中使用第一种就好，因为那不是写着<code>druid-spring-boot-starter</code>吗。。。。 至于为啥书籍中为什么用的第二种，我猜测可能是以前spring boot老版本还是能够兼容druid，或者是我的用法可能出错，此处暂不深究。</p>\n<br>\n<br>\n<br>\n\n<h3 id=\"2-Druid配置\"><a href=\"#2-Druid配置\" class=\"headerlink\" title=\"2.Druid配置\"></a>2.Druid配置</h3><ul>\n<li>在<code>application.yml</code>添加  </li>\n</ul>\n<pre class=\" language-yml\"><code class=\"language-yml\">spring:\n  datasource:\n    #  Mysql连接信息\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/hibernate?characterEncoding=utf-8\n    username: root\n    password: \n    #  数据源类别\n    type: com.alibaba.druid.pool.DruidDataSource\n    #  初始化大小\n    druid:\n      min-idle: 5\n      initial-size: 5\n      max-active: 20\n      #      配置获取连接等待超时的时间（毫秒）\n      max-wait: 60000\n      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接（毫秒）\n      time-between-eviction-runs-millis: 60000\n      # 配置一个连接在池中最小的生存时间（毫秒）\n      min-evictable-idle-time-millis: 30000\n      validation-query: SELECT 1 FROM DUAL\n      test-while-idle: true\n      test-on-borrow: false\n      test-on-return: false\n      # 打开PSCache ，并指定每个连接上PSCache的大小\n      pool-prepared-statements: true\n      max-pool-prepared-statement-per-connection-size: 20\n      # 配置监控统计拦截的filters\n\n      filters: stat,wall</code></pre>\n<br>\n<br>\n<br>\n\n<h3 id=\"3-开启监控功能\"><a href=\"#3-开启监控功能\" class=\"headerlink\" title=\"3.开启监控功能\"></a>3.开启监控功能</h3><ul>\n<li><p>开启监控的方法有很多种，这里介绍在工程<code>/src/main/java/com.smart.demo.filter</code>下新建一个配置类DruidConfiguration.java,代码如下：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DruidConfiguration</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token annotation punctuation\">@Bean</span>\n  <span class=\"token keyword\">public</span> ServletRegistrationBean <span class=\"token function\">druidStatViewServlet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      ServletRegistrationBean servletRegistrationBean <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServletRegistrationBean</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">StatViewServlet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/druid/*\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token operator\">/</span><span class=\"token operator\">/</span> 白名单 也可添加黑名单 第一个参数改为“deny”即可<span class=\"token punctuation\">(</span>deny优先级高于allow<span class=\"token punctuation\">)</span>\n      servletRegistrationBean<span class=\"token punctuation\">.</span><span class=\"token function\">addInitParameter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"allow\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token operator\">/</span><span class=\"token operator\">/</span> 监控页面登陆账号\n      servletRegistrationBean<span class=\"token punctuation\">.</span><span class=\"token function\">addInitParameter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"loginUsername\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"admin\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token operator\">/</span><span class=\"token operator\">/</span> 监控页面登陆密码\n      servletRegistrationBean<span class=\"token punctuation\">.</span><span class=\"token function\">addInitParameter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"loginPassword\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1111\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      servletRegistrationBean<span class=\"token punctuation\">.</span>addInitParameter\n      <span class=\"token operator\">/</span><span class=\"token operator\">/</span> 是否能够重置数据\n      <span class=\"token punctuation\">(</span><span class=\"token string\">\"resetEnable\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"false\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> servletRegistrationBean<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Bean</span>\n  <span class=\"token keyword\">public</span> FilterRegistrationBean <span class=\"token function\">druidStatFilter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      FilterRegistrationBean filterRegistrationBean <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FilterRegistrationBean</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">WebStatFilter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token operator\">/</span><span class=\"token operator\">/</span> 添加过滤规则\n      filterRegistrationBean<span class=\"token punctuation\">.</span><span class=\"token function\">addUrlPatterns</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/*\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token operator\">/</span><span class=\"token operator\">/</span> 添加需要忽略的格式\n      filterRegistrationBean<span class=\"token punctuation\">.</span><span class=\"token function\">addInitParameter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/exclusions\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"*.js,*.jpg,*.png,*/css,/druid/*\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> filterRegistrationBean<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<br>\n<br>\n<br>\n\n<h3 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><p>写好以上配置后，重启一下项目，访问<code>http://localhost:8080/druid/index.html</code>,输入在上面配置的账号和密码，即可进入监控页面。<br><br><br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200519211112.png\" alt=\"登陆页面\"><br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200519211156.png\" alt=\"监控\"></p>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<p>参考</p>\n<ul>\n<li>[1]黄文毅.一步一步学Spring Boot。北京：清华大学出版社，2019.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\" target=\"_blank\" rel=\"noopener\">Druid官方文档</a><br>Druid是阿里巴巴计算平台事业部出品，为监控而生的一个数据库连接池。它在监控、可扩展、稳定性和性能方面具有明显的优势，通过其提供的监控功能可以观察数据库连接池和SQL查询功能，使用Driud连接池可以提高数据库的访问性能。以下介绍一下Spring Boot如何简单集成Druid.</p>","more":"<h3 id=\"1-引入依赖\"><a href=\"#1-引入依赖\" class=\"headerlink\" title=\"1.引入依赖\"></a>1.引入依赖</h3><pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;1.1.9&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;druid&lt;/artifactId&gt;\n    &lt;version&gt;1.1.4&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>以上有两种依赖，但是根据我的测试第二种也是很多书籍中的用到的，在Spring Boot的pom.xml中还是会报异常，无法正常使用，而使用第一种不会。我查询资料和询问多方后，基本可以理解Spring Boot中使用第一种就好，因为那不是写着<code>druid-spring-boot-starter</code>吗。。。。 至于为啥书籍中为什么用的第二种，我猜测可能是以前spring boot老版本还是能够兼容druid，或者是我的用法可能出错，此处暂不深究。</p>\n<br>\n<br>\n<br>\n\n<h3 id=\"2-Druid配置\"><a href=\"#2-Druid配置\" class=\"headerlink\" title=\"2.Druid配置\"></a>2.Druid配置</h3><ul>\n<li>在<code>application.yml</code>添加  </li>\n</ul>\n<pre><code class=\"yml\">spring:\n  datasource:\n    #  Mysql连接信息\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/hibernate?characterEncoding=utf-8\n    username: root\n    password: \n    #  数据源类别\n    type: com.alibaba.druid.pool.DruidDataSource\n    #  初始化大小\n    druid:\n      min-idle: 5\n      initial-size: 5\n      max-active: 20\n      #      配置获取连接等待超时的时间（毫秒）\n      max-wait: 60000\n      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接（毫秒）\n      time-between-eviction-runs-millis: 60000\n      # 配置一个连接在池中最小的生存时间（毫秒）\n      min-evictable-idle-time-millis: 30000\n      validation-query: SELECT 1 FROM DUAL\n      test-while-idle: true\n      test-on-borrow: false\n      test-on-return: false\n      # 打开PSCache ，并指定每个连接上PSCache的大小\n      pool-prepared-statements: true\n      max-pool-prepared-statement-per-connection-size: 20\n      # 配置监控统计拦截的filters\n\n      filters: stat,wall</code></pre>\n<br>\n<br>\n<br>\n\n<h3 id=\"3-开启监控功能\"><a href=\"#3-开启监控功能\" class=\"headerlink\" title=\"3.开启监控功能\"></a>3.开启监控功能</h3><ul>\n<li><p>开启监控的方法有很多种，这里介绍在工程<code>/src/main/java/com.smart.demo.filter</code>下新建一个配置类DruidConfiguration.java,代码如下：</p>\n<pre><code class=\"java\">@Configuration\npublic class DruidConfiguration {\n\n  @Bean\n  public ServletRegistrationBean druidStatViewServlet() {\n      ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);\n      // 白名单 也可添加黑名单 第一个参数改为“deny”即可(deny优先级高于allow)\n      servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;127.0.0.1&quot;);\n      // 监控页面登陆账号\n      servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;admin&quot;);\n      // 监控页面登陆密码\n      servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;1111&quot;);\n      servletRegistrationBean.addInitParameter\n      // 是否能够重置数据\n      (&quot;resetEnable&quot;, &quot;false&quot;);\n      return servletRegistrationBean;\n  }\n\n  @Bean\n  public FilterRegistrationBean druidStatFilter() {\n      FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter());\n      // 添加过滤规则\n      filterRegistrationBean.addUrlPatterns(&quot;/*&quot;);\n      // 添加需要忽略的格式\n      filterRegistrationBean.addInitParameter(&quot;/exclusions&quot;, &quot;*.js,*.jpg,*.png,*/css,/druid/*&quot;);\n      return filterRegistrationBean;\n  }\n}</code></pre>\n</li>\n</ul>\n<br>\n<br>\n<br>\n\n<h3 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><p>写好以上配置后，重启一下项目，访问<code>http://localhost:8080/druid/index.html</code>,输入在上面配置的账号和密码，即可进入监控页面。<br><br><br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200519211112.png\" alt=\"登陆页面\"><br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200519211156.png\" alt=\"监控\"></p>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<p>参考</p>\n<ul>\n<li>[1]黄文毅.一步一步学Spring Boot。北京：清华大学出版社，2019.</li>\n</ul>"},{"title":"Spring Data Jpa设置联合主键","declare":true,"wordCount":true,"abbrlink":"b988190","data":"2020-04-27T15:20:10.000Z","_content":"对于三种比较常见的SpringBoot持久层框架中，作者最喜欢的Spring Data Jpa,因为相比于Hibernate和MyBatis，它更符合ORM的理念，更多的使用注解来实现各种持久化操作，简单易上手，而且也不需要写很多的相关文件，有点Spring和SpringBoot之间那么点意思，当然对于一些复杂CAUD场景可能会有不太方便的地方，但是对于需要快速开发的小项目时，它显得极为合适。<br>\n言归正传，前几天在快速搭建的一个日志分析系统，最后对数据表进行重构的时候，需要设置联合主键，遇到了一些问题，最后发现**并只不是在实体类的属性中添加多个`@Id`**,所以在此记下：\n<!-- more -->\n\n## 两种实现方法\n\n### 1.@IdClass + @Id\n\n#### 1.1联合主键类\n* 首先依照以下规则写一个**包含实体类所有组成联合主键的字段**的联合主键类，\n    * 继承Serializable接口进行序列化\n    * 重写hashCode()和equals()方法\n    * 有一个无参构造函数\n        ```java\n        /**\n        * Description 联合主键类\n        * Author Cloudr \n        * Date 2020/4/26 22:50\n        **/\n        public class PhoneMultiKeys implements Serializable {\n\n            private String band;\n            private String series;\n            private int size;\n\n            public PhoneMultiKeys() {\n            }\n\n            public PhoneMultiKeys(String band, String series, int size) {\n                this.band = band;\n                this.series = series;\n                this.size = size;\n            }\n\n            public int getSize() {\n                return size;\n            }\n\n            public void setSize(int size) {\n                this.size = size;\n            }\n\n            public String getBand() {\n                return band;\n            }\n\n            public void setBand(String band) {\n                this.band = band;\n            }\n\n            public String getSeries() {\n                return series;\n            }\n\n            public void setSeries(String series) {\n                this.series = series;\n            }\n\n            @Override\n            public int hashCode(){\n                int code=17;\n                code=code*31+(band!=null?band.hashCode():0);\n                code=code*31+(series!=null?series.hashCode():0);\n                code=code*31+(int)size;\n                return code;\n            }\n\n            @Override\n            public boolean equals(Object object){\n                if(object==null)\n                    return false;\n                if (!(object instanceof PhoneMultiKeys))\n                    return false;\n                PhoneMultiKeys obj=(PhoneMultiKeys)object;\n                if(obj.band.equals(band)&&obj.series.equals(series))\n                    return true;\n                return false;\n            }\n        }\n        ```\n\n#### 1.2实体类\n* 如常编写实体类\n    * 注意使用@IdClass,参数为对应的联合主键类\n    * @Id注解正常使用\n    * 重写equals()和hashCode()\n        ```java\n        /**\n        * Description 实体类\n        * Author Cloudr \n        * Date 2020/4/26 22:49\n        **/\n        @Entity\n        @Table(name = \"phoneTestFroMultiKeys\")\n        @IdClass(PhoneMultiKeys.class)\n        public class Phone implements Serializable {\n            @Id\n            private String band;\n            @Id\n            private String series;\n            @Id\n            private int size;\n            private String model;\n\n            public Phone() {\n            }\n\n            public Phone(String band, String series, String model,int size) {\n                this.band = band;\n                this.series = series;\n                this.model = model;\n                this.size=size;\n            }\n\n            public String getBand() {\n                return band;\n            }\n\n            public void setBand(String band) {\n                this.band = band;\n            }\n\n            public String getSeries() {\n                return series;\n            }\n\n            public void setSeries(String series) {\n                this.series = series;\n            }\n\n            public String getModel() {\n                return model;\n            }\n\n            public void setModel(String model) {\n                this.model = model;\n            }\n\n            public int getSize() {\n                return size;\n            }\n\n            public void setSize(int size) {\n                this.size = size;\n            }\n\n            @Override\n            public String toString() {\n                return \"Phone{\" +\n                        \"band='\" + band + '\\'' +\n                        \", series='\" + series + '\\'' +\n                        \", size=\" + size +\n                        \", model='\" + model + '\\'' +\n                        '}';\n            }\n        }\n     \n        ```\n\n#### 1.3测试\n* Dao层\n    * JpaRepository<T,TD> //TD类型测试过String、Integer、以及无关的Date和Object都可以，所以任何类型都可以？\n        ```java\n        public interface PhoneDao extends JpaRepository<Phone, Object> { \n\n            public Optional<Phone> findByBandAndSeriesAndSize(String band, String series, int size);\n\n        }\n        ```\n* Service层\n    ```java\n    @Service\n    public interface PhoneService {\n\n        void saveALl(List<Phone> phoneList);\n\n    }\n\n    @Service\n    public class PhoneServiceImpl implements PhoneService {\n\n        @Resource\n        private PhoneDao phoneDao;\n\n        @Override\n        public void saveALl(List<Phone> phoneList) {\n            phoneDao.saveAll(phoneList);\n        }\n\n        public Optional<Phone> findByBandAndSeriesAndSize(String mi, String mix, int i) {\n            return phoneDao.findByBandAndSeriesAndSize(mi,mix,i);\n        }\n    }\n    ```\n* 测试\n    ```java\n        //SUCCEED\n        @Test\n        void TestSaveList() {\n            Book book1 = new Book(\"cc1\", \"aa\");\n            Book book2 = new Book(\"cc2\", \"aa\");\n            List<Book> list = new ArrayList<>();\n            list.add(book1);\n            list.add(book2);\n            bookService.saveAll(list);\n        }\n    ```\n\n### 2.@Embeddable + @EmbedId \n\n#### 2.1 联合主键类\n\n* 加入@Embeddable\n* 序列化\n* 无参构造函数\n    > `UserPK`是一种命名风格并不是协议\n    ```java\n    @Embeddable\n    public class UserPK implements Serializable  {\n        private String userId;\n        private String userName;\n\n        public UserPK() {\n        }\n\n        public UserPK(String userId, String userName) {\n            this.userId = userId;\n            this.userName = userName;\n        }\n\n        public String getUserId() {\n            return userId;\n        }\n\n        public void setUserId(String userId) {\n            this.userId = userId;\n        }\n\n        public String getUserName() {\n            return userName;\n        }\n\n        public void setUserName(String userName) {\n            this.userName = userName;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            UserPK userPK = (UserPK) o;\n            return userId.equals(userPK.userId) &&\n                    userName.equals(userPK.userName);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(userId, userName);\n        }\n    }\n    ```\n#### 2.2 实体类\n* 使用@EmbeddedId标注Id\n* Id类型为UserPK\n    ```java\n    @Entity\n    @Table(name = \"user_test\")\n    public class User implements Serializable {\n        @EmbeddedId\n        private UserPK id;\n        private String nickName;\n\n        public User() {\n        }\n\n        public User(UserPK id, String nickName) {\n            this.id = id;\n            this.nickName = nickName;\n        }\n\n        public UserPK getId() {\n            return id;\n        }\n\n        public void setId(UserPK id) {\n            this.id = id;\n        }\n\n        public String getNickName() {\n            return nickName;\n        }\n\n        public void setNickName(String nickName) {\n            this.nickName = nickName;\n        }\n    }\n    ```\n* Dao层\n    * JpaRepository<T, TD> //TD类型为联合主键类\n        ```java\n        public interface UserRepository extends JpaRepository<User, UserPK> {\n        \n        }\n        ```\n#### 2.3 测试\n```java\n    @Resource\n    private UserRepository userDao;\n    @Test\n    void TestUserWithMultiKeys() {\n        User user = new User(new UserPK(\"123\", \"Lou\"), \"cc\");\n        userDao.save(user);\n        logger.info(\"存储成功\");\n    }\n```\n\n\n\n\n## 总结\n* 作者猜测Jpa之所以不能只在实体类中添加多个@Id实现联合主键是因为可能只靠注释可能在一些情况下不够准确，也可能底层没有做的特别完善，期待Jpa后续的更新。而在联合主键类中必须重写equals()和hashCode()以及都必须实现序列化都已在一定程度上印证了这一点。当然这些都是猜测，期望和各位的交流。\n\n* 关于以上两种方法，`@Embeddable + @EmbedId`更符合面向对象的设计思想，将联合主键直接封装成一个类，`@IdClass + @Id`更直观，目前作者还不知道其中的具体差异。\n\n\n\n\n\n","source":"_posts/code/JavaWeb/Spring Data Jpa设置联合主键.md","raw":"---\ntitle: Spring Data Jpa设置联合主键\ncategories: Code\ntags:\n  - JavaWeb\n  - ORM\ndeclare: true\nwordCount: true\nabbrlink: b988190\ndata: 2020-04-27 23:20:10\n---\n对于三种比较常见的SpringBoot持久层框架中，作者最喜欢的Spring Data Jpa,因为相比于Hibernate和MyBatis，它更符合ORM的理念，更多的使用注解来实现各种持久化操作，简单易上手，而且也不需要写很多的相关文件，有点Spring和SpringBoot之间那么点意思，当然对于一些复杂CAUD场景可能会有不太方便的地方，但是对于需要快速开发的小项目时，它显得极为合适。<br>\n言归正传，前几天在快速搭建的一个日志分析系统，最后对数据表进行重构的时候，需要设置联合主键，遇到了一些问题，最后发现**并只不是在实体类的属性中添加多个`@Id`**,所以在此记下：\n<!-- more -->\n\n## 两种实现方法\n\n### 1.@IdClass + @Id\n\n#### 1.1联合主键类\n* 首先依照以下规则写一个**包含实体类所有组成联合主键的字段**的联合主键类，\n    * 继承Serializable接口进行序列化\n    * 重写hashCode()和equals()方法\n    * 有一个无参构造函数\n        ```java\n        /**\n        * Description 联合主键类\n        * Author Cloudr \n        * Date 2020/4/26 22:50\n        **/\n        public class PhoneMultiKeys implements Serializable {\n\n            private String band;\n            private String series;\n            private int size;\n\n            public PhoneMultiKeys() {\n            }\n\n            public PhoneMultiKeys(String band, String series, int size) {\n                this.band = band;\n                this.series = series;\n                this.size = size;\n            }\n\n            public int getSize() {\n                return size;\n            }\n\n            public void setSize(int size) {\n                this.size = size;\n            }\n\n            public String getBand() {\n                return band;\n            }\n\n            public void setBand(String band) {\n                this.band = band;\n            }\n\n            public String getSeries() {\n                return series;\n            }\n\n            public void setSeries(String series) {\n                this.series = series;\n            }\n\n            @Override\n            public int hashCode(){\n                int code=17;\n                code=code*31+(band!=null?band.hashCode():0);\n                code=code*31+(series!=null?series.hashCode():0);\n                code=code*31+(int)size;\n                return code;\n            }\n\n            @Override\n            public boolean equals(Object object){\n                if(object==null)\n                    return false;\n                if (!(object instanceof PhoneMultiKeys))\n                    return false;\n                PhoneMultiKeys obj=(PhoneMultiKeys)object;\n                if(obj.band.equals(band)&&obj.series.equals(series))\n                    return true;\n                return false;\n            }\n        }\n        ```\n\n#### 1.2实体类\n* 如常编写实体类\n    * 注意使用@IdClass,参数为对应的联合主键类\n    * @Id注解正常使用\n    * 重写equals()和hashCode()\n        ```java\n        /**\n        * Description 实体类\n        * Author Cloudr \n        * Date 2020/4/26 22:49\n        **/\n        @Entity\n        @Table(name = \"phoneTestFroMultiKeys\")\n        @IdClass(PhoneMultiKeys.class)\n        public class Phone implements Serializable {\n            @Id\n            private String band;\n            @Id\n            private String series;\n            @Id\n            private int size;\n            private String model;\n\n            public Phone() {\n            }\n\n            public Phone(String band, String series, String model,int size) {\n                this.band = band;\n                this.series = series;\n                this.model = model;\n                this.size=size;\n            }\n\n            public String getBand() {\n                return band;\n            }\n\n            public void setBand(String band) {\n                this.band = band;\n            }\n\n            public String getSeries() {\n                return series;\n            }\n\n            public void setSeries(String series) {\n                this.series = series;\n            }\n\n            public String getModel() {\n                return model;\n            }\n\n            public void setModel(String model) {\n                this.model = model;\n            }\n\n            public int getSize() {\n                return size;\n            }\n\n            public void setSize(int size) {\n                this.size = size;\n            }\n\n            @Override\n            public String toString() {\n                return \"Phone{\" +\n                        \"band='\" + band + '\\'' +\n                        \", series='\" + series + '\\'' +\n                        \", size=\" + size +\n                        \", model='\" + model + '\\'' +\n                        '}';\n            }\n        }\n     \n        ```\n\n#### 1.3测试\n* Dao层\n    * JpaRepository<T,TD> //TD类型测试过String、Integer、以及无关的Date和Object都可以，所以任何类型都可以？\n        ```java\n        public interface PhoneDao extends JpaRepository<Phone, Object> { \n\n            public Optional<Phone> findByBandAndSeriesAndSize(String band, String series, int size);\n\n        }\n        ```\n* Service层\n    ```java\n    @Service\n    public interface PhoneService {\n\n        void saveALl(List<Phone> phoneList);\n\n    }\n\n    @Service\n    public class PhoneServiceImpl implements PhoneService {\n\n        @Resource\n        private PhoneDao phoneDao;\n\n        @Override\n        public void saveALl(List<Phone> phoneList) {\n            phoneDao.saveAll(phoneList);\n        }\n\n        public Optional<Phone> findByBandAndSeriesAndSize(String mi, String mix, int i) {\n            return phoneDao.findByBandAndSeriesAndSize(mi,mix,i);\n        }\n    }\n    ```\n* 测试\n    ```java\n        //SUCCEED\n        @Test\n        void TestSaveList() {\n            Book book1 = new Book(\"cc1\", \"aa\");\n            Book book2 = new Book(\"cc2\", \"aa\");\n            List<Book> list = new ArrayList<>();\n            list.add(book1);\n            list.add(book2);\n            bookService.saveAll(list);\n        }\n    ```\n\n### 2.@Embeddable + @EmbedId \n\n#### 2.1 联合主键类\n\n* 加入@Embeddable\n* 序列化\n* 无参构造函数\n    > `UserPK`是一种命名风格并不是协议\n    ```java\n    @Embeddable\n    public class UserPK implements Serializable  {\n        private String userId;\n        private String userName;\n\n        public UserPK() {\n        }\n\n        public UserPK(String userId, String userName) {\n            this.userId = userId;\n            this.userName = userName;\n        }\n\n        public String getUserId() {\n            return userId;\n        }\n\n        public void setUserId(String userId) {\n            this.userId = userId;\n        }\n\n        public String getUserName() {\n            return userName;\n        }\n\n        public void setUserName(String userName) {\n            this.userName = userName;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            UserPK userPK = (UserPK) o;\n            return userId.equals(userPK.userId) &&\n                    userName.equals(userPK.userName);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(userId, userName);\n        }\n    }\n    ```\n#### 2.2 实体类\n* 使用@EmbeddedId标注Id\n* Id类型为UserPK\n    ```java\n    @Entity\n    @Table(name = \"user_test\")\n    public class User implements Serializable {\n        @EmbeddedId\n        private UserPK id;\n        private String nickName;\n\n        public User() {\n        }\n\n        public User(UserPK id, String nickName) {\n            this.id = id;\n            this.nickName = nickName;\n        }\n\n        public UserPK getId() {\n            return id;\n        }\n\n        public void setId(UserPK id) {\n            this.id = id;\n        }\n\n        public String getNickName() {\n            return nickName;\n        }\n\n        public void setNickName(String nickName) {\n            this.nickName = nickName;\n        }\n    }\n    ```\n* Dao层\n    * JpaRepository<T, TD> //TD类型为联合主键类\n        ```java\n        public interface UserRepository extends JpaRepository<User, UserPK> {\n        \n        }\n        ```\n#### 2.3 测试\n```java\n    @Resource\n    private UserRepository userDao;\n    @Test\n    void TestUserWithMultiKeys() {\n        User user = new User(new UserPK(\"123\", \"Lou\"), \"cc\");\n        userDao.save(user);\n        logger.info(\"存储成功\");\n    }\n```\n\n\n\n\n## 总结\n* 作者猜测Jpa之所以不能只在实体类中添加多个@Id实现联合主键是因为可能只靠注释可能在一些情况下不够准确，也可能底层没有做的特别完善，期待Jpa后续的更新。而在联合主键类中必须重写equals()和hashCode()以及都必须实现序列化都已在一定程度上印证了这一点。当然这些都是猜测，期望和各位的交流。\n\n* 关于以上两种方法，`@Embeddable + @EmbedId`更符合面向对象的设计思想，将联合主键直接封装成一个类，`@IdClass + @Id`更直观，目前作者还不知道其中的具体差异。\n\n\n\n\n\n","slug":"code/JavaWeb/Spring Data Jpa设置联合主键","published":1,"date":"2021-08-09T10:06:58.827Z","updated":"2020-10-06T10:51:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gp005i0w7t98xm5aew","content":"<p>对于三种比较常见的SpringBoot持久层框架中，作者最喜欢的Spring Data Jpa,因为相比于Hibernate和MyBatis，它更符合ORM的理念，更多的使用注解来实现各种持久化操作，简单易上手，而且也不需要写很多的相关文件，有点Spring和SpringBoot之间那么点意思，当然对于一些复杂CAUD场景可能会有不太方便的地方，但是对于需要快速开发的小项目时，它显得极为合适。<br><br>言归正传，前几天在快速搭建的一个日志分析系统，最后对数据表进行重构的时候，需要设置联合主键，遇到了一些问题，最后发现<strong>并只不是在实体类的属性中添加多个<code>@Id</code></strong>,所以在此记下：</p>\n<a id=\"more\"></a>\n\n<h2 id=\"两种实现方法\"><a href=\"#两种实现方法\" class=\"headerlink\" title=\"两种实现方法\"></a>两种实现方法</h2><h3 id=\"1-IdClass-Id\"><a href=\"#1-IdClass-Id\" class=\"headerlink\" title=\"1.@IdClass + @Id\"></a>1.@IdClass + @Id</h3><h4 id=\"1-1联合主键类\"><a href=\"#1-1联合主键类\" class=\"headerlink\" title=\"1.1联合主键类\"></a>1.1联合主键类</h4><ul>\n<li><p>首先依照以下规则写一个<strong>包含实体类所有组成联合主键的字段</strong>的联合主键类，</p>\n<ul>\n<li><p>继承Serializable接口进行序列化</p>\n</li>\n<li><p>重写hashCode()和equals()方法</p>\n</li>\n<li><p>有一个无参构造函数</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token comment\" spellcheck=\"true\">/**\n  * Description 联合主键类\n  * Author Cloudr \n  * Date 2020/4/26 22:50\n  **/</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PhoneMultiKeys</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">private</span> String band<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">private</span> String series<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token function\">PhoneMultiKeys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token function\">PhoneMultiKeys</span><span class=\"token punctuation\">(</span>String band<span class=\"token punctuation\">,</span> String series<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>band <span class=\"token operator\">=</span> band<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>series <span class=\"token operator\">=</span> series<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> size<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setSize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> String <span class=\"token function\">getBand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> band<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setBand</span><span class=\"token punctuation\">(</span>String band<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>band <span class=\"token operator\">=</span> band<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> String <span class=\"token function\">getSeries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> series<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setSeries</span><span class=\"token punctuation\">(</span>String series<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>series <span class=\"token operator\">=</span> series<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token annotation punctuation\">@Override</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">int</span> code<span class=\"token operator\">=</span><span class=\"token number\">17</span><span class=\"token punctuation\">;</span>\n          code<span class=\"token operator\">=</span>code<span class=\"token operator\">*</span><span class=\"token number\">31</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span>band<span class=\"token operator\">!=</span>null<span class=\"token operator\">?</span>band<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          code<span class=\"token operator\">=</span>code<span class=\"token operator\">*</span><span class=\"token number\">31</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span>series<span class=\"token operator\">!=</span>null<span class=\"token operator\">?</span>series<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          code<span class=\"token operator\">=</span>code<span class=\"token operator\">*</span><span class=\"token number\">31</span><span class=\"token operator\">+</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>size<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">return</span> code<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token annotation punctuation\">@Override</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>Object object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>object<span class=\"token operator\">==</span>null<span class=\"token punctuation\">)</span>\n              <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>object <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">PhoneMultiKeys</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n              <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n          PhoneMultiKeys obj<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>PhoneMultiKeys<span class=\"token punctuation\">)</span>object<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span>band<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>band<span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;&amp;</span>obj<span class=\"token punctuation\">.</span>series<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>series<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n              <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2实体类\"><a href=\"#1-2实体类\" class=\"headerlink\" title=\"1.2实体类\"></a>1.2实体类</h4><ul>\n<li><p>如常编写实体类</p>\n<ul>\n<li><p>注意使用@IdClass,参数为对应的联合主键类</p>\n</li>\n<li><p>@Id注解正常使用</p>\n</li>\n<li><p>重写equals()和hashCode()</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token comment\" spellcheck=\"true\">/**\n  * Description 实体类\n  * Author Cloudr \n  * Date 2020/4/26 22:49\n  **/</span>\n  <span class=\"token annotation punctuation\">@Entity</span>\n  <span class=\"token annotation punctuation\">@Table</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"phoneTestFroMultiKeys\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token annotation punctuation\">@IdClass</span><span class=\"token punctuation\">(</span>PhoneMultiKeys<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Phone</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token annotation punctuation\">@Id</span>\n      <span class=\"token keyword\">private</span> String band<span class=\"token punctuation\">;</span>\n      <span class=\"token annotation punctuation\">@Id</span>\n      <span class=\"token keyword\">private</span> String series<span class=\"token punctuation\">;</span>\n      <span class=\"token annotation punctuation\">@Id</span>\n      <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">private</span> String model<span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token function\">Phone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token function\">Phone</span><span class=\"token punctuation\">(</span>String band<span class=\"token punctuation\">,</span> String series<span class=\"token punctuation\">,</span> String model<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>band <span class=\"token operator\">=</span> band<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>series <span class=\"token operator\">=</span> series<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model <span class=\"token operator\">=</span> model<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size<span class=\"token operator\">=</span>size<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> String <span class=\"token function\">getBand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> band<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setBand</span><span class=\"token punctuation\">(</span>String band<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>band <span class=\"token operator\">=</span> band<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> String <span class=\"token function\">getSeries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> series<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setSeries</span><span class=\"token punctuation\">(</span>String series<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>series <span class=\"token operator\">=</span> series<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> String <span class=\"token function\">getModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> model<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setModel</span><span class=\"token punctuation\">(</span>String model<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model <span class=\"token operator\">=</span> model<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> size<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setSize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token annotation punctuation\">@Override</span>\n      <span class=\"token keyword\">public</span> String <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> <span class=\"token string\">\"Phone{\"</span> <span class=\"token operator\">+</span>\n                  <span class=\"token string\">\"band='\"</span> <span class=\"token operator\">+</span> band <span class=\"token operator\">+</span> <span class=\"token string\">'\\''</span> <span class=\"token operator\">+</span>\n                  <span class=\"token string\">\", series='\"</span> <span class=\"token operator\">+</span> series <span class=\"token operator\">+</span> <span class=\"token string\">'\\''</span> <span class=\"token operator\">+</span>\n                  <span class=\"token string\">\", size=\"</span> <span class=\"token operator\">+</span> size <span class=\"token operator\">+</span>\n                  <span class=\"token string\">\", model='\"</span> <span class=\"token operator\">+</span> model <span class=\"token operator\">+</span> <span class=\"token string\">'\\''</span> <span class=\"token operator\">+</span>\n                  <span class=\"token string\">'}'</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-3测试\"><a href=\"#1-3测试\" class=\"headerlink\" title=\"1.3测试\"></a>1.3测试</h4><ul>\n<li><p>Dao层</p>\n<ul>\n<li><p>JpaRepository&lt;T,TD&gt; //TD类型测试过String、Integer、以及无关的Date和Object都可以，所以任何类型都可以？</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">PhoneDao</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">JpaRepository</span><span class=\"token operator\">&lt;</span>Phone<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> \n\n      <span class=\"token keyword\">public</span> Optional<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span> <span class=\"token function\">findByBandAndSeriesAndSize</span><span class=\"token punctuation\">(</span>String band<span class=\"token punctuation\">,</span> String series<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n</li>\n<li><p>Service层</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token annotation punctuation\">@Service</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">PhoneService</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">void</span> <span class=\"token function\">saveALl</span><span class=\"token punctuation\">(</span>List<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span> phoneList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Service</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PhoneServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">PhoneService</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token annotation punctuation\">@Resource</span>\n      <span class=\"token keyword\">private</span> PhoneDao phoneDao<span class=\"token punctuation\">;</span>\n\n      <span class=\"token annotation punctuation\">@Override</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">saveALl</span><span class=\"token punctuation\">(</span>List<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span> phoneList<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          phoneDao<span class=\"token punctuation\">.</span><span class=\"token function\">saveAll</span><span class=\"token punctuation\">(</span>phoneList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> Optional<span class=\"token operator\">&lt;</span>Phone<span class=\"token operator\">></span> <span class=\"token function\">findByBandAndSeriesAndSize</span><span class=\"token punctuation\">(</span>String mi<span class=\"token punctuation\">,</span> String mix<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> phoneDao<span class=\"token punctuation\">.</span><span class=\"token function\">findByBandAndSeriesAndSize</span><span class=\"token punctuation\">(</span>mi<span class=\"token punctuation\">,</span>mix<span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>测试</p>\n<pre class=\" language-java\"><code class=\"language-java\">      <span class=\"token comment\" spellcheck=\"true\">//SUCCEED</span>\n      <span class=\"token annotation punctuation\">@Test</span>\n      <span class=\"token keyword\">void</span> <span class=\"token function\">TestSaveList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          Book book1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Book</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cc1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          Book book2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Book</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cc2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          List<span class=\"token operator\">&lt;</span>Book<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>book1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>book2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          bookService<span class=\"token punctuation\">.</span><span class=\"token function\">saveAll</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<h3 id=\"2-Embeddable-EmbedId\"><a href=\"#2-Embeddable-EmbedId\" class=\"headerlink\" title=\"2.@Embeddable + @EmbedId\"></a>2.@Embeddable + @EmbedId</h3><h4 id=\"2-1-联合主键类\"><a href=\"#2-1-联合主键类\" class=\"headerlink\" title=\"2.1 联合主键类\"></a>2.1 联合主键类</h4><ul>\n<li><p>加入@Embeddable</p>\n</li>\n<li><p>序列化</p>\n</li>\n<li><p>无参构造函数</p>\n<blockquote>\n<p><code>UserPK</code>是一种命名风格并不是协议</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token annotation punctuation\">@Embeddable</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserPK</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span>  <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">private</span> String userId<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">private</span> String userName<span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token function\">UserPK</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token function\">UserPK</span><span class=\"token punctuation\">(</span>String userId<span class=\"token punctuation\">,</span> String userName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userId <span class=\"token operator\">=</span> userId<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userName <span class=\"token operator\">=</span> userName<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> String <span class=\"token function\">getUserId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> userId<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUserId</span><span class=\"token punctuation\">(</span>String userId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userId <span class=\"token operator\">=</span> userId<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> String <span class=\"token function\">getUserName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> userName<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUserName</span><span class=\"token punctuation\">(</span>String userName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userName <span class=\"token operator\">=</span> userName<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token annotation punctuation\">@Override</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>Object o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> o<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> <span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> o<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n          UserPK userPK <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>UserPK<span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">return</span> userId<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>userPK<span class=\"token punctuation\">.</span>userId<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n                  userName<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>userPK<span class=\"token punctuation\">.</span>userName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token annotation punctuation\">@Override</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> Objects<span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">,</span> userName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"2-2-实体类\"><a href=\"#2-2-实体类\" class=\"headerlink\" title=\"2.2 实体类\"></a>2.2 实体类</h4></li>\n<li><p>使用@EmbeddedId标注Id</p>\n</li>\n<li><p>Id类型为UserPK</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token annotation punctuation\">@Entity</span>\n  <span class=\"token annotation punctuation\">@Table</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"user_test\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token annotation punctuation\">@EmbeddedId</span>\n      <span class=\"token keyword\">private</span> UserPK id<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">private</span> String nickName<span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span>UserPK id<span class=\"token punctuation\">,</span> String nickName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nickName <span class=\"token operator\">=</span> nickName<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> UserPK <span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> id<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setId</span><span class=\"token punctuation\">(</span>UserPK id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> id<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> String <span class=\"token function\">getNickName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> nickName<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setNickName</span><span class=\"token punctuation\">(</span>String nickName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nickName <span class=\"token operator\">=</span> nickName<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>Dao层</p>\n<ul>\n<li><p>JpaRepository&lt;T, TD&gt; //TD类型为联合主键类</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserRepository</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">JpaRepository</span><span class=\"token operator\">&lt;</span>User<span class=\"token punctuation\">,</span> UserPK<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"2-3-测试\"><a href=\"#2-3-测试\" class=\"headerlink\" title=\"2.3 测试\"></a>2.3 测试</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Resource</span>\n<span class=\"token keyword\">private</span> UserRepository userDao<span class=\"token punctuation\">;</span>\n<span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">TestUserWithMultiKeys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  User user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">UserPK</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"123\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Lou\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  userDao<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"存储成功\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>作者猜测Jpa之所以不能只在实体类中添加多个@Id实现联合主键是因为可能只靠注释可能在一些情况下不够准确，也可能底层没有做的特别完善，期待Jpa后续的更新。而在联合主键类中必须重写equals()和hashCode()以及都必须实现序列化都已在一定程度上印证了这一点。当然这些都是猜测，期望和各位的交流。</p>\n</li>\n<li><p>关于以上两种方法，<code>@Embeddable + @EmbedId</code>更符合面向对象的设计思想，将联合主键直接封装成一个类，<code>@IdClass + @Id</code>更直观，目前作者还不知道其中的具体差异。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>对于三种比较常见的SpringBoot持久层框架中，作者最喜欢的Spring Data Jpa,因为相比于Hibernate和MyBatis，它更符合ORM的理念，更多的使用注解来实现各种持久化操作，简单易上手，而且也不需要写很多的相关文件，有点Spring和SpringBoot之间那么点意思，当然对于一些复杂CAUD场景可能会有不太方便的地方，但是对于需要快速开发的小项目时，它显得极为合适。<br><br>言归正传，前几天在快速搭建的一个日志分析系统，最后对数据表进行重构的时候，需要设置联合主键，遇到了一些问题，最后发现<strong>并只不是在实体类的属性中添加多个<code>@Id</code></strong>,所以在此记下：</p>","more":"<h2 id=\"两种实现方法\"><a href=\"#两种实现方法\" class=\"headerlink\" title=\"两种实现方法\"></a>两种实现方法</h2><h3 id=\"1-IdClass-Id\"><a href=\"#1-IdClass-Id\" class=\"headerlink\" title=\"1.@IdClass + @Id\"></a>1.@IdClass + @Id</h3><h4 id=\"1-1联合主键类\"><a href=\"#1-1联合主键类\" class=\"headerlink\" title=\"1.1联合主键类\"></a>1.1联合主键类</h4><ul>\n<li><p>首先依照以下规则写一个<strong>包含实体类所有组成联合主键的字段</strong>的联合主键类，</p>\n<ul>\n<li><p>继承Serializable接口进行序列化</p>\n</li>\n<li><p>重写hashCode()和equals()方法</p>\n</li>\n<li><p>有一个无参构造函数</p>\n<pre><code class=\"java\">  /**\n  * Description 联合主键类\n  * Author Cloudr \n  * Date 2020/4/26 22:50\n  **/\n  public class PhoneMultiKeys implements Serializable {\n\n      private String band;\n      private String series;\n      private int size;\n\n      public PhoneMultiKeys() {\n      }\n\n      public PhoneMultiKeys(String band, String series, int size) {\n          this.band = band;\n          this.series = series;\n          this.size = size;\n      }\n\n      public int getSize() {\n          return size;\n      }\n\n      public void setSize(int size) {\n          this.size = size;\n      }\n\n      public String getBand() {\n          return band;\n      }\n\n      public void setBand(String band) {\n          this.band = band;\n      }\n\n      public String getSeries() {\n          return series;\n      }\n\n      public void setSeries(String series) {\n          this.series = series;\n      }\n\n      @Override\n      public int hashCode(){\n          int code=17;\n          code=code*31+(band!=null?band.hashCode():0);\n          code=code*31+(series!=null?series.hashCode():0);\n          code=code*31+(int)size;\n          return code;\n      }\n\n      @Override\n      public boolean equals(Object object){\n          if(object==null)\n              return false;\n          if (!(object instanceof PhoneMultiKeys))\n              return false;\n          PhoneMultiKeys obj=(PhoneMultiKeys)object;\n          if(obj.band.equals(band)&amp;&amp;obj.series.equals(series))\n              return true;\n          return false;\n      }\n  }</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2实体类\"><a href=\"#1-2实体类\" class=\"headerlink\" title=\"1.2实体类\"></a>1.2实体类</h4><ul>\n<li><p>如常编写实体类</p>\n<ul>\n<li><p>注意使用@IdClass,参数为对应的联合主键类</p>\n</li>\n<li><p>@Id注解正常使用</p>\n</li>\n<li><p>重写equals()和hashCode()</p>\n<pre><code class=\"java\">  /**\n  * Description 实体类\n  * Author Cloudr \n  * Date 2020/4/26 22:49\n  **/\n  @Entity\n  @Table(name = &quot;phoneTestFroMultiKeys&quot;)\n  @IdClass(PhoneMultiKeys.class)\n  public class Phone implements Serializable {\n      @Id\n      private String band;\n      @Id\n      private String series;\n      @Id\n      private int size;\n      private String model;\n\n      public Phone() {\n      }\n\n      public Phone(String band, String series, String model,int size) {\n          this.band = band;\n          this.series = series;\n          this.model = model;\n          this.size=size;\n      }\n\n      public String getBand() {\n          return band;\n      }\n\n      public void setBand(String band) {\n          this.band = band;\n      }\n\n      public String getSeries() {\n          return series;\n      }\n\n      public void setSeries(String series) {\n          this.series = series;\n      }\n\n      public String getModel() {\n          return model;\n      }\n\n      public void setModel(String model) {\n          this.model = model;\n      }\n\n      public int getSize() {\n          return size;\n      }\n\n      public void setSize(int size) {\n          this.size = size;\n      }\n\n      @Override\n      public String toString() {\n          return &quot;Phone{&quot; +\n                  &quot;band=&#39;&quot; + band + &#39;\\&#39;&#39; +\n                  &quot;, series=&#39;&quot; + series + &#39;\\&#39;&#39; +\n                  &quot;, size=&quot; + size +\n                  &quot;, model=&#39;&quot; + model + &#39;\\&#39;&#39; +\n                  &#39;}&#39;;\n      }\n  }\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-3测试\"><a href=\"#1-3测试\" class=\"headerlink\" title=\"1.3测试\"></a>1.3测试</h4><ul>\n<li><p>Dao层</p>\n<ul>\n<li><p>JpaRepository&lt;T,TD&gt; //TD类型测试过String、Integer、以及无关的Date和Object都可以，所以任何类型都可以？</p>\n<pre><code class=\"java\">  public interface PhoneDao extends JpaRepository&lt;Phone, Object&gt; { \n\n      public Optional&lt;Phone&gt; findByBandAndSeriesAndSize(String band, String series, int size);\n\n  }</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Service层</p>\n<pre><code class=\"java\">  @Service\n  public interface PhoneService {\n\n      void saveALl(List&lt;Phone&gt; phoneList);\n\n  }\n\n  @Service\n  public class PhoneServiceImpl implements PhoneService {\n\n      @Resource\n      private PhoneDao phoneDao;\n\n      @Override\n      public void saveALl(List&lt;Phone&gt; phoneList) {\n          phoneDao.saveAll(phoneList);\n      }\n\n      public Optional&lt;Phone&gt; findByBandAndSeriesAndSize(String mi, String mix, int i) {\n          return phoneDao.findByBandAndSeriesAndSize(mi,mix,i);\n      }\n  }</code></pre>\n</li>\n<li><p>测试</p>\n<pre><code class=\"java\">      //SUCCEED\n      @Test\n      void TestSaveList() {\n          Book book1 = new Book(&quot;cc1&quot;, &quot;aa&quot;);\n          Book book2 = new Book(&quot;cc2&quot;, &quot;aa&quot;);\n          List&lt;Book&gt; list = new ArrayList&lt;&gt;();\n          list.add(book1);\n          list.add(book2);\n          bookService.saveAll(list);\n      }</code></pre>\n</li>\n</ul>\n<h3 id=\"2-Embeddable-EmbedId\"><a href=\"#2-Embeddable-EmbedId\" class=\"headerlink\" title=\"2.@Embeddable + @EmbedId\"></a>2.@Embeddable + @EmbedId</h3><h4 id=\"2-1-联合主键类\"><a href=\"#2-1-联合主键类\" class=\"headerlink\" title=\"2.1 联合主键类\"></a>2.1 联合主键类</h4><ul>\n<li><p>加入@Embeddable</p>\n</li>\n<li><p>序列化</p>\n</li>\n<li><p>无参构造函数</p>\n<blockquote>\n<p><code>UserPK</code>是一种命名风格并不是协议</p>\n</blockquote>\n<pre><code class=\"java\">  @Embeddable\n  public class UserPK implements Serializable  {\n      private String userId;\n      private String userName;\n\n      public UserPK() {\n      }\n\n      public UserPK(String userId, String userName) {\n          this.userId = userId;\n          this.userName = userName;\n      }\n\n      public String getUserId() {\n          return userId;\n      }\n\n      public void setUserId(String userId) {\n          this.userId = userId;\n      }\n\n      public String getUserName() {\n          return userName;\n      }\n\n      public void setUserName(String userName) {\n          this.userName = userName;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n          if (this == o) return true;\n          if (o == null || getClass() != o.getClass()) return false;\n          UserPK userPK = (UserPK) o;\n          return userId.equals(userPK.userId) &amp;&amp;\n                  userName.equals(userPK.userName);\n      }\n\n      @Override\n      public int hashCode() {\n          return Objects.hash(userId, userName);\n      }\n  }</code></pre>\n<h4 id=\"2-2-实体类\"><a href=\"#2-2-实体类\" class=\"headerlink\" title=\"2.2 实体类\"></a>2.2 实体类</h4></li>\n<li><p>使用@EmbeddedId标注Id</p>\n</li>\n<li><p>Id类型为UserPK</p>\n<pre><code class=\"java\">  @Entity\n  @Table(name = &quot;user_test&quot;)\n  public class User implements Serializable {\n      @EmbeddedId\n      private UserPK id;\n      private String nickName;\n\n      public User() {\n      }\n\n      public User(UserPK id, String nickName) {\n          this.id = id;\n          this.nickName = nickName;\n      }\n\n      public UserPK getId() {\n          return id;\n      }\n\n      public void setId(UserPK id) {\n          this.id = id;\n      }\n\n      public String getNickName() {\n          return nickName;\n      }\n\n      public void setNickName(String nickName) {\n          this.nickName = nickName;\n      }\n  }</code></pre>\n</li>\n<li><p>Dao层</p>\n<ul>\n<li><p>JpaRepository&lt;T, TD&gt; //TD类型为联合主键类</p>\n<pre><code class=\"java\">  public interface UserRepository extends JpaRepository&lt;User, UserPK&gt; {\n\n  }</code></pre>\n<h4 id=\"2-3-测试\"><a href=\"#2-3-测试\" class=\"headerlink\" title=\"2.3 测试\"></a>2.3 测试</h4><pre><code class=\"java\">@Resource\nprivate UserRepository userDao;\n@Test\nvoid TestUserWithMultiKeys() {\n  User user = new User(new UserPK(&quot;123&quot;, &quot;Lou&quot;), &quot;cc&quot;);\n  userDao.save(user);\n  logger.info(&quot;存储成功&quot;);\n}</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>作者猜测Jpa之所以不能只在实体类中添加多个@Id实现联合主键是因为可能只靠注释可能在一些情况下不够准确，也可能底层没有做的特别完善，期待Jpa后续的更新。而在联合主键类中必须重写equals()和hashCode()以及都必须实现序列化都已在一定程度上印证了这一点。当然这些都是猜测，期望和各位的交流。</p>\n</li>\n<li><p>关于以上两种方法，<code>@Embeddable + @EmbedId</code>更符合面向对象的设计思想，将联合主键直接封装成一个类，<code>@IdClass + @Id</code>更直观，目前作者还不知道其中的具体差异。</p>\n</li>\n</ul>"},{"title":"SpringBoot基础","abbrlink":25912,"data":"2020-04-21T18:40:10.000Z","declare":true,"wordCount":true,"_content":"Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。\n<!-- more -->\n\n\n\n## 一、注解\n### 1.1 Spring注解\n* @GetMapping、@PostMapping和@RequestMapping的区别\n    * @GetMapping\n        >用于将HTTP GET请求映射到特定处理程序方法的注释。具体来说，@GetMapping是一个作为快捷方式的组合注释@RequestMapping(method = RequestMethod.GET)。\n\n    * @PostMapping\n        >用于将HTTP POST请求映射到特定处理程序方法的注释。具体来说，@PostMapping是一个作为快捷方式的组合注释@RequestMapping(method = RequestMethod.POST)。\n\n    * @RequestMapping\n        >一般情况下都是用@RequestMapping（method=RequestMethod.），因为@**RequestMapping可以直接替代以上两个注解**，但是以上两个注解并不能替代@RequestMapping，@RequestMapping相当于以上两个注解的父类！ （找到相应的控制器）\n* @RestController\n    * @Controller和@ResponseBody的合集，表示被标记的对象是REST风格的Bean\n    * 返回结果默认为字符串\n        \n* @Controller \n    * 返回结果默认为视图。负责处理由DispatcherServlet分发的请求，将用户的请求经过业务层处理之后封装成一个Mode,然后将该model递交给相应的视图层，最后返回视图层。\n\n* @ResponseBody      \n    * 将内容或Java对象转换成响应报文的正文返回 \n    * 修改了Controller的返回要求，返回结果为字符串\n\n* @RequestBody\n    * 用于**接收前端传给后端的一些非HTML页面的其他格式数据（例如XML、JSON）**，是利用将请求报文中的正文自动转换为绑定给方法参数的变量字符串，而Get方法无请求体，前端不能使用Get方法提交而需要使用Post方法提交\n    \n* [@RequestParam](https://www.cnblogs.com/tomingto/p/11377138.html) 将请求中的值赋给被注解的方法参数\n    > `https://www.notecc.ink/username?q=123`\n    ```java\n        @RequestMapping(\"query\")\n        public ModelAndView query(@RequestParam(value = \"q\", required = false, defaultValue = \"1234567\") String q) {\n            ModelAndView mav = new ModelAndView();\n            mav.addObject(\"q\", q);\n            mav.setViewName(\"blogQuery\");\n            return mav;\n        }\n\n        @RequestMapping(\"/returnView\")\n        public String hello(@RequestParam String name, Model model){\n            model.addAttribute(\"name\",name);\n            return \"hello\";\n        }\n    ```\n\n* [@PathVariable](https://blog.csdn.net/qq_29115715/article/details/80090403)\n    * 可以将 **URL中占位符参数**绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。\n    > `https://www.note.ink/username/2`\n    ```java\n        @RequestMapping(\"/{id}\")\n        public ModelAndView show(@PathVariable(\"id\") Integer id) {\n            ModelAndView mav = new ModelAndView();\n            mav.addObject(\"id\", id);\n            mav.setViewName(\"blog\");\n            return mav;\n        }\n\n    ```\n* @MatrixVariable： 用于获取复杂URI\n\n\n\n* @Autowired 和 @Resource\n    >@Autowired默认按照**byType**方式进行bean匹配，@Resource默认按照**byName**方式进行bean匹配\n\n    >@Autowired是Spring的注解，@Resource是J2EE的注解，根据导入注解的包名就可以知道。\n\n    >Spring属于第三方的，J2EE是Java自己的东西。因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。\n\n* @Service\n    * service标注**业务层组件**,这个注解是写在类上面的，标注将这个类交给Spring容器管理，spring容器要为他创建对象\n\n* @Scope 用来定义Bean的作用域 \n    * singleton： 全局有且仅有一个实例\n    * prototype： 每次获取时都会有一个新的实例\n    * request：针对每一次HTTP请求都会产生一个新的Bean\n    * session：针对每一次HTTP请求都会产生一个新的Bean，但该Bean只在当前HTTP session中有效\n    * global session：与session类似，不过它仅仅只在基于Porlet的Web应用中才有效 \n    > JSR 330标准中默认Bean的作用域**默认为singleton**\n\n### 1.2 Spring Boot注解\n* @Value\n    * 注入Spring Boot配置的文件application.properties中配置的属性值\n\n* @ConfigurationProperties(prefix=\"server\")\n    * 获取配置文件中内容，prefix为其前缀，例如获取serverProperties.properties中内容，prefix为server\n\n* @PropertySource(\"classpath:serverProperties.properties\")\n    * 加载配置类\n\n### 1.3 JPA注解\n* @Entity\n    * 表明被标注的类是一个实体类\n\n* @Table\n    * 指出实体类对应的表名\n* @Id\n    * 声明实体类对应的属性映射为数据库的主键列\n* @GenerateValue\n    * 用于标注主键的生成策略\n        * `@GeneratedValue(strategy = GenerationType.IDENTITY)` 自增\n        * `@GeneratedValue(strategy = GenerationType.SEQUENCE)` 通过序列产生主键\n        * `@GeneratedValue(strategy = GenerationType.AUTO)` 自动选择主键生成策略，以适应不同的数据库移植。\n* [@Column](https://www.cnblogs.com/lovetl/p/11685843.html)\n    * 属性\n        * name属性定义了被标注字段在数据库表中所对应字段的名称；\n        * unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。\n        * nullable属性表示该字段是否可以为null值，默认为true。\n        * insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。\n        * updatable属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。\n        * columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。（也就是说，如果DB中表已经建好，该属性没有必要使用。）\n        * table属性定义了包含当前字段的表名。\n        * length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。\n        * precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。\n\n* @Modifying\n    * 在@Query注解中编写JPQL实现DELETE和UPDATE操作的时候必须加上@modifying注解，以通知Spring Data 这是一个DELETE或UPDATE操作。\n    * UPDATE或者DELETE操作需要使用事务，此时需要 定义Service层，在Service层的方法上添加事务操作。\n    * 注意JPQL不支持INSERT操作。　\n    * ~<https://www.cnblogs.com/zhaobingqing/p/6864223.html>~    \n\n\n## 二、开发起步\n### 2.1 自定义配置类\n当要配置的自定义属性比较多时，可以考虑自定义一个配置类。    \n* 在`src/main/resources`目录下定义配置文件\n```\nserver.port=8888\nserver.servlet.context-path=/demo\n```\n* 编写自定义配置类\n```java\n@Component\n@PropertySource(\"classpath:serverProperties.properties\")\npublic class ServerProperties {\n    @Value(\"${server.port}\")\n    private String port;\n    @Value(\"${server.servlet.context-path}\")\n    private String contextPath;\n\n    public String getContextPath() {\n        return contextPath;\n    }\n\n    public void setContextPath(String contextPath) {\n        this.contextPath = contextPath;\n    }\n\n    public String getPort() {\n        return port;\n    }\n\n    public void setPort(String port) {\n        this.port = port;\n    }\n\n}\n```\n\n\n\n\n\n\n\n\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n>参考：    \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<https://blog.csdn.net/qq_41973208/article/details/85008962> <br>\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<https://www.cnblogs.com/lovetl/p/11685843.html><br>\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<https://www.cnblogs.com/zhaobingqing/p/6864223.html><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;吴胜.Spring Boot开发实战. 北京: 清华大学出版社, 2019.\n\n\n","source":"_posts/code/JavaWeb/SpringBoot基础.md","raw":"---\ntitle: SpringBoot基础\ncategories: Code\ntags: JavaWeb\n# photos:\n#   - - 'https://i.loli.net/2020/04/26/WT5Mgd6G2h1Fefa.png'\nabbrlink: 25912\ndata: 2020-04-22 02:40:10\ndeclare: true\nwordCount: true\n---\nSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。\n<!-- more -->\n\n\n\n## 一、注解\n### 1.1 Spring注解\n* @GetMapping、@PostMapping和@RequestMapping的区别\n    * @GetMapping\n        >用于将HTTP GET请求映射到特定处理程序方法的注释。具体来说，@GetMapping是一个作为快捷方式的组合注释@RequestMapping(method = RequestMethod.GET)。\n\n    * @PostMapping\n        >用于将HTTP POST请求映射到特定处理程序方法的注释。具体来说，@PostMapping是一个作为快捷方式的组合注释@RequestMapping(method = RequestMethod.POST)。\n\n    * @RequestMapping\n        >一般情况下都是用@RequestMapping（method=RequestMethod.），因为@**RequestMapping可以直接替代以上两个注解**，但是以上两个注解并不能替代@RequestMapping，@RequestMapping相当于以上两个注解的父类！ （找到相应的控制器）\n* @RestController\n    * @Controller和@ResponseBody的合集，表示被标记的对象是REST风格的Bean\n    * 返回结果默认为字符串\n        \n* @Controller \n    * 返回结果默认为视图。负责处理由DispatcherServlet分发的请求，将用户的请求经过业务层处理之后封装成一个Mode,然后将该model递交给相应的视图层，最后返回视图层。\n\n* @ResponseBody      \n    * 将内容或Java对象转换成响应报文的正文返回 \n    * 修改了Controller的返回要求，返回结果为字符串\n\n* @RequestBody\n    * 用于**接收前端传给后端的一些非HTML页面的其他格式数据（例如XML、JSON）**，是利用将请求报文中的正文自动转换为绑定给方法参数的变量字符串，而Get方法无请求体，前端不能使用Get方法提交而需要使用Post方法提交\n    \n* [@RequestParam](https://www.cnblogs.com/tomingto/p/11377138.html) 将请求中的值赋给被注解的方法参数\n    > `https://www.notecc.ink/username?q=123`\n    ```java\n        @RequestMapping(\"query\")\n        public ModelAndView query(@RequestParam(value = \"q\", required = false, defaultValue = \"1234567\") String q) {\n            ModelAndView mav = new ModelAndView();\n            mav.addObject(\"q\", q);\n            mav.setViewName(\"blogQuery\");\n            return mav;\n        }\n\n        @RequestMapping(\"/returnView\")\n        public String hello(@RequestParam String name, Model model){\n            model.addAttribute(\"name\",name);\n            return \"hello\";\n        }\n    ```\n\n* [@PathVariable](https://blog.csdn.net/qq_29115715/article/details/80090403)\n    * 可以将 **URL中占位符参数**绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。\n    > `https://www.note.ink/username/2`\n    ```java\n        @RequestMapping(\"/{id}\")\n        public ModelAndView show(@PathVariable(\"id\") Integer id) {\n            ModelAndView mav = new ModelAndView();\n            mav.addObject(\"id\", id);\n            mav.setViewName(\"blog\");\n            return mav;\n        }\n\n    ```\n* @MatrixVariable： 用于获取复杂URI\n\n\n\n* @Autowired 和 @Resource\n    >@Autowired默认按照**byType**方式进行bean匹配，@Resource默认按照**byName**方式进行bean匹配\n\n    >@Autowired是Spring的注解，@Resource是J2EE的注解，根据导入注解的包名就可以知道。\n\n    >Spring属于第三方的，J2EE是Java自己的东西。因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。\n\n* @Service\n    * service标注**业务层组件**,这个注解是写在类上面的，标注将这个类交给Spring容器管理，spring容器要为他创建对象\n\n* @Scope 用来定义Bean的作用域 \n    * singleton： 全局有且仅有一个实例\n    * prototype： 每次获取时都会有一个新的实例\n    * request：针对每一次HTTP请求都会产生一个新的Bean\n    * session：针对每一次HTTP请求都会产生一个新的Bean，但该Bean只在当前HTTP session中有效\n    * global session：与session类似，不过它仅仅只在基于Porlet的Web应用中才有效 \n    > JSR 330标准中默认Bean的作用域**默认为singleton**\n\n### 1.2 Spring Boot注解\n* @Value\n    * 注入Spring Boot配置的文件application.properties中配置的属性值\n\n* @ConfigurationProperties(prefix=\"server\")\n    * 获取配置文件中内容，prefix为其前缀，例如获取serverProperties.properties中内容，prefix为server\n\n* @PropertySource(\"classpath:serverProperties.properties\")\n    * 加载配置类\n\n### 1.3 JPA注解\n* @Entity\n    * 表明被标注的类是一个实体类\n\n* @Table\n    * 指出实体类对应的表名\n* @Id\n    * 声明实体类对应的属性映射为数据库的主键列\n* @GenerateValue\n    * 用于标注主键的生成策略\n        * `@GeneratedValue(strategy = GenerationType.IDENTITY)` 自增\n        * `@GeneratedValue(strategy = GenerationType.SEQUENCE)` 通过序列产生主键\n        * `@GeneratedValue(strategy = GenerationType.AUTO)` 自动选择主键生成策略，以适应不同的数据库移植。\n* [@Column](https://www.cnblogs.com/lovetl/p/11685843.html)\n    * 属性\n        * name属性定义了被标注字段在数据库表中所对应字段的名称；\n        * unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。\n        * nullable属性表示该字段是否可以为null值，默认为true。\n        * insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。\n        * updatable属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。\n        * columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。（也就是说，如果DB中表已经建好，该属性没有必要使用。）\n        * table属性定义了包含当前字段的表名。\n        * length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。\n        * precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。\n\n* @Modifying\n    * 在@Query注解中编写JPQL实现DELETE和UPDATE操作的时候必须加上@modifying注解，以通知Spring Data 这是一个DELETE或UPDATE操作。\n    * UPDATE或者DELETE操作需要使用事务，此时需要 定义Service层，在Service层的方法上添加事务操作。\n    * 注意JPQL不支持INSERT操作。　\n    * ~<https://www.cnblogs.com/zhaobingqing/p/6864223.html>~    \n\n\n## 二、开发起步\n### 2.1 自定义配置类\n当要配置的自定义属性比较多时，可以考虑自定义一个配置类。    \n* 在`src/main/resources`目录下定义配置文件\n```\nserver.port=8888\nserver.servlet.context-path=/demo\n```\n* 编写自定义配置类\n```java\n@Component\n@PropertySource(\"classpath:serverProperties.properties\")\npublic class ServerProperties {\n    @Value(\"${server.port}\")\n    private String port;\n    @Value(\"${server.servlet.context-path}\")\n    private String contextPath;\n\n    public String getContextPath() {\n        return contextPath;\n    }\n\n    public void setContextPath(String contextPath) {\n        this.contextPath = contextPath;\n    }\n\n    public String getPort() {\n        return port;\n    }\n\n    public void setPort(String port) {\n        this.port = port;\n    }\n\n}\n```\n\n\n\n\n\n\n\n\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n>参考：    \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<https://blog.csdn.net/qq_41973208/article/details/85008962> <br>\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<https://www.cnblogs.com/lovetl/p/11685843.html><br>\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<https://www.cnblogs.com/zhaobingqing/p/6864223.html><br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;吴胜.Spring Boot开发实战. 北京: 清华大学出版社, 2019.\n\n\n","slug":"code/JavaWeb/SpringBoot基础","published":1,"date":"2021-08-09T10:06:58.830Z","updated":"2021-03-13T02:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gq005l0w7tfios906p","content":"<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p>\n<a id=\"more\"></a>\n\n\n\n<h2 id=\"一、注解\"><a href=\"#一、注解\" class=\"headerlink\" title=\"一、注解\"></a>一、注解</h2><h3 id=\"1-1-Spring注解\"><a href=\"#1-1-Spring注解\" class=\"headerlink\" title=\"1.1 Spring注解\"></a>1.1 Spring注解</h3><ul>\n<li><p>@GetMapping、@PostMapping和@RequestMapping的区别</p>\n<ul>\n<li><p>@GetMapping</p>\n<blockquote>\n<p>用于将HTTP GET请求映射到特定处理程序方法的注释。具体来说，@GetMapping是一个作为快捷方式的组合注释@RequestMapping(method = RequestMethod.GET)。</p>\n</blockquote>\n</li>\n<li><p>@PostMapping</p>\n<blockquote>\n<p>用于将HTTP POST请求映射到特定处理程序方法的注释。具体来说，@PostMapping是一个作为快捷方式的组合注释@RequestMapping(method = RequestMethod.POST)。</p>\n</blockquote>\n</li>\n<li><p>@RequestMapping</p>\n<blockquote>\n<p>一般情况下都是用@RequestMapping（method=RequestMethod.），因为@<strong>RequestMapping可以直接替代以上两个注解</strong>，但是以上两个注解并不能替代@RequestMapping，@RequestMapping相当于以上两个注解的父类！ （找到相应的控制器）</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>@RestController</p>\n<ul>\n<li>@Controller和@ResponseBody的合集，表示被标记的对象是REST风格的Bean</li>\n<li>返回结果默认为字符串</li>\n</ul>\n</li>\n<li><p>@Controller </p>\n<ul>\n<li>返回结果默认为视图。负责处理由DispatcherServlet分发的请求，将用户的请求经过业务层处理之后封装成一个Mode,然后将该model递交给相应的视图层，最后返回视图层。</li>\n</ul>\n</li>\n<li><p>@ResponseBody      </p>\n<ul>\n<li>将内容或Java对象转换成响应报文的正文返回 </li>\n<li>修改了Controller的返回要求，返回结果为字符串</li>\n</ul>\n</li>\n<li><p>@RequestBody</p>\n<ul>\n<li>用于<strong>接收前端传给后端的一些非HTML页面的其他格式数据（例如XML、JSON）</strong>，是利用将请求报文中的正文自动转换为绑定给方法参数的变量字符串，而Get方法无请求体，前端不能使用Get方法提交而需要使用Post方法提交</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/tomingto/p/11377138.html\" target=\"_blank\" rel=\"noopener\">@RequestParam</a> 将请求中的值赋给被注解的方法参数</p>\n<blockquote>\n<p><code>https://www.notecc.ink/username?q=123</code></p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\">      <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"query\"</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">public</span> ModelAndView <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestParam</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"q\"</span><span class=\"token punctuation\">,</span> required <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> defaultValue <span class=\"token operator\">=</span> <span class=\"token string\">\"1234567\"</span><span class=\"token punctuation\">)</span> String q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          ModelAndView mav <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ModelAndView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          mav<span class=\"token punctuation\">.</span><span class=\"token function\">addObject</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"q\"</span><span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          mav<span class=\"token punctuation\">.</span><span class=\"token function\">setViewName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"blogQuery\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">return</span> mav<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/returnView\"</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">public</span> String <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestParam</span> String name<span class=\"token punctuation\">,</span> Model model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          model<span class=\"token punctuation\">.</span><span class=\"token function\">addAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">return</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_29115715/article/details/80090403\" target=\"_blank\" rel=\"noopener\">@PathVariable</a></p>\n<ul>\n<li><p>可以将 <strong>URL中占位符参数</strong>绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。</p>\n<blockquote>\n<p><code>https://www.note.ink/username/2</code></p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/{id}\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">public</span> ModelAndView <span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@PathVariable</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span> Integer id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      ModelAndView mav <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ModelAndView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      mav<span class=\"token punctuation\">.</span><span class=\"token function\">addObject</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">,</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      mav<span class=\"token punctuation\">.</span><span class=\"token function\">setViewName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"blog\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> mav<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>@MatrixVariable： 用于获取复杂URI</p>\n</li>\n</ul>\n<ul>\n<li><p>@Autowired 和 @Resource</p>\n<blockquote>\n<p>@Autowired默认按照<strong>byType</strong>方式进行bean匹配，@Resource默认按照<strong>byName</strong>方式进行bean匹配</p>\n</blockquote>\n<blockquote>\n<p>@Autowired是Spring的注解，@Resource是J2EE的注解，根据导入注解的包名就可以知道。</p>\n</blockquote>\n<blockquote>\n<p>Spring属于第三方的，J2EE是Java自己的东西。因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。</p>\n</blockquote>\n</li>\n<li><p>@Service</p>\n<ul>\n<li>service标注<strong>业务层组件</strong>,这个注解是写在类上面的，标注将这个类交给Spring容器管理，spring容器要为他创建对象</li>\n</ul>\n</li>\n<li><p>@Scope 用来定义Bean的作用域 </p>\n<ul>\n<li>singleton： 全局有且仅有一个实例</li>\n<li>prototype： 每次获取时都会有一个新的实例</li>\n<li>request：针对每一次HTTP请求都会产生一个新的Bean</li>\n<li>session：针对每一次HTTP请求都会产生一个新的Bean，但该Bean只在当前HTTP session中有效</li>\n<li>global session：与session类似，不过它仅仅只在基于Porlet的Web应用中才有效 <blockquote>\n<p>JSR 330标准中默认Bean的作用域<strong>默认为singleton</strong></p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-Spring-Boot注解\"><a href=\"#1-2-Spring-Boot注解\" class=\"headerlink\" title=\"1.2 Spring Boot注解\"></a>1.2 Spring Boot注解</h3><ul>\n<li><p>@Value</p>\n<ul>\n<li>注入Spring Boot配置的文件application.properties中配置的属性值</li>\n</ul>\n</li>\n<li><p>@ConfigurationProperties(prefix=”server”)</p>\n<ul>\n<li>获取配置文件中内容，prefix为其前缀，例如获取serverProperties.properties中内容，prefix为server</li>\n</ul>\n</li>\n<li><p>@PropertySource(“classpath:serverProperties.properties”)</p>\n<ul>\n<li>加载配置类</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-JPA注解\"><a href=\"#1-3-JPA注解\" class=\"headerlink\" title=\"1.3 JPA注解\"></a>1.3 JPA注解</h3><ul>\n<li><p>@Entity</p>\n<ul>\n<li>表明被标注的类是一个实体类</li>\n</ul>\n</li>\n<li><p>@Table</p>\n<ul>\n<li>指出实体类对应的表名</li>\n</ul>\n</li>\n<li><p>@Id</p>\n<ul>\n<li>声明实体类对应的属性映射为数据库的主键列</li>\n</ul>\n</li>\n<li><p>@GenerateValue</p>\n<ul>\n<li>用于标注主键的生成策略<ul>\n<li><code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code> 自增</li>\n<li><code>@GeneratedValue(strategy = GenerationType.SEQUENCE)</code> 通过序列产生主键</li>\n<li><code>@GeneratedValue(strategy = GenerationType.AUTO)</code> 自动选择主键生成策略，以适应不同的数据库移植。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lovetl/p/11685843.html\" target=\"_blank\" rel=\"noopener\">@Column</a></p>\n<ul>\n<li>属性<ul>\n<li>name属性定义了被标注字段在数据库表中所对应字段的名称；</li>\n<li>unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。</li>\n<li>nullable属性表示该字段是否可以为null值，默认为true。</li>\n<li>insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。</li>\n<li>updatable属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。</li>\n<li>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。（也就是说，如果DB中表已经建好，该属性没有必要使用。）</li>\n<li>table属性定义了包含当前字段的表名。</li>\n<li>length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。</li>\n<li>precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>@Modifying</p>\n<ul>\n<li>在@Query注解中编写JPQL实现DELETE和UPDATE操作的时候必须加上@modifying注解，以通知Spring Data 这是一个DELETE或UPDATE操作。</li>\n<li>UPDATE或者DELETE操作需要使用事务，此时需要 定义Service层，在Service层的方法上添加事务操作。</li>\n<li>注意JPQL不支持INSERT操作。　</li>\n<li><del><a href=\"https://www.cnblogs.com/zhaobingqing/p/6864223.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhaobingqing/p/6864223.html</a></del>    </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、开发起步\"><a href=\"#二、开发起步\" class=\"headerlink\" title=\"二、开发起步\"></a>二、开发起步</h2><h3 id=\"2-1-自定义配置类\"><a href=\"#2-1-自定义配置类\" class=\"headerlink\" title=\"2.1 自定义配置类\"></a>2.1 自定义配置类</h3><p>当要配置的自定义属性比较多时，可以考虑自定义一个配置类。    </p>\n<ul>\n<li><p>在<code>src/main/resources</code>目录下定义配置文件</p>\n<pre><code>server.port=8888\nserver.servlet.context-path=/demo</code></pre></li>\n<li><p>编写自定义配置类</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token annotation punctuation\">@PropertySource</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"classpath:serverProperties.properties\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ServerProperties</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token annotation punctuation\">@Value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"${server.port}\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">private</span> String port<span class=\"token punctuation\">;</span>\n  <span class=\"token annotation punctuation\">@Value</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"${server.servlet.context-path}\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">private</span> String contextPath<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> String <span class=\"token function\">getContextPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> contextPath<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setContextPath</span><span class=\"token punctuation\">(</span>String contextPath<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>contextPath <span class=\"token operator\">=</span> contextPath<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> String <span class=\"token function\">getPort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> port<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setPort</span><span class=\"token punctuation\">(</span>String port<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>port <span class=\"token operator\">=</span> port<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n</ul>\n<p>}</p>\n<pre><code>\n\n\n\n\n\n\n\n\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n\n&gt;参考：    \n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;https://blog.csdn.net/qq_41973208/article/details/85008962&gt; &lt;br&gt;\n&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;https://www.cnblogs.com/lovetl/p/11685843.html&gt;&lt;br&gt;\n&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;https://www.cnblogs.com/zhaobingqing/p/6864223.html&gt;&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;吴胜.Spring Boot开发实战. 北京: 清华大学出版社, 2019.\n\n</code></pre>","site":{"data":{}},"excerpt":"<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p>","more":"<h2 id=\"一、注解\"><a href=\"#一、注解\" class=\"headerlink\" title=\"一、注解\"></a>一、注解</h2><h3 id=\"1-1-Spring注解\"><a href=\"#1-1-Spring注解\" class=\"headerlink\" title=\"1.1 Spring注解\"></a>1.1 Spring注解</h3><ul>\n<li><p>@GetMapping、@PostMapping和@RequestMapping的区别</p>\n<ul>\n<li><p>@GetMapping</p>\n<blockquote>\n<p>用于将HTTP GET请求映射到特定处理程序方法的注释。具体来说，@GetMapping是一个作为快捷方式的组合注释@RequestMapping(method = RequestMethod.GET)。</p>\n</blockquote>\n</li>\n<li><p>@PostMapping</p>\n<blockquote>\n<p>用于将HTTP POST请求映射到特定处理程序方法的注释。具体来说，@PostMapping是一个作为快捷方式的组合注释@RequestMapping(method = RequestMethod.POST)。</p>\n</blockquote>\n</li>\n<li><p>@RequestMapping</p>\n<blockquote>\n<p>一般情况下都是用@RequestMapping（method=RequestMethod.），因为@<strong>RequestMapping可以直接替代以上两个注解</strong>，但是以上两个注解并不能替代@RequestMapping，@RequestMapping相当于以上两个注解的父类！ （找到相应的控制器）</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>@RestController</p>\n<ul>\n<li>@Controller和@ResponseBody的合集，表示被标记的对象是REST风格的Bean</li>\n<li>返回结果默认为字符串</li>\n</ul>\n</li>\n<li><p>@Controller </p>\n<ul>\n<li>返回结果默认为视图。负责处理由DispatcherServlet分发的请求，将用户的请求经过业务层处理之后封装成一个Mode,然后将该model递交给相应的视图层，最后返回视图层。</li>\n</ul>\n</li>\n<li><p>@ResponseBody      </p>\n<ul>\n<li>将内容或Java对象转换成响应报文的正文返回 </li>\n<li>修改了Controller的返回要求，返回结果为字符串</li>\n</ul>\n</li>\n<li><p>@RequestBody</p>\n<ul>\n<li>用于<strong>接收前端传给后端的一些非HTML页面的其他格式数据（例如XML、JSON）</strong>，是利用将请求报文中的正文自动转换为绑定给方法参数的变量字符串，而Get方法无请求体，前端不能使用Get方法提交而需要使用Post方法提交</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/tomingto/p/11377138.html\" target=\"_blank\" rel=\"noopener\">@RequestParam</a> 将请求中的值赋给被注解的方法参数</p>\n<blockquote>\n<p><code>https://www.notecc.ink/username?q=123</code></p>\n</blockquote>\n<pre><code class=\"java\">      @RequestMapping(&quot;query&quot;)\n      public ModelAndView query(@RequestParam(value = &quot;q&quot;, required = false, defaultValue = &quot;1234567&quot;) String q) {\n          ModelAndView mav = new ModelAndView();\n          mav.addObject(&quot;q&quot;, q);\n          mav.setViewName(&quot;blogQuery&quot;);\n          return mav;\n      }\n\n      @RequestMapping(&quot;/returnView&quot;)\n      public String hello(@RequestParam String name, Model model){\n          model.addAttribute(&quot;name&quot;,name);\n          return &quot;hello&quot;;\n      }</code></pre>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_29115715/article/details/80090403\" target=\"_blank\" rel=\"noopener\">@PathVariable</a></p>\n<ul>\n<li><p>可以将 <strong>URL中占位符参数</strong>绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。</p>\n<blockquote>\n<p><code>https://www.note.ink/username/2</code></p>\n</blockquote>\n<pre><code class=\"java\">  @RequestMapping(&quot;/{id}&quot;)\n  public ModelAndView show(@PathVariable(&quot;id&quot;) Integer id) {\n      ModelAndView mav = new ModelAndView();\n      mav.addObject(&quot;id&quot;, id);\n      mav.setViewName(&quot;blog&quot;);\n      return mav;\n  }\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>@MatrixVariable： 用于获取复杂URI</p>\n</li>\n</ul>\n<ul>\n<li><p>@Autowired 和 @Resource</p>\n<blockquote>\n<p>@Autowired默认按照<strong>byType</strong>方式进行bean匹配，@Resource默认按照<strong>byName</strong>方式进行bean匹配</p>\n</blockquote>\n<blockquote>\n<p>@Autowired是Spring的注解，@Resource是J2EE的注解，根据导入注解的包名就可以知道。</p>\n</blockquote>\n<blockquote>\n<p>Spring属于第三方的，J2EE是Java自己的东西。因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。</p>\n</blockquote>\n</li>\n<li><p>@Service</p>\n<ul>\n<li>service标注<strong>业务层组件</strong>,这个注解是写在类上面的，标注将这个类交给Spring容器管理，spring容器要为他创建对象</li>\n</ul>\n</li>\n<li><p>@Scope 用来定义Bean的作用域 </p>\n<ul>\n<li>singleton： 全局有且仅有一个实例</li>\n<li>prototype： 每次获取时都会有一个新的实例</li>\n<li>request：针对每一次HTTP请求都会产生一个新的Bean</li>\n<li>session：针对每一次HTTP请求都会产生一个新的Bean，但该Bean只在当前HTTP session中有效</li>\n<li>global session：与session类似，不过它仅仅只在基于Porlet的Web应用中才有效 <blockquote>\n<p>JSR 330标准中默认Bean的作用域<strong>默认为singleton</strong></p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-Spring-Boot注解\"><a href=\"#1-2-Spring-Boot注解\" class=\"headerlink\" title=\"1.2 Spring Boot注解\"></a>1.2 Spring Boot注解</h3><ul>\n<li><p>@Value</p>\n<ul>\n<li>注入Spring Boot配置的文件application.properties中配置的属性值</li>\n</ul>\n</li>\n<li><p>@ConfigurationProperties(prefix=”server”)</p>\n<ul>\n<li>获取配置文件中内容，prefix为其前缀，例如获取serverProperties.properties中内容，prefix为server</li>\n</ul>\n</li>\n<li><p>@PropertySource(“classpath:serverProperties.properties”)</p>\n<ul>\n<li>加载配置类</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-3-JPA注解\"><a href=\"#1-3-JPA注解\" class=\"headerlink\" title=\"1.3 JPA注解\"></a>1.3 JPA注解</h3><ul>\n<li><p>@Entity</p>\n<ul>\n<li>表明被标注的类是一个实体类</li>\n</ul>\n</li>\n<li><p>@Table</p>\n<ul>\n<li>指出实体类对应的表名</li>\n</ul>\n</li>\n<li><p>@Id</p>\n<ul>\n<li>声明实体类对应的属性映射为数据库的主键列</li>\n</ul>\n</li>\n<li><p>@GenerateValue</p>\n<ul>\n<li>用于标注主键的生成策略<ul>\n<li><code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code> 自增</li>\n<li><code>@GeneratedValue(strategy = GenerationType.SEQUENCE)</code> 通过序列产生主键</li>\n<li><code>@GeneratedValue(strategy = GenerationType.AUTO)</code> 自动选择主键生成策略，以适应不同的数据库移植。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lovetl/p/11685843.html\" target=\"_blank\" rel=\"noopener\">@Column</a></p>\n<ul>\n<li>属性<ul>\n<li>name属性定义了被标注字段在数据库表中所对应字段的名称；</li>\n<li>unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。</li>\n<li>nullable属性表示该字段是否可以为null值，默认为true。</li>\n<li>insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。</li>\n<li>updatable属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。</li>\n<li>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。（也就是说，如果DB中表已经建好，该属性没有必要使用。）</li>\n<li>table属性定义了包含当前字段的表名。</li>\n<li>length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。</li>\n<li>precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>@Modifying</p>\n<ul>\n<li>在@Query注解中编写JPQL实现DELETE和UPDATE操作的时候必须加上@modifying注解，以通知Spring Data 这是一个DELETE或UPDATE操作。</li>\n<li>UPDATE或者DELETE操作需要使用事务，此时需要 定义Service层，在Service层的方法上添加事务操作。</li>\n<li>注意JPQL不支持INSERT操作。　</li>\n<li><del><a href=\"https://www.cnblogs.com/zhaobingqing/p/6864223.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhaobingqing/p/6864223.html</a></del>    </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、开发起步\"><a href=\"#二、开发起步\" class=\"headerlink\" title=\"二、开发起步\"></a>二、开发起步</h2><h3 id=\"2-1-自定义配置类\"><a href=\"#2-1-自定义配置类\" class=\"headerlink\" title=\"2.1 自定义配置类\"></a>2.1 自定义配置类</h3><p>当要配置的自定义属性比较多时，可以考虑自定义一个配置类。    </p>\n<ul>\n<li><p>在<code>src/main/resources</code>目录下定义配置文件</p>\n<pre><code>server.port=8888\nserver.servlet.context-path=/demo</code></pre></li>\n<li><p>编写自定义配置类</p>\n<pre><code class=\"java\">@Component\n@PropertySource(&quot;classpath:serverProperties.properties&quot;)\npublic class ServerProperties {\n  @Value(&quot;${server.port}&quot;)\n  private String port;\n  @Value(&quot;${server.servlet.context-path}&quot;)\n  private String contextPath;\n\n  public String getContextPath() {\n      return contextPath;\n  }\n\n  public void setContextPath(String contextPath) {\n      this.contextPath = contextPath;\n  }\n\n  public String getPort() {\n      return port;\n  }\n\n  public void setPort(String port) {\n      this.port = port;\n  }\n</code></pre>\n</li>\n</ul>\n<p>}</p>\n<pre><code>\n\n\n\n\n\n\n\n\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\n\n&gt;参考：    \n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;https://blog.csdn.net/qq_41973208/article/details/85008962&gt; &lt;br&gt;\n&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;https://www.cnblogs.com/lovetl/p/11685843.html&gt;&lt;br&gt;\n&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;https://www.cnblogs.com/zhaobingqing/p/6864223.html&gt;&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;吴胜.Spring Boot开发实战. 北京: 清华大学出版社, 2019.\n\n</code></pre>"},{"title":"【转载】BlockingQueue","declare":false,"wordCount":true,"abbrlink":"fe3b56f6","date":"2020-11-22T17:04:33.000Z","_content":"> 原文链接 https://www.iteye.com/blog/wsmajunfeng-1629354\n\n\n* 前言：\n    \n    在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。\n\n<!-- more -->\n\n* 认识BlockingQueue\n\n    阻塞队列，顾名思义，首先它是一个队列，而一个队列在数据结构中所起的作用大致如下图所示：\n\n    <div align = \"center\">\n        <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414472791.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n    </div>\n\n    从上图我们可以很清楚看到，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；\n\n    常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue就是其中的一种）     \n\n    先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种\n    程度上来说这种队列也体现了一种公平性。<br><br>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。\n\n    多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）<br><br>下面两幅图演示了BlockingQueue的两个常见阻塞场景：\n    <div align = \"center\">\n        <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414442194.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n    </div>\n\n    如上图所示：当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。\n\n    <div align = \"center\">\n        <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414451925.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n    </div>\n    如上图所示：当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。 \n\n    这也是我们在多线程环境下，为什么需要BlockingQueue的原因。作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。既然BlockingQueue如此神通广大，让我们一起来见识下它的常用方法：\n\n    * BlockingQueue的核心方法：\n\n        **放入数据**：\n        \n        `offer(anObject)`:表示如果可能的话,将anObject加到BlockingQueue里,即**如果BlockingQueue可以容纳,则返回true,否则返回false**.（本方法不阻塞当前执行方法的线程）\n        \n        `offer(E o, long timeout, TimeUnit unit)`,**可以设定等待的时间**，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。\n\n        `put(anObject)`:把an Object加到BlockingQueue里,**如果BlockQueue没有空间,则调用此方法的线程被阻断,直到BlockingQueue里面有空间再继续**.\n\n        **获取数据**：\n        poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;\n        \n        `poll(long timeout, TimeUnit unit)`：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。\n        \n        `take()`:**取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入**; \n        \n        `drainTo()`:一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数）， 通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。\n\n    * 常见BlockingQueue\n        <div align = \"center\">\n            <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112416335973.jpg\" alt=\"BlockingQueue家族成员\" />\n        </div>\n\n    * BlockingQueue成员详细介绍\n\n        1. ArrayBlockingQueue<br><br>\n            基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。<br><br>\n            ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。\n\n        2. LinkedBlockingQueue<br><br>\n        基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br><br>\n        作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。<br><br>ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。<br><br>\n\n        3. DelayQueue<br><br>\n        DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br>\n        使用场景：<br>\n        DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。\n\n        4. PriorityBlockingQueue<br><br>\n            基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。\n\n        5. SynchronousQueue<br><br>\n        一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。<br><br>\n        声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:<br>\n        如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；<br>\n        但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。\n\n    * 小结   \n        BlockingQueue不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，他还自动管理了多线间的自动等待于唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能。 \n\n***\n<br>\n下面的代码演示了如何使用BlockingQueue：\n\n```java\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\n \n/**\n * @author jackyuj\n */\npublic class BlockingQueueTest {\n \n    public static void main(String[] args) throws InterruptedException {\n        // 声明一个容量为10的缓存队列\n        BlockingQueue<String> queue = new LinkedBlockingQueue<String>(10);\n \n        Producer producer1 = new Producer(queue);\n        Producer producer2 = new Producer(queue);\n        Producer producer3 = new Producer(queue);\n        Consumer consumer = new Consumer(queue);\n \n        // 借助Executors\n        ExecutorService service = Executors.newCachedThreadPool();\n        // 启动线程\n        service.execute(producer1);\n        service.execute(producer2);\n        service.execute(producer3);\n        service.execute(consumer);\n \n        // 执行10s\n        Thread.sleep(10 * 1000);\n        producer1.stop();\n        producer2.stop();\n        producer3.stop();\n \n        Thread.sleep(2000);\n        // 退出Executor\n        service.shutdown();\n    }\n}\n\n```\n\n```java\n\nimport java.util.Random;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\n \n/**\n * 消费者线程\n * \n * @author jackyuj\n */\npublic class Consumer implements Runnable {\n \n    public Consumer(BlockingQueue<String> queue) {\n        this.queue = queue;\n    }\n \n    public void run() {\n        System.out.println(\"启动消费者线程！\");\n        Random r = new Random();\n        boolean isRunning = true;\n        try {\n            while (isRunning) {\n                System.out.println(\"正从队列获取数据...\");\n                String data = queue.poll(2, TimeUnit.SECONDS);\n                if (null != data) {\n                    System.out.println(\"拿到数据：\" + data);\n                    System.out.println(\"正在消费数据：\" + data);\n                    Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));\n                } else {\n                    // 超过2s还没数据，认为所有生产线程都已经退出，自动退出消费线程。\n                    isRunning = false;\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            Thread.currentThread().interrupt();\n        } finally {\n            System.out.println(\"退出消费者线程！\");\n        }\n    }\n \n    private BlockingQueue<String> queue;\n    private static final int      DEFAULT_RANGE_FOR_SLEEP = 1000;\n}\n \nimport java.util.Random;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n \n/**\n * 生产者线程\n * \n * @author jackyuj\n */\npublic class Producer implements Runnable {\n \n    public Producer(BlockingQueue queue) {\n        this.queue = queue;\n    }\n \n    public void run() {\n        String data = null;\n        Random r = new Random();\n \n        System.out.println(\"启动生产者线程！\");\n        try {\n            while (isRunning) {\n                System.out.println(\"正在生产数据...\");\n                Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));\n \n                data = \"data:\" + count.incrementAndGet();\n                System.out.println(\"将数据：\" + data + \"放入队列...\");\n                if (!queue.offer(data, 2, TimeUnit.SECONDS)) {\n                    System.out.println(\"放入数据失败：\" + data);\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            Thread.currentThread().interrupt();\n        } finally {\n            System.out.println(\"退出生产者线程！\");\n        }\n    }\n \n    public void stop() {\n        isRunning = false;\n    }\n \n    private volatile boolean      isRunning               = true;\n    private BlockingQueue queue;\n    private static AtomicInteger  count                   = new AtomicInteger();\n    private static final int      DEFAULT_RANGE_FOR_SLEEP = 1000;\n \n}\n\n```\n\n\n\n\n\n\n    \n\n\n\n\n\n\n","source":"_posts/code/Multi-Thread/【转载】BlockingQueue.md","raw":"---\ntitle: 【转载】BlockingQueue\ncategories: Code\ntags: Multi-Thread\ndeclare: false\nwordCount: true\nabbrlink: fe3b56f6\ndate: 2020-11-23 01:04:33\n---\n> 原文链接 https://www.iteye.com/blog/wsmajunfeng-1629354\n\n\n* 前言：\n    \n    在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。\n\n<!-- more -->\n\n* 认识BlockingQueue\n\n    阻塞队列，顾名思义，首先它是一个队列，而一个队列在数据结构中所起的作用大致如下图所示：\n\n    <div align = \"center\">\n        <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414472791.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n    </div>\n\n    从上图我们可以很清楚看到，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；\n\n    常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue就是其中的一种）     \n\n    先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种\n    程度上来说这种队列也体现了一种公平性。<br><br>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。\n\n    多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）<br><br>下面两幅图演示了BlockingQueue的两个常见阻塞场景：\n    <div align = \"center\">\n        <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414442194.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n    </div>\n\n    如上图所示：当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。\n\n    <div align = \"center\">\n        <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414451925.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n    </div>\n    如上图所示：当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。 \n\n    这也是我们在多线程环境下，为什么需要BlockingQueue的原因。作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。既然BlockingQueue如此神通广大，让我们一起来见识下它的常用方法：\n\n    * BlockingQueue的核心方法：\n\n        **放入数据**：\n        \n        `offer(anObject)`:表示如果可能的话,将anObject加到BlockingQueue里,即**如果BlockingQueue可以容纳,则返回true,否则返回false**.（本方法不阻塞当前执行方法的线程）\n        \n        `offer(E o, long timeout, TimeUnit unit)`,**可以设定等待的时间**，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。\n\n        `put(anObject)`:把an Object加到BlockingQueue里,**如果BlockQueue没有空间,则调用此方法的线程被阻断,直到BlockingQueue里面有空间再继续**.\n\n        **获取数据**：\n        poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;\n        \n        `poll(long timeout, TimeUnit unit)`：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。\n        \n        `take()`:**取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入**; \n        \n        `drainTo()`:一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数）， 通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。\n\n    * 常见BlockingQueue\n        <div align = \"center\">\n            <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112416335973.jpg\" alt=\"BlockingQueue家族成员\" />\n        </div>\n\n    * BlockingQueue成员详细介绍\n\n        1. ArrayBlockingQueue<br><br>\n            基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。<br><br>\n            ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。\n\n        2. LinkedBlockingQueue<br><br>\n        基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br><br>\n        作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。<br><br>ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。<br><br>\n\n        3. DelayQueue<br><br>\n        DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br>\n        使用场景：<br>\n        DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。\n\n        4. PriorityBlockingQueue<br><br>\n            基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。\n\n        5. SynchronousQueue<br><br>\n        一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。<br><br>\n        声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:<br>\n        如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；<br>\n        但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。\n\n    * 小结   \n        BlockingQueue不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，他还自动管理了多线间的自动等待于唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能。 \n\n***\n<br>\n下面的代码演示了如何使用BlockingQueue：\n\n```java\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\n \n/**\n * @author jackyuj\n */\npublic class BlockingQueueTest {\n \n    public static void main(String[] args) throws InterruptedException {\n        // 声明一个容量为10的缓存队列\n        BlockingQueue<String> queue = new LinkedBlockingQueue<String>(10);\n \n        Producer producer1 = new Producer(queue);\n        Producer producer2 = new Producer(queue);\n        Producer producer3 = new Producer(queue);\n        Consumer consumer = new Consumer(queue);\n \n        // 借助Executors\n        ExecutorService service = Executors.newCachedThreadPool();\n        // 启动线程\n        service.execute(producer1);\n        service.execute(producer2);\n        service.execute(producer3);\n        service.execute(consumer);\n \n        // 执行10s\n        Thread.sleep(10 * 1000);\n        producer1.stop();\n        producer2.stop();\n        producer3.stop();\n \n        Thread.sleep(2000);\n        // 退出Executor\n        service.shutdown();\n    }\n}\n\n```\n\n```java\n\nimport java.util.Random;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\n \n/**\n * 消费者线程\n * \n * @author jackyuj\n */\npublic class Consumer implements Runnable {\n \n    public Consumer(BlockingQueue<String> queue) {\n        this.queue = queue;\n    }\n \n    public void run() {\n        System.out.println(\"启动消费者线程！\");\n        Random r = new Random();\n        boolean isRunning = true;\n        try {\n            while (isRunning) {\n                System.out.println(\"正从队列获取数据...\");\n                String data = queue.poll(2, TimeUnit.SECONDS);\n                if (null != data) {\n                    System.out.println(\"拿到数据：\" + data);\n                    System.out.println(\"正在消费数据：\" + data);\n                    Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));\n                } else {\n                    // 超过2s还没数据，认为所有生产线程都已经退出，自动退出消费线程。\n                    isRunning = false;\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            Thread.currentThread().interrupt();\n        } finally {\n            System.out.println(\"退出消费者线程！\");\n        }\n    }\n \n    private BlockingQueue<String> queue;\n    private static final int      DEFAULT_RANGE_FOR_SLEEP = 1000;\n}\n \nimport java.util.Random;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n \n/**\n * 生产者线程\n * \n * @author jackyuj\n */\npublic class Producer implements Runnable {\n \n    public Producer(BlockingQueue queue) {\n        this.queue = queue;\n    }\n \n    public void run() {\n        String data = null;\n        Random r = new Random();\n \n        System.out.println(\"启动生产者线程！\");\n        try {\n            while (isRunning) {\n                System.out.println(\"正在生产数据...\");\n                Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));\n \n                data = \"data:\" + count.incrementAndGet();\n                System.out.println(\"将数据：\" + data + \"放入队列...\");\n                if (!queue.offer(data, 2, TimeUnit.SECONDS)) {\n                    System.out.println(\"放入数据失败：\" + data);\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            Thread.currentThread().interrupt();\n        } finally {\n            System.out.println(\"退出生产者线程！\");\n        }\n    }\n \n    public void stop() {\n        isRunning = false;\n    }\n \n    private volatile boolean      isRunning               = true;\n    private BlockingQueue queue;\n    private static AtomicInteger  count                   = new AtomicInteger();\n    private static final int      DEFAULT_RANGE_FOR_SLEEP = 1000;\n \n}\n\n```\n\n\n\n\n\n\n    \n\n\n\n\n\n\n","slug":"code/Multi-Thread/【转载】BlockingQueue","published":1,"updated":"2020-11-29T15:54:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gr005p0w7t5q540r5u","content":"<blockquote>\n<p>原文链接 <a href=\"https://www.iteye.com/blog/wsmajunfeng-1629354\" target=\"_blank\" rel=\"noopener\">https://www.iteye.com/blog/wsmajunfeng-1629354</a></p>\n</blockquote>\n<ul>\n<li><p>前言：</p>\n<p>  在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>认识BlockingQueue</p>\n<p>  阻塞队列，顾名思义，首先它是一个队列，而一个队列在数据结构中所起的作用大致如下图所示：</p>\n  <div align = \"center\">\n      <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414472791.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n  </div>\n\n<p>  从上图我们可以很清楚看到，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；</p>\n<p>  常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue就是其中的一种）     </p>\n<p>  先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种<br>  程度上来说这种队列也体现了一种公平性。<br><br>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。</p>\n<p>  多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）<br><br>下面两幅图演示了BlockingQueue的两个常见阻塞场景：</p>\n  <div align = \"center\">\n      <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414442194.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n  </div>\n\n<p>  如上图所示：当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</p>\n  <div align = \"center\">\n      <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414451925.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n  </div>\n  如上图所示：当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。 \n\n<p>  这也是我们在多线程环境下，为什么需要BlockingQueue的原因。作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。既然BlockingQueue如此神通广大，让我们一起来见识下它的常用方法：</p>\n<ul>\n<li><p>BlockingQueue的核心方法：</p>\n<p>  <strong>放入数据</strong>：</p>\n<p>  <code>offer(anObject)</code>:表示如果可能的话,将anObject加到BlockingQueue里,即<strong>如果BlockingQueue可以容纳,则返回true,否则返回false</strong>.（本方法不阻塞当前执行方法的线程）</p>\n<p>  <code>offer(E o, long timeout, TimeUnit unit)</code>,<strong>可以设定等待的时间</strong>，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。</p>\n<p>  <code>put(anObject)</code>:把an Object加到BlockingQueue里,<strong>如果BlockQueue没有空间,则调用此方法的线程被阻断,直到BlockingQueue里面有空间再继续</strong>.</p>\n<p>  <strong>获取数据</strong>：<br>  poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;</p>\n<p>  <code>poll(long timeout, TimeUnit unit)</code>：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</p>\n<p>  <code>take()</code>:<strong>取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入</strong>; </p>\n<p>  <code>drainTo()</code>:一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数）， 通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p>\n</li>\n<li><p>常见BlockingQueue</p>\n  <div align = \"center\">\n      <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112416335973.jpg\" alt=\"BlockingQueue家族成员\" />\n  </div>\n</li>\n<li><p>BlockingQueue成员详细介绍</p>\n<ol>\n<li><p>ArrayBlockingQueue<br><br><br> 基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。<br><br><br> ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>\n</li>\n<li><p>LinkedBlockingQueue<br><br><br>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br><br><br>作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。<br><br>ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。<br><br></p>\n</li>\n<li><p>DelayQueue<br><br><br>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br><br>使用场景：<br><br>DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</p>\n</li>\n<li><p>PriorityBlockingQueue<br><br><br> 基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p>\n</li>\n<li><p>SynchronousQueue<br><br><br>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。<br><br><br>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:<br><br>如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；<br><br>但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>\n</li>\n</ol>\n</li>\n<li><p>小结<br>  BlockingQueue不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，他还自动管理了多线间的自动等待于唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能。 </p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<br>\n下面的代码演示了如何使用BlockingQueue：\n\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>BlockingQueue<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>ExecutorService<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>Executors<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>LinkedBlockingQueue<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * @author jackyuj\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BlockingQueueTest</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 声明一个容量为10的缓存队列</span>\n        BlockingQueue<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> queue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        Producer producer1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Producer</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Producer producer2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Producer</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Producer producer3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Producer</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Consumer consumer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Consumer</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 借助Executors</span>\n        ExecutorService service <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 启动线程</span>\n        service<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>producer1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        service<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>producer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        service<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>producer3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        service<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>consumer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 执行10s</span>\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span> <span class=\"token operator\">*</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        producer1<span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        producer2<span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        producer3<span class=\"token punctuation\">.</span><span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 退出Executor</span>\n        service<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Random<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>BlockingQueue<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 消费者线程\n * \n * @author jackyuj\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Consumer</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Consumer</span><span class=\"token punctuation\">(</span>BlockingQueue<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> queue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"启动消费者线程！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Random r <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">boolean</span> isRunning <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>isRunning<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"正从队列获取数据...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                String data <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>null <span class=\"token operator\">!=</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"拿到数据：\"</span> <span class=\"token operator\">+</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"正在消费数据：\"</span> <span class=\"token operator\">+</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span>DEFAULT_RANGE_FOR_SLEEP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 超过2s还没数据，认为所有生产线程都已经退出，自动退出消费线程。</span>\n                    isRunning <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"退出消费者线程！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> BlockingQueue<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> queue<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span>      DEFAULT_RANGE_FOR_SLEEP <span class=\"token operator\">=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Random<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>BlockingQueue<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>atomic<span class=\"token punctuation\">.</span>AtomicInteger<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 生产者线程\n * \n * @author jackyuj\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Producer</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Producer</span><span class=\"token punctuation\">(</span>BlockingQueue queue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        String data <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        Random r <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"启动生产者线程！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>isRunning<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"正在生产数据...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span>DEFAULT_RANGE_FOR_SLEEP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                data <span class=\"token operator\">=</span> <span class=\"token string\">\"data:\"</span> <span class=\"token operator\">+</span> count<span class=\"token punctuation\">.</span><span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"将数据：\"</span> <span class=\"token operator\">+</span> data <span class=\"token operator\">+</span> <span class=\"token string\">\"放入队列...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>queue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"放入数据失败：\"</span> <span class=\"token operator\">+</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"退出生产者线程！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        isRunning <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">boolean</span>      isRunning               <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> BlockingQueue queue<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> AtomicInteger  count                   <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span>      DEFAULT_RANGE_FOR_SLEEP <span class=\"token operator\">=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>原文链接 <a href=\"https://www.iteye.com/blog/wsmajunfeng-1629354\" target=\"_blank\" rel=\"noopener\">https://www.iteye.com/blog/wsmajunfeng-1629354</a></p>\n</blockquote>\n<ul>\n<li><p>前言：</p>\n<p>  在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。</p>\n</li>\n</ul>","more":"<ul>\n<li><p>认识BlockingQueue</p>\n<p>  阻塞队列，顾名思义，首先它是一个队列，而一个队列在数据结构中所起的作用大致如下图所示：</p>\n  <div align = \"center\">\n      <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414472791.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n  </div>\n\n<p>  从上图我们可以很清楚看到，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；</p>\n<p>  常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue就是其中的一种）     </p>\n<p>  先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种<br>  程度上来说这种队列也体现了一种公平性。<br><br>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。</p>\n<p>  多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）<br><br>下面两幅图演示了BlockingQueue的两个常见阻塞场景：</p>\n  <div align = \"center\">\n      <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414442194.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n  </div>\n\n<p>  如上图所示：当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</p>\n  <div align = \"center\">\n      <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112414451925.jpg\" alt=\"阻塞队列\" width=\"30%\"/>\n  </div>\n  如上图所示：当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。 \n\n<p>  这也是我们在多线程环境下，为什么需要BlockingQueue的原因。作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。既然BlockingQueue如此神通广大，让我们一起来见识下它的常用方法：</p>\n<ul>\n<li><p>BlockingQueue的核心方法：</p>\n<p>  <strong>放入数据</strong>：</p>\n<p>  <code>offer(anObject)</code>:表示如果可能的话,将anObject加到BlockingQueue里,即<strong>如果BlockingQueue可以容纳,则返回true,否则返回false</strong>.（本方法不阻塞当前执行方法的线程）</p>\n<p>  <code>offer(E o, long timeout, TimeUnit unit)</code>,<strong>可以设定等待的时间</strong>，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。</p>\n<p>  <code>put(anObject)</code>:把an Object加到BlockingQueue里,<strong>如果BlockQueue没有空间,则调用此方法的线程被阻断,直到BlockingQueue里面有空间再继续</strong>.</p>\n<p>  <strong>获取数据</strong>：<br>  poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;</p>\n<p>  <code>poll(long timeout, TimeUnit unit)</code>：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</p>\n<p>  <code>take()</code>:<strong>取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入</strong>; </p>\n<p>  <code>drainTo()</code>:一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数）， 通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p>\n</li>\n<li><p>常见BlockingQueue</p>\n  <div align = \"center\">\n      <img src=\"http://pic002.cnblogs.com/images/2010/161940/2010112416335973.jpg\" alt=\"BlockingQueue家族成员\" />\n  </div>\n</li>\n<li><p>BlockingQueue成员详细介绍</p>\n<ol>\n<li><p>ArrayBlockingQueue<br><br><br> 基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。<br><br><br> ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>\n</li>\n<li><p>LinkedBlockingQueue<br><br><br>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br><br><br>作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。<br><br>ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。<br><br></p>\n</li>\n<li><p>DelayQueue<br><br><br>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br><br>使用场景：<br><br>DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</p>\n</li>\n<li><p>PriorityBlockingQueue<br><br><br> 基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p>\n</li>\n<li><p>SynchronousQueue<br><br><br>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。<br><br><br>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:<br><br>如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；<br><br>但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>\n</li>\n</ol>\n</li>\n<li><p>小结<br>  BlockingQueue不光实现了一个完整队列所具有的基本功能，同时在多线程环境下，他还自动管理了多线间的自动等待于唤醒功能，从而使得程序员可以忽略这些细节，关注更高级的功能。 </p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<br>\n下面的代码演示了如何使用BlockingQueue：\n\n<pre><code class=\"java\">import java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\n\n/**\n * @author jackyuj\n */\npublic class BlockingQueueTest {\n\n    public static void main(String[] args) throws InterruptedException {\n        // 声明一个容量为10的缓存队列\n        BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;String&gt;(10);\n\n        Producer producer1 = new Producer(queue);\n        Producer producer2 = new Producer(queue);\n        Producer producer3 = new Producer(queue);\n        Consumer consumer = new Consumer(queue);\n\n        // 借助Executors\n        ExecutorService service = Executors.newCachedThreadPool();\n        // 启动线程\n        service.execute(producer1);\n        service.execute(producer2);\n        service.execute(producer3);\n        service.execute(consumer);\n\n        // 执行10s\n        Thread.sleep(10 * 1000);\n        producer1.stop();\n        producer2.stop();\n        producer3.stop();\n\n        Thread.sleep(2000);\n        // 退出Executor\n        service.shutdown();\n    }\n}\n</code></pre>\n<pre><code class=\"java\">\nimport java.util.Random;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 消费者线程\n * \n * @author jackyuj\n */\npublic class Consumer implements Runnable {\n\n    public Consumer(BlockingQueue&lt;String&gt; queue) {\n        this.queue = queue;\n    }\n\n    public void run() {\n        System.out.println(&quot;启动消费者线程！&quot;);\n        Random r = new Random();\n        boolean isRunning = true;\n        try {\n            while (isRunning) {\n                System.out.println(&quot;正从队列获取数据...&quot;);\n                String data = queue.poll(2, TimeUnit.SECONDS);\n                if (null != data) {\n                    System.out.println(&quot;拿到数据：&quot; + data);\n                    System.out.println(&quot;正在消费数据：&quot; + data);\n                    Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));\n                } else {\n                    // 超过2s还没数据，认为所有生产线程都已经退出，自动退出消费线程。\n                    isRunning = false;\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            Thread.currentThread().interrupt();\n        } finally {\n            System.out.println(&quot;退出消费者线程！&quot;);\n        }\n    }\n\n    private BlockingQueue&lt;String&gt; queue;\n    private static final int      DEFAULT_RANGE_FOR_SLEEP = 1000;\n}\n\nimport java.util.Random;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * 生产者线程\n * \n * @author jackyuj\n */\npublic class Producer implements Runnable {\n\n    public Producer(BlockingQueue queue) {\n        this.queue = queue;\n    }\n\n    public void run() {\n        String data = null;\n        Random r = new Random();\n\n        System.out.println(&quot;启动生产者线程！&quot;);\n        try {\n            while (isRunning) {\n                System.out.println(&quot;正在生产数据...&quot;);\n                Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));\n\n                data = &quot;data:&quot; + count.incrementAndGet();\n                System.out.println(&quot;将数据：&quot; + data + &quot;放入队列...&quot;);\n                if (!queue.offer(data, 2, TimeUnit.SECONDS)) {\n                    System.out.println(&quot;放入数据失败：&quot; + data);\n                }\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            Thread.currentThread().interrupt();\n        } finally {\n            System.out.println(&quot;退出生产者线程！&quot;);\n        }\n    }\n\n    public void stop() {\n        isRunning = false;\n    }\n\n    private volatile boolean      isRunning               = true;\n    private BlockingQueue queue;\n    private static AtomicInteger  count                   = new AtomicInteger();\n    private static final int      DEFAULT_RANGE_FOR_SLEEP = 1000;\n\n}\n</code></pre>"},{"title":"Spring Boot集成Log4j2","declare":true,"wordCount":true,"abbrlink":"6b344792","date":"2020-05-21T04:20:10.000Z","_content":"[Log4j2官方文档](http://logging.apache.org/log4j/2.x/index.html)     \n\n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log4j2是Apache的一个开源项目，虽然Spring Boot默认集成来了Logback，但相比于此，我更喜欢使用Log4j2,它不但在Log4j的基础上新增了许多改进，而且也支持了Logback中的一些特性，更加灵活。通过它我们可以将日志信息输出到控制台中，在某些情况下更加方便调试；跟踪代码运行轨迹，方便Debug；也可周期性的记录到文件中，以供其他应用获取相关信息。以下将介绍Spring Boot如何简单集成Log4j2.<br>\n\n<!-- more -->\n \n## 1. 引入依赖\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-log4j2</artifactId>\n</dependency>\n```\n* 排除Spring Boot默认使用的Logback      \n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter</artifactId>\n    <exclusions>\n        <exclusion>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-logging</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n```\n* 我看到一些资料上是在`spring-boot-starter-web`排除该包依赖，我的是在`spring-boot-starter`中排除，所以具体情况还是最好自己排除jar包冲突。\n\n## 2. 配置文件\n* Log4j2支持xml文件log4j2.xml,Java特性文件log4j2.properties,或者直接在项目配置文件中配置，但是xml配置灵活性更高。    \n在`/src/main/resources`下添加`log4j2.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<configuration status=\"WARN\">\n    <appenders>\n        <!-- 控制台 -->\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <!--指定日志输出格式-->\n            <PatternLayout pattern=\"[%d{HH:mm:ss:SS}] [%p] - %l - %m%n\"/>\n        </Console>\n        <!-- 日志文件 -->\n        <RollingFile name=\"RollingFileInfo\" fileName=\"C:/Users/life/Desktop/goInfo.log\"\n                     filePattern=\"Y:/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log}\">\n            <Filters>\n                <ThresholdFilter level=\"INFO\"/>\n            </Filters>\n            <PatternLayout pattern=\"[%d{HH:mm:ss:SS}] [%p] - %l - %m%n\"/>\n            <Policies>\n                <TimeBasedTriggeringPolicy/>\n                <SizeBasedTriggeringPolicy size=\"500MB\"/>\n            </Policies>\n        </RollingFile>\n\n    </appenders>\n    <loggers>\n        <root level=\"WARN\">  <!-- 输出级别 -->\n            <appender-ref ref=\"Console\"/>\n            <!-- <appender-ref ref=\"RollingFileInfo\"/>-->\n        </root>\n    </loggers>\n</configuration>\n```\n\n> 输出级别：all< debug < info < warn < error < fatal < off ,**输出级别不低于设定级别的日志信息**\n\n## 3. 添加Log4j2配置\n在application.yml添加：\n```yml\nlogging:\n    config: classpath:log4j2.xml\n```","source":"_posts/code/JavaWeb/集成log4j2.md","raw":"---\ntitle: Spring Boot集成Log4j2\ncategories: Code\ntags:\n  - JavaWeb\ndeclare: true\nwordCount: true\nabbrlink: 6b344792\ndate: 2020-05-21 12:20:10\n---\n[Log4j2官方文档](http://logging.apache.org/log4j/2.x/index.html)     \n\n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log4j2是Apache的一个开源项目，虽然Spring Boot默认集成来了Logback，但相比于此，我更喜欢使用Log4j2,它不但在Log4j的基础上新增了许多改进，而且也支持了Logback中的一些特性，更加灵活。通过它我们可以将日志信息输出到控制台中，在某些情况下更加方便调试；跟踪代码运行轨迹，方便Debug；也可周期性的记录到文件中，以供其他应用获取相关信息。以下将介绍Spring Boot如何简单集成Log4j2.<br>\n\n<!-- more -->\n \n## 1. 引入依赖\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-log4j2</artifactId>\n</dependency>\n```\n* 排除Spring Boot默认使用的Logback      \n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter</artifactId>\n    <exclusions>\n        <exclusion>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-logging</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n```\n* 我看到一些资料上是在`spring-boot-starter-web`排除该包依赖，我的是在`spring-boot-starter`中排除，所以具体情况还是最好自己排除jar包冲突。\n\n## 2. 配置文件\n* Log4j2支持xml文件log4j2.xml,Java特性文件log4j2.properties,或者直接在项目配置文件中配置，但是xml配置灵活性更高。    \n在`/src/main/resources`下添加`log4j2.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<configuration status=\"WARN\">\n    <appenders>\n        <!-- 控制台 -->\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <!--指定日志输出格式-->\n            <PatternLayout pattern=\"[%d{HH:mm:ss:SS}] [%p] - %l - %m%n\"/>\n        </Console>\n        <!-- 日志文件 -->\n        <RollingFile name=\"RollingFileInfo\" fileName=\"C:/Users/life/Desktop/goInfo.log\"\n                     filePattern=\"Y:/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log}\">\n            <Filters>\n                <ThresholdFilter level=\"INFO\"/>\n            </Filters>\n            <PatternLayout pattern=\"[%d{HH:mm:ss:SS}] [%p] - %l - %m%n\"/>\n            <Policies>\n                <TimeBasedTriggeringPolicy/>\n                <SizeBasedTriggeringPolicy size=\"500MB\"/>\n            </Policies>\n        </RollingFile>\n\n    </appenders>\n    <loggers>\n        <root level=\"WARN\">  <!-- 输出级别 -->\n            <appender-ref ref=\"Console\"/>\n            <!-- <appender-ref ref=\"RollingFileInfo\"/>-->\n        </root>\n    </loggers>\n</configuration>\n```\n\n> 输出级别：all< debug < info < warn < error < fatal < off ,**输出级别不低于设定级别的日志信息**\n\n## 3. 添加Log4j2配置\n在application.yml添加：\n```yml\nlogging:\n    config: classpath:log4j2.xml\n```","slug":"code/JavaWeb/集成log4j2","published":1,"updated":"2020-05-21T04:47:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gr005r0w7t8mcnd8uq","content":"<p><a href=\"http://logging.apache.org/log4j/2.x/index.html\" target=\"_blank\" rel=\"noopener\">Log4j2官方文档</a>     </p>\n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log4j2是Apache的一个开源项目，虽然Spring Boot默认集成来了Logback，但相比于此，我更喜欢使用Log4j2,它不但在Log4j的基础上新增了许多改进，而且也支持了Logback中的一些特性，更加灵活。通过它我们可以将日志信息输出到控制台中，在某些情况下更加方便调试；跟踪代码运行轨迹，方便Debug；也可周期性的记录到文件中，以供其他应用获取相关信息。以下将介绍Spring Boot如何简单集成Log4j2.<br>\n\n<a id=\"more\"></a>\n\n<h2 id=\"1-引入依赖\"><a href=\"#1-引入依赖\" class=\"headerlink\" title=\"1. 引入依赖\"></a>1. 引入依赖</h2><pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-log4j2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></code></pre>\n<ul>\n<li>排除Spring Boot默认使用的Logback      </li>\n</ul>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>exclusions</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>exclusion</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-logging<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>exclusion</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>exclusions</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></code></pre>\n<ul>\n<li>我看到一些资料上是在<code>spring-boot-starter-web</code>排除该包依赖，我的是在<code>spring-boot-starter</code>中排除，所以具体情况还是最好自己排除jar包冲突。</li>\n</ul>\n<h2 id=\"2-配置文件\"><a href=\"#2-配置文件\" class=\"headerlink\" title=\"2. 配置文件\"></a>2. 配置文件</h2><ul>\n<li>Log4j2支持xml文件log4j2.xml,Java特性文件log4j2.properties,或者直接在项目配置文件中配置，但是xml配置灵活性更高。<br>在<code>/src/main/resources</code>下添加<code>log4j2.xml</code></li>\n</ul>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>configuration</span> <span class=\"token attr-name\">status</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>WARN<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>appenders</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 控制台 --></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Console</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Console<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">target</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>SYSTEM_OUT<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n            <span class=\"token comment\" spellcheck=\"true\">&lt;!--指定日志输出格式--></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>PatternLayout</span> <span class=\"token attr-name\">pattern</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>[%d{HH:mm:ss:SS}] [%p] - %l - %m%n<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Console</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 日志文件 --></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>RollingFile</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>RollingFileInfo<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">fileName</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>C:/Users/life/Desktop/goInfo.log<span class=\"token punctuation\">\"</span></span>\n                     <span class=\"token attr-name\">filePattern</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Y:/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Filters</span><span class=\"token punctuation\">></span></span>\n                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ThresholdFilter</span> <span class=\"token attr-name\">level</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>INFO<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Filters</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>PatternLayout</span> <span class=\"token attr-name\">pattern</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>[%d{HH:mm:ss:SS}] [%p] - %l - %m%n<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Policies</span><span class=\"token punctuation\">></span></span>\n                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TimeBasedTriggeringPolicy</span><span class=\"token punctuation\">/></span></span>\n                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>SizeBasedTriggeringPolicy</span> <span class=\"token attr-name\">size</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>500MB<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Policies</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>RollingFile</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>appenders</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>loggers</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>root</span> <span class=\"token attr-name\">level</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>WARN<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>  <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 输出级别 --></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>appender-ref</span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Console<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n            <span class=\"token comment\" spellcheck=\"true\">&lt;!-- &lt;appender-ref ref=\"RollingFileInfo\"/>--></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>root</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>loggers</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>configuration</span><span class=\"token punctuation\">></span></span></code></pre>\n<blockquote>\n<p>输出级别：all&lt; debug &lt; info &lt; warn &lt; error &lt; fatal &lt; off ,<strong>输出级别不低于设定级别的日志信息</strong></p>\n</blockquote>\n<h2 id=\"3-添加Log4j2配置\"><a href=\"#3-添加Log4j2配置\" class=\"headerlink\" title=\"3. 添加Log4j2配置\"></a>3. 添加Log4j2配置</h2><p>在application.yml添加：</p>\n<pre class=\" language-yml\"><code class=\"language-yml\">logging:\n    config: classpath:log4j2.xml</code></pre>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://logging.apache.org/log4j/2.x/index.html\" target=\"_blank\" rel=\"noopener\">Log4j2官方文档</a>     </p>\n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log4j2是Apache的一个开源项目，虽然Spring Boot默认集成来了Logback，但相比于此，我更喜欢使用Log4j2,它不但在Log4j的基础上新增了许多改进，而且也支持了Logback中的一些特性，更加灵活。通过它我们可以将日志信息输出到控制台中，在某些情况下更加方便调试；跟踪代码运行轨迹，方便Debug；也可周期性的记录到文件中，以供其他应用获取相关信息。以下将介绍Spring Boot如何简单集成Log4j2.<br>","more":"<h2 id=\"1-引入依赖\"><a href=\"#1-引入依赖\" class=\"headerlink\" title=\"1. 引入依赖\"></a>1. 引入依赖</h2><pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<ul>\n<li>排除Spring Boot默认使用的Logback      </li>\n</ul>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;</code></pre>\n<ul>\n<li>我看到一些资料上是在<code>spring-boot-starter-web</code>排除该包依赖，我的是在<code>spring-boot-starter</code>中排除，所以具体情况还是最好自己排除jar包冲突。</li>\n</ul>\n<h2 id=\"2-配置文件\"><a href=\"#2-配置文件\" class=\"headerlink\" title=\"2. 配置文件\"></a>2. 配置文件</h2><ul>\n<li>Log4j2支持xml文件log4j2.xml,Java特性文件log4j2.properties,或者直接在项目配置文件中配置，但是xml配置灵活性更高。<br>在<code>/src/main/resources</code>下添加<code>log4j2.xml</code></li>\n</ul>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;configuration status=&quot;WARN&quot;&gt;\n    &lt;appenders&gt;\n        &lt;!-- 控制台 --&gt;\n        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;\n            &lt;!--指定日志输出格式--&gt;\n            &lt;PatternLayout pattern=&quot;[%d{HH:mm:ss:SS}] [%p] - %l - %m%n&quot;/&gt;\n        &lt;/Console&gt;\n        &lt;!-- 日志文件 --&gt;\n        &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;C:/Users/life/Desktop/goInfo.log&quot;\n                     filePattern=&quot;Y:/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log}&quot;&gt;\n            &lt;Filters&gt;\n                &lt;ThresholdFilter level=&quot;INFO&quot;/&gt;\n            &lt;/Filters&gt;\n            &lt;PatternLayout pattern=&quot;[%d{HH:mm:ss:SS}] [%p] - %l - %m%n&quot;/&gt;\n            &lt;Policies&gt;\n                &lt;TimeBasedTriggeringPolicy/&gt;\n                &lt;SizeBasedTriggeringPolicy size=&quot;500MB&quot;/&gt;\n            &lt;/Policies&gt;\n        &lt;/RollingFile&gt;\n\n    &lt;/appenders&gt;\n    &lt;loggers&gt;\n        &lt;root level=&quot;WARN&quot;&gt;  &lt;!-- 输出级别 --&gt;\n            &lt;appender-ref ref=&quot;Console&quot;/&gt;\n            &lt;!-- &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt;--&gt;\n        &lt;/root&gt;\n    &lt;/loggers&gt;\n&lt;/configuration&gt;</code></pre>\n<blockquote>\n<p>输出级别：all&lt; debug &lt; info &lt; warn &lt; error &lt; fatal &lt; off ,<strong>输出级别不低于设定级别的日志信息</strong></p>\n</blockquote>\n<h2 id=\"3-添加Log4j2配置\"><a href=\"#3-添加Log4j2配置\" class=\"headerlink\" title=\"3. 添加Log4j2配置\"></a>3. 添加Log4j2配置</h2><p>在application.yml添加：</p>\n<pre><code class=\"yml\">logging:\n    config: classpath:log4j2.xml</code></pre>"},{"title":"生产者消费者模型","declare":true,"wordCount":true,"abbrlink":"161dcf21","date":"2020-11-22T17:03:24.000Z","_content":"\n生产者消费者模型是线程模型中一个经典问题：生产者和消费者在同一时间内共享同一个容器，生产者向容器添加产品，消费者从容器中取走产品，**当容器满时，生产者阻塞，当容器为空时，消费者阻塞**。\n\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/22/DzeAYk3SVMHQ4ZG.png\" alt=\"生产者消费者模型示意图\" width=\"60%\"/>\n</div>\n\n<!-- more -->\n\n## 一、Code\n### 1.1 synchronized实现\n#### 1.1.1 容器\n```java\npublic class Container {\n    private Queue<Integer> container = new LinkedList<>();\n    private int containerSize = 5;  //容器的大小\n\n    /**\n    * @Description: 生产者生产内容\n    * @Param: [val] 添加的内容\n    * @return: void\n    * @Author: cloudr\n    * @Date: 2020/11/22\n    */\n    public synchronized void add(int val) throws InterruptedException {\n        if (container.size() > containerSize) {\n            wait(); //阻塞生产者，不让其继续生产\n        }\n        container.add(val);\n        notify();   //通知消费者继续消费\n    }\n\n    /**\n    * @Description: 消费者消费内容\n    * @Param: []\n    * @return: int 返回生产者所生产的\n    * @Author: cloudr\n    * @Date: 2020/11/22\n    */\n    public synchronized int get() throws InterruptedException {\n        if (container.size() == 0) {\n            wait(); //阻塞生消费者，不让其继续消费\n        }\n        int returnRes = container.poll();\n        notify();   //通知生产者继续生产\n        return returnRes;\n    }\n}\n```\n \n#### 1.1.2 生产者\n```java\npublic class Producer extends Thread{\n    private Container container;\n\n    public Producer(Container container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            try {\n                container.add(i);   //生产内容添加进容器中\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### 1.1.3 消费者\n```java\npublic class Consumer extends Thread {\n    private Container container;\n\n    public Consumer(Container container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            int val = 0;\n            try {\n                val = container.get();  //从容器中获取产品消费\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(val);\n        }\n    }\n}\n```\n#### 1.1.4 Demo\n```java\npublic class ProducerAndConsumerDemo {\n    public static void main(String[] args) {\n        Container container = new Container();\n        Producer producer = new Producer(container);\n        Consumer consumer = new Consumer(container);\n        producer.start();\n        consumer.start();\n    }\n}\n```\n\n### 1.2 BlockingQueue实现\n\n使用BlockingQueue时，我们再也不必关心什么时候应该阻塞线程，什么时候应该唤醒线程。\n\n```java\npackage com.cc.step1.ProducerAndConsumerModel;\n\nimport java.util.Random;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\n/**\n * @author shangjing\n * @date 2018/11/22 4:05 PM\n * @describe32\n */\npublic class PCByBlockingQueue {\n    private static int count = 0;\n\n    private final BlockingQueue blockingQueue = new LinkedBlockingQueue(10);    //容器\n\n    class Producer implements Runnable {\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(new Random().nextInt(1000));   //模拟生产者和消费者效率不一致\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    int val = new Random().nextInt(1000);\n                    blockingQueue.put(val);  //生产内容进入容器\n                    count++;\n                    System.out.println(Thread.currentThread().getName() + \"-生产者生产\" + val + \"，容器中数量为:\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    class Consumer implements Runnable {\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(new Random().nextInt(500));    //模拟生产者和消费者效率不一致\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    int val = (int) blockingQueue.take();   //消费者从容器消费产品\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + \"-消费者消费\" + val + \"，容器中数量为：\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        PCByBlockingQueue blockingQueueTest = new PCByBlockingQueue();\n        new Thread(blockingQueueTest.new Producer()).start();\n        new Thread(blockingQueueTest.new Consumer()).start();\n        // 模拟多个生产者和消费者\n//        new Thread(blockingQueueTest.new Producer()).start();     \n//        new Thread(blockingQueueTest.new Consumer()).start();\n//        new Thread(blockingQueueTest.new Producer()).start();\n//        new Thread(blockingQueueTest.new Consumer()).start();\n    }\n}\n```\n\n### 参考    \n[1]https://www.jianshu.com/p/f53fb95b5820    \n\n","source":"_posts/code/Multi-Thread/生产者消费者模型.md","raw":"---\ntitle: 生产者消费者模型\ncategories: Code\ntags: Multi-Thread\ndeclare: true\nwordCount: true\nabbrlink: 161dcf21\ndate: 2020-11-23 01:03:24\n---\n\n生产者消费者模型是线程模型中一个经典问题：生产者和消费者在同一时间内共享同一个容器，生产者向容器添加产品，消费者从容器中取走产品，**当容器满时，生产者阻塞，当容器为空时，消费者阻塞**。\n\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/22/DzeAYk3SVMHQ4ZG.png\" alt=\"生产者消费者模型示意图\" width=\"60%\"/>\n</div>\n\n<!-- more -->\n\n## 一、Code\n### 1.1 synchronized实现\n#### 1.1.1 容器\n```java\npublic class Container {\n    private Queue<Integer> container = new LinkedList<>();\n    private int containerSize = 5;  //容器的大小\n\n    /**\n    * @Description: 生产者生产内容\n    * @Param: [val] 添加的内容\n    * @return: void\n    * @Author: cloudr\n    * @Date: 2020/11/22\n    */\n    public synchronized void add(int val) throws InterruptedException {\n        if (container.size() > containerSize) {\n            wait(); //阻塞生产者，不让其继续生产\n        }\n        container.add(val);\n        notify();   //通知消费者继续消费\n    }\n\n    /**\n    * @Description: 消费者消费内容\n    * @Param: []\n    * @return: int 返回生产者所生产的\n    * @Author: cloudr\n    * @Date: 2020/11/22\n    */\n    public synchronized int get() throws InterruptedException {\n        if (container.size() == 0) {\n            wait(); //阻塞生消费者，不让其继续消费\n        }\n        int returnRes = container.poll();\n        notify();   //通知生产者继续生产\n        return returnRes;\n    }\n}\n```\n \n#### 1.1.2 生产者\n```java\npublic class Producer extends Thread{\n    private Container container;\n\n    public Producer(Container container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            try {\n                container.add(i);   //生产内容添加进容器中\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### 1.1.3 消费者\n```java\npublic class Consumer extends Thread {\n    private Container container;\n\n    public Consumer(Container container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            int val = 0;\n            try {\n                val = container.get();  //从容器中获取产品消费\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(val);\n        }\n    }\n}\n```\n#### 1.1.4 Demo\n```java\npublic class ProducerAndConsumerDemo {\n    public static void main(String[] args) {\n        Container container = new Container();\n        Producer producer = new Producer(container);\n        Consumer consumer = new Consumer(container);\n        producer.start();\n        consumer.start();\n    }\n}\n```\n\n### 1.2 BlockingQueue实现\n\n使用BlockingQueue时，我们再也不必关心什么时候应该阻塞线程，什么时候应该唤醒线程。\n\n```java\npackage com.cc.step1.ProducerAndConsumerModel;\n\nimport java.util.Random;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\n/**\n * @author shangjing\n * @date 2018/11/22 4:05 PM\n * @describe32\n */\npublic class PCByBlockingQueue {\n    private static int count = 0;\n\n    private final BlockingQueue blockingQueue = new LinkedBlockingQueue(10);    //容器\n\n    class Producer implements Runnable {\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(new Random().nextInt(1000));   //模拟生产者和消费者效率不一致\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    int val = new Random().nextInt(1000);\n                    blockingQueue.put(val);  //生产内容进入容器\n                    count++;\n                    System.out.println(Thread.currentThread().getName() + \"-生产者生产\" + val + \"，容器中数量为:\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    class Consumer implements Runnable {\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(new Random().nextInt(500));    //模拟生产者和消费者效率不一致\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    int val = (int) blockingQueue.take();   //消费者从容器消费产品\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + \"-消费者消费\" + val + \"，容器中数量为：\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        PCByBlockingQueue blockingQueueTest = new PCByBlockingQueue();\n        new Thread(blockingQueueTest.new Producer()).start();\n        new Thread(blockingQueueTest.new Consumer()).start();\n        // 模拟多个生产者和消费者\n//        new Thread(blockingQueueTest.new Producer()).start();     \n//        new Thread(blockingQueueTest.new Consumer()).start();\n//        new Thread(blockingQueueTest.new Producer()).start();\n//        new Thread(blockingQueueTest.new Consumer()).start();\n    }\n}\n```\n\n### 参考    \n[1]https://www.jianshu.com/p/f53fb95b5820    \n\n","slug":"code/Multi-Thread/生产者消费者模型","published":1,"updated":"2020-11-22T17:08:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gs005u0w7t7amfay6p","content":"<p>生产者消费者模型是线程模型中一个经典问题：生产者和消费者在同一时间内共享同一个容器，生产者向容器添加产品，消费者从容器中取走产品，<strong>当容器满时，生产者阻塞，当容器为空时，消费者阻塞</strong>。</p>\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/22/DzeAYk3SVMHQ4ZG.png\" alt=\"生产者消费者模型示意图\" width=\"60%\"/>\n</div>\n\n<a id=\"more\"></a>\n\n<h2 id=\"一、Code\"><a href=\"#一、Code\" class=\"headerlink\" title=\"一、Code\"></a>一、Code</h2><h3 id=\"1-1-synchronized实现\"><a href=\"#1-1-synchronized实现\" class=\"headerlink\" title=\"1.1 synchronized实现\"></a>1.1 synchronized实现</h3><h4 id=\"1-1-1-容器\"><a href=\"#1-1-1-容器\" class=\"headerlink\" title=\"1.1.1 容器\"></a>1.1.1 容器</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Container</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Queue<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> container <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> containerSize <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//容器的大小</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n    * @Description: 生产者生产内容\n    * @Param: [val] 添加的内容\n    * @return: void\n    * @Author: cloudr\n    * @Date: 2020/11/22\n    */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> containerSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//阻塞生产者，不让其继续生产</span>\n        <span class=\"token punctuation\">}</span>\n        container<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">notify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//通知消费者继续消费</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n    * @Description: 消费者消费内容\n    * @Param: []\n    * @return: int 返回生产者所生产的\n    * @Author: cloudr\n    * @Date: 2020/11/22\n    */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">int</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//阻塞生消费者，不让其继续消费</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">int</span> returnRes <span class=\"token operator\">=</span> container<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">notify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//通知生产者继续生产</span>\n        <span class=\"token keyword\">return</span> returnRes<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"1-1-2-生产者\"><a href=\"#1-1-2-生产者\" class=\"headerlink\" title=\"1.1.2 生产者\"></a>1.1.2 生产者</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Producer</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Container container<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Producer</span><span class=\"token punctuation\">(</span>Container container<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>container <span class=\"token operator\">=</span> container<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                container<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//生产内容添加进容器中</span>\n                Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"1-1-3-消费者\"><a href=\"#1-1-3-消费者\" class=\"headerlink\" title=\"1.1.3 消费者\"></a>1.1.3 消费者</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Consumer</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Container container<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Consumer</span><span class=\"token punctuation\">(</span>Container container<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>container <span class=\"token operator\">=</span> container<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> val <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                val <span class=\"token operator\">=</span> container<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//从容器中获取产品消费</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"1-1-4-Demo\"><a href=\"#1-1-4-Demo\" class=\"headerlink\" title=\"1.1.4 Demo\"></a>1.1.4 Demo</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ProducerAndConsumerDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Container container <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Container</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Producer producer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Producer</span><span class=\"token punctuation\">(</span>container<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Consumer consumer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Consumer</span><span class=\"token punctuation\">(</span>container<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        producer<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        consumer<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"1-2-BlockingQueue实现\"><a href=\"#1-2-BlockingQueue实现\" class=\"headerlink\" title=\"1.2 BlockingQueue实现\"></a>1.2 BlockingQueue实现</h3><p>使用BlockingQueue时，我们再也不必关心什么时候应该阻塞线程，什么时候应该唤醒线程。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> com<span class=\"token punctuation\">.</span>cc<span class=\"token punctuation\">.</span>step1<span class=\"token punctuation\">.</span>ProducerAndConsumerModel<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Random<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>BlockingQueue<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>LinkedBlockingQueue<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * @author shangjing\n * @date 2018/11/22 4:05 PM\n * @describe32\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PCByBlockingQueue</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> BlockingQueue blockingQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//容器</span>\n\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Producer</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//模拟生产者和消费者效率不一致</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">int</span> val <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//生产内容进入容器</span>\n                    count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"-生产者生产\"</span> <span class=\"token operator\">+</span> val <span class=\"token operator\">+</span> <span class=\"token string\">\"，容器中数量为:\"</span> <span class=\"token operator\">+</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Consumer</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//模拟生产者和消费者效率不一致</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">int</span> val <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> blockingQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//消费者从容器消费产品</span>\n                    count<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"-消费者消费\"</span> <span class=\"token operator\">+</span> val <span class=\"token operator\">+</span> <span class=\"token string\">\"，容器中数量为：\"</span> <span class=\"token operator\">+</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        PCByBlockingQueue blockingQueueTest <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PCByBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>blockingQueueTest<span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Producer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>blockingQueueTest<span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Consumer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 模拟多个生产者和消费者</span>\n<span class=\"token comment\" spellcheck=\"true\">//        new Thread(blockingQueueTest.new Producer()).start();     </span>\n<span class=\"token comment\" spellcheck=\"true\">//        new Thread(blockingQueueTest.new Consumer()).start();</span>\n<span class=\"token comment\" spellcheck=\"true\">//        new Thread(blockingQueueTest.new Producer()).start();</span>\n<span class=\"token comment\" spellcheck=\"true\">//        new Thread(blockingQueueTest.new Consumer()).start();</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>[1]<a href=\"https://www.jianshu.com/p/f53fb95b5820\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f53fb95b5820</a>    </p>\n","site":{"data":{}},"excerpt":"<p>生产者消费者模型是线程模型中一个经典问题：生产者和消费者在同一时间内共享同一个容器，生产者向容器添加产品，消费者从容器中取走产品，<strong>当容器满时，生产者阻塞，当容器为空时，消费者阻塞</strong>。</p>\n<div align = \"center\">\n    <img src=\"https://i.loli.net/2020/11/22/DzeAYk3SVMHQ4ZG.png\" alt=\"生产者消费者模型示意图\" width=\"60%\"/>\n</div>","more":"<h2 id=\"一、Code\"><a href=\"#一、Code\" class=\"headerlink\" title=\"一、Code\"></a>一、Code</h2><h3 id=\"1-1-synchronized实现\"><a href=\"#1-1-synchronized实现\" class=\"headerlink\" title=\"1.1 synchronized实现\"></a>1.1 synchronized实现</h3><h4 id=\"1-1-1-容器\"><a href=\"#1-1-1-容器\" class=\"headerlink\" title=\"1.1.1 容器\"></a>1.1.1 容器</h4><pre><code class=\"java\">public class Container {\n    private Queue&lt;Integer&gt; container = new LinkedList&lt;&gt;();\n    private int containerSize = 5;  //容器的大小\n\n    /**\n    * @Description: 生产者生产内容\n    * @Param: [val] 添加的内容\n    * @return: void\n    * @Author: cloudr\n    * @Date: 2020/11/22\n    */\n    public synchronized void add(int val) throws InterruptedException {\n        if (container.size() &gt; containerSize) {\n            wait(); //阻塞生产者，不让其继续生产\n        }\n        container.add(val);\n        notify();   //通知消费者继续消费\n    }\n\n    /**\n    * @Description: 消费者消费内容\n    * @Param: []\n    * @return: int 返回生产者所生产的\n    * @Author: cloudr\n    * @Date: 2020/11/22\n    */\n    public synchronized int get() throws InterruptedException {\n        if (container.size() == 0) {\n            wait(); //阻塞生消费者，不让其继续消费\n        }\n        int returnRes = container.poll();\n        notify();   //通知生产者继续生产\n        return returnRes;\n    }\n}</code></pre>\n<h4 id=\"1-1-2-生产者\"><a href=\"#1-1-2-生产者\" class=\"headerlink\" title=\"1.1.2 生产者\"></a>1.1.2 生产者</h4><pre><code class=\"java\">public class Producer extends Thread{\n    private Container container;\n\n    public Producer(Container container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 10; i++) {\n            try {\n                container.add(i);   //生产内容添加进容器中\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre>\n<h4 id=\"1-1-3-消费者\"><a href=\"#1-1-3-消费者\" class=\"headerlink\" title=\"1.1.3 消费者\"></a>1.1.3 消费者</h4><pre><code class=\"java\">public class Consumer extends Thread {\n    private Container container;\n\n    public Consumer(Container container) {\n        this.container = container;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i &lt; 10; i++) {\n            int val = 0;\n            try {\n                val = container.get();  //从容器中获取产品消费\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(val);\n        }\n    }\n}</code></pre>\n<h4 id=\"1-1-4-Demo\"><a href=\"#1-1-4-Demo\" class=\"headerlink\" title=\"1.1.4 Demo\"></a>1.1.4 Demo</h4><pre><code class=\"java\">public class ProducerAndConsumerDemo {\n    public static void main(String[] args) {\n        Container container = new Container();\n        Producer producer = new Producer(container);\n        Consumer consumer = new Consumer(container);\n        producer.start();\n        consumer.start();\n    }\n}</code></pre>\n<h3 id=\"1-2-BlockingQueue实现\"><a href=\"#1-2-BlockingQueue实现\" class=\"headerlink\" title=\"1.2 BlockingQueue实现\"></a>1.2 BlockingQueue实现</h3><p>使用BlockingQueue时，我们再也不必关心什么时候应该阻塞线程，什么时候应该唤醒线程。</p>\n<pre><code class=\"java\">package com.cc.step1.ProducerAndConsumerModel;\n\nimport java.util.Random;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\n/**\n * @author shangjing\n * @date 2018/11/22 4:05 PM\n * @describe32\n */\npublic class PCByBlockingQueue {\n    private static int count = 0;\n\n    private final BlockingQueue blockingQueue = new LinkedBlockingQueue(10);    //容器\n\n    class Producer implements Runnable {\n\n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 10; i++) {\n                try {\n                    Thread.sleep(new Random().nextInt(1000));   //模拟生产者和消费者效率不一致\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    int val = new Random().nextInt(1000);\n                    blockingQueue.put(val);  //生产内容进入容器\n                    count++;\n                    System.out.println(Thread.currentThread().getName() + &quot;-生产者生产&quot; + val + &quot;，容器中数量为:&quot; + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    class Consumer implements Runnable {\n\n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 10; i++) {\n                try {\n                    Thread.sleep(new Random().nextInt(500));    //模拟生产者和消费者效率不一致\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    int val = (int) blockingQueue.take();   //消费者从容器消费产品\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + &quot;-消费者消费&quot; + val + &quot;，容器中数量为：&quot; + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        PCByBlockingQueue blockingQueueTest = new PCByBlockingQueue();\n        new Thread(blockingQueueTest.new Producer()).start();\n        new Thread(blockingQueueTest.new Consumer()).start();\n        // 模拟多个生产者和消费者\n//        new Thread(blockingQueueTest.new Producer()).start();     \n//        new Thread(blockingQueueTest.new Consumer()).start();\n//        new Thread(blockingQueueTest.new Producer()).start();\n//        new Thread(blockingQueueTest.new Consumer()).start();\n    }\n}</code></pre>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>[1]<a href=\"https://www.jianshu.com/p/f53fb95b5820\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f53fb95b5820</a>    </p>"},{"title":"死锁","declare":true,"wordCount":true,"abbrlink":"1abadc07","date":"2020-06-25T13:30:10.000Z","_content":"\n![思维导图](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200625211117.png)\n\n<!-- more -->\n\n# 死锁\n\n## 1. 例子\n\n### 1.1 交通堵塞\n\n一个十字路口有东西南北4个方向的车流，假设没有红绿灯，又没有交警指挥，并且4个方向的排头车辆几乎同时到达十字路口，为了防止撞车都停了下来，形成交通阻塞。\n交通死锁的含义就是两辆或两辆以上车辆中，**每一辆都占用一条道路，而又等待另外一辆车释放道路资源而无法前进**。\n\n### 1.2 过河\n\n小河中铺了一串垫脚石用于过河，并且**两个人在河中相遇且都不退让发生**死锁。\n\n## 2. 定义\n\n### 2.1 系统资源\n\n- 可抢占式资源\n\n  某进程获得这一类资源后，该资源可以再被系统或其他进程使用；\n  CPU\n  主存\n\n- 不可抢占式资源\n\n  某进程获得这类资源后，该资源不能被其他进程使用，直到使用完成后才被他主动释放，只能互斥使用；\n  打印机\n  磁带机\n\n### 2.2 定义\n\n死锁是指**多个进程在并发执行过程中因为争夺不可抢占资源而造成的一种僵局**。当这种僵局发生时，相关进程都处于永远等待（阻塞）状态，若无外力作用，这组进程都将永远无法继续向前推进。\n\n###  2.3 与死循环区别\n\n* 死锁具有偶然性\n* 发生死锁时，因为处于阻塞状态，所有没有占用cpu资源，但死循环会一直占用cpu资源\n* 死锁是多个进程之间因为争抢不可抢占式资源产生的，与操作系统的管理和资源调度有关；\n* 死循环是因为程序设计时的错误\n\n###  2.4 与饥饿的不同\n\n本质区别：\n* 饥饿状态一旦得到所需资源，就可立即运行\n* 处于死锁的相关进程都在相互等待对方占用的系统资源而又不释放自己所占资源，所以造成彼此永远无法得到所需资源的现象。\n\n## 3. 产生原因和必要条件\n\n### 3.1 产生原因\n\n- 系统资源不足\n- 进程推进顺序不当\n\n### 3.2 必要条件\n\n这几个条件并不是完全独立的\n\n- 互斥条件\n\n  进程对所获的资源进行排他性的使用\n\n- 请求保持条件\n\n  得不到资源而阻塞时，并不释放自己占有的资源\n\n- 不可抢占条件\n\n  进程所获得的资源在未使用结束前不能被其他进程抢占\n\n- 循环等待条件\n\n  隐含着上面三个条件\n\n## 4. 面对死锁问题\n\n### 4.1 预防\n\n#### 4.1.1 破坏请求和保持条件\n\n运行之前一次性申请他所需要的全部资源，并且在未获得全部资源前不投入运行，运行后也不再提出新的资源请求。         \n\n优点：\n* 安全 \n* 简单\n* 易于实现\n\n缺点：\n* 系统资源严重浪费。某一资源在被使用完后，并不能被及时释放\n* 会加剧作业饥饿的现象\n* 进程运行前，系统并不知道它需要多少资源\n\n#### 4.1.2 破坏不可抢占条件\n\n根据需求逐个提出资源请求，当一个已经占有了某些资源的进程，且又提出新的资源请求而得不到满足处于阻塞情况下，必须释放已占有的资源\n缺点：\n\n* 某些资源被抢占后可能会引发错误，因为不太容易恢复现场。\n* 比较复杂，代价太大\n* 可能存在某些进程的资源总是被抢占\n\n适用：\n* CPU\n* 主存\n\n#### 4.1.3 破坏循环等待条件\n\n采用资源有序分配策略，即将系统中所有资源进行编号，并规定进程申请资源时必须严格按照资源编号顺序进行\n\n缺点：\n* 进程实际适用资源顺序不一定和编号一致\n* 资源的不同编号方法对资源利用效率有影响\n* 资源编号必须相对稳定\n* 严格的资源编号使得用户编程的自主性收到限制\n\n### 4.2 死锁的避免\n\n### 4.2.1 银行家算法\n通过几种**预防死锁的方法尽管实现起来比较简单，但基本上都严重影响系统性能**或可能会引起致命错误\n\n一个进程提出资源请求后，系统先进行资源的试分配，然后检查本次的试分配是否使系统处于安全状态，若安全则按试分配方案分配资源，否则不分配资源。\n\n银行家算法缺少实用价值：很少有进程能够在运行之前就知道其所需资源的最大值，而且进程数不是固定的，往往在不断变化，况且原本可用的资源也可能突然间变得不可用。\n\n## 5. 死锁的检测和预防\n\n### 5.1 死锁检测\n\n- 资源分配图\n- 死锁定理\n- 死锁检测算法\n\n### 5.2 死锁解除\n\n- 撤销所有死锁进程\n- 让死锁回撤到正常执行状态\n- 某顺序逐个撤销死锁进程，直至不发生死锁为止\n- 采用抢占资源的策略直到不再发生死锁\n\n### 5.3 代价最小原则\n\n- 发现时，消耗的CPU资源最小\n- 发现时，获得的系统资源最小\n- 发现时，产生的输出了最小\n- 优先级最低\n- 预计进程的剩余时间最长\n\n\n<br><br>\n\n***\n\n<br><br>\n\n**参考**\n[1]胡元义,黑新宏.操作系统原理. 北京: 电子工业出版社, 2018.\n\n","source":"_posts/code/OS/死锁.md","raw":"---\ntitle: 死锁\ncategories: Code\ntags: OS\ndeclare: true\nwordCount: true\nabbrlink: 1abadc07\ndate: 2020-06-25 21:30:10\n---\n\n![思维导图](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200625211117.png)\n\n<!-- more -->\n\n# 死锁\n\n## 1. 例子\n\n### 1.1 交通堵塞\n\n一个十字路口有东西南北4个方向的车流，假设没有红绿灯，又没有交警指挥，并且4个方向的排头车辆几乎同时到达十字路口，为了防止撞车都停了下来，形成交通阻塞。\n交通死锁的含义就是两辆或两辆以上车辆中，**每一辆都占用一条道路，而又等待另外一辆车释放道路资源而无法前进**。\n\n### 1.2 过河\n\n小河中铺了一串垫脚石用于过河，并且**两个人在河中相遇且都不退让发生**死锁。\n\n## 2. 定义\n\n### 2.1 系统资源\n\n- 可抢占式资源\n\n  某进程获得这一类资源后，该资源可以再被系统或其他进程使用；\n  CPU\n  主存\n\n- 不可抢占式资源\n\n  某进程获得这类资源后，该资源不能被其他进程使用，直到使用完成后才被他主动释放，只能互斥使用；\n  打印机\n  磁带机\n\n### 2.2 定义\n\n死锁是指**多个进程在并发执行过程中因为争夺不可抢占资源而造成的一种僵局**。当这种僵局发生时，相关进程都处于永远等待（阻塞）状态，若无外力作用，这组进程都将永远无法继续向前推进。\n\n###  2.3 与死循环区别\n\n* 死锁具有偶然性\n* 发生死锁时，因为处于阻塞状态，所有没有占用cpu资源，但死循环会一直占用cpu资源\n* 死锁是多个进程之间因为争抢不可抢占式资源产生的，与操作系统的管理和资源调度有关；\n* 死循环是因为程序设计时的错误\n\n###  2.4 与饥饿的不同\n\n本质区别：\n* 饥饿状态一旦得到所需资源，就可立即运行\n* 处于死锁的相关进程都在相互等待对方占用的系统资源而又不释放自己所占资源，所以造成彼此永远无法得到所需资源的现象。\n\n## 3. 产生原因和必要条件\n\n### 3.1 产生原因\n\n- 系统资源不足\n- 进程推进顺序不当\n\n### 3.2 必要条件\n\n这几个条件并不是完全独立的\n\n- 互斥条件\n\n  进程对所获的资源进行排他性的使用\n\n- 请求保持条件\n\n  得不到资源而阻塞时，并不释放自己占有的资源\n\n- 不可抢占条件\n\n  进程所获得的资源在未使用结束前不能被其他进程抢占\n\n- 循环等待条件\n\n  隐含着上面三个条件\n\n## 4. 面对死锁问题\n\n### 4.1 预防\n\n#### 4.1.1 破坏请求和保持条件\n\n运行之前一次性申请他所需要的全部资源，并且在未获得全部资源前不投入运行，运行后也不再提出新的资源请求。         \n\n优点：\n* 安全 \n* 简单\n* 易于实现\n\n缺点：\n* 系统资源严重浪费。某一资源在被使用完后，并不能被及时释放\n* 会加剧作业饥饿的现象\n* 进程运行前，系统并不知道它需要多少资源\n\n#### 4.1.2 破坏不可抢占条件\n\n根据需求逐个提出资源请求，当一个已经占有了某些资源的进程，且又提出新的资源请求而得不到满足处于阻塞情况下，必须释放已占有的资源\n缺点：\n\n* 某些资源被抢占后可能会引发错误，因为不太容易恢复现场。\n* 比较复杂，代价太大\n* 可能存在某些进程的资源总是被抢占\n\n适用：\n* CPU\n* 主存\n\n#### 4.1.3 破坏循环等待条件\n\n采用资源有序分配策略，即将系统中所有资源进行编号，并规定进程申请资源时必须严格按照资源编号顺序进行\n\n缺点：\n* 进程实际适用资源顺序不一定和编号一致\n* 资源的不同编号方法对资源利用效率有影响\n* 资源编号必须相对稳定\n* 严格的资源编号使得用户编程的自主性收到限制\n\n### 4.2 死锁的避免\n\n### 4.2.1 银行家算法\n通过几种**预防死锁的方法尽管实现起来比较简单，但基本上都严重影响系统性能**或可能会引起致命错误\n\n一个进程提出资源请求后，系统先进行资源的试分配，然后检查本次的试分配是否使系统处于安全状态，若安全则按试分配方案分配资源，否则不分配资源。\n\n银行家算法缺少实用价值：很少有进程能够在运行之前就知道其所需资源的最大值，而且进程数不是固定的，往往在不断变化，况且原本可用的资源也可能突然间变得不可用。\n\n## 5. 死锁的检测和预防\n\n### 5.1 死锁检测\n\n- 资源分配图\n- 死锁定理\n- 死锁检测算法\n\n### 5.2 死锁解除\n\n- 撤销所有死锁进程\n- 让死锁回撤到正常执行状态\n- 某顺序逐个撤销死锁进程，直至不发生死锁为止\n- 采用抢占资源的策略直到不再发生死锁\n\n### 5.3 代价最小原则\n\n- 发现时，消耗的CPU资源最小\n- 发现时，获得的系统资源最小\n- 发现时，产生的输出了最小\n- 优先级最低\n- 预计进程的剩余时间最长\n\n\n<br><br>\n\n***\n\n<br><br>\n\n**参考**\n[1]胡元义,黑新宏.操作系统原理. 北京: 电子工业出版社, 2018.\n\n","slug":"code/OS/死锁","published":1,"updated":"2020-07-15T13:38:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gs005x0w7tfozj01iw","content":"<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200625211117.png\" alt=\"思维导图\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h1><h2 id=\"1-例子\"><a href=\"#1-例子\" class=\"headerlink\" title=\"1. 例子\"></a>1. 例子</h2><h3 id=\"1-1-交通堵塞\"><a href=\"#1-1-交通堵塞\" class=\"headerlink\" title=\"1.1 交通堵塞\"></a>1.1 交通堵塞</h3><p>一个十字路口有东西南北4个方向的车流，假设没有红绿灯，又没有交警指挥，并且4个方向的排头车辆几乎同时到达十字路口，为了防止撞车都停了下来，形成交通阻塞。<br>交通死锁的含义就是两辆或两辆以上车辆中，<strong>每一辆都占用一条道路，而又等待另外一辆车释放道路资源而无法前进</strong>。</p>\n<h3 id=\"1-2-过河\"><a href=\"#1-2-过河\" class=\"headerlink\" title=\"1.2 过河\"></a>1.2 过河</h3><p>小河中铺了一串垫脚石用于过河，并且<strong>两个人在河中相遇且都不退让发生</strong>死锁。</p>\n<h2 id=\"2-定义\"><a href=\"#2-定义\" class=\"headerlink\" title=\"2. 定义\"></a>2. 定义</h2><h3 id=\"2-1-系统资源\"><a href=\"#2-1-系统资源\" class=\"headerlink\" title=\"2.1 系统资源\"></a>2.1 系统资源</h3><ul>\n<li><p>可抢占式资源</p>\n<p>某进程获得这一类资源后，该资源可以再被系统或其他进程使用；<br>CPU<br>主存</p>\n</li>\n<li><p>不可抢占式资源</p>\n<p>某进程获得这类资源后，该资源不能被其他进程使用，直到使用完成后才被他主动释放，只能互斥使用；<br>打印机<br>磁带机</p>\n</li>\n</ul>\n<h3 id=\"2-2-定义\"><a href=\"#2-2-定义\" class=\"headerlink\" title=\"2.2 定义\"></a>2.2 定义</h3><p>死锁是指<strong>多个进程在并发执行过程中因为争夺不可抢占资源而造成的一种僵局</strong>。当这种僵局发生时，相关进程都处于永远等待（阻塞）状态，若无外力作用，这组进程都将永远无法继续向前推进。</p>\n<h3 id=\"2-3-与死循环区别\"><a href=\"#2-3-与死循环区别\" class=\"headerlink\" title=\"2.3 与死循环区别\"></a>2.3 与死循环区别</h3><ul>\n<li>死锁具有偶然性</li>\n<li>发生死锁时，因为处于阻塞状态，所有没有占用cpu资源，但死循环会一直占用cpu资源</li>\n<li>死锁是多个进程之间因为争抢不可抢占式资源产生的，与操作系统的管理和资源调度有关；</li>\n<li>死循环是因为程序设计时的错误</li>\n</ul>\n<h3 id=\"2-4-与饥饿的不同\"><a href=\"#2-4-与饥饿的不同\" class=\"headerlink\" title=\"2.4 与饥饿的不同\"></a>2.4 与饥饿的不同</h3><p>本质区别：</p>\n<ul>\n<li>饥饿状态一旦得到所需资源，就可立即运行</li>\n<li>处于死锁的相关进程都在相互等待对方占用的系统资源而又不释放自己所占资源，所以造成彼此永远无法得到所需资源的现象。</li>\n</ul>\n<h2 id=\"3-产生原因和必要条件\"><a href=\"#3-产生原因和必要条件\" class=\"headerlink\" title=\"3. 产生原因和必要条件\"></a>3. 产生原因和必要条件</h2><h3 id=\"3-1-产生原因\"><a href=\"#3-1-产生原因\" class=\"headerlink\" title=\"3.1 产生原因\"></a>3.1 产生原因</h3><ul>\n<li>系统资源不足</li>\n<li>进程推进顺序不当</li>\n</ul>\n<h3 id=\"3-2-必要条件\"><a href=\"#3-2-必要条件\" class=\"headerlink\" title=\"3.2 必要条件\"></a>3.2 必要条件</h3><p>这几个条件并不是完全独立的</p>\n<ul>\n<li><p>互斥条件</p>\n<p>进程对所获的资源进行排他性的使用</p>\n</li>\n<li><p>请求保持条件</p>\n<p>得不到资源而阻塞时，并不释放自己占有的资源</p>\n</li>\n<li><p>不可抢占条件</p>\n<p>进程所获得的资源在未使用结束前不能被其他进程抢占</p>\n</li>\n<li><p>循环等待条件</p>\n<p>隐含着上面三个条件</p>\n</li>\n</ul>\n<h2 id=\"4-面对死锁问题\"><a href=\"#4-面对死锁问题\" class=\"headerlink\" title=\"4. 面对死锁问题\"></a>4. 面对死锁问题</h2><h3 id=\"4-1-预防\"><a href=\"#4-1-预防\" class=\"headerlink\" title=\"4.1 预防\"></a>4.1 预防</h3><h4 id=\"4-1-1-破坏请求和保持条件\"><a href=\"#4-1-1-破坏请求和保持条件\" class=\"headerlink\" title=\"4.1.1 破坏请求和保持条件\"></a>4.1.1 破坏请求和保持条件</h4><p>运行之前一次性申请他所需要的全部资源，并且在未获得全部资源前不投入运行，运行后也不再提出新的资源请求。         </p>\n<p>优点：</p>\n<ul>\n<li>安全 </li>\n<li>简单</li>\n<li>易于实现</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>系统资源严重浪费。某一资源在被使用完后，并不能被及时释放</li>\n<li>会加剧作业饥饿的现象</li>\n<li>进程运行前，系统并不知道它需要多少资源</li>\n</ul>\n<h4 id=\"4-1-2-破坏不可抢占条件\"><a href=\"#4-1-2-破坏不可抢占条件\" class=\"headerlink\" title=\"4.1.2 破坏不可抢占条件\"></a>4.1.2 破坏不可抢占条件</h4><p>根据需求逐个提出资源请求，当一个已经占有了某些资源的进程，且又提出新的资源请求而得不到满足处于阻塞情况下，必须释放已占有的资源<br>缺点：</p>\n<ul>\n<li>某些资源被抢占后可能会引发错误，因为不太容易恢复现场。</li>\n<li>比较复杂，代价太大</li>\n<li>可能存在某些进程的资源总是被抢占</li>\n</ul>\n<p>适用：</p>\n<ul>\n<li>CPU</li>\n<li>主存</li>\n</ul>\n<h4 id=\"4-1-3-破坏循环等待条件\"><a href=\"#4-1-3-破坏循环等待条件\" class=\"headerlink\" title=\"4.1.3 破坏循环等待条件\"></a>4.1.3 破坏循环等待条件</h4><p>采用资源有序分配策略，即将系统中所有资源进行编号，并规定进程申请资源时必须严格按照资源编号顺序进行</p>\n<p>缺点：</p>\n<ul>\n<li>进程实际适用资源顺序不一定和编号一致</li>\n<li>资源的不同编号方法对资源利用效率有影响</li>\n<li>资源编号必须相对稳定</li>\n<li>严格的资源编号使得用户编程的自主性收到限制</li>\n</ul>\n<h3 id=\"4-2-死锁的避免\"><a href=\"#4-2-死锁的避免\" class=\"headerlink\" title=\"4.2 死锁的避免\"></a>4.2 死锁的避免</h3><h3 id=\"4-2-1-银行家算法\"><a href=\"#4-2-1-银行家算法\" class=\"headerlink\" title=\"4.2.1 银行家算法\"></a>4.2.1 银行家算法</h3><p>通过几种<strong>预防死锁的方法尽管实现起来比较简单，但基本上都严重影响系统性能</strong>或可能会引起致命错误</p>\n<p>一个进程提出资源请求后，系统先进行资源的试分配，然后检查本次的试分配是否使系统处于安全状态，若安全则按试分配方案分配资源，否则不分配资源。</p>\n<p>银行家算法缺少实用价值：很少有进程能够在运行之前就知道其所需资源的最大值，而且进程数不是固定的，往往在不断变化，况且原本可用的资源也可能突然间变得不可用。</p>\n<h2 id=\"5-死锁的检测和预防\"><a href=\"#5-死锁的检测和预防\" class=\"headerlink\" title=\"5. 死锁的检测和预防\"></a>5. 死锁的检测和预防</h2><h3 id=\"5-1-死锁检测\"><a href=\"#5-1-死锁检测\" class=\"headerlink\" title=\"5.1 死锁检测\"></a>5.1 死锁检测</h3><ul>\n<li>资源分配图</li>\n<li>死锁定理</li>\n<li>死锁检测算法</li>\n</ul>\n<h3 id=\"5-2-死锁解除\"><a href=\"#5-2-死锁解除\" class=\"headerlink\" title=\"5.2 死锁解除\"></a>5.2 死锁解除</h3><ul>\n<li>撤销所有死锁进程</li>\n<li>让死锁回撤到正常执行状态</li>\n<li>某顺序逐个撤销死锁进程，直至不发生死锁为止</li>\n<li>采用抢占资源的策略直到不再发生死锁</li>\n</ul>\n<h3 id=\"5-3-代价最小原则\"><a href=\"#5-3-代价最小原则\" class=\"headerlink\" title=\"5.3 代价最小原则\"></a>5.3 代价最小原则</h3><ul>\n<li>发现时，消耗的CPU资源最小</li>\n<li>发现时，获得的系统资源最小</li>\n<li>发现时，产生的输出了最小</li>\n<li>优先级最低</li>\n<li>预计进程的剩余时间最长</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<p><strong>参考</strong><br>[1]胡元义,黑新宏.操作系统原理. 北京: 电子工业出版社, 2018.</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200625211117.png\" alt=\"思维导图\"></p>","more":"<h1 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h1><h2 id=\"1-例子\"><a href=\"#1-例子\" class=\"headerlink\" title=\"1. 例子\"></a>1. 例子</h2><h3 id=\"1-1-交通堵塞\"><a href=\"#1-1-交通堵塞\" class=\"headerlink\" title=\"1.1 交通堵塞\"></a>1.1 交通堵塞</h3><p>一个十字路口有东西南北4个方向的车流，假设没有红绿灯，又没有交警指挥，并且4个方向的排头车辆几乎同时到达十字路口，为了防止撞车都停了下来，形成交通阻塞。<br>交通死锁的含义就是两辆或两辆以上车辆中，<strong>每一辆都占用一条道路，而又等待另外一辆车释放道路资源而无法前进</strong>。</p>\n<h3 id=\"1-2-过河\"><a href=\"#1-2-过河\" class=\"headerlink\" title=\"1.2 过河\"></a>1.2 过河</h3><p>小河中铺了一串垫脚石用于过河，并且<strong>两个人在河中相遇且都不退让发生</strong>死锁。</p>\n<h2 id=\"2-定义\"><a href=\"#2-定义\" class=\"headerlink\" title=\"2. 定义\"></a>2. 定义</h2><h3 id=\"2-1-系统资源\"><a href=\"#2-1-系统资源\" class=\"headerlink\" title=\"2.1 系统资源\"></a>2.1 系统资源</h3><ul>\n<li><p>可抢占式资源</p>\n<p>某进程获得这一类资源后，该资源可以再被系统或其他进程使用；<br>CPU<br>主存</p>\n</li>\n<li><p>不可抢占式资源</p>\n<p>某进程获得这类资源后，该资源不能被其他进程使用，直到使用完成后才被他主动释放，只能互斥使用；<br>打印机<br>磁带机</p>\n</li>\n</ul>\n<h3 id=\"2-2-定义\"><a href=\"#2-2-定义\" class=\"headerlink\" title=\"2.2 定义\"></a>2.2 定义</h3><p>死锁是指<strong>多个进程在并发执行过程中因为争夺不可抢占资源而造成的一种僵局</strong>。当这种僵局发生时，相关进程都处于永远等待（阻塞）状态，若无外力作用，这组进程都将永远无法继续向前推进。</p>\n<h3 id=\"2-3-与死循环区别\"><a href=\"#2-3-与死循环区别\" class=\"headerlink\" title=\"2.3 与死循环区别\"></a>2.3 与死循环区别</h3><ul>\n<li>死锁具有偶然性</li>\n<li>发生死锁时，因为处于阻塞状态，所有没有占用cpu资源，但死循环会一直占用cpu资源</li>\n<li>死锁是多个进程之间因为争抢不可抢占式资源产生的，与操作系统的管理和资源调度有关；</li>\n<li>死循环是因为程序设计时的错误</li>\n</ul>\n<h3 id=\"2-4-与饥饿的不同\"><a href=\"#2-4-与饥饿的不同\" class=\"headerlink\" title=\"2.4 与饥饿的不同\"></a>2.4 与饥饿的不同</h3><p>本质区别：</p>\n<ul>\n<li>饥饿状态一旦得到所需资源，就可立即运行</li>\n<li>处于死锁的相关进程都在相互等待对方占用的系统资源而又不释放自己所占资源，所以造成彼此永远无法得到所需资源的现象。</li>\n</ul>\n<h2 id=\"3-产生原因和必要条件\"><a href=\"#3-产生原因和必要条件\" class=\"headerlink\" title=\"3. 产生原因和必要条件\"></a>3. 产生原因和必要条件</h2><h3 id=\"3-1-产生原因\"><a href=\"#3-1-产生原因\" class=\"headerlink\" title=\"3.1 产生原因\"></a>3.1 产生原因</h3><ul>\n<li>系统资源不足</li>\n<li>进程推进顺序不当</li>\n</ul>\n<h3 id=\"3-2-必要条件\"><a href=\"#3-2-必要条件\" class=\"headerlink\" title=\"3.2 必要条件\"></a>3.2 必要条件</h3><p>这几个条件并不是完全独立的</p>\n<ul>\n<li><p>互斥条件</p>\n<p>进程对所获的资源进行排他性的使用</p>\n</li>\n<li><p>请求保持条件</p>\n<p>得不到资源而阻塞时，并不释放自己占有的资源</p>\n</li>\n<li><p>不可抢占条件</p>\n<p>进程所获得的资源在未使用结束前不能被其他进程抢占</p>\n</li>\n<li><p>循环等待条件</p>\n<p>隐含着上面三个条件</p>\n</li>\n</ul>\n<h2 id=\"4-面对死锁问题\"><a href=\"#4-面对死锁问题\" class=\"headerlink\" title=\"4. 面对死锁问题\"></a>4. 面对死锁问题</h2><h3 id=\"4-1-预防\"><a href=\"#4-1-预防\" class=\"headerlink\" title=\"4.1 预防\"></a>4.1 预防</h3><h4 id=\"4-1-1-破坏请求和保持条件\"><a href=\"#4-1-1-破坏请求和保持条件\" class=\"headerlink\" title=\"4.1.1 破坏请求和保持条件\"></a>4.1.1 破坏请求和保持条件</h4><p>运行之前一次性申请他所需要的全部资源，并且在未获得全部资源前不投入运行，运行后也不再提出新的资源请求。         </p>\n<p>优点：</p>\n<ul>\n<li>安全 </li>\n<li>简单</li>\n<li>易于实现</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>系统资源严重浪费。某一资源在被使用完后，并不能被及时释放</li>\n<li>会加剧作业饥饿的现象</li>\n<li>进程运行前，系统并不知道它需要多少资源</li>\n</ul>\n<h4 id=\"4-1-2-破坏不可抢占条件\"><a href=\"#4-1-2-破坏不可抢占条件\" class=\"headerlink\" title=\"4.1.2 破坏不可抢占条件\"></a>4.1.2 破坏不可抢占条件</h4><p>根据需求逐个提出资源请求，当一个已经占有了某些资源的进程，且又提出新的资源请求而得不到满足处于阻塞情况下，必须释放已占有的资源<br>缺点：</p>\n<ul>\n<li>某些资源被抢占后可能会引发错误，因为不太容易恢复现场。</li>\n<li>比较复杂，代价太大</li>\n<li>可能存在某些进程的资源总是被抢占</li>\n</ul>\n<p>适用：</p>\n<ul>\n<li>CPU</li>\n<li>主存</li>\n</ul>\n<h4 id=\"4-1-3-破坏循环等待条件\"><a href=\"#4-1-3-破坏循环等待条件\" class=\"headerlink\" title=\"4.1.3 破坏循环等待条件\"></a>4.1.3 破坏循环等待条件</h4><p>采用资源有序分配策略，即将系统中所有资源进行编号，并规定进程申请资源时必须严格按照资源编号顺序进行</p>\n<p>缺点：</p>\n<ul>\n<li>进程实际适用资源顺序不一定和编号一致</li>\n<li>资源的不同编号方法对资源利用效率有影响</li>\n<li>资源编号必须相对稳定</li>\n<li>严格的资源编号使得用户编程的自主性收到限制</li>\n</ul>\n<h3 id=\"4-2-死锁的避免\"><a href=\"#4-2-死锁的避免\" class=\"headerlink\" title=\"4.2 死锁的避免\"></a>4.2 死锁的避免</h3><h3 id=\"4-2-1-银行家算法\"><a href=\"#4-2-1-银行家算法\" class=\"headerlink\" title=\"4.2.1 银行家算法\"></a>4.2.1 银行家算法</h3><p>通过几种<strong>预防死锁的方法尽管实现起来比较简单，但基本上都严重影响系统性能</strong>或可能会引起致命错误</p>\n<p>一个进程提出资源请求后，系统先进行资源的试分配，然后检查本次的试分配是否使系统处于安全状态，若安全则按试分配方案分配资源，否则不分配资源。</p>\n<p>银行家算法缺少实用价值：很少有进程能够在运行之前就知道其所需资源的最大值，而且进程数不是固定的，往往在不断变化，况且原本可用的资源也可能突然间变得不可用。</p>\n<h2 id=\"5-死锁的检测和预防\"><a href=\"#5-死锁的检测和预防\" class=\"headerlink\" title=\"5. 死锁的检测和预防\"></a>5. 死锁的检测和预防</h2><h3 id=\"5-1-死锁检测\"><a href=\"#5-1-死锁检测\" class=\"headerlink\" title=\"5.1 死锁检测\"></a>5.1 死锁检测</h3><ul>\n<li>资源分配图</li>\n<li>死锁定理</li>\n<li>死锁检测算法</li>\n</ul>\n<h3 id=\"5-2-死锁解除\"><a href=\"#5-2-死锁解除\" class=\"headerlink\" title=\"5.2 死锁解除\"></a>5.2 死锁解除</h3><ul>\n<li>撤销所有死锁进程</li>\n<li>让死锁回撤到正常执行状态</li>\n<li>某顺序逐个撤销死锁进程，直至不发生死锁为止</li>\n<li>采用抢占资源的策略直到不再发生死锁</li>\n</ul>\n<h3 id=\"5-3-代价最小原则\"><a href=\"#5-3-代价最小原则\" class=\"headerlink\" title=\"5.3 代价最小原则\"></a>5.3 代价最小原则</h3><ul>\n<li>发现时，消耗的CPU资源最小</li>\n<li>发现时，获得的系统资源最小</li>\n<li>发现时，产生的输出了最小</li>\n<li>优先级最低</li>\n<li>预计进程的剩余时间最长</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<p><strong>参考</strong><br>[1]胡元义,黑新宏.操作系统原理. 北京: 电子工业出版社, 2018.</p>"},{"title":"进程与线程","declare":true,"wordCount":true,"abbrlink":"eefe591f","date":"2020-07-16T11:10:10.000Z","_content":"\n为了有效地管理CPU,操作系统引入了线程的概念，即以进程为基本单位来实现CPU的分配与执行。随着并行处理技术的发展，为了进一步提高系统的并行性，实现进程内部的并发执行，操作系统又引入了线程的概念。这样，CPU的管理最终归结于对进程和线程的管理。\n![进程与线程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/进程与线程.png)\n\n<!-- more -->\n\n# 一、进程\n程序是一个在时间方向上严格按照先后次序实现算法功能的指令序列。\n\n## 1.1 程序的顺序执行和并发执行\n\n### 1.1 顺序执行\n一个具有独立功能的程序独占CPU运行，直到获得最终结果的过程。\n* **顺序性**。 每个操作都必须在前一个操作结束后才能开始\n* **封闭性**。 程序一旦开始运行，其运行结果不会受到外界因素的影响\n* **可再现性**。 程序运行结果仅由初始结果和程序本身的操作决定\n\n### 1.1.2 并发执行\n在计算机引入**通道和中断**机制后，就使得CPU和外部设备之间，以及外部设备与外部设备之间可以并行操作，使得多道程序设计成为可能。      \n\n在同一时刻，有的程序占用CPU运行，有的程序通过外部设备传递数据。**从宏观上看是多个设备同时运行，从微观上来看它们是在交替运行。**\n\n因此，程序并发执行环境下的计算机资源，已不再被某一个用户程序所独占，而是由多个并发执行的程序所共享。虽然提高了资源的利用率，但在另外一方面却**引发了多个并发程序对资源的竞争导致了程序执行环境与运行速度的改变，从而可能产生程序运行结果不唯一的情况。**\n\n* **间断性**\n* **无封闭性**\n* **不可再现性**\n\n***\n<br>\n\n## 1.2 进程的定义\n**程序的一个动态执行过程**\n\n结构：\n进程实体=程序段+相关数据段+PCB(进程控制块) \n\n\n## 1.4 进程的特点\n\n* 动态性。 进程具有生命期，具有“创建-运行-消亡”这样一个过程\n* 并发性。 多个进程能够在一段时间内并发执行\n* 独立性。 每个进程都是一个独立运行的基本单位，也是**系统进行资源分配和调度的基本单位**\n* 异步性。 任何时刻只能有一个进程占用CPU，具有“执行-暂停-执行”这种间断性规律\n* 结构性。 由程序段、相关数据段、PCB三部分组成\n\n\n***\n\n<br>\n\n## 1.5 进程和程序的区别\n**程序像是一个乐谱**，任何时候都可以翻阅它，但乐谱本身是静态的。    \n**进程则可以看做是乐谱的一次演奏**，具有生命周期，并随着时间的流逝，演奏的音乐将不复存在，即使是重现演奏这个乐谱，也不是刚刚逝去的那段音乐。\n\n同一程序的不同进程，则像是同卵双胞胎的不同人生。\n\n**程序和进程并无一一对应关系**。同一程序可以产生多个进程，一个进程也可包含多个程序。\n\n***\n\n<br>\n\n## 1.6 进程的状态及转换\n![进程五状态模型](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/进程五状态模型.png)\n\n1. 新建\n    当需要创建一个新进程时，系统为该进程分配一个进程控制块PCB，并为该进程分配内存空间，且装入该进程对应的程序和有关数据。\n\n2. 就绪\n    **进程得到除了CPU之外的所需资源，一旦得到CPU资源既可以立即投入运行**。\n\n3. 运行\n    进程获得了CUP和其他所需要的资源，目前正在CPU上运行\n\n4. 阻塞\n    **进程 运行 过程中发生了某种等待事件（比如发生了I/O操作）而暂时不能运行的状态**。即使把CPU资源分配给它也不能够运行。\n\n5. 结束\n    系统逐步释放为为其分配的资源，最后释放其PCB.\n\n \n> 核心的三状态就比如一个游乐场，一群小朋友进入游乐场排序玩一个滑梯     \n> * 排队的小朋友就处于就绪转态    \n> * 玩滑梯的那一个小朋友就处于运行状态    \n> * 每个小朋友只能玩5分钟，时间到了就得重新排序    \n> * 如果小朋友**在玩滑梯的过程中**需要上厕所，那么上厕所的过程就是阻塞状态，上厕所结束后则需要重新排队（就绪）\n\n<br>\n\n![七状态进程模型](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/七状态进程模型.png)\n\n上面的5状态进程模型中，新创建的进程一旦被系统接纳都一直存在于内存中，直到被终止。在这种情况下，**系统内存资源会变得越来越紧张**，此外由于CPU速度远超于I/O等操作速度，**内存中就会存在大多数进程等待I/O操作而CPU空闲的现象**。为此可以采用交换技术，将内存中暂时不能运行的某些进程挂起，释放所占用的内存资源，以便于重新接纳一个新进程或外存上已具备运行条件的进程进入内存就绪队列。**进程挂起即将内存中的进程暂时移出到外存（如磁盘）中的过程。**\n>现代操作系统只是将进程的某些页放到外存上去\n\n<br><br>\n***\n<br><br>\n\n# 二、进程同步与通信\n## 2.1 进程的同步与互斥\n### 2.1.1 进程同步\n\n某些进程之间在逻辑上的相互制约关系，即若干进程为了完成某一个共同任务和相互合作。\n\n### 2.1.2 进程互斥\n某一资源同一时间只允许一个进程对其访问，这种访问具有唯一性和排他性。\n\n***\n<br>\n\n## 2.2 临界资源和临界区\n系统中同时存在着许多进程，它们共享着各种资源。然而许多资源在某一时刻只能允许一个进程使用，如打印机，磁带机等硬件设备，软件中的变量、队列等数据结构。如果多个进程同时使用这类资源就会造成混乱。因此必须保护这些资源，避免两个或多个进程同时访问这些资源。\n\n**把同一时刻只允许一个进程使用的资源成为临界资源。**\n\n对临界资源的访问必须互斥进行，即各个进程对同一临界资源进行先从操作的程序段也应互斥进行，只有这样才能保证对临界资源的互斥访问。**把进程中访问临界资源的代码称为临界区。**\n\n对于临界资源的访问必须互斥进行，**所以进程在进入临界区时首先判断是否有其他进程在使用此临界资源，如果有，则该进程必须等待；如果没有，则该进程才能进入临界区执行临界区代码，同时还要关闭临界区以防止其他进程进入。当进程使用完临界资源时，要开放临界区以便其他进程进入。**\n\n![](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/临界区代码结构.png)\n\n***\n\n<br>\n\n## 2.3 实现进程互斥的硬件方法\n### 2.3.1 开关中断指令\n又称硬件锁，进程在进入临界区之前，先执行“关中断”指令来屏蔽掉所有中断，进程完成所有临界区的任务后，再执行“开中断”指令将中断打开。\n\n开关中断时间过长会导致系统效率降低。\n\n### 2.3.2 测试与设置指令\n为每一个临界资源设置一个整型变量s，若s为0，则表示没有进程访问该临界资源，若s为1则表示该临界资源已经被某个进程占用。\n\n利用TS指令可以实现临界区的开锁和关锁原语操作，进入临界区之前先使用TS指令测试s，若s为0则表明没有进程使用临界资源，于是本进程进入临界区，**否则必须循环测试直至s的值为0**。\n>原语：一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。（原子操作）\n\n### 2.3.3 交换指令\n若要使用交换指令来实现进程互斥，则需要为每个临界资源设置一个整型变量s，若s为0，则表示没有进程访问该临界资源，若s为1则表示该临界资源已经被某个进程占用。此外，还有设置一个整型局部变量key,只有当s为0且key为1时，进程才能进入临界区，进入临界区后，s的值为1且key的值为0。\n\nTS和SWAP指令都能方便地实现进程互斥，但都存在过多循环测试s的值而引起的系统资源消耗问题。\n\n\n***\n<br>\n\n## 2.4 实现进程互斥的软件方法\n### 2.4.1 两标志进程互斥算法\n不能很好解决两个进程同时到达的问题\n\n### 2.4.2 三标志进程互斥算法\n扩展性较差，进程一多久复杂了，效率变低\n\n***\n<br>\n\n## 2.5 信号量机制\n在操作系统中，信号量代表了一类物理资源，它是相应物理资源的抽象。具体实现时，信号量被定义为具有某种类型的变量，通常为整型或者其他结构体类型。\n\n**value变量**：     \nvalue的初值是一个非负整数，代表着系统中某类资源的数量，随着该资源的不断被分配，value的值也随之发生变化，会出现以下三种情况：\n* value>0，代表该类资源当前的可用数量  \n* value=0，表示该资源为空\n* value<0，**其绝对值代表因等待该资源而阻塞的进程数量**\n\n**P操作（发信号）**：\n* 执行一此P操作就相当于申请一个资源S\n    * 若S>0，则意味着系统中有可用资源S,并将其分配，且将S的资源可用数量value减1\n    * 若S<=0，表示当前系统已无资源S可用，立即将当前运行进程阻塞起来，并插入到S.L的进程阻塞队列中去\n\n**V操作（等待）**：\n* 执行一次V操作相当于释放一个资源S,将资源S的value值加1\n* 若S.value加1后其值仍小于等于0，则表明仍有处于阻塞状态的进程在等待资源S，于是将S.L所指进程阻塞队列中的第一个阻塞进程唤醒并将刚刚回收的资源S分配给它。\n\n    \n\nP、V信号量**解决了进程主动进行循环测试消耗系统资源的问题**。因为这种协调的本质是当出现资源竞争的冲突时，就将原来并发执行的多个进程在P、V操作的协调下变为**依次顺序执行**，**当资源冲突结束后又恢复为并发执行。**\n\n<br><br>\n***\n<br><br>\n\n# 三、线程\n\n进程就如我们在一台旧电视上看节目，如果两个频道正在直播不同的精彩节目，我们只能在这两个频道之间来回切换选择观看的内容（相当于进程的切换）。这就是进程的缺点，**它在一个时间段内只能做一件事情**，如果想要同时做两件或者多件事情，进程就不够用了。此外，如果**进程在执行过程中因等待输入输入数据而阻塞**，且这时进程还有一些不依赖于输入的其他工作可以做，但由于进程的阻塞而无法进行。\n\n线程就是为了解决上述两个缺陷而解决的，例如**新电视可以将两个频道或多个频道同时显示在同一块屏幕上**（分屏），这就是线程的方式。例如**使用WPS时，实际上是打开了多线程，一个线程负责显示，一个线程负责输入，一个线程负责定时存盘......** 这些线程一起运转，使我们觉得输入和显示同时发生，而不是键入一些文字，等待一会儿再显示到屏幕上。\n\n>多线程，在一个口罩工厂中建立多个生产线生产口罩 （一个进程内的多个线程）\n\n>并行：同一时刻，多个执行流都拥有一个CPU同时在计算     \n>并发：多个执行流，每个执行流独占CPU一会儿进行计算，按照时间片轮转法分配运行时间\n## 3.1 线程的引入\n\n在操作系统中引入进程后，使得原来不能并发执行的程序变成能够并发执行的进程，从而改善了资源的利用率和系统吞吐量。此时，**进程既是资源分配的基本单位，也是独立调度、独立运行的基本单位。**\n\n然而，正是由于进程扮演了这两种角色，导致了**进程的并发执行产生了很大的时空开销**，因为他要完成如下操作：     \n1. 创建进程\n2. 进程切换\n3. 撤销进程\n\n上述操作占用不少的CPU资源（尤其是进程切换），为此有一个想法是**将进程承担的两个角色分开**。\n\n此外，多CPU的计算机系统的出现，对于**原有的进程执行方式增加CPU并不能提高一个进程的执行效率。**  ***将一个进程分解为多个线程，这样就可以让多个线程同时运行在不同的CPU上。*** 此时，*线程是CPU调度和执行的最小单元*\n\n***\n<br><br>\n\n## 3.2 线程的定义\n* 进程内的一个执行单元\n* 进程内的一个可独立调度的实体\n* 进程内的一个相对独立的控制流序列\n* 执行的上下文\n\n属性：\n* 线程属于轻型实体，**基本不拥有系统资源**\n* **线程是独立调度和分配的基本单位，也是能够独立运行的基本单位**\n* 同一个进程的所有线程共享该进程的所拥有的全部资源\n* 线程的并发执行程度高，**不但同一进程的多个线程可以并发执行，甚至属于不同进程的多个线程也可以并发执行**\n\n与进程类似，线程也有生命周期，也存在 执行、就绪和阻塞这三种基本状态，这是因为线程完全继承了进程的运行属性，因此**线程的三种状态含义和转换关系与进程相同**。由于线程不是资源的拥有单位，因此**挂起状态对单个线程没有意义**。\n\n在多线程操作系统中，为了使并发的多个线程能够有条不紊地运行，操作系统必须提供用于线程间互斥和同步的机制：\n* **互斥锁**，每次只允许一个线程来执行特定的代码或访问特定的数据。\n* **读写锁**，对受保护的共享资源进行并发读取和独占写入。\n* **条件变量**，一直阻塞线程，直到特定的条件为真。 \n* **奇数信号量**，用来协调对资源的访问，达到指定的计数时信号将阻塞。\n\n***\n<br><br>\n\n## 3.3 线程与进程\n线程有由于有很多进程的特性，因此有人将它称为轻量级进程，而将传统进程称为重量级进程。\n\n差异：\n* 新建、切换和撤销一个线程所花费的时空消耗远小于新建、切换和撤销一个进程的时空开销\n* 进程是资源分配的最小单元，而线程不是，同一进程的多个线程可以共享资源\n\n\n\n\n\n\n\n\n\n\n\n\n<br><br><br>\n\n***\n\n<br><br><br>\n\n**参考**      \n[1]胡元义,黑新宏.操作系统原理. 北京: 电子工业出版社, 2018.\n[2]https://blog.csdn.net/jinixin/article/details/90345661\n\n\n\n","source":"_posts/code/OS/进程同步与通信.md","raw":"---\ntitle: 进程与线程\ncategories: Code\ntags: OS\ndeclare: true\nwordCount: true\nabbrlink: eefe591f\ndate: 2020-07-16 19:10:10\n---\n\n为了有效地管理CPU,操作系统引入了线程的概念，即以进程为基本单位来实现CPU的分配与执行。随着并行处理技术的发展，为了进一步提高系统的并行性，实现进程内部的并发执行，操作系统又引入了线程的概念。这样，CPU的管理最终归结于对进程和线程的管理。\n![进程与线程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/进程与线程.png)\n\n<!-- more -->\n\n# 一、进程\n程序是一个在时间方向上严格按照先后次序实现算法功能的指令序列。\n\n## 1.1 程序的顺序执行和并发执行\n\n### 1.1 顺序执行\n一个具有独立功能的程序独占CPU运行，直到获得最终结果的过程。\n* **顺序性**。 每个操作都必须在前一个操作结束后才能开始\n* **封闭性**。 程序一旦开始运行，其运行结果不会受到外界因素的影响\n* **可再现性**。 程序运行结果仅由初始结果和程序本身的操作决定\n\n### 1.1.2 并发执行\n在计算机引入**通道和中断**机制后，就使得CPU和外部设备之间，以及外部设备与外部设备之间可以并行操作，使得多道程序设计成为可能。      \n\n在同一时刻，有的程序占用CPU运行，有的程序通过外部设备传递数据。**从宏观上看是多个设备同时运行，从微观上来看它们是在交替运行。**\n\n因此，程序并发执行环境下的计算机资源，已不再被某一个用户程序所独占，而是由多个并发执行的程序所共享。虽然提高了资源的利用率，但在另外一方面却**引发了多个并发程序对资源的竞争导致了程序执行环境与运行速度的改变，从而可能产生程序运行结果不唯一的情况。**\n\n* **间断性**\n* **无封闭性**\n* **不可再现性**\n\n***\n<br>\n\n## 1.2 进程的定义\n**程序的一个动态执行过程**\n\n结构：\n进程实体=程序段+相关数据段+PCB(进程控制块) \n\n\n## 1.4 进程的特点\n\n* 动态性。 进程具有生命期，具有“创建-运行-消亡”这样一个过程\n* 并发性。 多个进程能够在一段时间内并发执行\n* 独立性。 每个进程都是一个独立运行的基本单位，也是**系统进行资源分配和调度的基本单位**\n* 异步性。 任何时刻只能有一个进程占用CPU，具有“执行-暂停-执行”这种间断性规律\n* 结构性。 由程序段、相关数据段、PCB三部分组成\n\n\n***\n\n<br>\n\n## 1.5 进程和程序的区别\n**程序像是一个乐谱**，任何时候都可以翻阅它，但乐谱本身是静态的。    \n**进程则可以看做是乐谱的一次演奏**，具有生命周期，并随着时间的流逝，演奏的音乐将不复存在，即使是重现演奏这个乐谱，也不是刚刚逝去的那段音乐。\n\n同一程序的不同进程，则像是同卵双胞胎的不同人生。\n\n**程序和进程并无一一对应关系**。同一程序可以产生多个进程，一个进程也可包含多个程序。\n\n***\n\n<br>\n\n## 1.6 进程的状态及转换\n![进程五状态模型](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/进程五状态模型.png)\n\n1. 新建\n    当需要创建一个新进程时，系统为该进程分配一个进程控制块PCB，并为该进程分配内存空间，且装入该进程对应的程序和有关数据。\n\n2. 就绪\n    **进程得到除了CPU之外的所需资源，一旦得到CPU资源既可以立即投入运行**。\n\n3. 运行\n    进程获得了CUP和其他所需要的资源，目前正在CPU上运行\n\n4. 阻塞\n    **进程 运行 过程中发生了某种等待事件（比如发生了I/O操作）而暂时不能运行的状态**。即使把CPU资源分配给它也不能够运行。\n\n5. 结束\n    系统逐步释放为为其分配的资源，最后释放其PCB.\n\n \n> 核心的三状态就比如一个游乐场，一群小朋友进入游乐场排序玩一个滑梯     \n> * 排队的小朋友就处于就绪转态    \n> * 玩滑梯的那一个小朋友就处于运行状态    \n> * 每个小朋友只能玩5分钟，时间到了就得重新排序    \n> * 如果小朋友**在玩滑梯的过程中**需要上厕所，那么上厕所的过程就是阻塞状态，上厕所结束后则需要重新排队（就绪）\n\n<br>\n\n![七状态进程模型](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/七状态进程模型.png)\n\n上面的5状态进程模型中，新创建的进程一旦被系统接纳都一直存在于内存中，直到被终止。在这种情况下，**系统内存资源会变得越来越紧张**，此外由于CPU速度远超于I/O等操作速度，**内存中就会存在大多数进程等待I/O操作而CPU空闲的现象**。为此可以采用交换技术，将内存中暂时不能运行的某些进程挂起，释放所占用的内存资源，以便于重新接纳一个新进程或外存上已具备运行条件的进程进入内存就绪队列。**进程挂起即将内存中的进程暂时移出到外存（如磁盘）中的过程。**\n>现代操作系统只是将进程的某些页放到外存上去\n\n<br><br>\n***\n<br><br>\n\n# 二、进程同步与通信\n## 2.1 进程的同步与互斥\n### 2.1.1 进程同步\n\n某些进程之间在逻辑上的相互制约关系，即若干进程为了完成某一个共同任务和相互合作。\n\n### 2.1.2 进程互斥\n某一资源同一时间只允许一个进程对其访问，这种访问具有唯一性和排他性。\n\n***\n<br>\n\n## 2.2 临界资源和临界区\n系统中同时存在着许多进程，它们共享着各种资源。然而许多资源在某一时刻只能允许一个进程使用，如打印机，磁带机等硬件设备，软件中的变量、队列等数据结构。如果多个进程同时使用这类资源就会造成混乱。因此必须保护这些资源，避免两个或多个进程同时访问这些资源。\n\n**把同一时刻只允许一个进程使用的资源成为临界资源。**\n\n对临界资源的访问必须互斥进行，即各个进程对同一临界资源进行先从操作的程序段也应互斥进行，只有这样才能保证对临界资源的互斥访问。**把进程中访问临界资源的代码称为临界区。**\n\n对于临界资源的访问必须互斥进行，**所以进程在进入临界区时首先判断是否有其他进程在使用此临界资源，如果有，则该进程必须等待；如果没有，则该进程才能进入临界区执行临界区代码，同时还要关闭临界区以防止其他进程进入。当进程使用完临界资源时，要开放临界区以便其他进程进入。**\n\n![](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/临界区代码结构.png)\n\n***\n\n<br>\n\n## 2.3 实现进程互斥的硬件方法\n### 2.3.1 开关中断指令\n又称硬件锁，进程在进入临界区之前，先执行“关中断”指令来屏蔽掉所有中断，进程完成所有临界区的任务后，再执行“开中断”指令将中断打开。\n\n开关中断时间过长会导致系统效率降低。\n\n### 2.3.2 测试与设置指令\n为每一个临界资源设置一个整型变量s，若s为0，则表示没有进程访问该临界资源，若s为1则表示该临界资源已经被某个进程占用。\n\n利用TS指令可以实现临界区的开锁和关锁原语操作，进入临界区之前先使用TS指令测试s，若s为0则表明没有进程使用临界资源，于是本进程进入临界区，**否则必须循环测试直至s的值为0**。\n>原语：一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。（原子操作）\n\n### 2.3.3 交换指令\n若要使用交换指令来实现进程互斥，则需要为每个临界资源设置一个整型变量s，若s为0，则表示没有进程访问该临界资源，若s为1则表示该临界资源已经被某个进程占用。此外，还有设置一个整型局部变量key,只有当s为0且key为1时，进程才能进入临界区，进入临界区后，s的值为1且key的值为0。\n\nTS和SWAP指令都能方便地实现进程互斥，但都存在过多循环测试s的值而引起的系统资源消耗问题。\n\n\n***\n<br>\n\n## 2.4 实现进程互斥的软件方法\n### 2.4.1 两标志进程互斥算法\n不能很好解决两个进程同时到达的问题\n\n### 2.4.2 三标志进程互斥算法\n扩展性较差，进程一多久复杂了，效率变低\n\n***\n<br>\n\n## 2.5 信号量机制\n在操作系统中，信号量代表了一类物理资源，它是相应物理资源的抽象。具体实现时，信号量被定义为具有某种类型的变量，通常为整型或者其他结构体类型。\n\n**value变量**：     \nvalue的初值是一个非负整数，代表着系统中某类资源的数量，随着该资源的不断被分配，value的值也随之发生变化，会出现以下三种情况：\n* value>0，代表该类资源当前的可用数量  \n* value=0，表示该资源为空\n* value<0，**其绝对值代表因等待该资源而阻塞的进程数量**\n\n**P操作（发信号）**：\n* 执行一此P操作就相当于申请一个资源S\n    * 若S>0，则意味着系统中有可用资源S,并将其分配，且将S的资源可用数量value减1\n    * 若S<=0，表示当前系统已无资源S可用，立即将当前运行进程阻塞起来，并插入到S.L的进程阻塞队列中去\n\n**V操作（等待）**：\n* 执行一次V操作相当于释放一个资源S,将资源S的value值加1\n* 若S.value加1后其值仍小于等于0，则表明仍有处于阻塞状态的进程在等待资源S，于是将S.L所指进程阻塞队列中的第一个阻塞进程唤醒并将刚刚回收的资源S分配给它。\n\n    \n\nP、V信号量**解决了进程主动进行循环测试消耗系统资源的问题**。因为这种协调的本质是当出现资源竞争的冲突时，就将原来并发执行的多个进程在P、V操作的协调下变为**依次顺序执行**，**当资源冲突结束后又恢复为并发执行。**\n\n<br><br>\n***\n<br><br>\n\n# 三、线程\n\n进程就如我们在一台旧电视上看节目，如果两个频道正在直播不同的精彩节目，我们只能在这两个频道之间来回切换选择观看的内容（相当于进程的切换）。这就是进程的缺点，**它在一个时间段内只能做一件事情**，如果想要同时做两件或者多件事情，进程就不够用了。此外，如果**进程在执行过程中因等待输入输入数据而阻塞**，且这时进程还有一些不依赖于输入的其他工作可以做，但由于进程的阻塞而无法进行。\n\n线程就是为了解决上述两个缺陷而解决的，例如**新电视可以将两个频道或多个频道同时显示在同一块屏幕上**（分屏），这就是线程的方式。例如**使用WPS时，实际上是打开了多线程，一个线程负责显示，一个线程负责输入，一个线程负责定时存盘......** 这些线程一起运转，使我们觉得输入和显示同时发生，而不是键入一些文字，等待一会儿再显示到屏幕上。\n\n>多线程，在一个口罩工厂中建立多个生产线生产口罩 （一个进程内的多个线程）\n\n>并行：同一时刻，多个执行流都拥有一个CPU同时在计算     \n>并发：多个执行流，每个执行流独占CPU一会儿进行计算，按照时间片轮转法分配运行时间\n## 3.1 线程的引入\n\n在操作系统中引入进程后，使得原来不能并发执行的程序变成能够并发执行的进程，从而改善了资源的利用率和系统吞吐量。此时，**进程既是资源分配的基本单位，也是独立调度、独立运行的基本单位。**\n\n然而，正是由于进程扮演了这两种角色，导致了**进程的并发执行产生了很大的时空开销**，因为他要完成如下操作：     \n1. 创建进程\n2. 进程切换\n3. 撤销进程\n\n上述操作占用不少的CPU资源（尤其是进程切换），为此有一个想法是**将进程承担的两个角色分开**。\n\n此外，多CPU的计算机系统的出现，对于**原有的进程执行方式增加CPU并不能提高一个进程的执行效率。**  ***将一个进程分解为多个线程，这样就可以让多个线程同时运行在不同的CPU上。*** 此时，*线程是CPU调度和执行的最小单元*\n\n***\n<br><br>\n\n## 3.2 线程的定义\n* 进程内的一个执行单元\n* 进程内的一个可独立调度的实体\n* 进程内的一个相对独立的控制流序列\n* 执行的上下文\n\n属性：\n* 线程属于轻型实体，**基本不拥有系统资源**\n* **线程是独立调度和分配的基本单位，也是能够独立运行的基本单位**\n* 同一个进程的所有线程共享该进程的所拥有的全部资源\n* 线程的并发执行程度高，**不但同一进程的多个线程可以并发执行，甚至属于不同进程的多个线程也可以并发执行**\n\n与进程类似，线程也有生命周期，也存在 执行、就绪和阻塞这三种基本状态，这是因为线程完全继承了进程的运行属性，因此**线程的三种状态含义和转换关系与进程相同**。由于线程不是资源的拥有单位，因此**挂起状态对单个线程没有意义**。\n\n在多线程操作系统中，为了使并发的多个线程能够有条不紊地运行，操作系统必须提供用于线程间互斥和同步的机制：\n* **互斥锁**，每次只允许一个线程来执行特定的代码或访问特定的数据。\n* **读写锁**，对受保护的共享资源进行并发读取和独占写入。\n* **条件变量**，一直阻塞线程，直到特定的条件为真。 \n* **奇数信号量**，用来协调对资源的访问，达到指定的计数时信号将阻塞。\n\n***\n<br><br>\n\n## 3.3 线程与进程\n线程有由于有很多进程的特性，因此有人将它称为轻量级进程，而将传统进程称为重量级进程。\n\n差异：\n* 新建、切换和撤销一个线程所花费的时空消耗远小于新建、切换和撤销一个进程的时空开销\n* 进程是资源分配的最小单元，而线程不是，同一进程的多个线程可以共享资源\n\n\n\n\n\n\n\n\n\n\n\n\n<br><br><br>\n\n***\n\n<br><br><br>\n\n**参考**      \n[1]胡元义,黑新宏.操作系统原理. 北京: 电子工业出版社, 2018.\n[2]https://blog.csdn.net/jinixin/article/details/90345661\n\n\n\n","slug":"code/OS/进程同步与通信","published":1,"updated":"2020-12-20T12:12:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gt00600w7t8k9w2yw0","content":"<p>为了有效地管理CPU,操作系统引入了线程的概念，即以进程为基本单位来实现CPU的分配与执行。随着并行处理技术的发展，为了进一步提高系统的并行性，实现进程内部的并发执行，操作系统又引入了线程的概念。这样，CPU的管理最终归结于对进程和线程的管理。<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.png\" alt=\"进程与线程\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"一、进程\"><a href=\"#一、进程\" class=\"headerlink\" title=\"一、进程\"></a>一、进程</h1><p>程序是一个在时间方向上严格按照先后次序实现算法功能的指令序列。</p>\n<h2 id=\"1-1-程序的顺序执行和并发执行\"><a href=\"#1-1-程序的顺序执行和并发执行\" class=\"headerlink\" title=\"1.1 程序的顺序执行和并发执行\"></a>1.1 程序的顺序执行和并发执行</h2><h3 id=\"1-1-顺序执行\"><a href=\"#1-1-顺序执行\" class=\"headerlink\" title=\"1.1 顺序执行\"></a>1.1 顺序执行</h3><p>一个具有独立功能的程序独占CPU运行，直到获得最终结果的过程。</p>\n<ul>\n<li><strong>顺序性</strong>。 每个操作都必须在前一个操作结束后才能开始</li>\n<li><strong>封闭性</strong>。 程序一旦开始运行，其运行结果不会受到外界因素的影响</li>\n<li><strong>可再现性</strong>。 程序运行结果仅由初始结果和程序本身的操作决定</li>\n</ul>\n<h3 id=\"1-1-2-并发执行\"><a href=\"#1-1-2-并发执行\" class=\"headerlink\" title=\"1.1.2 并发执行\"></a>1.1.2 并发执行</h3><p>在计算机引入<strong>通道和中断</strong>机制后，就使得CPU和外部设备之间，以及外部设备与外部设备之间可以并行操作，使得多道程序设计成为可能。      </p>\n<p>在同一时刻，有的程序占用CPU运行，有的程序通过外部设备传递数据。<strong>从宏观上看是多个设备同时运行，从微观上来看它们是在交替运行。</strong></p>\n<p>因此，程序并发执行环境下的计算机资源，已不再被某一个用户程序所独占，而是由多个并发执行的程序所共享。虽然提高了资源的利用率，但在另外一方面却<strong>引发了多个并发程序对资源的竞争导致了程序执行环境与运行速度的改变，从而可能产生程序运行结果不唯一的情况。</strong></p>\n<ul>\n<li><strong>间断性</strong></li>\n<li><strong>无封闭性</strong></li>\n<li><strong>不可再现性</strong></li>\n</ul>\n<hr>\n<br>\n\n<h2 id=\"1-2-进程的定义\"><a href=\"#1-2-进程的定义\" class=\"headerlink\" title=\"1.2 进程的定义\"></a>1.2 进程的定义</h2><p><strong>程序的一个动态执行过程</strong></p>\n<p>结构：<br>进程实体=程序段+相关数据段+PCB(进程控制块) </p>\n<h2 id=\"1-4-进程的特点\"><a href=\"#1-4-进程的特点\" class=\"headerlink\" title=\"1.4 进程的特点\"></a>1.4 进程的特点</h2><ul>\n<li>动态性。 进程具有生命期，具有“创建-运行-消亡”这样一个过程</li>\n<li>并发性。 多个进程能够在一段时间内并发执行</li>\n<li>独立性。 每个进程都是一个独立运行的基本单位，也是<strong>系统进行资源分配和调度的基本单位</strong></li>\n<li>异步性。 任何时刻只能有一个进程占用CPU，具有“执行-暂停-执行”这种间断性规律</li>\n<li>结构性。 由程序段、相关数据段、PCB三部分组成</li>\n</ul>\n<hr>\n<br>\n\n<h2 id=\"1-5-进程和程序的区别\"><a href=\"#1-5-进程和程序的区别\" class=\"headerlink\" title=\"1.5 进程和程序的区别\"></a>1.5 进程和程序的区别</h2><p><strong>程序像是一个乐谱</strong>，任何时候都可以翻阅它，但乐谱本身是静态的。<br><strong>进程则可以看做是乐谱的一次演奏</strong>，具有生命周期，并随着时间的流逝，演奏的音乐将不复存在，即使是重现演奏这个乐谱，也不是刚刚逝去的那段音乐。</p>\n<p>同一程序的不同进程，则像是同卵双胞胎的不同人生。</p>\n<p><strong>程序和进程并无一一对应关系</strong>。同一程序可以产生多个进程，一个进程也可包含多个程序。</p>\n<hr>\n<br>\n\n<h2 id=\"1-6-进程的状态及转换\"><a href=\"#1-6-进程的状态及转换\" class=\"headerlink\" title=\"1.6 进程的状态及转换\"></a>1.6 进程的状态及转换</h2><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E8%BF%9B%E7%A8%8B%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png\" alt=\"进程五状态模型\"></p>\n<ol>\n<li><p>新建<br> 当需要创建一个新进程时，系统为该进程分配一个进程控制块PCB，并为该进程分配内存空间，且装入该进程对应的程序和有关数据。</p>\n</li>\n<li><p>就绪<br> <strong>进程得到除了CPU之外的所需资源，一旦得到CPU资源既可以立即投入运行</strong>。</p>\n</li>\n<li><p>运行<br> 进程获得了CUP和其他所需要的资源，目前正在CPU上运行</p>\n</li>\n<li><p>阻塞<br> <strong>进程 运行 过程中发生了某种等待事件（比如发生了I/O操作）而暂时不能运行的状态</strong>。即使把CPU资源分配给它也不能够运行。</p>\n</li>\n<li><p>结束<br> 系统逐步释放为为其分配的资源，最后释放其PCB.</p>\n</li>\n</ol>\n<blockquote>\n<p>核心的三状态就比如一个游乐场，一群小朋友进入游乐场排序玩一个滑梯     </p>\n<ul>\n<li>排队的小朋友就处于就绪转态    </li>\n<li>玩滑梯的那一个小朋友就处于运行状态    </li>\n<li>每个小朋友只能玩5分钟，时间到了就得重新排序    </li>\n<li>如果小朋友<strong>在玩滑梯的过程中</strong>需要上厕所，那么上厕所的过程就是阻塞状态，上厕所结束后则需要重新排队（就绪）</li>\n</ul>\n</blockquote>\n<br>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E4%B8%83%E7%8A%B6%E6%80%81%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png\" alt=\"七状态进程模型\"></p>\n<p>上面的5状态进程模型中，新创建的进程一旦被系统接纳都一直存在于内存中，直到被终止。在这种情况下，<strong>系统内存资源会变得越来越紧张</strong>，此外由于CPU速度远超于I/O等操作速度，<strong>内存中就会存在大多数进程等待I/O操作而CPU空闲的现象</strong>。为此可以采用交换技术，将内存中暂时不能运行的某些进程挂起，释放所占用的内存资源，以便于重新接纳一个新进程或外存上已具备运行条件的进程进入内存就绪队列。<strong>进程挂起即将内存中的进程暂时移出到外存（如磁盘）中的过程。</strong></p>\n<blockquote>\n<p>现代操作系统只是将进程的某些页放到外存上去</p>\n</blockquote>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h1 id=\"二、进程同步与通信\"><a href=\"#二、进程同步与通信\" class=\"headerlink\" title=\"二、进程同步与通信\"></a>二、进程同步与通信</h1><h2 id=\"2-1-进程的同步与互斥\"><a href=\"#2-1-进程的同步与互斥\" class=\"headerlink\" title=\"2.1 进程的同步与互斥\"></a>2.1 进程的同步与互斥</h2><h3 id=\"2-1-1-进程同步\"><a href=\"#2-1-1-进程同步\" class=\"headerlink\" title=\"2.1.1 进程同步\"></a>2.1.1 进程同步</h3><p>某些进程之间在逻辑上的相互制约关系，即若干进程为了完成某一个共同任务和相互合作。</p>\n<h3 id=\"2-1-2-进程互斥\"><a href=\"#2-1-2-进程互斥\" class=\"headerlink\" title=\"2.1.2 进程互斥\"></a>2.1.2 进程互斥</h3><p>某一资源同一时间只允许一个进程对其访问，这种访问具有唯一性和排他性。</p>\n<hr>\n<br>\n\n<h2 id=\"2-2-临界资源和临界区\"><a href=\"#2-2-临界资源和临界区\" class=\"headerlink\" title=\"2.2 临界资源和临界区\"></a>2.2 临界资源和临界区</h2><p>系统中同时存在着许多进程，它们共享着各种资源。然而许多资源在某一时刻只能允许一个进程使用，如打印机，磁带机等硬件设备，软件中的变量、队列等数据结构。如果多个进程同时使用这类资源就会造成混乱。因此必须保护这些资源，避免两个或多个进程同时访问这些资源。</p>\n<p><strong>把同一时刻只允许一个进程使用的资源成为临界资源。</strong></p>\n<p>对临界资源的访问必须互斥进行，即各个进程对同一临界资源进行先从操作的程序段也应互斥进行，只有这样才能保证对临界资源的互斥访问。<strong>把进程中访问临界资源的代码称为临界区。</strong></p>\n<p>对于临界资源的访问必须互斥进行，<strong>所以进程在进入临界区时首先判断是否有其他进程在使用此临界资源，如果有，则该进程必须等待；如果没有，则该进程才能进入临界区执行临界区代码，同时还要关闭临界区以防止其他进程进入。当进程使用完临界资源时，要开放临界区以便其他进程进入。</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<hr>\n<br>\n\n<h2 id=\"2-3-实现进程互斥的硬件方法\"><a href=\"#2-3-实现进程互斥的硬件方法\" class=\"headerlink\" title=\"2.3 实现进程互斥的硬件方法\"></a>2.3 实现进程互斥的硬件方法</h2><h3 id=\"2-3-1-开关中断指令\"><a href=\"#2-3-1-开关中断指令\" class=\"headerlink\" title=\"2.3.1 开关中断指令\"></a>2.3.1 开关中断指令</h3><p>又称硬件锁，进程在进入临界区之前，先执行“关中断”指令来屏蔽掉所有中断，进程完成所有临界区的任务后，再执行“开中断”指令将中断打开。</p>\n<p>开关中断时间过长会导致系统效率降低。</p>\n<h3 id=\"2-3-2-测试与设置指令\"><a href=\"#2-3-2-测试与设置指令\" class=\"headerlink\" title=\"2.3.2 测试与设置指令\"></a>2.3.2 测试与设置指令</h3><p>为每一个临界资源设置一个整型变量s，若s为0，则表示没有进程访问该临界资源，若s为1则表示该临界资源已经被某个进程占用。</p>\n<p>利用TS指令可以实现临界区的开锁和关锁原语操作，进入临界区之前先使用TS指令测试s，若s为0则表明没有进程使用临界资源，于是本进程进入临界区，<strong>否则必须循环测试直至s的值为0</strong>。</p>\n<blockquote>\n<p>原语：一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。（原子操作）</p>\n</blockquote>\n<h3 id=\"2-3-3-交换指令\"><a href=\"#2-3-3-交换指令\" class=\"headerlink\" title=\"2.3.3 交换指令\"></a>2.3.3 交换指令</h3><p>若要使用交换指令来实现进程互斥，则需要为每个临界资源设置一个整型变量s，若s为0，则表示没有进程访问该临界资源，若s为1则表示该临界资源已经被某个进程占用。此外，还有设置一个整型局部变量key,只有当s为0且key为1时，进程才能进入临界区，进入临界区后，s的值为1且key的值为0。</p>\n<p>TS和SWAP指令都能方便地实现进程互斥，但都存在过多循环测试s的值而引起的系统资源消耗问题。</p>\n<hr>\n<br>\n\n<h2 id=\"2-4-实现进程互斥的软件方法\"><a href=\"#2-4-实现进程互斥的软件方法\" class=\"headerlink\" title=\"2.4 实现进程互斥的软件方法\"></a>2.4 实现进程互斥的软件方法</h2><h3 id=\"2-4-1-两标志进程互斥算法\"><a href=\"#2-4-1-两标志进程互斥算法\" class=\"headerlink\" title=\"2.4.1 两标志进程互斥算法\"></a>2.4.1 两标志进程互斥算法</h3><p>不能很好解决两个进程同时到达的问题</p>\n<h3 id=\"2-4-2-三标志进程互斥算法\"><a href=\"#2-4-2-三标志进程互斥算法\" class=\"headerlink\" title=\"2.4.2 三标志进程互斥算法\"></a>2.4.2 三标志进程互斥算法</h3><p>扩展性较差，进程一多久复杂了，效率变低</p>\n<hr>\n<br>\n\n<h2 id=\"2-5-信号量机制\"><a href=\"#2-5-信号量机制\" class=\"headerlink\" title=\"2.5 信号量机制\"></a>2.5 信号量机制</h2><p>在操作系统中，信号量代表了一类物理资源，它是相应物理资源的抽象。具体实现时，信号量被定义为具有某种类型的变量，通常为整型或者其他结构体类型。</p>\n<p><strong>value变量</strong>：<br>value的初值是一个非负整数，代表着系统中某类资源的数量，随着该资源的不断被分配，value的值也随之发生变化，会出现以下三种情况：</p>\n<ul>\n<li>value&gt;0，代表该类资源当前的可用数量  </li>\n<li>value=0，表示该资源为空</li>\n<li>value&lt;0，<strong>其绝对值代表因等待该资源而阻塞的进程数量</strong></li>\n</ul>\n<p><strong>P操作（发信号）</strong>：</p>\n<ul>\n<li>执行一此P操作就相当于申请一个资源S<ul>\n<li>若S&gt;0，则意味着系统中有可用资源S,并将其分配，且将S的资源可用数量value减1</li>\n<li>若S&lt;=0，表示当前系统已无资源S可用，立即将当前运行进程阻塞起来，并插入到S.L的进程阻塞队列中去</li>\n</ul>\n</li>\n</ul>\n<p><strong>V操作（等待）</strong>：</p>\n<ul>\n<li>执行一次V操作相当于释放一个资源S,将资源S的value值加1</li>\n<li>若S.value加1后其值仍小于等于0，则表明仍有处于阻塞状态的进程在等待资源S，于是将S.L所指进程阻塞队列中的第一个阻塞进程唤醒并将刚刚回收的资源S分配给它。</li>\n</ul>\n<p>P、V信号量<strong>解决了进程主动进行循环测试消耗系统资源的问题</strong>。因为这种协调的本质是当出现资源竞争的冲突时，就将原来并发执行的多个进程在P、V操作的协调下变为<strong>依次顺序执行</strong>，<strong>当资源冲突结束后又恢复为并发执行。</strong></p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h1 id=\"三、线程\"><a href=\"#三、线程\" class=\"headerlink\" title=\"三、线程\"></a>三、线程</h1><p>进程就如我们在一台旧电视上看节目，如果两个频道正在直播不同的精彩节目，我们只能在这两个频道之间来回切换选择观看的内容（相当于进程的切换）。这就是进程的缺点，<strong>它在一个时间段内只能做一件事情</strong>，如果想要同时做两件或者多件事情，进程就不够用了。此外，如果<strong>进程在执行过程中因等待输入输入数据而阻塞</strong>，且这时进程还有一些不依赖于输入的其他工作可以做，但由于进程的阻塞而无法进行。</p>\n<p>线程就是为了解决上述两个缺陷而解决的，例如<strong>新电视可以将两个频道或多个频道同时显示在同一块屏幕上</strong>（分屏），这就是线程的方式。例如<strong>使用WPS时，实际上是打开了多线程，一个线程负责显示，一个线程负责输入，一个线程负责定时存盘……</strong> 这些线程一起运转，使我们觉得输入和显示同时发生，而不是键入一些文字，等待一会儿再显示到屏幕上。</p>\n<blockquote>\n<p>多线程，在一个口罩工厂中建立多个生产线生产口罩 （一个进程内的多个线程）</p>\n</blockquote>\n<blockquote>\n<p>并行：同一时刻，多个执行流都拥有一个CPU同时在计算<br>并发：多个执行流，每个执行流独占CPU一会儿进行计算，按照时间片轮转法分配运行时间</p>\n</blockquote>\n<h2 id=\"3-1-线程的引入\"><a href=\"#3-1-线程的引入\" class=\"headerlink\" title=\"3.1 线程的引入\"></a>3.1 线程的引入</h2><p>在操作系统中引入进程后，使得原来不能并发执行的程序变成能够并发执行的进程，从而改善了资源的利用率和系统吞吐量。此时，<strong>进程既是资源分配的基本单位，也是独立调度、独立运行的基本单位。</strong></p>\n<p>然而，正是由于进程扮演了这两种角色，导致了<strong>进程的并发执行产生了很大的时空开销</strong>，因为他要完成如下操作：     </p>\n<ol>\n<li>创建进程</li>\n<li>进程切换</li>\n<li>撤销进程</li>\n</ol>\n<p>上述操作占用不少的CPU资源（尤其是进程切换），为此有一个想法是<strong>将进程承担的两个角色分开</strong>。</p>\n<p>此外，多CPU的计算机系统的出现，对于<strong>原有的进程执行方式增加CPU并不能提高一个进程的执行效率。</strong>  <strong><em>将一个进程分解为多个线程，这样就可以让多个线程同时运行在不同的CPU上。</em></strong> 此时，<em>线程是CPU调度和执行的最小单元</em></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"3-2-线程的定义\"><a href=\"#3-2-线程的定义\" class=\"headerlink\" title=\"3.2 线程的定义\"></a>3.2 线程的定义</h2><ul>\n<li>进程内的一个执行单元</li>\n<li>进程内的一个可独立调度的实体</li>\n<li>进程内的一个相对独立的控制流序列</li>\n<li>执行的上下文</li>\n</ul>\n<p>属性：</p>\n<ul>\n<li>线程属于轻型实体，<strong>基本不拥有系统资源</strong></li>\n<li><strong>线程是独立调度和分配的基本单位，也是能够独立运行的基本单位</strong></li>\n<li>同一个进程的所有线程共享该进程的所拥有的全部资源</li>\n<li>线程的并发执行程度高，<strong>不但同一进程的多个线程可以并发执行，甚至属于不同进程的多个线程也可以并发执行</strong></li>\n</ul>\n<p>与进程类似，线程也有生命周期，也存在 执行、就绪和阻塞这三种基本状态，这是因为线程完全继承了进程的运行属性，因此<strong>线程的三种状态含义和转换关系与进程相同</strong>。由于线程不是资源的拥有单位，因此<strong>挂起状态对单个线程没有意义</strong>。</p>\n<p>在多线程操作系统中，为了使并发的多个线程能够有条不紊地运行，操作系统必须提供用于线程间互斥和同步的机制：</p>\n<ul>\n<li><strong>互斥锁</strong>，每次只允许一个线程来执行特定的代码或访问特定的数据。</li>\n<li><strong>读写锁</strong>，对受保护的共享资源进行并发读取和独占写入。</li>\n<li><strong>条件变量</strong>，一直阻塞线程，直到特定的条件为真。 </li>\n<li><strong>奇数信号量</strong>，用来协调对资源的访问，达到指定的计数时信号将阻塞。</li>\n</ul>\n<hr>\n<p><br><br></p>\n<h2 id=\"3-3-线程与进程\"><a href=\"#3-3-线程与进程\" class=\"headerlink\" title=\"3.3 线程与进程\"></a>3.3 线程与进程</h2><p>线程有由于有很多进程的特性，因此有人将它称为轻量级进程，而将传统进程称为重量级进程。</p>\n<p>差异：</p>\n<ul>\n<li>新建、切换和撤销一个线程所花费的时空消耗远小于新建、切换和撤销一个进程的时空开销</li>\n<li>进程是资源分配的最小单元，而线程不是，同一进程的多个线程可以共享资源</li>\n</ul>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<p><strong>参考</strong><br>[1]胡元义,黑新宏.操作系统原理. 北京: 电子工业出版社, 2018.<br>[2]<a href=\"https://blog.csdn.net/jinixin/article/details/90345661\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jinixin/article/details/90345661</a></p>\n","site":{"data":{}},"excerpt":"<p>为了有效地管理CPU,操作系统引入了线程的概念，即以进程为基本单位来实现CPU的分配与执行。随着并行处理技术的发展，为了进一步提高系统的并行性，实现进程内部的并发执行，操作系统又引入了线程的概念。这样，CPU的管理最终归结于对进程和线程的管理。<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.png\" alt=\"进程与线程\"></p>","more":"<h1 id=\"一、进程\"><a href=\"#一、进程\" class=\"headerlink\" title=\"一、进程\"></a>一、进程</h1><p>程序是一个在时间方向上严格按照先后次序实现算法功能的指令序列。</p>\n<h2 id=\"1-1-程序的顺序执行和并发执行\"><a href=\"#1-1-程序的顺序执行和并发执行\" class=\"headerlink\" title=\"1.1 程序的顺序执行和并发执行\"></a>1.1 程序的顺序执行和并发执行</h2><h3 id=\"1-1-顺序执行\"><a href=\"#1-1-顺序执行\" class=\"headerlink\" title=\"1.1 顺序执行\"></a>1.1 顺序执行</h3><p>一个具有独立功能的程序独占CPU运行，直到获得最终结果的过程。</p>\n<ul>\n<li><strong>顺序性</strong>。 每个操作都必须在前一个操作结束后才能开始</li>\n<li><strong>封闭性</strong>。 程序一旦开始运行，其运行结果不会受到外界因素的影响</li>\n<li><strong>可再现性</strong>。 程序运行结果仅由初始结果和程序本身的操作决定</li>\n</ul>\n<h3 id=\"1-1-2-并发执行\"><a href=\"#1-1-2-并发执行\" class=\"headerlink\" title=\"1.1.2 并发执行\"></a>1.1.2 并发执行</h3><p>在计算机引入<strong>通道和中断</strong>机制后，就使得CPU和外部设备之间，以及外部设备与外部设备之间可以并行操作，使得多道程序设计成为可能。      </p>\n<p>在同一时刻，有的程序占用CPU运行，有的程序通过外部设备传递数据。<strong>从宏观上看是多个设备同时运行，从微观上来看它们是在交替运行。</strong></p>\n<p>因此，程序并发执行环境下的计算机资源，已不再被某一个用户程序所独占，而是由多个并发执行的程序所共享。虽然提高了资源的利用率，但在另外一方面却<strong>引发了多个并发程序对资源的竞争导致了程序执行环境与运行速度的改变，从而可能产生程序运行结果不唯一的情况。</strong></p>\n<ul>\n<li><strong>间断性</strong></li>\n<li><strong>无封闭性</strong></li>\n<li><strong>不可再现性</strong></li>\n</ul>\n<hr>\n<br>\n\n<h2 id=\"1-2-进程的定义\"><a href=\"#1-2-进程的定义\" class=\"headerlink\" title=\"1.2 进程的定义\"></a>1.2 进程的定义</h2><p><strong>程序的一个动态执行过程</strong></p>\n<p>结构：<br>进程实体=程序段+相关数据段+PCB(进程控制块) </p>\n<h2 id=\"1-4-进程的特点\"><a href=\"#1-4-进程的特点\" class=\"headerlink\" title=\"1.4 进程的特点\"></a>1.4 进程的特点</h2><ul>\n<li>动态性。 进程具有生命期，具有“创建-运行-消亡”这样一个过程</li>\n<li>并发性。 多个进程能够在一段时间内并发执行</li>\n<li>独立性。 每个进程都是一个独立运行的基本单位，也是<strong>系统进行资源分配和调度的基本单位</strong></li>\n<li>异步性。 任何时刻只能有一个进程占用CPU，具有“执行-暂停-执行”这种间断性规律</li>\n<li>结构性。 由程序段、相关数据段、PCB三部分组成</li>\n</ul>\n<hr>\n<br>\n\n<h2 id=\"1-5-进程和程序的区别\"><a href=\"#1-5-进程和程序的区别\" class=\"headerlink\" title=\"1.5 进程和程序的区别\"></a>1.5 进程和程序的区别</h2><p><strong>程序像是一个乐谱</strong>，任何时候都可以翻阅它，但乐谱本身是静态的。<br><strong>进程则可以看做是乐谱的一次演奏</strong>，具有生命周期，并随着时间的流逝，演奏的音乐将不复存在，即使是重现演奏这个乐谱，也不是刚刚逝去的那段音乐。</p>\n<p>同一程序的不同进程，则像是同卵双胞胎的不同人生。</p>\n<p><strong>程序和进程并无一一对应关系</strong>。同一程序可以产生多个进程，一个进程也可包含多个程序。</p>\n<hr>\n<br>\n\n<h2 id=\"1-6-进程的状态及转换\"><a href=\"#1-6-进程的状态及转换\" class=\"headerlink\" title=\"1.6 进程的状态及转换\"></a>1.6 进程的状态及转换</h2><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E8%BF%9B%E7%A8%8B%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png\" alt=\"进程五状态模型\"></p>\n<ol>\n<li><p>新建<br> 当需要创建一个新进程时，系统为该进程分配一个进程控制块PCB，并为该进程分配内存空间，且装入该进程对应的程序和有关数据。</p>\n</li>\n<li><p>就绪<br> <strong>进程得到除了CPU之外的所需资源，一旦得到CPU资源既可以立即投入运行</strong>。</p>\n</li>\n<li><p>运行<br> 进程获得了CUP和其他所需要的资源，目前正在CPU上运行</p>\n</li>\n<li><p>阻塞<br> <strong>进程 运行 过程中发生了某种等待事件（比如发生了I/O操作）而暂时不能运行的状态</strong>。即使把CPU资源分配给它也不能够运行。</p>\n</li>\n<li><p>结束<br> 系统逐步释放为为其分配的资源，最后释放其PCB.</p>\n</li>\n</ol>\n<blockquote>\n<p>核心的三状态就比如一个游乐场，一群小朋友进入游乐场排序玩一个滑梯     </p>\n<ul>\n<li>排队的小朋友就处于就绪转态    </li>\n<li>玩滑梯的那一个小朋友就处于运行状态    </li>\n<li>每个小朋友只能玩5分钟，时间到了就得重新排序    </li>\n<li>如果小朋友<strong>在玩滑梯的过程中</strong>需要上厕所，那么上厕所的过程就是阻塞状态，上厕所结束后则需要重新排队（就绪）</li>\n</ul>\n</blockquote>\n<br>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E4%B8%83%E7%8A%B6%E6%80%81%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png\" alt=\"七状态进程模型\"></p>\n<p>上面的5状态进程模型中，新创建的进程一旦被系统接纳都一直存在于内存中，直到被终止。在这种情况下，<strong>系统内存资源会变得越来越紧张</strong>，此外由于CPU速度远超于I/O等操作速度，<strong>内存中就会存在大多数进程等待I/O操作而CPU空闲的现象</strong>。为此可以采用交换技术，将内存中暂时不能运行的某些进程挂起，释放所占用的内存资源，以便于重新接纳一个新进程或外存上已具备运行条件的进程进入内存就绪队列。<strong>进程挂起即将内存中的进程暂时移出到外存（如磁盘）中的过程。</strong></p>\n<blockquote>\n<p>现代操作系统只是将进程的某些页放到外存上去</p>\n</blockquote>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h1 id=\"二、进程同步与通信\"><a href=\"#二、进程同步与通信\" class=\"headerlink\" title=\"二、进程同步与通信\"></a>二、进程同步与通信</h1><h2 id=\"2-1-进程的同步与互斥\"><a href=\"#2-1-进程的同步与互斥\" class=\"headerlink\" title=\"2.1 进程的同步与互斥\"></a>2.1 进程的同步与互斥</h2><h3 id=\"2-1-1-进程同步\"><a href=\"#2-1-1-进程同步\" class=\"headerlink\" title=\"2.1.1 进程同步\"></a>2.1.1 进程同步</h3><p>某些进程之间在逻辑上的相互制约关系，即若干进程为了完成某一个共同任务和相互合作。</p>\n<h3 id=\"2-1-2-进程互斥\"><a href=\"#2-1-2-进程互斥\" class=\"headerlink\" title=\"2.1.2 进程互斥\"></a>2.1.2 进程互斥</h3><p>某一资源同一时间只允许一个进程对其访问，这种访问具有唯一性和排他性。</p>\n<hr>\n<br>\n\n<h2 id=\"2-2-临界资源和临界区\"><a href=\"#2-2-临界资源和临界区\" class=\"headerlink\" title=\"2.2 临界资源和临界区\"></a>2.2 临界资源和临界区</h2><p>系统中同时存在着许多进程，它们共享着各种资源。然而许多资源在某一时刻只能允许一个进程使用，如打印机，磁带机等硬件设备，软件中的变量、队列等数据结构。如果多个进程同时使用这类资源就会造成混乱。因此必须保护这些资源，避免两个或多个进程同时访问这些资源。</p>\n<p><strong>把同一时刻只允许一个进程使用的资源成为临界资源。</strong></p>\n<p>对临界资源的访问必须互斥进行，即各个进程对同一临界资源进行先从操作的程序段也应互斥进行，只有这样才能保证对临界资源的互斥访问。<strong>把进程中访问临界资源的代码称为临界区。</strong></p>\n<p>对于临界资源的访问必须互斥进行，<strong>所以进程在进入临界区时首先判断是否有其他进程在使用此临界资源，如果有，则该进程必须等待；如果没有，则该进程才能进入临界区执行临界区代码，同时还要关闭临界区以防止其他进程进入。当进程使用完临界资源时，要开放临界区以便其他进程进入。</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<hr>\n<br>\n\n<h2 id=\"2-3-实现进程互斥的硬件方法\"><a href=\"#2-3-实现进程互斥的硬件方法\" class=\"headerlink\" title=\"2.3 实现进程互斥的硬件方法\"></a>2.3 实现进程互斥的硬件方法</h2><h3 id=\"2-3-1-开关中断指令\"><a href=\"#2-3-1-开关中断指令\" class=\"headerlink\" title=\"2.3.1 开关中断指令\"></a>2.3.1 开关中断指令</h3><p>又称硬件锁，进程在进入临界区之前，先执行“关中断”指令来屏蔽掉所有中断，进程完成所有临界区的任务后，再执行“开中断”指令将中断打开。</p>\n<p>开关中断时间过长会导致系统效率降低。</p>\n<h3 id=\"2-3-2-测试与设置指令\"><a href=\"#2-3-2-测试与设置指令\" class=\"headerlink\" title=\"2.3.2 测试与设置指令\"></a>2.3.2 测试与设置指令</h3><p>为每一个临界资源设置一个整型变量s，若s为0，则表示没有进程访问该临界资源，若s为1则表示该临界资源已经被某个进程占用。</p>\n<p>利用TS指令可以实现临界区的开锁和关锁原语操作，进入临界区之前先使用TS指令测试s，若s为0则表明没有进程使用临界资源，于是本进程进入临界区，<strong>否则必须循环测试直至s的值为0</strong>。</p>\n<blockquote>\n<p>原语：一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。（原子操作）</p>\n</blockquote>\n<h3 id=\"2-3-3-交换指令\"><a href=\"#2-3-3-交换指令\" class=\"headerlink\" title=\"2.3.3 交换指令\"></a>2.3.3 交换指令</h3><p>若要使用交换指令来实现进程互斥，则需要为每个临界资源设置一个整型变量s，若s为0，则表示没有进程访问该临界资源，若s为1则表示该临界资源已经被某个进程占用。此外，还有设置一个整型局部变量key,只有当s为0且key为1时，进程才能进入临界区，进入临界区后，s的值为1且key的值为0。</p>\n<p>TS和SWAP指令都能方便地实现进程互斥，但都存在过多循环测试s的值而引起的系统资源消耗问题。</p>\n<hr>\n<br>\n\n<h2 id=\"2-4-实现进程互斥的软件方法\"><a href=\"#2-4-实现进程互斥的软件方法\" class=\"headerlink\" title=\"2.4 实现进程互斥的软件方法\"></a>2.4 实现进程互斥的软件方法</h2><h3 id=\"2-4-1-两标志进程互斥算法\"><a href=\"#2-4-1-两标志进程互斥算法\" class=\"headerlink\" title=\"2.4.1 两标志进程互斥算法\"></a>2.4.1 两标志进程互斥算法</h3><p>不能很好解决两个进程同时到达的问题</p>\n<h3 id=\"2-4-2-三标志进程互斥算法\"><a href=\"#2-4-2-三标志进程互斥算法\" class=\"headerlink\" title=\"2.4.2 三标志进程互斥算法\"></a>2.4.2 三标志进程互斥算法</h3><p>扩展性较差，进程一多久复杂了，效率变低</p>\n<hr>\n<br>\n\n<h2 id=\"2-5-信号量机制\"><a href=\"#2-5-信号量机制\" class=\"headerlink\" title=\"2.5 信号量机制\"></a>2.5 信号量机制</h2><p>在操作系统中，信号量代表了一类物理资源，它是相应物理资源的抽象。具体实现时，信号量被定义为具有某种类型的变量，通常为整型或者其他结构体类型。</p>\n<p><strong>value变量</strong>：<br>value的初值是一个非负整数，代表着系统中某类资源的数量，随着该资源的不断被分配，value的值也随之发生变化，会出现以下三种情况：</p>\n<ul>\n<li>value&gt;0，代表该类资源当前的可用数量  </li>\n<li>value=0，表示该资源为空</li>\n<li>value&lt;0，<strong>其绝对值代表因等待该资源而阻塞的进程数量</strong></li>\n</ul>\n<p><strong>P操作（发信号）</strong>：</p>\n<ul>\n<li>执行一此P操作就相当于申请一个资源S<ul>\n<li>若S&gt;0，则意味着系统中有可用资源S,并将其分配，且将S的资源可用数量value减1</li>\n<li>若S&lt;=0，表示当前系统已无资源S可用，立即将当前运行进程阻塞起来，并插入到S.L的进程阻塞队列中去</li>\n</ul>\n</li>\n</ul>\n<p><strong>V操作（等待）</strong>：</p>\n<ul>\n<li>执行一次V操作相当于释放一个资源S,将资源S的value值加1</li>\n<li>若S.value加1后其值仍小于等于0，则表明仍有处于阻塞状态的进程在等待资源S，于是将S.L所指进程阻塞队列中的第一个阻塞进程唤醒并将刚刚回收的资源S分配给它。</li>\n</ul>\n<p>P、V信号量<strong>解决了进程主动进行循环测试消耗系统资源的问题</strong>。因为这种协调的本质是当出现资源竞争的冲突时，就将原来并发执行的多个进程在P、V操作的协调下变为<strong>依次顺序执行</strong>，<strong>当资源冲突结束后又恢复为并发执行。</strong></p>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h1 id=\"三、线程\"><a href=\"#三、线程\" class=\"headerlink\" title=\"三、线程\"></a>三、线程</h1><p>进程就如我们在一台旧电视上看节目，如果两个频道正在直播不同的精彩节目，我们只能在这两个频道之间来回切换选择观看的内容（相当于进程的切换）。这就是进程的缺点，<strong>它在一个时间段内只能做一件事情</strong>，如果想要同时做两件或者多件事情，进程就不够用了。此外，如果<strong>进程在执行过程中因等待输入输入数据而阻塞</strong>，且这时进程还有一些不依赖于输入的其他工作可以做，但由于进程的阻塞而无法进行。</p>\n<p>线程就是为了解决上述两个缺陷而解决的，例如<strong>新电视可以将两个频道或多个频道同时显示在同一块屏幕上</strong>（分屏），这就是线程的方式。例如<strong>使用WPS时，实际上是打开了多线程，一个线程负责显示，一个线程负责输入，一个线程负责定时存盘……</strong> 这些线程一起运转，使我们觉得输入和显示同时发生，而不是键入一些文字，等待一会儿再显示到屏幕上。</p>\n<blockquote>\n<p>多线程，在一个口罩工厂中建立多个生产线生产口罩 （一个进程内的多个线程）</p>\n</blockquote>\n<blockquote>\n<p>并行：同一时刻，多个执行流都拥有一个CPU同时在计算<br>并发：多个执行流，每个执行流独占CPU一会儿进行计算，按照时间片轮转法分配运行时间</p>\n</blockquote>\n<h2 id=\"3-1-线程的引入\"><a href=\"#3-1-线程的引入\" class=\"headerlink\" title=\"3.1 线程的引入\"></a>3.1 线程的引入</h2><p>在操作系统中引入进程后，使得原来不能并发执行的程序变成能够并发执行的进程，从而改善了资源的利用率和系统吞吐量。此时，<strong>进程既是资源分配的基本单位，也是独立调度、独立运行的基本单位。</strong></p>\n<p>然而，正是由于进程扮演了这两种角色，导致了<strong>进程的并发执行产生了很大的时空开销</strong>，因为他要完成如下操作：     </p>\n<ol>\n<li>创建进程</li>\n<li>进程切换</li>\n<li>撤销进程</li>\n</ol>\n<p>上述操作占用不少的CPU资源（尤其是进程切换），为此有一个想法是<strong>将进程承担的两个角色分开</strong>。</p>\n<p>此外，多CPU的计算机系统的出现，对于<strong>原有的进程执行方式增加CPU并不能提高一个进程的执行效率。</strong>  <strong><em>将一个进程分解为多个线程，这样就可以让多个线程同时运行在不同的CPU上。</em></strong> 此时，<em>线程是CPU调度和执行的最小单元</em></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"3-2-线程的定义\"><a href=\"#3-2-线程的定义\" class=\"headerlink\" title=\"3.2 线程的定义\"></a>3.2 线程的定义</h2><ul>\n<li>进程内的一个执行单元</li>\n<li>进程内的一个可独立调度的实体</li>\n<li>进程内的一个相对独立的控制流序列</li>\n<li>执行的上下文</li>\n</ul>\n<p>属性：</p>\n<ul>\n<li>线程属于轻型实体，<strong>基本不拥有系统资源</strong></li>\n<li><strong>线程是独立调度和分配的基本单位，也是能够独立运行的基本单位</strong></li>\n<li>同一个进程的所有线程共享该进程的所拥有的全部资源</li>\n<li>线程的并发执行程度高，<strong>不但同一进程的多个线程可以并发执行，甚至属于不同进程的多个线程也可以并发执行</strong></li>\n</ul>\n<p>与进程类似，线程也有生命周期，也存在 执行、就绪和阻塞这三种基本状态，这是因为线程完全继承了进程的运行属性，因此<strong>线程的三种状态含义和转换关系与进程相同</strong>。由于线程不是资源的拥有单位，因此<strong>挂起状态对单个线程没有意义</strong>。</p>\n<p>在多线程操作系统中，为了使并发的多个线程能够有条不紊地运行，操作系统必须提供用于线程间互斥和同步的机制：</p>\n<ul>\n<li><strong>互斥锁</strong>，每次只允许一个线程来执行特定的代码或访问特定的数据。</li>\n<li><strong>读写锁</strong>，对受保护的共享资源进行并发读取和独占写入。</li>\n<li><strong>条件变量</strong>，一直阻塞线程，直到特定的条件为真。 </li>\n<li><strong>奇数信号量</strong>，用来协调对资源的访问，达到指定的计数时信号将阻塞。</li>\n</ul>\n<hr>\n<p><br><br></p>\n<h2 id=\"3-3-线程与进程\"><a href=\"#3-3-线程与进程\" class=\"headerlink\" title=\"3.3 线程与进程\"></a>3.3 线程与进程</h2><p>线程有由于有很多进程的特性，因此有人将它称为轻量级进程，而将传统进程称为重量级进程。</p>\n<p>差异：</p>\n<ul>\n<li>新建、切换和撤销一个线程所花费的时空消耗远小于新建、切换和撤销一个进程的时空开销</li>\n<li>进程是资源分配的最小单元，而线程不是，同一进程的多个线程可以共享资源</li>\n</ul>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<p><strong>参考</strong><br>[1]胡元义,黑新宏.操作系统原理. 北京: 电子工业出版社, 2018.<br>[2]<a href=\"https://blog.csdn.net/jinixin/article/details/90345661\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jinixin/article/details/90345661</a></p>"},{"title":"《MySql必知必会》学习笔记","declare":true,"wordCount":true,"abbrlink":"27b4eaba","date":"2020-07-23T12:59:10.000Z","_content":"<div style=\"width: 95%\">\n\n![《MySql必知必会》学习笔记](https://img2020.cnblogs.com/blog/2104937/202007/2104937-20200723232459669-218625272.png)\n\n</div>\n\n\nMySQL已经成为世界上最受欢迎的数据库管理系统之一。无论是用 在小型开发项目上，还是用来构建那些声名显赫的网站，MySQL都证明 了自己是个稳定、可靠、快速、可信的系统，足以胜任任何数据存储业 务的需要。\n<!-- more -->\n\n## MySql的使用\n```sql\n--选择数据库\nuse database; \n\n--返回可用数据库列表\nshow database; \n\n--返回一个数据库内表的列表\nshow tables; \n\n--对一个表的每个字段返回一行，行中包括字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息等\nshow columns from table;    \n--功能同上\ndescribe table;\n\n--用于显示广泛的服务器状态信息； \nshow status;    \n\n--显示创建创建数据库和表的MySql信息\nshow create database DBName; \nshow create table TName; \n\n--用于显示服务器错误或警告信息\nshow errors; \nshow warnings; \n```\n<br><br> \n\n***\n\n<br><br>\n\n## 检索数据\n```sql\n--查询多个字段\nselect nickname,email from user;  \n\n--查询不同的姓名\nselect distinct nickname from user; \n\n--返回前几行\nselect nickname,email from user limit 1; \n\n--返回从第0行开始的2行\nselect nickname,email from user limit 0,2;  \n\n--功能同上\nselect nickname,email from user limit 0 offset 2;  \n```\n\n<br><br> \n\n***\n\n<br><br>\n\n## 排序和过滤检索数据\n```sql\n--按照年龄从大到小排序，如果年龄相同则按照昵称从小到大排序\nselect nickname,email from user order by age desc , nickname;   \n\n--返回年龄不等于20的用户姓名 `<>`用法等同于`!=`\nselect nickename from user where age <> 20; \n\n--返回邮箱信息为空的用户名\nselect nickename from user where email is NULL; \n\n--返回邮箱信息为空的用户名\nselect nickename from user where email is NULL; \n\n--默认执行顺序为 `( age=10 ) or ( age=20 and eamil is NULL )`，`and`优先级更高\nselect * from user where age=10 or age=20 and eamil is NULL; //\n\n--对`IN`后圆括中的每一个元素进行匹配，等同于`OR`\nselect * from user where age in(10,20); \n\n--对其中条件进行否定\nselect * from user where age not in(10,20); \n\n--表示昵称包含字符e的所有用户，%表示通配符 表示任何字符出现的次数，0次、1次或多次。\nselect * from user where nickname like '%e%';   \n\n--表示昵称第二个字符为e的所有用户，`_`表示匹配单个字符。 \nselect * from user where nickname like '_e%';   \n\n```\n\n<br><br> \n\n***\n\n<br><br>\n\n## 正则表达式\n\n```sql\n--正则表达式，匹配年龄为10、20、30... 的用户，`.`表示匹配任意一个字符\nselect * from user where age REGEXP '.0';   \n\n-- `BINARY`用于正则表达式中区分大小写\nselect * from user where age BINARY REGEXP 'JetPack.000';   \n\n--正则表达式进行OR匹配\nselect * from user where age BINARY REGEXP '1000|1000';   \n\n--返回的是`1 Ton` `2 Ton` ,`[123]`为`[1|2|3]`的缩写，表示匹配1或2或3\nselect nickname from user where nickname BINARY REGEXP '[123] Ton';   \n\n--返回的是匹配指定字符串以外的值\nselect nickname from user where nickname BINARY REGEXP '[^123] Ton';   \n\n--nikename中包含`a Ton` `b Ton` `c Ton`，age中包含1,2,3\nselect nickname from user where nickname BINARY REGEXP '[a-c] Ton' and age REGEXP '[1-3]';  \n```\n\n\n\n### 匹配字符类     \n类|说明 \n-|-\n[:alnum:]|任意字符和数字（同[a-zA-Z0-9]）\n[:alpha:]|任意字符（同[a-zA-Z]）\n[:blank:]|空格和制表（同[\\\\t]）\n[:cntrl:]|ASCII控制字符（ASCII 0到31和127）\n[:digit:]|任意数字（同[0-9]）\n[:graph:]|与[:print:]相同，但不包括空格\n[:lower:]|任意小写字母（同[a-z]）\n[:print:]|任意可打印字符\n[:punct:]|既不在[:alnum:]又不在[:cntrl:]中的任意字符\n[:space:]|包括空格在内的任意空白字符（同[\\\\f\\\\n\\\\r\\\\t\\\\v]）\n[:upper:]|任意大写字母（同[A-Z]）\n[:xdigit:]|任意十六进制数字（同[a-fA-F0-9]）\n\n<br>\n\n### 匹配多个实例\n元字符|说明\n-|-\n*|0个或多个匹配\n+|1个或多个匹配（等于{1,}）\n?|0个或1个匹配（等于{0,1}）\n{n}|指定数目的匹配\n{n,}|不少于指定数目的匹配\n{n,m}|匹配数目的范围（m不超过255）\n\n> **'\\\\\\\\([0-9]stick?\\\\\\\\)'**    \n> A (1 stick)     \n> B (1 sticks)    \n> `\\\\`为转移符 ，第一个\\是MySql自己解释一个，第二\\是正则表达式解释一个\n\n<br>\n\n### 定位符\n元字符|说明\n-|-\n^|文本的开始\n$|文本的结尾\n[[:<:]]|词的开始\n[[:>:]]|词的结尾\n\n> '^\\[0-9\\\\.]'     \n> `^`匹配串的开始，即以数字开头或者`.`开头的字符串\n\n\n\n## 计算字段\n### 拼接\n```sql\n-- 按照 `云卷云舒（20）`这样的昵称+年龄格式表示，`RTrim`去掉值右边的所有空格，\nselect Concat(RTrim(nick_name),'(',RTrim(age),')') from user_info;\n```\n<br>\n\n### 使用别名\n```sql\n-- as info\nselect Concat(RTrim(nick_name),'(',RTrim(age),')') as info from user_info;\n```\n<br>\n\n### 算术运算 \n```sql\nselect order_id,quantity,item_price,quantity*item_price as cost from order_items;\n```\n操作符|说明\n-|-\n+|加法\n-|减法\n*|乘法\n/|除法\n\n\n\n<br><br> \n\n***\n\n<br><br>\n\n## 数据处理函数\n### 文本处理函数\n函数|说明\n-|-\nLeft()|返回串左边的字符\nLength()|返回串的长度\nLocate()|找出串的一个子串\nLower()|将串转换为小写\nLTrim()|去掉串左边的空格\nRight()|返回串右边的字符\nRTrim()|去掉串右边的空格\nSoundex()|返回串的SOUNDEX值\nSubString()|返回子串的字符\nUpper()|将串转换为大写\n\n\n\n>SOUNDEX:将任何文本串转换为其语音表示的字母数字模式的算法。使得能**对串进行发音比较而不是字母比较**\n```sql\n-- nikename发音类似cc的所有nickname\nselect nickname from user_info where Soundex(nickname)=Soundex('cc');\n```\n<br>\n\n### 时间处理函数\n函数|说明\n-|-\nAddDate()|增加一个日期（天、周等）\nAddTime()|增加一个时间（时、分等）\nCurDate()|返回当前日期\nCurTime()|返回当前时间\nDate()|返回日期时间的日期部分\nDateDiff()|计算两个日期之差\nDate_Add()|高度灵活的日期运算函数\nDate_Format()|返回一个格式化的日期或时间串\nDay()|返回一个日期的天数部分\nDayOfWeek()|对于一个日期，返回对应的星期几\nHour()|返回一个时间的小时部分\nMinute()|返回一个时间的分钟部分\nMonth()|返回一个日期的月份部分\nNow()|返回当前日期和时间\nSecond()|返回一个时间的秒部分\nTime()|返回一个日期时间的时间部分\nYear()|返回一个日期的年份部分\n\n>日期格式最好为yyyy-mm-dd,可以排除多义性，这样MySql就不必做出任何假设，更加可靠\n\n>`select * from user where birthday='2000-01-01'` 会和 birthday为'2000-01-01 01:01:01'的匹配失败     \n> 更好的解决方案是利用`Date()`函数直接匹配日期部分 `select * from user where Date(birthday)='2000-01-01'`\n\n### 数值处理函数\n函数|说明\n-|-\nAbs()|返回一个数的绝对值\nCos()|返回一个角度的余弦\nExp()|返回一个数的指数值\nMod()|返回除操作的余数\nPi()|返回圆周率\nRand()|返回一个随机数\nSin()|返回一个角度的正弦\nSqrt()|返回一个数的平方根\nTan()|返回一个角度的正切\n\n<br><br>\n***\n<br><br>\n\n## 汇总数据\n### 聚集函数\n函数|说明\n-|-\nAVG()|返回某列的平均值\nCOUNT()|返回某列的行数\nMAX()|返回某列的最大值\nMIN()|返回某列的最小值\nSUM()|返回某列值之和\n\n>以上函数均忽略列值为NULL的行\n\n```sql\nselect AVG(age)    from user_info;\nselect COUNT(age)  from user_info;\nselect MAX(age)    from user_info;\nselect MIN(age)    from user_info;\nselect SUM(age)    from user_info;\n```\n\n<br><br>\n***\n<br><br>\n\n## 分组函数\n\n### 创建分组\n\n1. 先按照特定顺序分组\n2. 再对**每一组**进行计算\n\n```sql\n-- 先按照昵称分组，然后对每一组进行求和运算\nselect nick_name,SUM(age) from user_info group by nick_name;\n```\n>select后的每一列都**必须在GROUP BY字句中给出**\n\n>如果在select中使用表达式，则必须在group by子句中指定相同的表达式\n\n### 过滤分组\nHAVING:\n* 基础功能和WHERE一样，在简单句式中可以替代WHERE\n* 区别：\n    * WHERE过滤行，HAVING过滤分组\n    * WHERE在数据**分组前**过滤数据，HAVING在数据**分组后**对组进行分组。\n\n```sql\n-- 先对过滤掉age<=10的数据，再筛选出分组总年龄大于100的小组\nselect nick_name,SUM(age) from user_info where age>10 group by nick_name having SUM(age)>100;\n```\n\n<br><br>\n***\n<br><br>\n\n## 子查询\n\n### 利用子查询过滤\n>现在有订单表orderitems，客户信息表customers，订单物品表orderitems      \n>查询出订购物品cc2的所有客户姓名\n\n* 检索包含物品cc2的所有订单的编号。\n```sql\nselect order_num from orderitems where prod_id='cc2';\n```\n* 检索具有前一步骤列出的订单编号的所有客户的ID。\n```sql\nselect cust_id from orders where order_num IN (2005,2006);\n```\n* 检索前一步骤返回的所有客户ID的客户信息。 **从内向外执行**\n```sql\nselect cust_id from orders where order_num IN (select order_num from orderitems where prod_id='cc2');\n```\n* 从客户ID中查询出信息\n```sql\nselect \n    cust_name \nfrom \n    customers \nwhere \n    cust_id IN (select \n                    cust_id \n                from \n                    orders \n                where \n                    order_num IN (select \n                                    order_num \n                                from \n                                    orderitems \n                                where \n                                    prod_id='cc2'));\n```\n\n\n### 作为计算手段使用子查询\n>现有订单表orderitems，客户信息表customers      \n>查询每个用户的订单总数\n\n* 查询某个用户的所有订单数\n```sql\nselect count(*) as orders from orders where cust_id=1001;\n```\n* 查询在订单表中每个用户的订单总数及其信息\n```sql\nselect cust_name,\n       (select count(*)\n        from orders \n        where oders.cust_id=customers.cust_id) as orders \nfrom customer \norder by cust_name;\n```   \n\n\n<br><br>\n***\n<br><br>\n\n## 联结表\n### 使用where\n```sql\nselect vend_name,prod_name,prod_price from vendors,products where vendors.vend_id=prodcts.vend_id order by vend_name,prod_name;\n```\n### 内部联结\n使用 INNER JOIN 指定表，再使用 ON 执行特定条件的连接\n\n* 检索所有客户及其订单\n```sql\nSELECT customer.cust_id,orders.order_num FROM customer INNER JOIN orders ON customers.cust_id = orders.cust_id;\n```\n\n### 多表联结\n```sql\nselect cust_name \nfrom customer,orders,orderitems \nwhere customer.cust_id=oders.cust_id \nand orderitems.order_num=orders.order_num\nand prod_id='cc2';\n```\n\n<br><br>\n***\n<br><br>\n\n## 高级联结\n### 使用表别名\n```sql\nselect cust_name \nfrom customer as c,orders as o,orderitems as oi \nwhere c.cust_id=o.cust_id \nand oi.order_num=o.order_num\nand prod_id='cc2';\n```\n\n### 自联结\n>在商品表中发一下一个不合格商品(id为cc3)，现在需要查找出生产这个商品的厂家的其他产品\n\n* 使用子查询\n```sql\nSELECT prod_id,prod_name FROM products where vend_id = (SELECT vend_id FROM products WHERE prod_id = 'cc2');\n```\n\n* 使用自联结\n```sql\nSELECT p1.prod_id,p1.prod_name FROM products AS p1, products AS p2 WHERE p1.vend_id=p2.vend_id AND p2.prod_id = 'cc3';\n```\n>p1,p2实际上是相同的一张表\n\n### 自然联结\n无论何时对表进行联结，应该至少有一个列出现在不止一个表中，标准的联结(内部联结)返回所有的数据，**甚至所有的列多次出现**。\n\n**自然联结排除多次出现，使每个列只返回一次。**\n\n\n### 外部联结\n许多联结将一个表中的行与另外一个表中的行相关联。但有时候需要**包含没有关联行的那些行**。\n* 列出所有产品以及订购数据，**包括哪些没有人订购的产品**\n* 对每个客户下了多少订单进行计数，**包括哪些至今尚未下订单的客户**\n* 检索所有客户及其订单(内部联结)\n\n```sql\nSELECT customer.cust_id,orders.order_num FROM customer INNER JOIN orders ON customers.cust_id = orders.cust_id;\n```\n\n* 检索所有客户，包括那些没有下订单的客户(外部联结)\n```sql\nSELECT customer.cust_id,orders.order_num FROM customer LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id;\n```\n\n>RIGHT表示OUTER JION右边的表的所有行（匹配或不匹配）都将被检索出来   \n>LEFT 表示OUTER JION左边的表   \n\n\n### 带聚集函数的联结\n检索出所有客户及每个客户所下的订单数\n```sql\nSELECT customers.cust_id,count(orders.ooder_num) FROM customer LEFT OUTER JOIN orders ON customer.cust_id = orders.cust_id ORDER BY customers.id;\n```\n\n<br><br>\n***\n<br><br>\n\n## 组合查询\n* 对于单个查询中从不同表汇总返回类似结构的数据\n* 对单个表执行多个查询，按单个查询返回数据\n\n### 使用UNION\n>检索出所有价格小于5且来自2001,2002的供应商的所有商品\n```sql\nSELECT prod_id,pro_name\nFROM products\nWHERE prod_price < 5\nUNION\nSELECT prod_id,pro_name\nFROM productes\nWHERE vend_id in (2001,2003)\nORDER BY prod_name;\n```\n\n>默认去除多个SELECT结果的重复行，但是可以使用UNION ALL来返回所有的改变行      \n>排序语句放在最后一个SELECT的后面\n\n\n<br><br>\n***\n<br><br>\n\n## 全文本搜索\n### 启用全文搜索\nMySql指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySql可以快速有效地判断哪些行包含它们，哪些词不匹配，它们匹配的频率，等等\n**FULLTEXT(列名称)**    \n```sql\nCREATE TABLE product(\n    note_id     int         NOT NULL,\n    pro_id      char(10)    NOT NULL,\n    note_text   text        NOT NULL,\n    PRIMARY KEY(pro_id),\n    FULLTEXT(note_text)\n)ENGINE=MyISAM;\n```\n>InnoDB不支持全文本搜索引擎\n\n### 进行全文本搜索\nMatch()：指定被搜索的列      \nAgainst()：指定要使用的搜索表达式\n```sql\nSELECT note_text FROM productnotes WHERE Match (note_text) Against('rabbit');\n```\n\n### 使用扩展查询\n考虑下面 的情况。你想找出所有提到anvils的注释。只有一个注释包含词anvils， 但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils。 这也是查询扩展的一项任务。在使用查询扩展时，MySQL对数据和 索引进行两遍扫描来完成搜索： \n* 首先，进行一个基本的全文本搜索，**找出与搜索条件匹配的所有行**；\n* 其次，MySQL检查这些匹配行并**选择**所有有用的词（我们将会简 要地解释MySQL如何断定什么有用，什么无用）。 \n* 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件， 而且还使用所有有用的词。 \n```sql\nSELECT note_text FROM productnotes WHERE Match(note_text) Against ('anvil' WITH QUERY EXPANsION);\n```\n>可能返回多行，但只有第一行含有关键字'anvil'，其他行因为含有第一行的相关字而有可能被检索出来\n\n### 布尔文本搜索\n可以提供关于如下内容的细节：\n* 要匹配的词\n* 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含 其他指定的词也是如此） \n* 排列提示（指定某些词比其他词更重要，更重要的词等级更高）\n* 表达式分组\n* 另外一些内容\n\n布尔操作符|说明\n-|-\n+|包含，词必须存在\n-|排除，词必须不出现\n\\>|包含，而且增加等级值 \n<|包含，且减少等级值 \n()|把词组成子表达式（允许这些子表达式作为一个组被包含、 排除、排列等） \n~|取消一个词的排序值 \n*|词尾的通配符 \n\"\"|定义一个短语（与单个词的列表不一样，它匹配整个短语以 便包含或排除这个短语） \n \n```sql\nSELECT note_text FROM productnotes WHERE Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE);\n```\n>检索含有关键字`heavy`**但不含有以`rope`开头的行**\n\n\n### 一些说明\n* 在索引全文本数据时，**短词被忽略且从索引中排除**。短词定义为 那些具有*3个或3个以下字符的词*（如果需要，这个数目可以更改）。\n* MySQL带有一个**内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略**。如果需要，可以覆盖这个列表（请参 阅MySQL文档以了解如何完成此工作）。\n* 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。 因此，MySQL规定了一条50%规则，**如果一个词出现在50%以上的行中，则将它作为一个非用词忽略**。*50%规则不用于IN BOOLEAN MODE。*\n* 如果表中的**行数少于3行，则全文本搜索不返回结果**（因为每个词 或者不出现，或者至少出现在50%的行中）。 \n* *忽略词中的单引号*。例如，don't索引为dont。 \n* *不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文*本搜索结果。 \n* 如前所述，**仅在MyISAM数据库引擎中支持全文本搜索。** \n\n<br><br> \n\n***\n\n<br><br>\n\n## 插入数据\n### 插入完整的行\n```sql\nINSERT into customers VALUES (\"1\",\"cc\",\"cc@foxmail\");\n```\n>对每个列**必须**提供一个值。**如果某个列没有值，应该使用NULL值**（假定表允许对该列指定空值）。\n>对于自增的字段，也需要设为NULL\n\n>种语法很简单，但并不安全，**应该尽量避免使用**。不能保证下一次表结构变动后各个列 保持完全相同的次序\n\n```sql\nINSERT into customers(cust_id,cust_name,cust_email) VALUES (\"1\",\"cc\",\"cc@foxmail\");\n```\n>用VALUES 列表中的相应值填入列表中的对应项        \n>对于自增字段，可以不出现\n\n>如果数据检索是最重要的（通常是这样），则你可以通过在 INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL 降低INSERT语句的优先级，如下所示：         \n>`INSERT LOW_PRIORITY INTO`        \n>这也适用于UPDATE和DELETE语句      \n\n### 插入多行\n```sql\nINSERT into customers(cust_id,cust_name,cust_email) VALUES (\"1\",\"cc\",\"cc@foxmail\"),(\"2,cc2,cc2@foxmail\");\n```\n###  插入检索出来的数据\n合并新旧表\n```sql\nINSERT into cust_new(cust_id,\n                      cust_name,\n                      cust_email)\nSELECT  cust_id,\n        cust_name,   \n        cust_email                \nFROM cust_old;\n```\n\n<br><br> \n\n***\n\n<br><br>\n\n## 更新和删除数据\n### 更新\n```sql\nUPDATE customers SET cust_email = 'newmail@foxmial.com', cust_name = 'newname' WHERE cust_id = '1';\n```\n> 如果没有`WHERE`语句，**则将更新这张表中所有数据**\n\n>IGNORE关键字，如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 （错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示： UPDATE IGNORE customers… \n\n>为了删除某一行的某个列值，可以将它更新为NULL\n\n### 删除\n* 删除一行\n```sql\nDELETE FROM customers WHERE cust_id = '1231';\n```\n>如果没有`WHERE`语句，**则将删除这张表中所有数据**     \n>如果更快的删除而且删除清零自增字段，可以使用`truncate tablename`\n\n除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE 子句的UPDATE或DELETE语句。\n保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能 像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。\n在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进 行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。 \n\n### 创建和删除表\n#### 创建表\n```sql\nCREATE TABLE product(\n    pro_id      char(10)    NOT NULL  AUTO_INCREMENT, --自增\n    note_id     int         NOT NULL,\n    note_text   text        NOT NULL,\n    pro_price   ine         NOT NULL DEFAULT 1, --默认值为1\n    PRIMARY KEY(pro_id)\n)ENGINE=InnoDB;\n```\n>自增字段 AUTO_INCREMENT，（每个表**只允许有一个自增字段**，且**必须被索引**<例如使它变为主键>）       \n>使用`SELECT last_insert_id()`语句**返回最后一个AUTO_INCREMENT值**\n\n> DEFAULT 设置默认值\n\n#### 引擎类型\n与其他DBMS一样，MySQL有一个**具体管理和处理数据**的内部引擎。 在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT 语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候， 此引擎都隐藏在DBMS内，不需要过多关注它。   \n\n但MySQL与其他DBMS不一样，**它具有多种引擎**。它打包多个引擎， 这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT 等命令。 \n\n为什么要发行多种引擎呢？因为它们**具有各自不同的功能和特性**， 为不同的任务选择正确的引擎能获得**良好的功能和灵活性**。 \n\n当然，你完全可以忽略这些数据库引擎。如果省略ENGINE=语句，则 使用默认引擎（很可能是MyISAM），多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么ENGINE=语句很重要的原因 （也就是为什么本书的样列表中使用两种引擎的原因）。 \n\n* InnoDB是一个**可靠的事务处理引擎**（参见第26章），它**不支持全文本搜索**\n* MEMORY在功能等同于MyISAM，但由于**数据存储在内存**（不是磁盘） 中，**速度很快**（特别适合于临时表）\n* MyISAM是一个**性能极高**的引擎，它支持全文本搜索（参见第18章）， 但**不支持事务处理**。 \n \n#### 更新表\n为更新表定义，可使用**ALTER TABLE**语句。但是，理想状态下，*当表中存储数据以后，该表就不应该再被更新*。在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。 \n\n```sql\n--增加字段\nALTER TABLE products ADD prod_price;\n--删除字段\nALTER TABLE products DROP prod_price;\n--定义外键\nALTER TABLE products ADD CONSTRAINT orderitems FOREIGN KEY (order_num) REFERENCES (order_num);\n```\n\n**复杂的表结构更改**一般需要手动删除过程，它涉及以下步骤： \n* 用新的列布局创建一个新表\n* 使用INSERT SELECT语句从旧表复制数据到新表\n* 检验包含所需数据的新表\n* 重命名旧表（如果确定，可以删除它）\n* 用旧表原来的名字重命名新表\n* 根据需要，重新创建触发器、存储过程、索引和外键\n \n#### 删除表\n```sql\nDROP TABLE customers;\n```\n\n### 清除表数据\n```sql\n--删除数据\ndelete * from TName;\n--删除所有数据并重置自增序列\ntruncate table TName; \n```\n\n#### 重命名表\n```sql\nRENAME TABLE customer1 TO customer2;\n```\n\n<br><br> \n\n***\n\n<br><br>\n\n## 视图\n视图是**虚拟的表**。与包含数据的表不一样，视图**只包含使用时动态检索数据的查询**。 \n>它**本身不包含**表中应该有的**任何列或数据**，它**包含的是一个SQL查询**\n\n\n### 视图的应用\n* **重用SQL语句**\n* **简化复杂的SQL操作**。在编写查询后，可以方便地重用它而不必知道它的基本查询细节\n* **使用表的组成部分**而不是整个表。\n* **保护数据**。可以给用户授予表的特定部分的访问权限而不是整个 表的访问权限\n* **更改数据格式和表示**。视图可返回与底层表的表示和格式不同的数据\n\n在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图**执行SELECT操作**，**过滤**和**排序**数据，将视**图联结到其他视图或表**，甚至能**添加**和**更新**数据（添加和更新数据存在某些限制。关于这个内容稍 后还要做进一步的介绍）。 \n>如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。\n\n### 视图的规则和限制\n* 视图必须唯一命名\n* 创建的视图数目没有限制\n* **必须具有足够的访问权限**\n* **视图可以嵌套**，即可以利用从其他视图中检索数据的查询来构造 一个视图\n* ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖\n* **视图不能索引**，也不能有关联的触发器或默认值\n* 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句。 \n\n### 使用视图\n* CREATE VIEW语句来创建\n* SHOW CREATE VIEW viewname；来查看创建视图的语\n* 用DROP删除视图，其语法为DROP VIEW viewname\n* 更新视图时，可以先用DROP再用CREATE，也可以直接用`CREATE OR REPLACE VIEW`。如果要更新的视图不存在，则第2条更新语句会创 建一个视图；如果要更新的视图存在，则第2条更新语句会替换原 有视图\n\n### 更新视图\n通常，视图是可更新的，但是，并非所有视图都是可更新的。基本上可以说，**如果MySQL不能正确地确定被更新的基数据，则不允许更新**（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新： \n* 分组\n* 联结\n* 子查询\n* 并\n* 聚集函数（Min()、Count()、Sum()等）\n* DISTINCT\n* 导出（计算）列\n\n<br><br> \n\n***\n\n<br><br>\n\n## 存储过程 \n迄今为止，使用的大多数SQL语句都是针对一个或多个表的单条语 句。并非所有操作都这么简单，经常会有一个完整的操作需要多条语句 才能完成。例如，考虑以下的情形\n* 为了处理订单，需要核对以保证库存中有相应的物品\n* 如果库存有物品，这些物品需要预定以便不将它们再卖给别的人，并且要减少可用的物品数量以反映正确的库存量\n* 库存中没有的物品需要订购，这需要与供应商进行某种交互 \n* 关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的客户\n\n执行这个**处理需要针对许多表的多条MySQL语句**。此外，需要执行的**具体语句及其次序**也不是固定的，它们可能会（和将）根据哪些物品在库存中哪些不在而变化。 \n\n存储过程简单来说，就是为以后的使用而保存的**一条或多条MySQL语句的集合**。\n>可将其视为批文件，虽然它们的作用不仅限于批处理。 \n\n### 使用存储过程的优缺点\n#### 优点\n**简单、安全、高性能**\n* 通过把处理封装在容易使用的单元中，**简化复杂的操作**（正如前 面例子所述）\n* 由于不要求反复建立一系列处理步骤，这**保证了数据的完整性**。*如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的*。 这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误**保证了数据的一致性**\n* **简化对变动的管理**。如果表名、列名或业务逻辑（或别的内容） 有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化\n* **提高性能**。因为使用存储过程比使用单独的SQL语句要快 \n* 存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写**功能更强更灵活**的代码\n\n#### 缺点\n* 存储过程的**编写比基本SQL语句复杂**，编写存储过程需要更高的技能，更丰富的经验。 \n* 你可能**没有创建存储过程的安全访问权限**。许多数据库管理员限 制存储过程的创建权限，允许用户使用存储过程，但不允许他们 创建存储过程。 \n\n### 使用存储过程\n* 执行（call）\n```sql\nCALL productpricing(@pricelow,@pricehigh,@priceaverage);\n```\n### 创建存储过程\n返回产品平均过程的存储过程\n```sql\nCREATE PROCEDURE productpricing()\nBEGIN\n    SELECT AVG(prod_price) AS priceaverage FROM products;\nEND\n```\n> 注意productpricing()的()\n\nmysql命令行客户机的分隔符(命令行工具)\n```sql\nDELIMITER//\n\n\nCREATE PROCEDURE productpricing()\nBEGIN\n    SELECT AVG(prod_price) AS priceaverage FROM products;\nEND//\n\nDELIMITER;\n\n```\n>因为在存储过程存在`;`，所以在命令行程序中需使用特定的分隔符     \n>DELIMITER+符号（分隔符）：表示告诉程序使用此分隔符作为新的语句结束分隔符,所以由`END`变为了`END//`     \n>除\\符号外，任何字符都可以用作语句分隔符。 \n\n### 删除存储过程\n```sql\nDROP PROCEDURE productpricing;\n```\n>注意没有`()`    \n>如果该存储过程不存在，则会报错，所以建议使用`DROP PROCEDURE IF EXISTS`\n\n### 使用参数\n* 创建带参数的存储过程\n```sql\nCREATE PROCEDURE productpricing(\n    OUT pl DECIMAL(8,2),    --pl:存储产品最低价格\n    OUT ph DECIMAL(8,2),    --ph:存储产品最高价格\n)\nBEGIN\n    SELECT MIN(prod_price) INTO pl FROM products;\n    SELECT MAX(prod_price) INTO ph FROM products;\nEND\n```\n>存储过程保存在BEGIN和END之间\n\n> OUT指出相应的参数用来**从存储过程传出** 一个值（返回给调用者）     \n> IN,传递给存储过程     \n> INOUT，对存储过程传入传出\n\n\n* 使用存储过程\n```sql\n--指定变量名\nCALL productpricing(@pricelow, @prichigh);\n\n--检索\nSELECT @prcielow;\n\nSELECT @prcielow, @prichigh;\n```\n\n### 检查存储过程\n```sql\n-- 显示创建的语句\nSHOW CREATE PROCEDURE ordertotal;\n\n-- 显示更加详细，何时、由何人创建的信息\nSHOW CREATE PROCEDURE STATUS ordertotal;\n\n-- 过滤查看更多存储过程的信息\nSHOW CREATE PROCEDURE STATUS LIKE 'ordertotal';\n```\n<br><br> \n\n***\n\n<br><br>\n\n## 游标\n\n（~~有待填坑~~）\n\n有时，**需要在检索出来的行中前进或后退一行或多行**。这就是使用游标的原因。游标（cursor）是**一个存储在MySQL服务器上的数据库查询**， 它不是一条SELECT语句，**而是被该语句检索出来的结果集**。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。 \n\n游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。 \n\n### 使用注意\n* 在能够**使用游标前，必须声明**（定义）它\n* 一旦声明后，必须打开游标以供使用。\n* 对于填有数据的游标，根据需要取出（检索）各行。 \n* 在结束游标使用时，必须关闭游标。 \n\n### 创建游标\n```sql\nCREATE PROCEDURE processorders()\nBEGIN\n    DECLARE ordernumbers CURSOR\n    FOR\n    SELECT order_num FROM orders;\nEND;\n```\n### 打开和关闭游标\n```sql\n--打开\nOPEN ordernumbers;\n\n--关闭\nCLOSE ordernumbers;\n```\n>如果不明确关闭游标，MySql将会在到达END语句时自动关闭\n\n### 使用游标\n在一个游标被打开后，可以使用**FETCH语句**分别访问它的每一行。 FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。 它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。\n```sql\nCREATE PROCEDURE processorders()\nBEGIN\n    --声明一个变量\n    DECLARE o INT;\n    --声明一个游标\n    DECLARE ordernumbers CURSOR\n    FOR\n    SELECT order_num FROM orders;\n    --打开一个游标\n    OPEN ordernumbers;\n    --获取数据\n    FETCH ordernumbers INTO o;\n    --关闭游标\n    CLOSE ordernumbers;\nEND;\n```\n<br><br> \n\n***\n\n<br><br>\n \n## 触发器\nMySQL语句在需要时被执行，存储过程也是如此。但是，如果你想要**某条语句（或某些语句）在事件发生时自动执行**，怎么办呢？例如： \n* 每当增加一个顾客到某个数据库表时，都检查其电话号码格式是 否正确，州的缩写是否为大写； \n* 每当订购一个产品时，都从库存数量中减去订购的数量； \n* 无论何时删除一行，都在某个存档表中保留一个副本。 \n\n所有这些例子的共同之处是它们都需要在某个表发生更改时自动处理。这确切地说就是触发器。触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语 句） ： \n* DELETE； \n* INSERT； \n* UPDATE。\n\n*其他MySQL语句不支持触发器。* \n\n### 创建触发器\n在创建触发器时，需要给出4条信息： \n* 唯一的触发器名； \n* 触发器关联的表； (只有表支持触发器，视图不支持)\n* 触发器应该响应的活动（DELETE、INSERT或UPDATE）； \n* 触发器何时执行（处理之前或之后）。 \n\n>每个表将最多支持6个触发器，DELETE、INSERT或UPDATE的处理之前或之后\n\n \n> 在MySQL 5中，触发器名必 须在每个表中唯一，但不是在每个数据库中唯一。这表示同一 数据库中的两个表可具有相同名字的触发器。这在其他每个数 据库触发器名必须唯一的DBMS中是不允许的，而且以后的 MySQL版本很可能会使命名规则更为严格。因此，现在最好 是在数据库范围内使用唯一的触发器名。 \n \n```sql\nCREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'product added';\n```\n> 使用INSERT语句添加一行或多行到products表中时，将对每一行显示文本product added\n \n### 删除触发器\n```sql\nDROP TRIGGER newproduct;\n```\n>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。\n\n### 使用触发器\n#### INSERT触发器 \nINSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点： \n* 在INSERT触发器代码内，可引用一个**名为NEW的虚拟表，访问被插入的行**； \n* 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值） ； \n* 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。 \n```sql\nCREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT NEW.order_num;\n```\n>在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从NEW. order_num取得这个值并返回它。\n\n#### DELETE触发器\nDELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两 点： \n* 在DELETE触发器代码内，你可以引用一个名为**OLD的虚拟表，访问被删除的行**；\n* OLD中的值全都是只读的，不能更新。  \n```sql\nCREATE TRIGGER deleteorder BEFORE DELETE ON products FOR EACH ROW\nBEGIN\n    INSERT INTO archive_orders(order_num,order_date)\n    VALUES(OLD.order_num,OLD.order_num);\nEND;\n```\n>在任意订单被删除前将执行此触发器。它使用一条INSERT语句 将OLD中的值（要被删除的订单）保存到一个名为archive_ orders的存档表中\n\n\n#### UPDATE触发器 \nUPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：\n* 在UPDATE触发器代码中，你可以引用一个名为**OLD**的虚拟表**访问以前**（UPDATE语句前）的值，引用一个名为**NEW的虚拟表访问新更新的值**； \n* 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改 将要用于UPDATE语句中的值）； \n* OLD中的值全都是**只读的，不能更新**。 \n```sql\nCREATE TRIGGER updateevendor BEFORE DELETE ON vendors FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend-state);\n```\n>下面的例子保证州名缩写总是大写（不管UPDATE语句中给出的是大 写还是小写）： \n \n\n### 进一步介绍\n\n在结束本章之前，我们再介绍一些使用触发器时需要记住的重点。\n* 与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来的 MySQL版本中有一些改进和增强触发器支持的计划。 \n* 创建触发器可能需要特殊的安全访问权限，但是，**触发器的执行是自动的。如果INSERT、UPDATE或DELETE语句能够执行，则相关的触发器也能执行**。 \n* 应该用触发器来**保证数据的一致性**（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。 \n* 触发器的一种非常有意义的使用是**创建审计跟踪**。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个 表非常容易。 \n* 遗憾的是，MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。\n\n<br><br> \n\n***\n\n<br><br>\n\n## 事务处理\n事务处理（transaction processing）可以用来维护数据库的完整性，它 保证成批的MySQL操作**要么完全执行，要么完全不执行。** \n\n \n利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）**。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。**\n \n> * 事务（transaction）指一组SQL语句； \n> * 回退（rollback）指撤销指定SQL语句的过程； \n> * 提交（commit）指将未存储的SQL语句结果写入数据库表； \n> * 保留点（savepoint）指事务处理中设置的临时占位符（place- holder），你可以对它发布回退（与回退整个事务处理不同\n\n### 使用ROLLBACK \nMySQL的ROLLBACK命令用来回退（撤销）MySQL语句。\n```sql\nSELECT * FROM ordertotals ;\n--开始事物\nSTART TRANSACTION; \nDELETE FROM ordertotals;\nSELECT * FROM ordertotals;\n--撤销\nROLLBACK;\nSELECT * FROM ordertotals;\n```\n>首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条 SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句**回退 START TRANSACTION之后的所有语句**，最后一条SELECT语句显示该表不为空。 \n\n### 使用COMMIT\n一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。 \n\n但是，**在事务处理块中，提交不会隐含地进行**。为进行明确的提交，使用COMMIT语句，如下所示： \n ```sql\n--开始事物\nSTART TRANSACTION; \nDELETE FROM ordertotals WHERE order_num = 20010;\nDELETE FROM orders WHERE order_num = 20010;\n--提交\nCOMMIT;\n```\n>从系统中完全删除订单20010。因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来**保证订单不被部分删除**。最后的COMMIT语句**仅在不出错时写出更改**。如 果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的） \n\n>**隐含事务关闭**  当COMMIT或ROLLBACK语句执行后，事务会自 动关闭（将来的更改会隐含提交）。 \n\n### 使用保用点\n简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但 是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要**部分提交或回退**。 \n```sql\n--创建保用点\nSAVEPOINT delete1;\n--回退\nROLLBACK TO delete1\n```\n>**保留点越多越好** .可以在MySQL代码中设置任意多的保留 点，越多越好。为什么呢？因为保留点越多，你就越能按自己的意愿**灵活**地进行回退。\n\n> 保留点在事务处理完成（执行一条**ROLLBACK或 COMMIT）后**自动释放**。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。 \n \n### 更改默认提交方式\n正如所述，默认的MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句： \n```sql\nSET autocommit=0;\n```\n\n## 全球化和本地化 \n**不同的语言和字符集需要以不同的方式存储和检索**。\n\n因此，MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法。\n\n* **字符集**：字母和符号的集合； \n* **编码**：某个字符集成员的内部表示； \n* **校对**：规定字符如何比较的指令。 \n>校对为什么重要  排序英文正文很容易，对吗？或许不。考 虑词APE、apex和Apple。它们处于正确的排序顺序吗？这有 赖于你是否想区分大小写。使用区分大小写的校对顺序，这 些词有一种排序方式，使用不区分大小写的校对顺序有另外 一种排序方式。这不仅影响排序（如用ORDER BY排序数据） ， 还影响搜索（例如，寻找apple的WHERE子句是否能找到 APPLE）。在使用诸如法文à或德文ö这样的字符时，情况更复 杂，在使用不基于拉丁文的字符集（日文、希伯来文、俄文 等）时，情况更为复杂\n\n\n### 使用字符集和校对顺序 \n为查看所支持的字符集完整列表\n```sql\nSHOW CHARACTER SET;\n```\n为了查看所支持校对的完整列\n```sql\nSHOW COLLATION;\n```\n\n通常系统管理在安装时定义一个默认的字符集和校对。此外，也可 以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对可以使用以下语句： \n```sql\nSHOW VARIABLES LIKE 'character%';\nSHOW VARIABLES LIKE 'collation%';\n```\n\n为了给表指定字符集和校对，可使用带子句的CREATE TABLE       \n```sql\nCREATE TABLE mytable\n(\n    column1 INT,\n    column2 VARCHAR(10),\n) DEFAULT CHARACTER SET brew     --字符集\n  COLLATE hebrew_general_ci;     --校对顺序\n```\n\n对某个列设置单独的字符集和校对\n```sql\nCREATE TABLE mytable\n(\n    column1 INT,\n    column2 VARCHAR(10),\n    column3 VARCHAR(20) CHARACTER SET latin1 COLLATE latin1_general_ci\n) DEFAULT CHARACTER SET brew     --字符集\n  COLLATE hebrew_general_ci;     --校对顺序\n```\n\n\n如前所述，校对在对用ORDER BY子句检索出来的数据排序时起重要 的作用。如果你**需要用与创建表时不同的校对顺序排序特定的SELECT语句**，可以在SELECT语句自身中进行：\n```sql\n    SELECT * FROM  customer ORDER BY lastname COLLATE latin1_general_ci;\n```\n<br><br> \n\n***\n\n<br><br>\n\n## 安全管理\nMySQL服务器的安全基础是：**用户应该对他们需要的数据具有适当的访问权，既不能多也不能少**。换句话说，用户不能对过多的数据具有过多的访问权。 \n>应该严肃对待root登录的使用。仅在绝对需 要时使用它（或许在你不能登录其他管理账号时使用）。不应 该在日常的MySQL操作中使用root。 \n\n### 管理用户\nMySQL用户账号和信息存储在名为mysql的MySQL数据库中。一般不需要直接访问mysql数据库和表（你稍后会明白这一点），但有时需要直接访问。需要直接访问它的时机之一是在需要获得所有用户账号列表时。\n\nmysql数据库有一个名为user的表，它包含所有用户账号。user 表有一个名为user的列，它存储用户登录名。\n\n#### 创建用户\n```sql\n--创建账户名为cc1,密码为123的账户\nCREATE USER cc1 IDENTIFIED BY '123';\n--重命名\nRENAME USER cc1 TO cc2;\n```\n> **使用GRANT或INSERT** GRANT语句也可以创建用 户账号，但一般来说CREATE USER是最清楚和最简单的句子。 此外，也可以通过直接插入行到user表来增加用户，不过为安全起见，一般不建议这样做。MySQL用来存储用户账号信息 的表（以及表模式等）极为重要，对它们的任何毁坏都 可能严重地伤害到MySQL服务器。因此，相对于直接处理来 说，最好是用标记和函数来处理这些表。 \n\n#### 更改口令\n```sql\nSET PASSWORD FOR  cc2 = Password('456');\n--设置当前账户口令\nSET PASSWORD = Password('456');\n```\n\n#### 删除用户\n```sql\nDROP USER cc2;\n```\n\n### 设置访问权限\n在创建用户账号后，必须接着分配访问权限。**新创建的用户账号没有访问权限**。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。\n```sql\n--看到赋予用户账号的权限\nSHOW GRANTS FOR cc2;\n```\n为**设置权限**，使用GRANT语句。GRANT要求你至少给出以下信息： \n* 要授予的权限\n* 被授予访问权限的数据库或表；\n* 用户名\n\n```sql\n--此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。\nGRANT SELECT ON crashcourse.* TO cc3;\n```\n>通过只授予SELECT访问权限，用户bforta对crashcourse数据库中的所有数据具有只读访问权限。 \n\nGRANT的反操作为REVOKE，用它来**撤销特定的权限**。\n```sql\n--取消刚赋予用户cc3的SELECT访问权限\nREVOKE SELECT ON crashcourse.* FROM cc3;\n```\n\nGRANT和REVOKE可在几个层次上控制访问权限： \n* 整个服务器，使用GRANT ALL和REVOKE ALL； \n* 整个数据库，使用ON database.*； \n* 特定的表，使用ON database.table； \n* 特定的列； \n* 特定的存储过程。\n\n下标列出可以授予或撤销的每个权限。 \n\n权限|说明\n-|-\nALL|除GRANT OPTION外的所有权限 \nALTER|使用ALTER TABLE \nALTER ROUTINE|使用ALTER PROCEDURE和DROP PROCEDURE \nCREATE|使用CREATE TABLE \nCREATE ROUTINE|使用CREATE PROCEDURE \nCREATE TEMPORARY TABLES|使用CREATE TEMPORARY TABLE \nCREATE USER|使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES \nCREATE VIEW|使用CREATE VIEW \nDELETE|使用DELETE \nDROP|使用DROP TABLE \nEXECUTE|使用CALL和存储过程 \nFILE|使用SELECT INTO OUTFILE和LOAD DATA INFILE \nGRANT OPTION|使用GRANT和REVOKE \nINDEX|使用CREATE INDEX和DROP INDEX \nINSERT|使用INSERT \nLOCK TABLES|使用LOCK TABLES \nPROCESS|使用SHOW FULL PROCESSLIST \nRELOAD|使用FLUSH \nREPLICATION CLIENT|服务器位置的访问 \nREPLICATION SLAVE|由复制从属使用 \nSELECT|使用SELECT \nSHOW DATABASES|使用SHOW DATABASES \nSHOW VIEW|使用SHOW CREATE VIEW \nSHUTDOWN|使用mysqladmin shutdown（用来关闭MySQL） \nSUPER|使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER 和SET GLOBAL。还允许mysqladmin调试登录\nUPDATE|使用UPDATE\nUSAGE|无访问权限 \n\n，当某个数据库或表被删除时（用DROP语 句），相关的访问权限仍然存在。而且，如果将来重新创建该 数据库或表，这些权限仍然起作用。 \n\n>未来的授权  在使用GRANT和REVOKE时，用户账号必须存在， 但对所涉及的对象没有这个要求。这允许管理员在创建数据库 和表之前设计和实现安全措施。 这样做的副作用是，当某个数据库或表被删除时（用DROP语 句），相关的访问权限仍然存在。而且，如果将来重新创建该 数据库或表，这些权限仍然起作用。 \n\n>简化多次授权  可通过列出各权限并用逗号分隔，将多条 GRANT语句串在一起，如下所示： `GRANT SELECT,INSERT ON crashcourse.* TO cc2;`\n\n<br><br> \n\n***\n\n<br><br>\n\n## 数据库维护\n### 数据库备份\n像所有数据一样，MySQL的数据也必须经常备份。由于MySQL数据 库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。 但是，**由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效**。 \n下面列出这个问题的可能解决方案。 \n* 使用**命令行实用程序mysqldump**转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正 确地备份转储文件。\n* 可用**命令行实用程序mysqlhotcopy**从一个数据库复制所有数据 （并非所有数据库引擎都支持这个实用程序）。 \n* 可以使用**MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储**所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原。 \n\n>首先刷新未写数据 为**了保证所有数据被写到磁盘（包括索引数据）**，可能需要在进行备份前使用**FLUSH TABLES**语句。 \n### 数据库维护\n\n**ANALYZE TABLE**，用来检查**表键**是否正确\n\n如果从一个表中删除大量数据，应该使用**OPTIMIZE TABLE**来收回所用的空间，从而优化表的性能。 \n \n### 诊断启动问题\n\n命令行mysqld手动启动\n\n### 查看错误日志\nMySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下几种。 \n* **错误日志**。它包含启动和关闭问题以及任意关键错误的细节。此 日志通常名为hostname.err，位于data目录中。此日志名可用 --log-error命令行选项更改。 \n* **查询日志**。它记录所有MySQL活动，在诊断问题时非常有用。此 日志文件可能会很快地变得非常大，因此不应该长期使用它。此 日志通常名为hostname.log，位于data目录中。此名字可以用 --log命令行选项更改。 \n* **二进制日志**。它记录更新过数据（或者可能更新过数据）的所有 语句。此日志通常名为hostname-bin，位于data目录内。此名字 可以用--log-bin命令行选项更改。注意，这个日志文件是MySQL 5中添加的，以前的MySQL版本中使用的是更新日志。 \n* **缓慢查询日志**。顾名思义，此日志记录执行缓慢的任何查询。这 个日志在确定数据库何处需要优化很有用。此日志通常名为 hostname-slow.log ，位于data 目录中。此名字可以用 --log-slow-queries命令行选项更改。 在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文 件。 \n\n在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。 \n\n## 改善性能\n\n* 首先，MySQL（与所有DBMS一样）具有**特定的硬件建议**。在学 习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但 对用于生产的服务器来说，应该坚持遵循这些硬件建议。\n* 一般来说，关键的生产DBMS应该运行在自己的**专用服务器**上。 \n* MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你**可能需要调整内存分配、缓冲区大小等。**（为查看当前设置，可使用SHOW VARIABLES;和SHOW STATUS;。） \n* MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。**如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢**。如果你遇到显著的性能不良，可使用SHOW PROCESSLIST 显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录） 。 \n* 总是有**不止一种方法编写同一条SELECT语句**。应该试验联结、并、 子查询等，找出最佳的方法。 \n* 使用**EXPLAIN语句**让MySQL**解释它将如何执行一条SELECT语句**。 \n* 一般来说，**存储过程执行得比一条一条地执行其中的各条MySQL语句快**。 \n*  应该总是使用正确的数据类型。 \n* 决**不要检索比需求还要多的数据**。换言之，不要用SELECT *（除 非你真正需要每个列）。 \n* 有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。\n* **在导入数据时，应该关闭自动提交**。你**可能还想删除索引**（包括 FULLTEXT索引），然后在导入完成后再重建它们。 \n* **必须索引数据库表以改善数据检索的性能**。确定索引什么不是一件微不足道的任务，需要分析使用的SELECT语句以找出重复的 WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。 \n* 你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的**UNION语句**，你能看到极大的性能改 进。 \n* **索引改善数据检索的性能，但损害数据插入、删除和更新的性能**。 如果你有一些表，它们收集数据且不经常被搜索，则在有必要之 前不要索引它们。（索引可根据需要添加和删除。） \n*  LIKE很慢。一般来说，**最好是使用FULLTEXT而不是LIKE**。 \n* 数据库是不断变化的实体。一组优化良好的表一会儿后可能就面 目全非了。由于表的使用和内容的更改，理想的优化和配置也会 改变。 \n* 最重要的规则就是，每条规则在某些条件下都会被打破。 \n\n\n<br><br> \n\n\n<br><br>\n\n\n\n\n\n## 参考\n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]Ben Forta, Mysql必知必会. 北京：人民邮电出版社，2019.\n</div>\n","source":"_posts/code/MySql/MySql必知必会.md","raw":"---\ntitle: 《MySql必知必会》学习笔记\ncategories: Code\ntags: Mysql\ndeclare: true\nwordCount: true\nabbrlink: 27b4eaba\ndate: 2020-07-23 20:59:10\n---\n<div style=\"width: 95%\">\n\n![《MySql必知必会》学习笔记](https://img2020.cnblogs.com/blog/2104937/202007/2104937-20200723232459669-218625272.png)\n\n</div>\n\n\nMySQL已经成为世界上最受欢迎的数据库管理系统之一。无论是用 在小型开发项目上，还是用来构建那些声名显赫的网站，MySQL都证明 了自己是个稳定、可靠、快速、可信的系统，足以胜任任何数据存储业 务的需要。\n<!-- more -->\n\n## MySql的使用\n```sql\n--选择数据库\nuse database; \n\n--返回可用数据库列表\nshow database; \n\n--返回一个数据库内表的列表\nshow tables; \n\n--对一个表的每个字段返回一行，行中包括字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息等\nshow columns from table;    \n--功能同上\ndescribe table;\n\n--用于显示广泛的服务器状态信息； \nshow status;    \n\n--显示创建创建数据库和表的MySql信息\nshow create database DBName; \nshow create table TName; \n\n--用于显示服务器错误或警告信息\nshow errors; \nshow warnings; \n```\n<br><br> \n\n***\n\n<br><br>\n\n## 检索数据\n```sql\n--查询多个字段\nselect nickname,email from user;  \n\n--查询不同的姓名\nselect distinct nickname from user; \n\n--返回前几行\nselect nickname,email from user limit 1; \n\n--返回从第0行开始的2行\nselect nickname,email from user limit 0,2;  \n\n--功能同上\nselect nickname,email from user limit 0 offset 2;  \n```\n\n<br><br> \n\n***\n\n<br><br>\n\n## 排序和过滤检索数据\n```sql\n--按照年龄从大到小排序，如果年龄相同则按照昵称从小到大排序\nselect nickname,email from user order by age desc , nickname;   \n\n--返回年龄不等于20的用户姓名 `<>`用法等同于`!=`\nselect nickename from user where age <> 20; \n\n--返回邮箱信息为空的用户名\nselect nickename from user where email is NULL; \n\n--返回邮箱信息为空的用户名\nselect nickename from user where email is NULL; \n\n--默认执行顺序为 `( age=10 ) or ( age=20 and eamil is NULL )`，`and`优先级更高\nselect * from user where age=10 or age=20 and eamil is NULL; //\n\n--对`IN`后圆括中的每一个元素进行匹配，等同于`OR`\nselect * from user where age in(10,20); \n\n--对其中条件进行否定\nselect * from user where age not in(10,20); \n\n--表示昵称包含字符e的所有用户，%表示通配符 表示任何字符出现的次数，0次、1次或多次。\nselect * from user where nickname like '%e%';   \n\n--表示昵称第二个字符为e的所有用户，`_`表示匹配单个字符。 \nselect * from user where nickname like '_e%';   \n\n```\n\n<br><br> \n\n***\n\n<br><br>\n\n## 正则表达式\n\n```sql\n--正则表达式，匹配年龄为10、20、30... 的用户，`.`表示匹配任意一个字符\nselect * from user where age REGEXP '.0';   \n\n-- `BINARY`用于正则表达式中区分大小写\nselect * from user where age BINARY REGEXP 'JetPack.000';   \n\n--正则表达式进行OR匹配\nselect * from user where age BINARY REGEXP '1000|1000';   \n\n--返回的是`1 Ton` `2 Ton` ,`[123]`为`[1|2|3]`的缩写，表示匹配1或2或3\nselect nickname from user where nickname BINARY REGEXP '[123] Ton';   \n\n--返回的是匹配指定字符串以外的值\nselect nickname from user where nickname BINARY REGEXP '[^123] Ton';   \n\n--nikename中包含`a Ton` `b Ton` `c Ton`，age中包含1,2,3\nselect nickname from user where nickname BINARY REGEXP '[a-c] Ton' and age REGEXP '[1-3]';  \n```\n\n\n\n### 匹配字符类     \n类|说明 \n-|-\n[:alnum:]|任意字符和数字（同[a-zA-Z0-9]）\n[:alpha:]|任意字符（同[a-zA-Z]）\n[:blank:]|空格和制表（同[\\\\t]）\n[:cntrl:]|ASCII控制字符（ASCII 0到31和127）\n[:digit:]|任意数字（同[0-9]）\n[:graph:]|与[:print:]相同，但不包括空格\n[:lower:]|任意小写字母（同[a-z]）\n[:print:]|任意可打印字符\n[:punct:]|既不在[:alnum:]又不在[:cntrl:]中的任意字符\n[:space:]|包括空格在内的任意空白字符（同[\\\\f\\\\n\\\\r\\\\t\\\\v]）\n[:upper:]|任意大写字母（同[A-Z]）\n[:xdigit:]|任意十六进制数字（同[a-fA-F0-9]）\n\n<br>\n\n### 匹配多个实例\n元字符|说明\n-|-\n*|0个或多个匹配\n+|1个或多个匹配（等于{1,}）\n?|0个或1个匹配（等于{0,1}）\n{n}|指定数目的匹配\n{n,}|不少于指定数目的匹配\n{n,m}|匹配数目的范围（m不超过255）\n\n> **'\\\\\\\\([0-9]stick?\\\\\\\\)'**    \n> A (1 stick)     \n> B (1 sticks)    \n> `\\\\`为转移符 ，第一个\\是MySql自己解释一个，第二\\是正则表达式解释一个\n\n<br>\n\n### 定位符\n元字符|说明\n-|-\n^|文本的开始\n$|文本的结尾\n[[:<:]]|词的开始\n[[:>:]]|词的结尾\n\n> '^\\[0-9\\\\.]'     \n> `^`匹配串的开始，即以数字开头或者`.`开头的字符串\n\n\n\n## 计算字段\n### 拼接\n```sql\n-- 按照 `云卷云舒（20）`这样的昵称+年龄格式表示，`RTrim`去掉值右边的所有空格，\nselect Concat(RTrim(nick_name),'(',RTrim(age),')') from user_info;\n```\n<br>\n\n### 使用别名\n```sql\n-- as info\nselect Concat(RTrim(nick_name),'(',RTrim(age),')') as info from user_info;\n```\n<br>\n\n### 算术运算 \n```sql\nselect order_id,quantity,item_price,quantity*item_price as cost from order_items;\n```\n操作符|说明\n-|-\n+|加法\n-|减法\n*|乘法\n/|除法\n\n\n\n<br><br> \n\n***\n\n<br><br>\n\n## 数据处理函数\n### 文本处理函数\n函数|说明\n-|-\nLeft()|返回串左边的字符\nLength()|返回串的长度\nLocate()|找出串的一个子串\nLower()|将串转换为小写\nLTrim()|去掉串左边的空格\nRight()|返回串右边的字符\nRTrim()|去掉串右边的空格\nSoundex()|返回串的SOUNDEX值\nSubString()|返回子串的字符\nUpper()|将串转换为大写\n\n\n\n>SOUNDEX:将任何文本串转换为其语音表示的字母数字模式的算法。使得能**对串进行发音比较而不是字母比较**\n```sql\n-- nikename发音类似cc的所有nickname\nselect nickname from user_info where Soundex(nickname)=Soundex('cc');\n```\n<br>\n\n### 时间处理函数\n函数|说明\n-|-\nAddDate()|增加一个日期（天、周等）\nAddTime()|增加一个时间（时、分等）\nCurDate()|返回当前日期\nCurTime()|返回当前时间\nDate()|返回日期时间的日期部分\nDateDiff()|计算两个日期之差\nDate_Add()|高度灵活的日期运算函数\nDate_Format()|返回一个格式化的日期或时间串\nDay()|返回一个日期的天数部分\nDayOfWeek()|对于一个日期，返回对应的星期几\nHour()|返回一个时间的小时部分\nMinute()|返回一个时间的分钟部分\nMonth()|返回一个日期的月份部分\nNow()|返回当前日期和时间\nSecond()|返回一个时间的秒部分\nTime()|返回一个日期时间的时间部分\nYear()|返回一个日期的年份部分\n\n>日期格式最好为yyyy-mm-dd,可以排除多义性，这样MySql就不必做出任何假设，更加可靠\n\n>`select * from user where birthday='2000-01-01'` 会和 birthday为'2000-01-01 01:01:01'的匹配失败     \n> 更好的解决方案是利用`Date()`函数直接匹配日期部分 `select * from user where Date(birthday)='2000-01-01'`\n\n### 数值处理函数\n函数|说明\n-|-\nAbs()|返回一个数的绝对值\nCos()|返回一个角度的余弦\nExp()|返回一个数的指数值\nMod()|返回除操作的余数\nPi()|返回圆周率\nRand()|返回一个随机数\nSin()|返回一个角度的正弦\nSqrt()|返回一个数的平方根\nTan()|返回一个角度的正切\n\n<br><br>\n***\n<br><br>\n\n## 汇总数据\n### 聚集函数\n函数|说明\n-|-\nAVG()|返回某列的平均值\nCOUNT()|返回某列的行数\nMAX()|返回某列的最大值\nMIN()|返回某列的最小值\nSUM()|返回某列值之和\n\n>以上函数均忽略列值为NULL的行\n\n```sql\nselect AVG(age)    from user_info;\nselect COUNT(age)  from user_info;\nselect MAX(age)    from user_info;\nselect MIN(age)    from user_info;\nselect SUM(age)    from user_info;\n```\n\n<br><br>\n***\n<br><br>\n\n## 分组函数\n\n### 创建分组\n\n1. 先按照特定顺序分组\n2. 再对**每一组**进行计算\n\n```sql\n-- 先按照昵称分组，然后对每一组进行求和运算\nselect nick_name,SUM(age) from user_info group by nick_name;\n```\n>select后的每一列都**必须在GROUP BY字句中给出**\n\n>如果在select中使用表达式，则必须在group by子句中指定相同的表达式\n\n### 过滤分组\nHAVING:\n* 基础功能和WHERE一样，在简单句式中可以替代WHERE\n* 区别：\n    * WHERE过滤行，HAVING过滤分组\n    * WHERE在数据**分组前**过滤数据，HAVING在数据**分组后**对组进行分组。\n\n```sql\n-- 先对过滤掉age<=10的数据，再筛选出分组总年龄大于100的小组\nselect nick_name,SUM(age) from user_info where age>10 group by nick_name having SUM(age)>100;\n```\n\n<br><br>\n***\n<br><br>\n\n## 子查询\n\n### 利用子查询过滤\n>现在有订单表orderitems，客户信息表customers，订单物品表orderitems      \n>查询出订购物品cc2的所有客户姓名\n\n* 检索包含物品cc2的所有订单的编号。\n```sql\nselect order_num from orderitems where prod_id='cc2';\n```\n* 检索具有前一步骤列出的订单编号的所有客户的ID。\n```sql\nselect cust_id from orders where order_num IN (2005,2006);\n```\n* 检索前一步骤返回的所有客户ID的客户信息。 **从内向外执行**\n```sql\nselect cust_id from orders where order_num IN (select order_num from orderitems where prod_id='cc2');\n```\n* 从客户ID中查询出信息\n```sql\nselect \n    cust_name \nfrom \n    customers \nwhere \n    cust_id IN (select \n                    cust_id \n                from \n                    orders \n                where \n                    order_num IN (select \n                                    order_num \n                                from \n                                    orderitems \n                                where \n                                    prod_id='cc2'));\n```\n\n\n### 作为计算手段使用子查询\n>现有订单表orderitems，客户信息表customers      \n>查询每个用户的订单总数\n\n* 查询某个用户的所有订单数\n```sql\nselect count(*) as orders from orders where cust_id=1001;\n```\n* 查询在订单表中每个用户的订单总数及其信息\n```sql\nselect cust_name,\n       (select count(*)\n        from orders \n        where oders.cust_id=customers.cust_id) as orders \nfrom customer \norder by cust_name;\n```   \n\n\n<br><br>\n***\n<br><br>\n\n## 联结表\n### 使用where\n```sql\nselect vend_name,prod_name,prod_price from vendors,products where vendors.vend_id=prodcts.vend_id order by vend_name,prod_name;\n```\n### 内部联结\n使用 INNER JOIN 指定表，再使用 ON 执行特定条件的连接\n\n* 检索所有客户及其订单\n```sql\nSELECT customer.cust_id,orders.order_num FROM customer INNER JOIN orders ON customers.cust_id = orders.cust_id;\n```\n\n### 多表联结\n```sql\nselect cust_name \nfrom customer,orders,orderitems \nwhere customer.cust_id=oders.cust_id \nand orderitems.order_num=orders.order_num\nand prod_id='cc2';\n```\n\n<br><br>\n***\n<br><br>\n\n## 高级联结\n### 使用表别名\n```sql\nselect cust_name \nfrom customer as c,orders as o,orderitems as oi \nwhere c.cust_id=o.cust_id \nand oi.order_num=o.order_num\nand prod_id='cc2';\n```\n\n### 自联结\n>在商品表中发一下一个不合格商品(id为cc3)，现在需要查找出生产这个商品的厂家的其他产品\n\n* 使用子查询\n```sql\nSELECT prod_id,prod_name FROM products where vend_id = (SELECT vend_id FROM products WHERE prod_id = 'cc2');\n```\n\n* 使用自联结\n```sql\nSELECT p1.prod_id,p1.prod_name FROM products AS p1, products AS p2 WHERE p1.vend_id=p2.vend_id AND p2.prod_id = 'cc3';\n```\n>p1,p2实际上是相同的一张表\n\n### 自然联结\n无论何时对表进行联结，应该至少有一个列出现在不止一个表中，标准的联结(内部联结)返回所有的数据，**甚至所有的列多次出现**。\n\n**自然联结排除多次出现，使每个列只返回一次。**\n\n\n### 外部联结\n许多联结将一个表中的行与另外一个表中的行相关联。但有时候需要**包含没有关联行的那些行**。\n* 列出所有产品以及订购数据，**包括哪些没有人订购的产品**\n* 对每个客户下了多少订单进行计数，**包括哪些至今尚未下订单的客户**\n* 检索所有客户及其订单(内部联结)\n\n```sql\nSELECT customer.cust_id,orders.order_num FROM customer INNER JOIN orders ON customers.cust_id = orders.cust_id;\n```\n\n* 检索所有客户，包括那些没有下订单的客户(外部联结)\n```sql\nSELECT customer.cust_id,orders.order_num FROM customer LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id;\n```\n\n>RIGHT表示OUTER JION右边的表的所有行（匹配或不匹配）都将被检索出来   \n>LEFT 表示OUTER JION左边的表   \n\n\n### 带聚集函数的联结\n检索出所有客户及每个客户所下的订单数\n```sql\nSELECT customers.cust_id,count(orders.ooder_num) FROM customer LEFT OUTER JOIN orders ON customer.cust_id = orders.cust_id ORDER BY customers.id;\n```\n\n<br><br>\n***\n<br><br>\n\n## 组合查询\n* 对于单个查询中从不同表汇总返回类似结构的数据\n* 对单个表执行多个查询，按单个查询返回数据\n\n### 使用UNION\n>检索出所有价格小于5且来自2001,2002的供应商的所有商品\n```sql\nSELECT prod_id,pro_name\nFROM products\nWHERE prod_price < 5\nUNION\nSELECT prod_id,pro_name\nFROM productes\nWHERE vend_id in (2001,2003)\nORDER BY prod_name;\n```\n\n>默认去除多个SELECT结果的重复行，但是可以使用UNION ALL来返回所有的改变行      \n>排序语句放在最后一个SELECT的后面\n\n\n<br><br>\n***\n<br><br>\n\n## 全文本搜索\n### 启用全文搜索\nMySql指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySql可以快速有效地判断哪些行包含它们，哪些词不匹配，它们匹配的频率，等等\n**FULLTEXT(列名称)**    \n```sql\nCREATE TABLE product(\n    note_id     int         NOT NULL,\n    pro_id      char(10)    NOT NULL,\n    note_text   text        NOT NULL,\n    PRIMARY KEY(pro_id),\n    FULLTEXT(note_text)\n)ENGINE=MyISAM;\n```\n>InnoDB不支持全文本搜索引擎\n\n### 进行全文本搜索\nMatch()：指定被搜索的列      \nAgainst()：指定要使用的搜索表达式\n```sql\nSELECT note_text FROM productnotes WHERE Match (note_text) Against('rabbit');\n```\n\n### 使用扩展查询\n考虑下面 的情况。你想找出所有提到anvils的注释。只有一个注释包含词anvils， 但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils。 这也是查询扩展的一项任务。在使用查询扩展时，MySQL对数据和 索引进行两遍扫描来完成搜索： \n* 首先，进行一个基本的全文本搜索，**找出与搜索条件匹配的所有行**；\n* 其次，MySQL检查这些匹配行并**选择**所有有用的词（我们将会简 要地解释MySQL如何断定什么有用，什么无用）。 \n* 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件， 而且还使用所有有用的词。 \n```sql\nSELECT note_text FROM productnotes WHERE Match(note_text) Against ('anvil' WITH QUERY EXPANsION);\n```\n>可能返回多行，但只有第一行含有关键字'anvil'，其他行因为含有第一行的相关字而有可能被检索出来\n\n### 布尔文本搜索\n可以提供关于如下内容的细节：\n* 要匹配的词\n* 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含 其他指定的词也是如此） \n* 排列提示（指定某些词比其他词更重要，更重要的词等级更高）\n* 表达式分组\n* 另外一些内容\n\n布尔操作符|说明\n-|-\n+|包含，词必须存在\n-|排除，词必须不出现\n\\>|包含，而且增加等级值 \n<|包含，且减少等级值 \n()|把词组成子表达式（允许这些子表达式作为一个组被包含、 排除、排列等） \n~|取消一个词的排序值 \n*|词尾的通配符 \n\"\"|定义一个短语（与单个词的列表不一样，它匹配整个短语以 便包含或排除这个短语） \n \n```sql\nSELECT note_text FROM productnotes WHERE Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE);\n```\n>检索含有关键字`heavy`**但不含有以`rope`开头的行**\n\n\n### 一些说明\n* 在索引全文本数据时，**短词被忽略且从索引中排除**。短词定义为 那些具有*3个或3个以下字符的词*（如果需要，这个数目可以更改）。\n* MySQL带有一个**内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略**。如果需要，可以覆盖这个列表（请参 阅MySQL文档以了解如何完成此工作）。\n* 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。 因此，MySQL规定了一条50%规则，**如果一个词出现在50%以上的行中，则将它作为一个非用词忽略**。*50%规则不用于IN BOOLEAN MODE。*\n* 如果表中的**行数少于3行，则全文本搜索不返回结果**（因为每个词 或者不出现，或者至少出现在50%的行中）。 \n* *忽略词中的单引号*。例如，don't索引为dont。 \n* *不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文*本搜索结果。 \n* 如前所述，**仅在MyISAM数据库引擎中支持全文本搜索。** \n\n<br><br> \n\n***\n\n<br><br>\n\n## 插入数据\n### 插入完整的行\n```sql\nINSERT into customers VALUES (\"1\",\"cc\",\"cc@foxmail\");\n```\n>对每个列**必须**提供一个值。**如果某个列没有值，应该使用NULL值**（假定表允许对该列指定空值）。\n>对于自增的字段，也需要设为NULL\n\n>种语法很简单，但并不安全，**应该尽量避免使用**。不能保证下一次表结构变动后各个列 保持完全相同的次序\n\n```sql\nINSERT into customers(cust_id,cust_name,cust_email) VALUES (\"1\",\"cc\",\"cc@foxmail\");\n```\n>用VALUES 列表中的相应值填入列表中的对应项        \n>对于自增字段，可以不出现\n\n>如果数据检索是最重要的（通常是这样），则你可以通过在 INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL 降低INSERT语句的优先级，如下所示：         \n>`INSERT LOW_PRIORITY INTO`        \n>这也适用于UPDATE和DELETE语句      \n\n### 插入多行\n```sql\nINSERT into customers(cust_id,cust_name,cust_email) VALUES (\"1\",\"cc\",\"cc@foxmail\"),(\"2,cc2,cc2@foxmail\");\n```\n###  插入检索出来的数据\n合并新旧表\n```sql\nINSERT into cust_new(cust_id,\n                      cust_name,\n                      cust_email)\nSELECT  cust_id,\n        cust_name,   \n        cust_email                \nFROM cust_old;\n```\n\n<br><br> \n\n***\n\n<br><br>\n\n## 更新和删除数据\n### 更新\n```sql\nUPDATE customers SET cust_email = 'newmail@foxmial.com', cust_name = 'newname' WHERE cust_id = '1';\n```\n> 如果没有`WHERE`语句，**则将更新这张表中所有数据**\n\n>IGNORE关键字，如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 （错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示： UPDATE IGNORE customers… \n\n>为了删除某一行的某个列值，可以将它更新为NULL\n\n### 删除\n* 删除一行\n```sql\nDELETE FROM customers WHERE cust_id = '1231';\n```\n>如果没有`WHERE`语句，**则将删除这张表中所有数据**     \n>如果更快的删除而且删除清零自增字段，可以使用`truncate tablename`\n\n除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE 子句的UPDATE或DELETE语句。\n保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能 像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。\n在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进 行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。 \n\n### 创建和删除表\n#### 创建表\n```sql\nCREATE TABLE product(\n    pro_id      char(10)    NOT NULL  AUTO_INCREMENT, --自增\n    note_id     int         NOT NULL,\n    note_text   text        NOT NULL,\n    pro_price   ine         NOT NULL DEFAULT 1, --默认值为1\n    PRIMARY KEY(pro_id)\n)ENGINE=InnoDB;\n```\n>自增字段 AUTO_INCREMENT，（每个表**只允许有一个自增字段**，且**必须被索引**<例如使它变为主键>）       \n>使用`SELECT last_insert_id()`语句**返回最后一个AUTO_INCREMENT值**\n\n> DEFAULT 设置默认值\n\n#### 引擎类型\n与其他DBMS一样，MySQL有一个**具体管理和处理数据**的内部引擎。 在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT 语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候， 此引擎都隐藏在DBMS内，不需要过多关注它。   \n\n但MySQL与其他DBMS不一样，**它具有多种引擎**。它打包多个引擎， 这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT 等命令。 \n\n为什么要发行多种引擎呢？因为它们**具有各自不同的功能和特性**， 为不同的任务选择正确的引擎能获得**良好的功能和灵活性**。 \n\n当然，你完全可以忽略这些数据库引擎。如果省略ENGINE=语句，则 使用默认引擎（很可能是MyISAM），多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么ENGINE=语句很重要的原因 （也就是为什么本书的样列表中使用两种引擎的原因）。 \n\n* InnoDB是一个**可靠的事务处理引擎**（参见第26章），它**不支持全文本搜索**\n* MEMORY在功能等同于MyISAM，但由于**数据存储在内存**（不是磁盘） 中，**速度很快**（特别适合于临时表）\n* MyISAM是一个**性能极高**的引擎，它支持全文本搜索（参见第18章）， 但**不支持事务处理**。 \n \n#### 更新表\n为更新表定义，可使用**ALTER TABLE**语句。但是，理想状态下，*当表中存储数据以后，该表就不应该再被更新*。在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。 \n\n```sql\n--增加字段\nALTER TABLE products ADD prod_price;\n--删除字段\nALTER TABLE products DROP prod_price;\n--定义外键\nALTER TABLE products ADD CONSTRAINT orderitems FOREIGN KEY (order_num) REFERENCES (order_num);\n```\n\n**复杂的表结构更改**一般需要手动删除过程，它涉及以下步骤： \n* 用新的列布局创建一个新表\n* 使用INSERT SELECT语句从旧表复制数据到新表\n* 检验包含所需数据的新表\n* 重命名旧表（如果确定，可以删除它）\n* 用旧表原来的名字重命名新表\n* 根据需要，重新创建触发器、存储过程、索引和外键\n \n#### 删除表\n```sql\nDROP TABLE customers;\n```\n\n### 清除表数据\n```sql\n--删除数据\ndelete * from TName;\n--删除所有数据并重置自增序列\ntruncate table TName; \n```\n\n#### 重命名表\n```sql\nRENAME TABLE customer1 TO customer2;\n```\n\n<br><br> \n\n***\n\n<br><br>\n\n## 视图\n视图是**虚拟的表**。与包含数据的表不一样，视图**只包含使用时动态检索数据的查询**。 \n>它**本身不包含**表中应该有的**任何列或数据**，它**包含的是一个SQL查询**\n\n\n### 视图的应用\n* **重用SQL语句**\n* **简化复杂的SQL操作**。在编写查询后，可以方便地重用它而不必知道它的基本查询细节\n* **使用表的组成部分**而不是整个表。\n* **保护数据**。可以给用户授予表的特定部分的访问权限而不是整个 表的访问权限\n* **更改数据格式和表示**。视图可返回与底层表的表示和格式不同的数据\n\n在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图**执行SELECT操作**，**过滤**和**排序**数据，将视**图联结到其他视图或表**，甚至能**添加**和**更新**数据（添加和更新数据存在某些限制。关于这个内容稍 后还要做进一步的介绍）。 \n>如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。\n\n### 视图的规则和限制\n* 视图必须唯一命名\n* 创建的视图数目没有限制\n* **必须具有足够的访问权限**\n* **视图可以嵌套**，即可以利用从其他视图中检索数据的查询来构造 一个视图\n* ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖\n* **视图不能索引**，也不能有关联的触发器或默认值\n* 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句。 \n\n### 使用视图\n* CREATE VIEW语句来创建\n* SHOW CREATE VIEW viewname；来查看创建视图的语\n* 用DROP删除视图，其语法为DROP VIEW viewname\n* 更新视图时，可以先用DROP再用CREATE，也可以直接用`CREATE OR REPLACE VIEW`。如果要更新的视图不存在，则第2条更新语句会创 建一个视图；如果要更新的视图存在，则第2条更新语句会替换原 有视图\n\n### 更新视图\n通常，视图是可更新的，但是，并非所有视图都是可更新的。基本上可以说，**如果MySQL不能正确地确定被更新的基数据，则不允许更新**（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新： \n* 分组\n* 联结\n* 子查询\n* 并\n* 聚集函数（Min()、Count()、Sum()等）\n* DISTINCT\n* 导出（计算）列\n\n<br><br> \n\n***\n\n<br><br>\n\n## 存储过程 \n迄今为止，使用的大多数SQL语句都是针对一个或多个表的单条语 句。并非所有操作都这么简单，经常会有一个完整的操作需要多条语句 才能完成。例如，考虑以下的情形\n* 为了处理订单，需要核对以保证库存中有相应的物品\n* 如果库存有物品，这些物品需要预定以便不将它们再卖给别的人，并且要减少可用的物品数量以反映正确的库存量\n* 库存中没有的物品需要订购，这需要与供应商进行某种交互 \n* 关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的客户\n\n执行这个**处理需要针对许多表的多条MySQL语句**。此外，需要执行的**具体语句及其次序**也不是固定的，它们可能会（和将）根据哪些物品在库存中哪些不在而变化。 \n\n存储过程简单来说，就是为以后的使用而保存的**一条或多条MySQL语句的集合**。\n>可将其视为批文件，虽然它们的作用不仅限于批处理。 \n\n### 使用存储过程的优缺点\n#### 优点\n**简单、安全、高性能**\n* 通过把处理封装在容易使用的单元中，**简化复杂的操作**（正如前 面例子所述）\n* 由于不要求反复建立一系列处理步骤，这**保证了数据的完整性**。*如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的*。 这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误**保证了数据的一致性**\n* **简化对变动的管理**。如果表名、列名或业务逻辑（或别的内容） 有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化\n* **提高性能**。因为使用存储过程比使用单独的SQL语句要快 \n* 存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写**功能更强更灵活**的代码\n\n#### 缺点\n* 存储过程的**编写比基本SQL语句复杂**，编写存储过程需要更高的技能，更丰富的经验。 \n* 你可能**没有创建存储过程的安全访问权限**。许多数据库管理员限 制存储过程的创建权限，允许用户使用存储过程，但不允许他们 创建存储过程。 \n\n### 使用存储过程\n* 执行（call）\n```sql\nCALL productpricing(@pricelow,@pricehigh,@priceaverage);\n```\n### 创建存储过程\n返回产品平均过程的存储过程\n```sql\nCREATE PROCEDURE productpricing()\nBEGIN\n    SELECT AVG(prod_price) AS priceaverage FROM products;\nEND\n```\n> 注意productpricing()的()\n\nmysql命令行客户机的分隔符(命令行工具)\n```sql\nDELIMITER//\n\n\nCREATE PROCEDURE productpricing()\nBEGIN\n    SELECT AVG(prod_price) AS priceaverage FROM products;\nEND//\n\nDELIMITER;\n\n```\n>因为在存储过程存在`;`，所以在命令行程序中需使用特定的分隔符     \n>DELIMITER+符号（分隔符）：表示告诉程序使用此分隔符作为新的语句结束分隔符,所以由`END`变为了`END//`     \n>除\\符号外，任何字符都可以用作语句分隔符。 \n\n### 删除存储过程\n```sql\nDROP PROCEDURE productpricing;\n```\n>注意没有`()`    \n>如果该存储过程不存在，则会报错，所以建议使用`DROP PROCEDURE IF EXISTS`\n\n### 使用参数\n* 创建带参数的存储过程\n```sql\nCREATE PROCEDURE productpricing(\n    OUT pl DECIMAL(8,2),    --pl:存储产品最低价格\n    OUT ph DECIMAL(8,2),    --ph:存储产品最高价格\n)\nBEGIN\n    SELECT MIN(prod_price) INTO pl FROM products;\n    SELECT MAX(prod_price) INTO ph FROM products;\nEND\n```\n>存储过程保存在BEGIN和END之间\n\n> OUT指出相应的参数用来**从存储过程传出** 一个值（返回给调用者）     \n> IN,传递给存储过程     \n> INOUT，对存储过程传入传出\n\n\n* 使用存储过程\n```sql\n--指定变量名\nCALL productpricing(@pricelow, @prichigh);\n\n--检索\nSELECT @prcielow;\n\nSELECT @prcielow, @prichigh;\n```\n\n### 检查存储过程\n```sql\n-- 显示创建的语句\nSHOW CREATE PROCEDURE ordertotal;\n\n-- 显示更加详细，何时、由何人创建的信息\nSHOW CREATE PROCEDURE STATUS ordertotal;\n\n-- 过滤查看更多存储过程的信息\nSHOW CREATE PROCEDURE STATUS LIKE 'ordertotal';\n```\n<br><br> \n\n***\n\n<br><br>\n\n## 游标\n\n（~~有待填坑~~）\n\n有时，**需要在检索出来的行中前进或后退一行或多行**。这就是使用游标的原因。游标（cursor）是**一个存储在MySQL服务器上的数据库查询**， 它不是一条SELECT语句，**而是被该语句检索出来的结果集**。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。 \n\n游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。 \n\n### 使用注意\n* 在能够**使用游标前，必须声明**（定义）它\n* 一旦声明后，必须打开游标以供使用。\n* 对于填有数据的游标，根据需要取出（检索）各行。 \n* 在结束游标使用时，必须关闭游标。 \n\n### 创建游标\n```sql\nCREATE PROCEDURE processorders()\nBEGIN\n    DECLARE ordernumbers CURSOR\n    FOR\n    SELECT order_num FROM orders;\nEND;\n```\n### 打开和关闭游标\n```sql\n--打开\nOPEN ordernumbers;\n\n--关闭\nCLOSE ordernumbers;\n```\n>如果不明确关闭游标，MySql将会在到达END语句时自动关闭\n\n### 使用游标\n在一个游标被打开后，可以使用**FETCH语句**分别访问它的每一行。 FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。 它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。\n```sql\nCREATE PROCEDURE processorders()\nBEGIN\n    --声明一个变量\n    DECLARE o INT;\n    --声明一个游标\n    DECLARE ordernumbers CURSOR\n    FOR\n    SELECT order_num FROM orders;\n    --打开一个游标\n    OPEN ordernumbers;\n    --获取数据\n    FETCH ordernumbers INTO o;\n    --关闭游标\n    CLOSE ordernumbers;\nEND;\n```\n<br><br> \n\n***\n\n<br><br>\n \n## 触发器\nMySQL语句在需要时被执行，存储过程也是如此。但是，如果你想要**某条语句（或某些语句）在事件发生时自动执行**，怎么办呢？例如： \n* 每当增加一个顾客到某个数据库表时，都检查其电话号码格式是 否正确，州的缩写是否为大写； \n* 每当订购一个产品时，都从库存数量中减去订购的数量； \n* 无论何时删除一行，都在某个存档表中保留一个副本。 \n\n所有这些例子的共同之处是它们都需要在某个表发生更改时自动处理。这确切地说就是触发器。触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语 句） ： \n* DELETE； \n* INSERT； \n* UPDATE。\n\n*其他MySQL语句不支持触发器。* \n\n### 创建触发器\n在创建触发器时，需要给出4条信息： \n* 唯一的触发器名； \n* 触发器关联的表； (只有表支持触发器，视图不支持)\n* 触发器应该响应的活动（DELETE、INSERT或UPDATE）； \n* 触发器何时执行（处理之前或之后）。 \n\n>每个表将最多支持6个触发器，DELETE、INSERT或UPDATE的处理之前或之后\n\n \n> 在MySQL 5中，触发器名必 须在每个表中唯一，但不是在每个数据库中唯一。这表示同一 数据库中的两个表可具有相同名字的触发器。这在其他每个数 据库触发器名必须唯一的DBMS中是不允许的，而且以后的 MySQL版本很可能会使命名规则更为严格。因此，现在最好 是在数据库范围内使用唯一的触发器名。 \n \n```sql\nCREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'product added';\n```\n> 使用INSERT语句添加一行或多行到products表中时，将对每一行显示文本product added\n \n### 删除触发器\n```sql\nDROP TRIGGER newproduct;\n```\n>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。\n\n### 使用触发器\n#### INSERT触发器 \nINSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点： \n* 在INSERT触发器代码内，可引用一个**名为NEW的虚拟表，访问被插入的行**； \n* 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值） ； \n* 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。 \n```sql\nCREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT NEW.order_num;\n```\n>在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从NEW. order_num取得这个值并返回它。\n\n#### DELETE触发器\nDELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两 点： \n* 在DELETE触发器代码内，你可以引用一个名为**OLD的虚拟表，访问被删除的行**；\n* OLD中的值全都是只读的，不能更新。  \n```sql\nCREATE TRIGGER deleteorder BEFORE DELETE ON products FOR EACH ROW\nBEGIN\n    INSERT INTO archive_orders(order_num,order_date)\n    VALUES(OLD.order_num,OLD.order_num);\nEND;\n```\n>在任意订单被删除前将执行此触发器。它使用一条INSERT语句 将OLD中的值（要被删除的订单）保存到一个名为archive_ orders的存档表中\n\n\n#### UPDATE触发器 \nUPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：\n* 在UPDATE触发器代码中，你可以引用一个名为**OLD**的虚拟表**访问以前**（UPDATE语句前）的值，引用一个名为**NEW的虚拟表访问新更新的值**； \n* 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改 将要用于UPDATE语句中的值）； \n* OLD中的值全都是**只读的，不能更新**。 \n```sql\nCREATE TRIGGER updateevendor BEFORE DELETE ON vendors FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend-state);\n```\n>下面的例子保证州名缩写总是大写（不管UPDATE语句中给出的是大 写还是小写）： \n \n\n### 进一步介绍\n\n在结束本章之前，我们再介绍一些使用触发器时需要记住的重点。\n* 与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来的 MySQL版本中有一些改进和增强触发器支持的计划。 \n* 创建触发器可能需要特殊的安全访问权限，但是，**触发器的执行是自动的。如果INSERT、UPDATE或DELETE语句能够执行，则相关的触发器也能执行**。 \n* 应该用触发器来**保证数据的一致性**（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。 \n* 触发器的一种非常有意义的使用是**创建审计跟踪**。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个 表非常容易。 \n* 遗憾的是，MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。\n\n<br><br> \n\n***\n\n<br><br>\n\n## 事务处理\n事务处理（transaction processing）可以用来维护数据库的完整性，它 保证成批的MySQL操作**要么完全执行，要么完全不执行。** \n\n \n利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）**。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。**\n \n> * 事务（transaction）指一组SQL语句； \n> * 回退（rollback）指撤销指定SQL语句的过程； \n> * 提交（commit）指将未存储的SQL语句结果写入数据库表； \n> * 保留点（savepoint）指事务处理中设置的临时占位符（place- holder），你可以对它发布回退（与回退整个事务处理不同\n\n### 使用ROLLBACK \nMySQL的ROLLBACK命令用来回退（撤销）MySQL语句。\n```sql\nSELECT * FROM ordertotals ;\n--开始事物\nSTART TRANSACTION; \nDELETE FROM ordertotals;\nSELECT * FROM ordertotals;\n--撤销\nROLLBACK;\nSELECT * FROM ordertotals;\n```\n>首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条 SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句**回退 START TRANSACTION之后的所有语句**，最后一条SELECT语句显示该表不为空。 \n\n### 使用COMMIT\n一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。 \n\n但是，**在事务处理块中，提交不会隐含地进行**。为进行明确的提交，使用COMMIT语句，如下所示： \n ```sql\n--开始事物\nSTART TRANSACTION; \nDELETE FROM ordertotals WHERE order_num = 20010;\nDELETE FROM orders WHERE order_num = 20010;\n--提交\nCOMMIT;\n```\n>从系统中完全删除订单20010。因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来**保证订单不被部分删除**。最后的COMMIT语句**仅在不出错时写出更改**。如 果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的） \n\n>**隐含事务关闭**  当COMMIT或ROLLBACK语句执行后，事务会自 动关闭（将来的更改会隐含提交）。 \n\n### 使用保用点\n简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但 是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要**部分提交或回退**。 \n```sql\n--创建保用点\nSAVEPOINT delete1;\n--回退\nROLLBACK TO delete1\n```\n>**保留点越多越好** .可以在MySQL代码中设置任意多的保留 点，越多越好。为什么呢？因为保留点越多，你就越能按自己的意愿**灵活**地进行回退。\n\n> 保留点在事务处理完成（执行一条**ROLLBACK或 COMMIT）后**自动释放**。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。 \n \n### 更改默认提交方式\n正如所述，默认的MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句： \n```sql\nSET autocommit=0;\n```\n\n## 全球化和本地化 \n**不同的语言和字符集需要以不同的方式存储和检索**。\n\n因此，MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法。\n\n* **字符集**：字母和符号的集合； \n* **编码**：某个字符集成员的内部表示； \n* **校对**：规定字符如何比较的指令。 \n>校对为什么重要  排序英文正文很容易，对吗？或许不。考 虑词APE、apex和Apple。它们处于正确的排序顺序吗？这有 赖于你是否想区分大小写。使用区分大小写的校对顺序，这 些词有一种排序方式，使用不区分大小写的校对顺序有另外 一种排序方式。这不仅影响排序（如用ORDER BY排序数据） ， 还影响搜索（例如，寻找apple的WHERE子句是否能找到 APPLE）。在使用诸如法文à或德文ö这样的字符时，情况更复 杂，在使用不基于拉丁文的字符集（日文、希伯来文、俄文 等）时，情况更为复杂\n\n\n### 使用字符集和校对顺序 \n为查看所支持的字符集完整列表\n```sql\nSHOW CHARACTER SET;\n```\n为了查看所支持校对的完整列\n```sql\nSHOW COLLATION;\n```\n\n通常系统管理在安装时定义一个默认的字符集和校对。此外，也可 以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对可以使用以下语句： \n```sql\nSHOW VARIABLES LIKE 'character%';\nSHOW VARIABLES LIKE 'collation%';\n```\n\n为了给表指定字符集和校对，可使用带子句的CREATE TABLE       \n```sql\nCREATE TABLE mytable\n(\n    column1 INT,\n    column2 VARCHAR(10),\n) DEFAULT CHARACTER SET brew     --字符集\n  COLLATE hebrew_general_ci;     --校对顺序\n```\n\n对某个列设置单独的字符集和校对\n```sql\nCREATE TABLE mytable\n(\n    column1 INT,\n    column2 VARCHAR(10),\n    column3 VARCHAR(20) CHARACTER SET latin1 COLLATE latin1_general_ci\n) DEFAULT CHARACTER SET brew     --字符集\n  COLLATE hebrew_general_ci;     --校对顺序\n```\n\n\n如前所述，校对在对用ORDER BY子句检索出来的数据排序时起重要 的作用。如果你**需要用与创建表时不同的校对顺序排序特定的SELECT语句**，可以在SELECT语句自身中进行：\n```sql\n    SELECT * FROM  customer ORDER BY lastname COLLATE latin1_general_ci;\n```\n<br><br> \n\n***\n\n<br><br>\n\n## 安全管理\nMySQL服务器的安全基础是：**用户应该对他们需要的数据具有适当的访问权，既不能多也不能少**。换句话说，用户不能对过多的数据具有过多的访问权。 \n>应该严肃对待root登录的使用。仅在绝对需 要时使用它（或许在你不能登录其他管理账号时使用）。不应 该在日常的MySQL操作中使用root。 \n\n### 管理用户\nMySQL用户账号和信息存储在名为mysql的MySQL数据库中。一般不需要直接访问mysql数据库和表（你稍后会明白这一点），但有时需要直接访问。需要直接访问它的时机之一是在需要获得所有用户账号列表时。\n\nmysql数据库有一个名为user的表，它包含所有用户账号。user 表有一个名为user的列，它存储用户登录名。\n\n#### 创建用户\n```sql\n--创建账户名为cc1,密码为123的账户\nCREATE USER cc1 IDENTIFIED BY '123';\n--重命名\nRENAME USER cc1 TO cc2;\n```\n> **使用GRANT或INSERT** GRANT语句也可以创建用 户账号，但一般来说CREATE USER是最清楚和最简单的句子。 此外，也可以通过直接插入行到user表来增加用户，不过为安全起见，一般不建议这样做。MySQL用来存储用户账号信息 的表（以及表模式等）极为重要，对它们的任何毁坏都 可能严重地伤害到MySQL服务器。因此，相对于直接处理来 说，最好是用标记和函数来处理这些表。 \n\n#### 更改口令\n```sql\nSET PASSWORD FOR  cc2 = Password('456');\n--设置当前账户口令\nSET PASSWORD = Password('456');\n```\n\n#### 删除用户\n```sql\nDROP USER cc2;\n```\n\n### 设置访问权限\n在创建用户账号后，必须接着分配访问权限。**新创建的用户账号没有访问权限**。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。\n```sql\n--看到赋予用户账号的权限\nSHOW GRANTS FOR cc2;\n```\n为**设置权限**，使用GRANT语句。GRANT要求你至少给出以下信息： \n* 要授予的权限\n* 被授予访问权限的数据库或表；\n* 用户名\n\n```sql\n--此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。\nGRANT SELECT ON crashcourse.* TO cc3;\n```\n>通过只授予SELECT访问权限，用户bforta对crashcourse数据库中的所有数据具有只读访问权限。 \n\nGRANT的反操作为REVOKE，用它来**撤销特定的权限**。\n```sql\n--取消刚赋予用户cc3的SELECT访问权限\nREVOKE SELECT ON crashcourse.* FROM cc3;\n```\n\nGRANT和REVOKE可在几个层次上控制访问权限： \n* 整个服务器，使用GRANT ALL和REVOKE ALL； \n* 整个数据库，使用ON database.*； \n* 特定的表，使用ON database.table； \n* 特定的列； \n* 特定的存储过程。\n\n下标列出可以授予或撤销的每个权限。 \n\n权限|说明\n-|-\nALL|除GRANT OPTION外的所有权限 \nALTER|使用ALTER TABLE \nALTER ROUTINE|使用ALTER PROCEDURE和DROP PROCEDURE \nCREATE|使用CREATE TABLE \nCREATE ROUTINE|使用CREATE PROCEDURE \nCREATE TEMPORARY TABLES|使用CREATE TEMPORARY TABLE \nCREATE USER|使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES \nCREATE VIEW|使用CREATE VIEW \nDELETE|使用DELETE \nDROP|使用DROP TABLE \nEXECUTE|使用CALL和存储过程 \nFILE|使用SELECT INTO OUTFILE和LOAD DATA INFILE \nGRANT OPTION|使用GRANT和REVOKE \nINDEX|使用CREATE INDEX和DROP INDEX \nINSERT|使用INSERT \nLOCK TABLES|使用LOCK TABLES \nPROCESS|使用SHOW FULL PROCESSLIST \nRELOAD|使用FLUSH \nREPLICATION CLIENT|服务器位置的访问 \nREPLICATION SLAVE|由复制从属使用 \nSELECT|使用SELECT \nSHOW DATABASES|使用SHOW DATABASES \nSHOW VIEW|使用SHOW CREATE VIEW \nSHUTDOWN|使用mysqladmin shutdown（用来关闭MySQL） \nSUPER|使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER 和SET GLOBAL。还允许mysqladmin调试登录\nUPDATE|使用UPDATE\nUSAGE|无访问权限 \n\n，当某个数据库或表被删除时（用DROP语 句），相关的访问权限仍然存在。而且，如果将来重新创建该 数据库或表，这些权限仍然起作用。 \n\n>未来的授权  在使用GRANT和REVOKE时，用户账号必须存在， 但对所涉及的对象没有这个要求。这允许管理员在创建数据库 和表之前设计和实现安全措施。 这样做的副作用是，当某个数据库或表被删除时（用DROP语 句），相关的访问权限仍然存在。而且，如果将来重新创建该 数据库或表，这些权限仍然起作用。 \n\n>简化多次授权  可通过列出各权限并用逗号分隔，将多条 GRANT语句串在一起，如下所示： `GRANT SELECT,INSERT ON crashcourse.* TO cc2;`\n\n<br><br> \n\n***\n\n<br><br>\n\n## 数据库维护\n### 数据库备份\n像所有数据一样，MySQL的数据也必须经常备份。由于MySQL数据 库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。 但是，**由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效**。 \n下面列出这个问题的可能解决方案。 \n* 使用**命令行实用程序mysqldump**转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正 确地备份转储文件。\n* 可用**命令行实用程序mysqlhotcopy**从一个数据库复制所有数据 （并非所有数据库引擎都支持这个实用程序）。 \n* 可以使用**MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储**所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原。 \n\n>首先刷新未写数据 为**了保证所有数据被写到磁盘（包括索引数据）**，可能需要在进行备份前使用**FLUSH TABLES**语句。 \n### 数据库维护\n\n**ANALYZE TABLE**，用来检查**表键**是否正确\n\n如果从一个表中删除大量数据，应该使用**OPTIMIZE TABLE**来收回所用的空间，从而优化表的性能。 \n \n### 诊断启动问题\n\n命令行mysqld手动启动\n\n### 查看错误日志\nMySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下几种。 \n* **错误日志**。它包含启动和关闭问题以及任意关键错误的细节。此 日志通常名为hostname.err，位于data目录中。此日志名可用 --log-error命令行选项更改。 \n* **查询日志**。它记录所有MySQL活动，在诊断问题时非常有用。此 日志文件可能会很快地变得非常大，因此不应该长期使用它。此 日志通常名为hostname.log，位于data目录中。此名字可以用 --log命令行选项更改。 \n* **二进制日志**。它记录更新过数据（或者可能更新过数据）的所有 语句。此日志通常名为hostname-bin，位于data目录内。此名字 可以用--log-bin命令行选项更改。注意，这个日志文件是MySQL 5中添加的，以前的MySQL版本中使用的是更新日志。 \n* **缓慢查询日志**。顾名思义，此日志记录执行缓慢的任何查询。这 个日志在确定数据库何处需要优化很有用。此日志通常名为 hostname-slow.log ，位于data 目录中。此名字可以用 --log-slow-queries命令行选项更改。 在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文 件。 \n\n在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。 \n\n## 改善性能\n\n* 首先，MySQL（与所有DBMS一样）具有**特定的硬件建议**。在学 习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但 对用于生产的服务器来说，应该坚持遵循这些硬件建议。\n* 一般来说，关键的生产DBMS应该运行在自己的**专用服务器**上。 \n* MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你**可能需要调整内存分配、缓冲区大小等。**（为查看当前设置，可使用SHOW VARIABLES;和SHOW STATUS;。） \n* MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。**如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢**。如果你遇到显著的性能不良，可使用SHOW PROCESSLIST 显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录） 。 \n* 总是有**不止一种方法编写同一条SELECT语句**。应该试验联结、并、 子查询等，找出最佳的方法。 \n* 使用**EXPLAIN语句**让MySQL**解释它将如何执行一条SELECT语句**。 \n* 一般来说，**存储过程执行得比一条一条地执行其中的各条MySQL语句快**。 \n*  应该总是使用正确的数据类型。 \n* 决**不要检索比需求还要多的数据**。换言之，不要用SELECT *（除 非你真正需要每个列）。 \n* 有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。\n* **在导入数据时，应该关闭自动提交**。你**可能还想删除索引**（包括 FULLTEXT索引），然后在导入完成后再重建它们。 \n* **必须索引数据库表以改善数据检索的性能**。确定索引什么不是一件微不足道的任务，需要分析使用的SELECT语句以找出重复的 WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。 \n* 你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的**UNION语句**，你能看到极大的性能改 进。 \n* **索引改善数据检索的性能，但损害数据插入、删除和更新的性能**。 如果你有一些表，它们收集数据且不经常被搜索，则在有必要之 前不要索引它们。（索引可根据需要添加和删除。） \n*  LIKE很慢。一般来说，**最好是使用FULLTEXT而不是LIKE**。 \n* 数据库是不断变化的实体。一组优化良好的表一会儿后可能就面 目全非了。由于表的使用和内容的更改，理想的优化和配置也会 改变。 \n* 最重要的规则就是，每条规则在某些条件下都会被打破。 \n\n\n<br><br> \n\n\n<br><br>\n\n\n\n\n\n## 参考\n<div style=\"margin-left: 5px  font-size:16px;\">\n[1]Ben Forta, Mysql必知必会. 北京：人民邮电出版社，2019.\n</div>\n","slug":"code/MySql/MySql必知必会","published":1,"updated":"2020-12-09T15:40:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gu00620w7teaeu9c6s","content":"<div style=\"width: 95%\">\n\n<p><img src=\"https://img2020.cnblogs.com/blog/2104937/202007/2104937-20200723232459669-218625272.png\" alt=\"《MySql必知必会》学习笔记\"></p>\n</div>\n\n\n<p>MySQL已经成为世界上最受欢迎的数据库管理系统之一。无论是用 在小型开发项目上，还是用来构建那些声名显赫的网站，MySQL都证明 了自己是个稳定、可靠、快速、可信的系统，足以胜任任何数据存储业 务的需要。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"MySql的使用\"><a href=\"#MySql的使用\" class=\"headerlink\" title=\"MySql的使用\"></a>MySql的使用</h2><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--选择数据库</span>\n<span class=\"token keyword\">use</span> <span class=\"token keyword\">database</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--返回可用数据库列表</span>\n<span class=\"token keyword\">show</span> <span class=\"token keyword\">database</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--返回一个数据库内表的列表</span>\n<span class=\"token keyword\">show</span> <span class=\"token keyword\">tables</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--对一个表的每个字段返回一行，行中包括字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息等</span>\n<span class=\"token keyword\">show</span> <span class=\"token keyword\">columns</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span><span class=\"token punctuation\">;</span>    \n<span class=\"token comment\" spellcheck=\"true\">--功能同上</span>\n<span class=\"token keyword\">describe</span> <span class=\"token keyword\">table</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">--用于显示广泛的服务器状态信息； </span>\n<span class=\"token keyword\">show</span> <span class=\"token keyword\">status</span><span class=\"token punctuation\">;</span>    \n\n<span class=\"token comment\" spellcheck=\"true\">--显示创建创建数据库和表的MySql信息</span>\n<span class=\"token keyword\">show</span> <span class=\"token keyword\">create</span> <span class=\"token keyword\">database</span> DBName<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">show</span> <span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> TName<span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--用于显示服务器错误或警告信息</span>\n<span class=\"token keyword\">show</span> <span class=\"token keyword\">errors</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">show</span> <span class=\"token keyword\">warnings</span><span class=\"token punctuation\">;</span> </code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"检索数据\"><a href=\"#检索数据\" class=\"headerlink\" title=\"检索数据\"></a>检索数据</h2><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--查询多个字段</span>\n<span class=\"token keyword\">select</span> nickname<span class=\"token punctuation\">,</span>email <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span>  \n\n<span class=\"token comment\" spellcheck=\"true\">--查询不同的姓名</span>\n<span class=\"token keyword\">select</span> <span class=\"token keyword\">distinct</span> nickname <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--返回前几行</span>\n<span class=\"token keyword\">select</span> nickname<span class=\"token punctuation\">,</span>email <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">limit</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--返回从第0行开始的2行</span>\n<span class=\"token keyword\">select</span> nickname<span class=\"token punctuation\">,</span>email <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">limit</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>  \n\n<span class=\"token comment\" spellcheck=\"true\">--功能同上</span>\n<span class=\"token keyword\">select</span> nickname<span class=\"token punctuation\">,</span>email <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">limit</span> <span class=\"token number\">0</span> <span class=\"token keyword\">offset</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>  </code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"排序和过滤检索数据\"><a href=\"#排序和过滤检索数据\" class=\"headerlink\" title=\"排序和过滤检索数据\"></a>排序和过滤检索数据</h2><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--按照年龄从大到小排序，如果年龄相同则按照昵称从小到大排序</span>\n<span class=\"token keyword\">select</span> nickname<span class=\"token punctuation\">,</span>email <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> age <span class=\"token keyword\">desc</span> <span class=\"token punctuation\">,</span> nickname<span class=\"token punctuation\">;</span>   \n\n<span class=\"token comment\" spellcheck=\"true\">--返回年龄不等于20的用户姓名 `&lt;>`用法等同于`!=`</span>\n<span class=\"token keyword\">select</span> nickename <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token operator\">&lt;></span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--返回邮箱信息为空的用户名</span>\n<span class=\"token keyword\">select</span> nickename <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> email <span class=\"token operator\">is</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--返回邮箱信息为空的用户名</span>\n<span class=\"token keyword\">select</span> nickename <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> email <span class=\"token operator\">is</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--默认执行顺序为 `( age=10 ) or ( age=20 and eamil is NULL )`，`and`优先级更高</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age<span class=\"token operator\">=</span><span class=\"token number\">10</span> <span class=\"token operator\">or</span> age<span class=\"token operator\">=</span><span class=\"token number\">20</span> <span class=\"token operator\">and</span> eamil <span class=\"token operator\">is</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//</span>\n\n<span class=\"token comment\" spellcheck=\"true\">--对`IN`后圆括中的每一个元素进行匹配，等同于`OR`</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token operator\">in</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--对其中条件进行否定</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token operator\">not</span> <span class=\"token operator\">in</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">--表示昵称包含字符e的所有用户，%表示通配符 表示任何字符出现的次数，0次、1次或多次。</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> nickname <span class=\"token operator\">like</span> <span class=\"token string\">'%e%'</span><span class=\"token punctuation\">;</span>   \n\n<span class=\"token comment\" spellcheck=\"true\">--表示昵称第二个字符为e的所有用户，`_`表示匹配单个字符。 </span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> nickname <span class=\"token operator\">like</span> <span class=\"token string\">'_e%'</span><span class=\"token punctuation\">;</span>   \n</code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--正则表达式，匹配年龄为10、20、30... 的用户，`.`表示匹配任意一个字符</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token operator\">REGEXP</span> <span class=\"token string\">'.0'</span><span class=\"token punctuation\">;</span>   \n\n<span class=\"token comment\" spellcheck=\"true\">-- `BINARY`用于正则表达式中区分大小写</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token keyword\">BINARY</span> <span class=\"token operator\">REGEXP</span> <span class=\"token string\">'JetPack.000'</span><span class=\"token punctuation\">;</span>   \n\n<span class=\"token comment\" spellcheck=\"true\">--正则表达式进行OR匹配</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> age <span class=\"token keyword\">BINARY</span> <span class=\"token operator\">REGEXP</span> <span class=\"token string\">'1000|1000'</span><span class=\"token punctuation\">;</span>   \n\n<span class=\"token comment\" spellcheck=\"true\">--返回的是`1 Ton` `2 Ton` ,`[123]`为`[1|2|3]`的缩写，表示匹配1或2或3</span>\n<span class=\"token keyword\">select</span> nickname <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> nickname <span class=\"token keyword\">BINARY</span> <span class=\"token operator\">REGEXP</span> <span class=\"token string\">'[123] Ton'</span><span class=\"token punctuation\">;</span>   \n\n<span class=\"token comment\" spellcheck=\"true\">--返回的是匹配指定字符串以外的值</span>\n<span class=\"token keyword\">select</span> nickname <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> nickname <span class=\"token keyword\">BINARY</span> <span class=\"token operator\">REGEXP</span> <span class=\"token string\">'[^123] Ton'</span><span class=\"token punctuation\">;</span>   \n\n<span class=\"token comment\" spellcheck=\"true\">--nikename中包含`a Ton` `b Ton` `c Ton`，age中包含1,2,3</span>\n<span class=\"token keyword\">select</span> nickname <span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">where</span> nickname <span class=\"token keyword\">BINARY</span> <span class=\"token operator\">REGEXP</span> <span class=\"token string\">'[a-c] Ton'</span> <span class=\"token operator\">and</span> age <span class=\"token operator\">REGEXP</span> <span class=\"token string\">'[1-3]'</span><span class=\"token punctuation\">;</span>  </code></pre>\n<h3 id=\"匹配字符类\"><a href=\"#匹配字符类\" class=\"headerlink\" title=\"匹配字符类\"></a>匹配字符类</h3><table>\n<thead>\n<tr>\n<th>类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[:alnum:]</td>\n<td>任意字符和数字（同[a-zA-Z0-9]）</td>\n</tr>\n<tr>\n<td>[:alpha:]</td>\n<td>任意字符（同[a-zA-Z]）</td>\n</tr>\n<tr>\n<td>[:blank:]</td>\n<td>空格和制表（同[\\t]）</td>\n</tr>\n<tr>\n<td>[:cntrl:]</td>\n<td>ASCII控制字符（ASCII 0到31和127）</td>\n</tr>\n<tr>\n<td>[:digit:]</td>\n<td>任意数字（同[0-9]）</td>\n</tr>\n<tr>\n<td>[:graph:]</td>\n<td>与[:print:]相同，但不包括空格</td>\n</tr>\n<tr>\n<td>[:lower:]</td>\n<td>任意小写字母（同[a-z]）</td>\n</tr>\n<tr>\n<td>[:print:]</td>\n<td>任意可打印字符</td>\n</tr>\n<tr>\n<td>[:punct:]</td>\n<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>\n</tr>\n<tr>\n<td>[:space:]</td>\n<td>包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]）</td>\n</tr>\n<tr>\n<td>[:upper:]</td>\n<td>任意大写字母（同[A-Z]）</td>\n</tr>\n<tr>\n<td>[:xdigit:]</td>\n<td>任意十六进制数字（同[a-fA-F0-9]）</td>\n</tr>\n</tbody></table>\n<br>\n\n<h3 id=\"匹配多个实例\"><a href=\"#匹配多个实例\" class=\"headerlink\" title=\"匹配多个实例\"></a>匹配多个实例</h3><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>0个或多个匹配</td>\n</tr>\n<tr>\n<td>+</td>\n<td>1个或多个匹配（等于{1,}）</td>\n</tr>\n<tr>\n<td>?</td>\n<td>0个或1个匹配（等于{0,1}）</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>指定数目的匹配</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>不少于指定数目的匹配</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>匹配数目的范围（m不超过255）</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>‘\\\\([0-9]stick?\\\\)’</strong><br>A (1 stick)<br>B (1 sticks)<br><code>\\\\</code>为转移符 ，第一个\\是MySql自己解释一个，第二\\是正则表达式解释一个</p>\n</blockquote>\n<br>\n\n<h3 id=\"定位符\"><a href=\"#定位符\" class=\"headerlink\" title=\"定位符\"></a>定位符</h3><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>^</td>\n<td>文本的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td>文本的结尾</td>\n</tr>\n<tr>\n<td>[[:&lt;:]]</td>\n<td>词的开始</td>\n</tr>\n<tr>\n<td>[[:&gt;:]]</td>\n<td>词的结尾</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>‘^[0-9\\.]’<br><code>^</code>匹配串的开始，即以数字开头或者<code>.</code>开头的字符串</p>\n</blockquote>\n<h2 id=\"计算字段\"><a href=\"#计算字段\" class=\"headerlink\" title=\"计算字段\"></a>计算字段</h2><h3 id=\"拼接\"><a href=\"#拼接\" class=\"headerlink\" title=\"拼接\"></a>拼接</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">-- 按照 `云卷云舒（20）`这样的昵称+年龄格式表示，`RTrim`去掉值右边的所有空格，</span>\n<span class=\"token keyword\">select</span> Concat<span class=\"token punctuation\">(</span>RTrim<span class=\"token punctuation\">(</span>nick_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token string\">'('</span><span class=\"token punctuation\">,</span>RTrim<span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token string\">')'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> user_info<span class=\"token punctuation\">;</span></code></pre>\n<br>\n\n<h3 id=\"使用别名\"><a href=\"#使用别名\" class=\"headerlink\" title=\"使用别名\"></a>使用别名</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">-- as info</span>\n<span class=\"token keyword\">select</span> Concat<span class=\"token punctuation\">(</span>RTrim<span class=\"token punctuation\">(</span>nick_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token string\">'('</span><span class=\"token punctuation\">,</span>RTrim<span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token string\">')'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> info <span class=\"token keyword\">from</span> user_info<span class=\"token punctuation\">;</span></code></pre>\n<br>\n\n<h3 id=\"算术运算\"><a href=\"#算术运算\" class=\"headerlink\" title=\"算术运算\"></a>算术运算</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> order_id<span class=\"token punctuation\">,</span>quantity<span class=\"token punctuation\">,</span>item_price<span class=\"token punctuation\">,</span>quantity<span class=\"token operator\">*</span>item_price <span class=\"token keyword\">as</span> cost <span class=\"token keyword\">from</span> order_items<span class=\"token punctuation\">;</span></code></pre>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>加法</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减法</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法</td>\n</tr>\n</tbody></table>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"数据处理函数\"><a href=\"#数据处理函数\" class=\"headerlink\" title=\"数据处理函数\"></a>数据处理函数</h2><h3 id=\"文本处理函数\"><a href=\"#文本处理函数\" class=\"headerlink\" title=\"文本处理函数\"></a>文本处理函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Left()</td>\n<td>返回串左边的字符</td>\n</tr>\n<tr>\n<td>Length()</td>\n<td>返回串的长度</td>\n</tr>\n<tr>\n<td>Locate()</td>\n<td>找出串的一个子串</td>\n</tr>\n<tr>\n<td>Lower()</td>\n<td>将串转换为小写</td>\n</tr>\n<tr>\n<td>LTrim()</td>\n<td>去掉串左边的空格</td>\n</tr>\n<tr>\n<td>Right()</td>\n<td>返回串右边的字符</td>\n</tr>\n<tr>\n<td>RTrim()</td>\n<td>去掉串右边的空格</td>\n</tr>\n<tr>\n<td>Soundex()</td>\n<td>返回串的SOUNDEX值</td>\n</tr>\n<tr>\n<td>SubString()</td>\n<td>返回子串的字符</td>\n</tr>\n<tr>\n<td>Upper()</td>\n<td>将串转换为大写</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>SOUNDEX:将任何文本串转换为其语音表示的字母数字模式的算法。使得能<strong>对串进行发音比较而不是字母比较</strong></p>\n</blockquote>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">-- nikename发音类似cc的所有nickname</span>\n<span class=\"token keyword\">select</span> nickname <span class=\"token keyword\">from</span> user_info <span class=\"token keyword\">where</span> Soundex<span class=\"token punctuation\">(</span>nickname<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span>Soundex<span class=\"token punctuation\">(</span><span class=\"token string\">'cc'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<br>\n\n<h3 id=\"时间处理函数\"><a href=\"#时间处理函数\" class=\"headerlink\" title=\"时间处理函数\"></a>时间处理函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AddDate()</td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td>AddTime()</td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td>CurDate()</td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td>CurTime()</td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td>Date()</td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td>DateDiff()</td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td>Date_Add()</td>\n<td>高度灵活的日期运算函数</td>\n</tr>\n<tr>\n<td>Date_Format()</td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td>Day()</td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td>DayOfWeek()</td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td>Hour()</td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td>Minute()</td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td>Month()</td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td>Now()</td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td>Second()</td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td>Time()</td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td>Year()</td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>日期格式最好为yyyy-mm-dd,可以排除多义性，这样MySql就不必做出任何假设，更加可靠</p>\n</blockquote>\n<blockquote>\n<p><code>select * from user where birthday=&#39;2000-01-01&#39;</code> 会和 birthday为’2000-01-01 01:01:01’的匹配失败<br>更好的解决方案是利用<code>Date()</code>函数直接匹配日期部分 <code>select * from user where Date(birthday)=&#39;2000-01-01&#39;</code></p>\n</blockquote>\n<h3 id=\"数值处理函数\"><a href=\"#数值处理函数\" class=\"headerlink\" title=\"数值处理函数\"></a>数值处理函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Abs()</td>\n<td>返回一个数的绝对值</td>\n</tr>\n<tr>\n<td>Cos()</td>\n<td>返回一个角度的余弦</td>\n</tr>\n<tr>\n<td>Exp()</td>\n<td>返回一个数的指数值</td>\n</tr>\n<tr>\n<td>Mod()</td>\n<td>返回除操作的余数</td>\n</tr>\n<tr>\n<td>Pi()</td>\n<td>返回圆周率</td>\n</tr>\n<tr>\n<td>Rand()</td>\n<td>返回一个随机数</td>\n</tr>\n<tr>\n<td>Sin()</td>\n<td>返回一个角度的正弦</td>\n</tr>\n<tr>\n<td>Sqrt()</td>\n<td>返回一个数的平方根</td>\n</tr>\n<tr>\n<td>Tan()</td>\n<td>返回一个角度的正切</td>\n</tr>\n</tbody></table>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"汇总数据\"><a href=\"#汇总数据\" class=\"headerlink\" title=\"汇总数据\"></a>汇总数据</h2><h3 id=\"聚集函数\"><a href=\"#聚集函数\" class=\"headerlink\" title=\"聚集函数\"></a>聚集函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AVG()</td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td>COUNT()</td>\n<td>返回某列的行数</td>\n</tr>\n<tr>\n<td>MAX()</td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td>MIN()</td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td>SUM()</td>\n<td>返回某列值之和</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>以上函数均忽略列值为NULL的行</p>\n</blockquote>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token function\">AVG</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span>    <span class=\"token keyword\">from</span> user_info<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span>  <span class=\"token keyword\">from</span> user_info<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token function\">MAX</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span>    <span class=\"token keyword\">from</span> user_info<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token function\">MIN</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span>    <span class=\"token keyword\">from</span> user_info<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">select</span> <span class=\"token function\">SUM</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span>    <span class=\"token keyword\">from</span> user_info<span class=\"token punctuation\">;</span></code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"分组函数\"><a href=\"#分组函数\" class=\"headerlink\" title=\"分组函数\"></a>分组函数</h2><h3 id=\"创建分组\"><a href=\"#创建分组\" class=\"headerlink\" title=\"创建分组\"></a>创建分组</h3><ol>\n<li>先按照特定顺序分组</li>\n<li>再对<strong>每一组</strong>进行计算</li>\n</ol>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">-- 先按照昵称分组，然后对每一组进行求和运算</span>\n<span class=\"token keyword\">select</span> nick_name<span class=\"token punctuation\">,</span><span class=\"token function\">SUM</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> user_info <span class=\"token keyword\">group</span> <span class=\"token keyword\">by</span> nick_name<span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>select后的每一列都<strong>必须在GROUP BY字句中给出</strong></p>\n</blockquote>\n<blockquote>\n<p>如果在select中使用表达式，则必须在group by子句中指定相同的表达式</p>\n</blockquote>\n<h3 id=\"过滤分组\"><a href=\"#过滤分组\" class=\"headerlink\" title=\"过滤分组\"></a>过滤分组</h3><p>HAVING:</p>\n<ul>\n<li>基础功能和WHERE一样，在简单句式中可以替代WHERE</li>\n<li>区别：<ul>\n<li>WHERE过滤行，HAVING过滤分组</li>\n<li>WHERE在数据<strong>分组前</strong>过滤数据，HAVING在数据<strong>分组后</strong>对组进行分组。</li>\n</ul>\n</li>\n</ul>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">-- 先对过滤掉age&lt;=10的数据，再筛选出分组总年龄大于100的小组</span>\n<span class=\"token keyword\">select</span> nick_name<span class=\"token punctuation\">,</span><span class=\"token function\">SUM</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> user_info <span class=\"token keyword\">where</span> age<span class=\"token operator\">></span><span class=\"token number\">10</span> <span class=\"token keyword\">group</span> <span class=\"token keyword\">by</span> nick_name <span class=\"token keyword\">having</span> <span class=\"token function\">SUM</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token number\">100</span><span class=\"token punctuation\">;</span></code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><h3 id=\"利用子查询过滤\"><a href=\"#利用子查询过滤\" class=\"headerlink\" title=\"利用子查询过滤\"></a>利用子查询过滤</h3><blockquote>\n<p>现在有订单表orderitems，客户信息表customers，订单物品表orderitems<br>查询出订购物品cc2的所有客户姓名</p>\n</blockquote>\n<ul>\n<li>检索包含物品cc2的所有订单的编号。<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> order_num <span class=\"token keyword\">from</span> orderitems <span class=\"token keyword\">where</span> prod_id<span class=\"token operator\">=</span><span class=\"token string\">'cc2'</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li>检索具有前一步骤列出的订单编号的所有客户的ID。<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> cust_id <span class=\"token keyword\">from</span> orders <span class=\"token keyword\">where</span> order_num <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2005</span><span class=\"token punctuation\">,</span><span class=\"token number\">2006</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li>检索前一步骤返回的所有客户ID的客户信息。 <strong>从内向外执行</strong><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> cust_id <span class=\"token keyword\">from</span> orders <span class=\"token keyword\">where</span> order_num <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> order_num <span class=\"token keyword\">from</span> orderitems <span class=\"token keyword\">where</span> prod_id<span class=\"token operator\">=</span><span class=\"token string\">'cc2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li>从客户ID中查询出信息<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> \n  cust_name \n<span class=\"token keyword\">from</span> \n  customers \n<span class=\"token keyword\">where</span> \n  cust_id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> \n                  cust_id \n              <span class=\"token keyword\">from</span> \n                  orders \n              <span class=\"token keyword\">where</span> \n                  order_num <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> \n                                  order_num \n                              <span class=\"token keyword\">from</span> \n                                  orderitems \n                              <span class=\"token keyword\">where</span> \n                                  prod_id<span class=\"token operator\">=</span><span class=\"token string\">'cc2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"作为计算手段使用子查询\"><a href=\"#作为计算手段使用子查询\" class=\"headerlink\" title=\"作为计算手段使用子查询\"></a>作为计算手段使用子查询</h3><blockquote>\n<p>现有订单表orderitems，客户信息表customers<br>查询每个用户的订单总数</p>\n</blockquote>\n<ul>\n<li>查询某个用户的所有订单数<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> orders <span class=\"token keyword\">from</span> orders <span class=\"token keyword\">where</span> cust_id<span class=\"token operator\">=</span><span class=\"token number\">1001</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li>查询在订单表中每个用户的订单总数及其信息<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> cust_name<span class=\"token punctuation\">,</span>\n     <span class=\"token punctuation\">(</span><span class=\"token keyword\">select</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">from</span> orders \n      <span class=\"token keyword\">where</span> oders<span class=\"token punctuation\">.</span>cust_id<span class=\"token operator\">=</span>customers<span class=\"token punctuation\">.</span>cust_id<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> orders \n<span class=\"token keyword\">from</span> customer \n<span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> cust_name<span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"联结表\"><a href=\"#联结表\" class=\"headerlink\" title=\"联结表\"></a>联结表</h2><h3 id=\"使用where\"><a href=\"#使用where\" class=\"headerlink\" title=\"使用where\"></a>使用where</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> vend_name<span class=\"token punctuation\">,</span>prod_name<span class=\"token punctuation\">,</span>prod_price <span class=\"token keyword\">from</span> vendors<span class=\"token punctuation\">,</span>products <span class=\"token keyword\">where</span> vendors<span class=\"token punctuation\">.</span>vend_id<span class=\"token operator\">=</span>prodcts<span class=\"token punctuation\">.</span>vend_id <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> vend_name<span class=\"token punctuation\">,</span>prod_name<span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"内部联结\"><a href=\"#内部联结\" class=\"headerlink\" title=\"内部联结\"></a>内部联结</h3><p>使用 INNER JOIN 指定表，再使用 ON 执行特定条件的连接</p>\n<ul>\n<li>检索所有客户及其订单<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> customer<span class=\"token punctuation\">.</span>cust_id<span class=\"token punctuation\">,</span>orders<span class=\"token punctuation\">.</span>order_num <span class=\"token keyword\">FROM</span> customer <span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> orders <span class=\"token keyword\">ON</span> customers<span class=\"token punctuation\">.</span>cust_id <span class=\"token operator\">=</span> orders<span class=\"token punctuation\">.</span>cust_id<span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"多表联结\"><a href=\"#多表联结\" class=\"headerlink\" title=\"多表联结\"></a>多表联结</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> cust_name \n<span class=\"token keyword\">from</span> customer<span class=\"token punctuation\">,</span>orders<span class=\"token punctuation\">,</span>orderitems \n<span class=\"token keyword\">where</span> customer<span class=\"token punctuation\">.</span>cust_id<span class=\"token operator\">=</span>oders<span class=\"token punctuation\">.</span>cust_id \n<span class=\"token operator\">and</span> orderitems<span class=\"token punctuation\">.</span>order_num<span class=\"token operator\">=</span>orders<span class=\"token punctuation\">.</span>order_num\n<span class=\"token operator\">and</span> prod_id<span class=\"token operator\">=</span><span class=\"token string\">'cc2'</span><span class=\"token punctuation\">;</span></code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"高级联结\"><a href=\"#高级联结\" class=\"headerlink\" title=\"高级联结\"></a>高级联结</h2><h3 id=\"使用表别名\"><a href=\"#使用表别名\" class=\"headerlink\" title=\"使用表别名\"></a>使用表别名</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> cust_name \n<span class=\"token keyword\">from</span> customer <span class=\"token keyword\">as</span> <span class=\"token number\">c</span><span class=\"token punctuation\">,</span>orders <span class=\"token keyword\">as</span> o<span class=\"token punctuation\">,</span>orderitems <span class=\"token keyword\">as</span> oi \n<span class=\"token keyword\">where</span> <span class=\"token number\">c</span><span class=\"token punctuation\">.</span>cust_id<span class=\"token operator\">=</span>o<span class=\"token punctuation\">.</span>cust_id \n<span class=\"token operator\">and</span> oi<span class=\"token punctuation\">.</span>order_num<span class=\"token operator\">=</span>o<span class=\"token punctuation\">.</span>order_num\n<span class=\"token operator\">and</span> prod_id<span class=\"token operator\">=</span><span class=\"token string\">'cc2'</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"自联结\"><a href=\"#自联结\" class=\"headerlink\" title=\"自联结\"></a>自联结</h3><blockquote>\n<p>在商品表中发一下一个不合格商品(id为cc3)，现在需要查找出生产这个商品的厂家的其他产品</p>\n</blockquote>\n<ul>\n<li><p>使用子查询</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span>prod_name <span class=\"token keyword\">FROM</span> products <span class=\"token keyword\">where</span> vend_id <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> vend_id <span class=\"token keyword\">FROM</span> products <span class=\"token keyword\">WHERE</span> prod_id <span class=\"token operator\">=</span> <span class=\"token string\">'cc2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n</li>\n<li><p>使用自联结</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> p1<span class=\"token punctuation\">.</span>prod_id<span class=\"token punctuation\">,</span>p1<span class=\"token punctuation\">.</span>prod_name <span class=\"token keyword\">FROM</span> products <span class=\"token keyword\">AS</span> p1<span class=\"token punctuation\">,</span> products <span class=\"token keyword\">AS</span> p2 <span class=\"token keyword\">WHERE</span> p1<span class=\"token punctuation\">.</span>vend_id<span class=\"token operator\">=</span>p2<span class=\"token punctuation\">.</span>vend_id <span class=\"token operator\">AND</span> p2<span class=\"token punctuation\">.</span>prod_id <span class=\"token operator\">=</span> <span class=\"token string\">'cc3'</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>p1,p2实际上是相同的一张表</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"自然联结\"><a href=\"#自然联结\" class=\"headerlink\" title=\"自然联结\"></a>自然联结</h3><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中，标准的联结(内部联结)返回所有的数据，<strong>甚至所有的列多次出现</strong>。</p>\n<p><strong>自然联结排除多次出现，使每个列只返回一次。</strong></p>\n<h3 id=\"外部联结\"><a href=\"#外部联结\" class=\"headerlink\" title=\"外部联结\"></a>外部联结</h3><p>许多联结将一个表中的行与另外一个表中的行相关联。但有时候需要<strong>包含没有关联行的那些行</strong>。</p>\n<ul>\n<li>列出所有产品以及订购数据，<strong>包括哪些没有人订购的产品</strong></li>\n<li>对每个客户下了多少订单进行计数，<strong>包括哪些至今尚未下订单的客户</strong></li>\n<li>检索所有客户及其订单(内部联结)</li>\n</ul>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> customer<span class=\"token punctuation\">.</span>cust_id<span class=\"token punctuation\">,</span>orders<span class=\"token punctuation\">.</span>order_num <span class=\"token keyword\">FROM</span> customer <span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> orders <span class=\"token keyword\">ON</span> customers<span class=\"token punctuation\">.</span>cust_id <span class=\"token operator\">=</span> orders<span class=\"token punctuation\">.</span>cust_id<span class=\"token punctuation\">;</span></code></pre>\n<ul>\n<li>检索所有客户，包括那些没有下订单的客户(外部联结)<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> customer<span class=\"token punctuation\">.</span>cust_id<span class=\"token punctuation\">,</span>orders<span class=\"token punctuation\">.</span>order_num <span class=\"token keyword\">FROM</span> customer <span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">OUTER</span> <span class=\"token keyword\">JOIN</span> orders <span class=\"token keyword\">ON</span> customers<span class=\"token punctuation\">.</span>cust_id <span class=\"token operator\">=</span> orders<span class=\"token punctuation\">.</span>cust_id<span class=\"token punctuation\">;</span></code></pre>\n</li>\n</ul>\n<blockquote>\n<p>RIGHT表示OUTER JION右边的表的所有行（匹配或不匹配）都将被检索出来<br>LEFT 表示OUTER JION左边的表   </p>\n</blockquote>\n<h3 id=\"带聚集函数的联结\"><a href=\"#带聚集函数的联结\" class=\"headerlink\" title=\"带聚集函数的联结\"></a>带聚集函数的联结</h3><p>检索出所有客户及每个客户所下的订单数</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> customers<span class=\"token punctuation\">.</span>cust_id<span class=\"token punctuation\">,</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span>orders<span class=\"token punctuation\">.</span>ooder_num<span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> customer <span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">OUTER</span> <span class=\"token keyword\">JOIN</span> orders <span class=\"token keyword\">ON</span> customer<span class=\"token punctuation\">.</span>cust_id <span class=\"token operator\">=</span> orders<span class=\"token punctuation\">.</span>cust_id <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> customers<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span></code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"组合查询\"><a href=\"#组合查询\" class=\"headerlink\" title=\"组合查询\"></a>组合查询</h2><ul>\n<li>对于单个查询中从不同表汇总返回类似结构的数据</li>\n<li>对单个表执行多个查询，按单个查询返回数据</li>\n</ul>\n<h3 id=\"使用UNION\"><a href=\"#使用UNION\" class=\"headerlink\" title=\"使用UNION\"></a>使用UNION</h3><blockquote>\n<p>检索出所有价格小于5且来自2001,2002的供应商的所有商品</p>\n</blockquote>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span>pro_name\n<span class=\"token keyword\">FROM</span> products\n<span class=\"token keyword\">WHERE</span> prod_price <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span>\n<span class=\"token keyword\">UNION</span>\n<span class=\"token keyword\">SELECT</span> prod_id<span class=\"token punctuation\">,</span>pro_name\n<span class=\"token keyword\">FROM</span> productes\n<span class=\"token keyword\">WHERE</span> vend_id <span class=\"token operator\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2001</span><span class=\"token punctuation\">,</span><span class=\"token number\">2003</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> prod_name<span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>默认去除多个SELECT结果的重复行，但是可以使用UNION ALL来返回所有的改变行<br>排序语句放在最后一个SELECT的后面</p>\n</blockquote>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"全文本搜索\"><a href=\"#全文本搜索\" class=\"headerlink\" title=\"全文本搜索\"></a>全文本搜索</h2><h3 id=\"启用全文搜索\"><a href=\"#启用全文搜索\" class=\"headerlink\" title=\"启用全文搜索\"></a>启用全文搜索</h3><p>MySql指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySql可以快速有效地判断哪些行包含它们，哪些词不匹配，它们匹配的频率，等等<br><strong>FULLTEXT(列名称)</strong>    </p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> product<span class=\"token punctuation\">(</span>\n    note_id     <span class=\"token keyword\">int</span>         <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    pro_id      char<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    note_text   <span class=\"token keyword\">text</span>        <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">(</span>pro_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    FULLTEXT<span class=\"token punctuation\">(</span>note_text<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span>MyISAM<span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>InnoDB不支持全文本搜索引擎</p>\n</blockquote>\n<h3 id=\"进行全文本搜索\"><a href=\"#进行全文本搜索\" class=\"headerlink\" title=\"进行全文本搜索\"></a>进行全文本搜索</h3><p>Match()：指定被搜索的列<br>Against()：指定要使用的搜索表达式</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> note_text <span class=\"token keyword\">FROM</span> productnotes <span class=\"token keyword\">WHERE</span> <span class=\"token keyword\">Match</span> <span class=\"token punctuation\">(</span>note_text<span class=\"token punctuation\">)</span> Against<span class=\"token punctuation\">(</span><span class=\"token string\">'rabbit'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"使用扩展查询\"><a href=\"#使用扩展查询\" class=\"headerlink\" title=\"使用扩展查询\"></a>使用扩展查询</h3><p>考虑下面 的情况。你想找出所有提到anvils的注释。只有一个注释包含词anvils， 但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils。 这也是查询扩展的一项任务。在使用查询扩展时，MySQL对数据和 索引进行两遍扫描来完成搜索： </p>\n<ul>\n<li>首先，进行一个基本的全文本搜索，<strong>找出与搜索条件匹配的所有行</strong>；</li>\n<li>其次，MySQL检查这些匹配行并<strong>选择</strong>所有有用的词（我们将会简 要地解释MySQL如何断定什么有用，什么无用）。 </li>\n<li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件， 而且还使用所有有用的词。 <pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> note_text <span class=\"token keyword\">FROM</span> productnotes <span class=\"token keyword\">WHERE</span> <span class=\"token keyword\">Match</span><span class=\"token punctuation\">(</span>note_text<span class=\"token punctuation\">)</span> Against <span class=\"token punctuation\">(</span><span class=\"token string\">'anvil'</span> <span class=\"token keyword\">WITH</span> QUERY EXPANsION<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>可能返回多行，但只有第一行含有关键字’anvil’，其他行因为含有第一行的相关字而有可能被检索出来</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"布尔文本搜索\"><a href=\"#布尔文本搜索\" class=\"headerlink\" title=\"布尔文本搜索\"></a>布尔文本搜索</h3><p>可以提供关于如下内容的细节：</p>\n<ul>\n<li>要匹配的词</li>\n<li>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含 其他指定的词也是如此） </li>\n<li>排列提示（指定某些词比其他词更重要，更重要的词等级更高）</li>\n<li>表达式分组</li>\n<li>另外一些内容</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>布尔操作符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>包含，词必须存在</td>\n</tr>\n<tr>\n<td>-</td>\n<td>排除，词必须不出现</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>包含，而且增加等级值</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>包含，且减少等级值</td>\n</tr>\n<tr>\n<td>()</td>\n<td>把词组成子表达式（允许这些子表达式作为一个组被包含、 排除、排列等）</td>\n</tr>\n<tr>\n<td>~</td>\n<td>取消一个词的排序值</td>\n</tr>\n<tr>\n<td>*</td>\n<td>词尾的通配符</td>\n</tr>\n<tr>\n<td>“”</td>\n<td>定义一个短语（与单个词的列表不一样，它匹配整个短语以 便包含或排除这个短语）</td>\n</tr>\n</tbody></table>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> note_text <span class=\"token keyword\">FROM</span> productnotes <span class=\"token keyword\">WHERE</span> <span class=\"token keyword\">Match</span><span class=\"token punctuation\">(</span>note_text<span class=\"token punctuation\">)</span> Against<span class=\"token punctuation\">(</span><span class=\"token string\">'heavy -rope*'</span> <span class=\"token operator\">IN</span> <span class=\"token keyword\">BOOLEAN</span> MODE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>检索含有关键字<code>heavy</code><strong>但不含有以<code>rope</code>开头的行</strong></p>\n</blockquote>\n<h3 id=\"一些说明\"><a href=\"#一些说明\" class=\"headerlink\" title=\"一些说明\"></a>一些说明</h3><ul>\n<li>在索引全文本数据时，<strong>短词被忽略且从索引中排除</strong>。短词定义为 那些具有<em>3个或3个以下字符的词</em>（如果需要，这个数目可以更改）。</li>\n<li>MySQL带有一个<strong>内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略</strong>。如果需要，可以覆盖这个列表（请参 阅MySQL文档以了解如何完成此工作）。</li>\n<li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。 因此，MySQL规定了一条50%规则，<strong>如果一个词出现在50%以上的行中，则将它作为一个非用词忽略</strong>。<em>50%规则不用于IN BOOLEAN MODE。</em></li>\n<li>如果表中的<strong>行数少于3行，则全文本搜索不返回结果</strong>（因为每个词 或者不出现，或者至少出现在50%的行中）。 </li>\n<li><em>忽略词中的单引号</em>。例如，don’t索引为dont。 </li>\n<li><em>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文</em>本搜索结果。 </li>\n<li>如前所述，<strong>仅在MyISAM数据库引擎中支持全文本搜索。</strong> </li>\n</ul>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h2><h3 id=\"插入完整的行\"><a href=\"#插入完整的行\" class=\"headerlink\" title=\"插入完整的行\"></a>插入完整的行</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">into</span> customers <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"cc\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"cc@foxmail\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>对每个列<strong>必须</strong>提供一个值。<strong>如果某个列没有值，应该使用NULL值</strong>（假定表允许对该列指定空值）。<br>对于自增的字段，也需要设为NULL</p>\n</blockquote>\n<blockquote>\n<p>种语法很简单，但并不安全，<strong>应该尽量避免使用</strong>。不能保证下一次表结构变动后各个列 保持完全相同的次序</p>\n</blockquote>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">into</span> customers<span class=\"token punctuation\">(</span>cust_id<span class=\"token punctuation\">,</span>cust_name<span class=\"token punctuation\">,</span>cust_email<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"cc\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"cc@foxmail\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>用VALUES 列表中的相应值填入列表中的对应项<br>对于自增字段，可以不出现</p>\n</blockquote>\n<blockquote>\n<p>如果数据检索是最重要的（通常是这样），则你可以通过在 INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL 降低INSERT语句的优先级，如下所示：<br><code>INSERT LOW_PRIORITY INTO</code><br>这也适用于UPDATE和DELETE语句      </p>\n</blockquote>\n<h3 id=\"插入多行\"><a href=\"#插入多行\" class=\"headerlink\" title=\"插入多行\"></a>插入多行</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">into</span> customers<span class=\"token punctuation\">(</span>cust_id<span class=\"token punctuation\">,</span>cust_name<span class=\"token punctuation\">,</span>cust_email<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"cc\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"cc@foxmail\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2,cc2,cc2@foxmail\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"插入检索出来的数据\"><a href=\"#插入检索出来的数据\" class=\"headerlink\" title=\"插入检索出来的数据\"></a>插入检索出来的数据</h3><p>合并新旧表</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">into</span> cust_new<span class=\"token punctuation\">(</span>cust_id<span class=\"token punctuation\">,</span>\n                      cust_name<span class=\"token punctuation\">,</span>\n                      cust_email<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">SELECT</span>  cust_id<span class=\"token punctuation\">,</span>\n        cust_name<span class=\"token punctuation\">,</span>   \n        cust_email                \n<span class=\"token keyword\">FROM</span> cust_old<span class=\"token punctuation\">;</span></code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"更新和删除数据\"><a href=\"#更新和删除数据\" class=\"headerlink\" title=\"更新和删除数据\"></a>更新和删除数据</h2><h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">UPDATE</span> customers <span class=\"token keyword\">SET</span> cust_email <span class=\"token operator\">=</span> <span class=\"token string\">'newmail@foxmial.com'</span><span class=\"token punctuation\">,</span> cust_name <span class=\"token operator\">=</span> <span class=\"token string\">'newname'</span> <span class=\"token keyword\">WHERE</span> cust_id <span class=\"token operator\">=</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>如果没有<code>WHERE</code>语句，<strong>则将更新这张表中所有数据</strong></p>\n</blockquote>\n<blockquote>\n<p>IGNORE关键字，如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 （错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示： UPDATE IGNORE customers… </p>\n</blockquote>\n<blockquote>\n<p>为了删除某一行的某个列值，可以将它更新为NULL</p>\n</blockquote>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><ul>\n<li>删除一行<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> customers <span class=\"token keyword\">WHERE</span> cust_id <span class=\"token operator\">=</span> <span class=\"token string\">'1231'</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>如果没有<code>WHERE</code>语句，<strong>则将删除这张表中所有数据</strong><br>如果更快的删除而且删除清零自增字段，可以使用<code>truncate tablename</code></p>\n</blockquote>\n</li>\n</ul>\n<p>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE 子句的UPDATE或DELETE语句。<br>保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能 像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。<br>在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进 行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。 </p>\n<h3 id=\"创建和删除表\"><a href=\"#创建和删除表\" class=\"headerlink\" title=\"创建和删除表\"></a>创建和删除表</h3><h4 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h4><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> product<span class=\"token punctuation\">(</span>\n    pro_id      char<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>  <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">--自增</span>\n    note_id     <span class=\"token keyword\">int</span>         <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    note_text   <span class=\"token keyword\">text</span>        <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n    pro_price   ine         <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">--默认值为1</span>\n    <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">(</span>pro_id<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>自增字段 AUTO_INCREMENT，（每个表<strong>只允许有一个自增字段</strong>，且<strong>必须被索引</strong>&lt;例如使它变为主键&gt;）<br>使用<code>SELECT last_insert_id()</code>语句<strong>返回最后一个AUTO_INCREMENT值</strong></p>\n</blockquote>\n<blockquote>\n<p>DEFAULT 设置默认值</p>\n</blockquote>\n<h4 id=\"引擎类型\"><a href=\"#引擎类型\" class=\"headerlink\" title=\"引擎类型\"></a>引擎类型</h4><p>与其他DBMS一样，MySQL有一个<strong>具体管理和处理数据</strong>的内部引擎。 在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT 语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候， 此引擎都隐藏在DBMS内，不需要过多关注它。   </p>\n<p>但MySQL与其他DBMS不一样，<strong>它具有多种引擎</strong>。它打包多个引擎， 这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT 等命令。 </p>\n<p>为什么要发行多种引擎呢？因为它们<strong>具有各自不同的功能和特性</strong>， 为不同的任务选择正确的引擎能获得<strong>良好的功能和灵活性</strong>。 </p>\n<p>当然，你完全可以忽略这些数据库引擎。如果省略ENGINE=语句，则 使用默认引擎（很可能是MyISAM），多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么ENGINE=语句很重要的原因 （也就是为什么本书的样列表中使用两种引擎的原因）。 </p>\n<ul>\n<li>InnoDB是一个<strong>可靠的事务处理引擎</strong>（参见第26章），它<strong>不支持全文本搜索</strong></li>\n<li>MEMORY在功能等同于MyISAM，但由于<strong>数据存储在内存</strong>（不是磁盘） 中，<strong>速度很快</strong>（特别适合于临时表）</li>\n<li>MyISAM是一个<strong>性能极高</strong>的引擎，它支持全文本搜索（参见第18章）， 但<strong>不支持事务处理</strong>。 </li>\n</ul>\n<h4 id=\"更新表\"><a href=\"#更新表\" class=\"headerlink\" title=\"更新表\"></a>更新表</h4><p>为更新表定义，可使用<strong>ALTER TABLE</strong>语句。但是，理想状态下，<em>当表中存储数据以后，该表就不应该再被更新</em>。在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。 </p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--增加字段</span>\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> products <span class=\"token keyword\">ADD</span> prod_price<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">--删除字段</span>\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> products <span class=\"token keyword\">DROP</span> prod_price<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">--定义外键</span>\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> products <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">CONSTRAINT</span> orderitems <span class=\"token keyword\">FOREIGN</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>order_num<span class=\"token punctuation\">)</span> <span class=\"token keyword\">REFERENCES</span> <span class=\"token punctuation\">(</span>order_num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p><strong>复杂的表结构更改</strong>一般需要手动删除过程，它涉及以下步骤： </p>\n<ul>\n<li>用新的列布局创建一个新表</li>\n<li>使用INSERT SELECT语句从旧表复制数据到新表</li>\n<li>检验包含所需数据的新表</li>\n<li>重命名旧表（如果确定，可以删除它）</li>\n<li>用旧表原来的名字重命名新表</li>\n<li>根据需要，重新创建触发器、存储过程、索引和外键</li>\n</ul>\n<h4 id=\"删除表\"><a href=\"#删除表\" class=\"headerlink\" title=\"删除表\"></a>删除表</h4><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TABLE</span> customers<span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"清除表数据\"><a href=\"#清除表数据\" class=\"headerlink\" title=\"清除表数据\"></a>清除表数据</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--删除数据</span>\n<span class=\"token keyword\">delete</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> TName<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">--删除所有数据并重置自增序列</span>\n<span class=\"token keyword\">truncate</span> <span class=\"token keyword\">table</span> TName<span class=\"token punctuation\">;</span> </code></pre>\n<h4 id=\"重命名表\"><a href=\"#重命名表\" class=\"headerlink\" title=\"重命名表\"></a>重命名表</h4><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">RENAME</span> <span class=\"token keyword\">TABLE</span> customer1 <span class=\"token keyword\">TO</span> customer2<span class=\"token punctuation\">;</span></code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>视图是<strong>虚拟的表</strong>。与包含数据的表不一样，视图<strong>只包含使用时动态检索数据的查询</strong>。 </p>\n<blockquote>\n<p>它<strong>本身不包含</strong>表中应该有的<strong>任何列或数据</strong>，它<strong>包含的是一个SQL查询</strong></p>\n</blockquote>\n<h3 id=\"视图的应用\"><a href=\"#视图的应用\" class=\"headerlink\" title=\"视图的应用\"></a>视图的应用</h3><ul>\n<li><strong>重用SQL语句</strong></li>\n<li><strong>简化复杂的SQL操作</strong>。在编写查询后，可以方便地重用它而不必知道它的基本查询细节</li>\n<li><strong>使用表的组成部分</strong>而不是整个表。</li>\n<li><strong>保护数据</strong>。可以给用户授予表的特定部分的访问权限而不是整个 表的访问权限</li>\n<li><strong>更改数据格式和表示</strong>。视图可返回与底层表的表示和格式不同的数据</li>\n</ul>\n<p>在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图<strong>执行SELECT操作</strong>，<strong>过滤</strong>和<strong>排序</strong>数据，将视<strong>图联结到其他视图或表</strong>，甚至能<strong>添加</strong>和<strong>更新</strong>数据（添加和更新数据存在某些限制。关于这个内容稍 后还要做进一步的介绍）。 </p>\n<blockquote>\n<p>如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。</p>\n</blockquote>\n<h3 id=\"视图的规则和限制\"><a href=\"#视图的规则和限制\" class=\"headerlink\" title=\"视图的规则和限制\"></a>视图的规则和限制</h3><ul>\n<li>视图必须唯一命名</li>\n<li>创建的视图数目没有限制</li>\n<li><strong>必须具有足够的访问权限</strong></li>\n<li><strong>视图可以嵌套</strong>，即可以利用从其他视图中检索数据的查询来构造 一个视图</li>\n<li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖</li>\n<li><strong>视图不能索引</strong>，也不能有关联的触发器或默认值</li>\n<li>视图可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句。 </li>\n</ul>\n<h3 id=\"使用视图\"><a href=\"#使用视图\" class=\"headerlink\" title=\"使用视图\"></a>使用视图</h3><ul>\n<li>CREATE VIEW语句来创建</li>\n<li>SHOW CREATE VIEW viewname；来查看创建视图的语</li>\n<li>用DROP删除视图，其语法为DROP VIEW viewname</li>\n<li>更新视图时，可以先用DROP再用CREATE，也可以直接用<code>CREATE OR REPLACE VIEW</code>。如果要更新的视图不存在，则第2条更新语句会创 建一个视图；如果要更新的视图存在，则第2条更新语句会替换原 有视图</li>\n</ul>\n<h3 id=\"更新视图\"><a href=\"#更新视图\" class=\"headerlink\" title=\"更新视图\"></a>更新视图</h3><p>通常，视图是可更新的，但是，并非所有视图都是可更新的。基本上可以说，<strong>如果MySQL不能正确地确定被更新的基数据，则不允许更新</strong>（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新： </p>\n<ul>\n<li>分组</li>\n<li>联结</li>\n<li>子查询</li>\n<li>并</li>\n<li>聚集函数（Min()、Count()、Sum()等）</li>\n<li>DISTINCT</li>\n<li>导出（计算）列</li>\n</ul>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h2><p>迄今为止，使用的大多数SQL语句都是针对一个或多个表的单条语 句。并非所有操作都这么简单，经常会有一个完整的操作需要多条语句 才能完成。例如，考虑以下的情形</p>\n<ul>\n<li>为了处理订单，需要核对以保证库存中有相应的物品</li>\n<li>如果库存有物品，这些物品需要预定以便不将它们再卖给别的人，并且要减少可用的物品数量以反映正确的库存量</li>\n<li>库存中没有的物品需要订购，这需要与供应商进行某种交互 </li>\n<li>关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的客户</li>\n</ul>\n<p>执行这个<strong>处理需要针对许多表的多条MySQL语句</strong>。此外，需要执行的<strong>具体语句及其次序</strong>也不是固定的，它们可能会（和将）根据哪些物品在库存中哪些不在而变化。 </p>\n<p>存储过程简单来说，就是为以后的使用而保存的<strong>一条或多条MySQL语句的集合</strong>。</p>\n<blockquote>\n<p>可将其视为批文件，虽然它们的作用不仅限于批处理。 </p>\n</blockquote>\n<h3 id=\"使用存储过程的优缺点\"><a href=\"#使用存储过程的优缺点\" class=\"headerlink\" title=\"使用存储过程的优缺点\"></a>使用存储过程的优缺点</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p><strong>简单、安全、高性能</strong></p>\n<ul>\n<li>通过把处理封装在容易使用的单元中，<strong>简化复杂的操作</strong>（正如前 面例子所述）</li>\n<li>由于不要求反复建立一系列处理步骤，这<strong>保证了数据的完整性</strong>。<em>如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的</em>。 这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误<strong>保证了数据的一致性</strong></li>\n<li><strong>简化对变动的管理</strong>。如果表名、列名或业务逻辑（或别的内容） 有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化</li>\n<li><strong>提高性能</strong>。因为使用存储过程比使用单独的SQL语句要快 </li>\n<li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写<strong>功能更强更灵活</strong>的代码</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>存储过程的<strong>编写比基本SQL语句复杂</strong>，编写存储过程需要更高的技能，更丰富的经验。 </li>\n<li>你可能<strong>没有创建存储过程的安全访问权限</strong>。许多数据库管理员限 制存储过程的创建权限，允许用户使用存储过程，但不允许他们 创建存储过程。 </li>\n</ul>\n<h3 id=\"使用存储过程\"><a href=\"#使用存储过程\" class=\"headerlink\" title=\"使用存储过程\"></a>使用存储过程</h3><ul>\n<li>执行（call）<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CALL</span> productpricing<span class=\"token punctuation\">(</span><span class=\"token variable\">@pricelow</span><span class=\"token punctuation\">,</span><span class=\"token variable\">@pricehigh</span><span class=\"token punctuation\">,</span><span class=\"token variable\">@priceaverage</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h3>返回产品平均过程的存储过程<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">PROCEDURE</span> productpricing<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">BEGIN</span>\n  <span class=\"token keyword\">SELECT</span> <span class=\"token function\">AVG</span><span class=\"token punctuation\">(</span>prod_price<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> priceaverage <span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">END</span></code></pre>\n<blockquote>\n<p>注意productpricing()的()</p>\n</blockquote>\n</li>\n</ul>\n<p>mysql命令行客户机的分隔符(命令行工具)</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DELIMITER</span><span class=\"token comment\" spellcheck=\"true\">//</span>\n\n\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">PROCEDURE</span> productpricing<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">BEGIN</span>\n    <span class=\"token keyword\">SELECT</span> <span class=\"token function\">AVG</span><span class=\"token punctuation\">(</span>prod_price<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> priceaverage <span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">END</span><span class=\"token comment\" spellcheck=\"true\">//</span>\n\n<span class=\"token keyword\">DELIMITER</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote>\n<p>因为在存储过程存在<code>;</code>，所以在命令行程序中需使用特定的分隔符<br>DELIMITER+符号（分隔符）：表示告诉程序使用此分隔符作为新的语句结束分隔符,所以由<code>END</code>变为了<code>END//</code><br>除\\符号外，任何字符都可以用作语句分隔符。 </p>\n</blockquote>\n<h3 id=\"删除存储过程\"><a href=\"#删除存储过程\" class=\"headerlink\" title=\"删除存储过程\"></a>删除存储过程</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">PROCEDURE</span> productpricing<span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>注意没有<code>()</code><br>如果该存储过程不存在，则会报错，所以建议使用<code>DROP PROCEDURE IF EXISTS</code></p>\n</blockquote>\n<h3 id=\"使用参数\"><a href=\"#使用参数\" class=\"headerlink\" title=\"使用参数\"></a>使用参数</h3><ul>\n<li>创建带参数的存储过程<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">PROCEDURE</span> productpricing<span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">OUT</span> pl <span class=\"token keyword\">DECIMAL</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>    <span class=\"token comment\" spellcheck=\"true\">--pl:存储产品最低价格</span>\n  <span class=\"token keyword\">OUT</span> ph <span class=\"token keyword\">DECIMAL</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>    <span class=\"token comment\" spellcheck=\"true\">--ph:存储产品最高价格</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">BEGIN</span>\n  <span class=\"token keyword\">SELECT</span> <span class=\"token function\">MIN</span><span class=\"token punctuation\">(</span>prod_price<span class=\"token punctuation\">)</span> <span class=\"token keyword\">INTO</span> pl <span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">SELECT</span> <span class=\"token function\">MAX</span><span class=\"token punctuation\">(</span>prod_price<span class=\"token punctuation\">)</span> <span class=\"token keyword\">INTO</span> ph <span class=\"token keyword\">FROM</span> products<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">END</span></code></pre>\n<blockquote>\n<p>存储过程保存在BEGIN和END之间</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>OUT指出相应的参数用来<strong>从存储过程传出</strong> 一个值（返回给调用者）<br>IN,传递给存储过程<br>INOUT，对存储过程传入传出</p>\n</blockquote>\n<ul>\n<li>使用存储过程<br>```sql</li>\n</ul>\n<p>–指定变量名<br>CALL productpricing(@pricelow, @prichigh);</p>\n<p>–检索<br>SELECT @prcielow;</p>\n<p>SELECT @prcielow, @prichigh;</p>\n<pre><code>\n### 检查存储过程\n```sql\n-- 显示创建的语句\nSHOW CREATE PROCEDURE ordertotal;\n\n-- 显示更加详细，何时、由何人创建的信息\nSHOW CREATE PROCEDURE STATUS ordertotal;\n\n-- 过滤查看更多存储过程的信息\nSHOW CREATE PROCEDURE STATUS LIKE &#39;ordertotal&#39;;</code></pre><p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"游标\"><a href=\"#游标\" class=\"headerlink\" title=\"游标\"></a>游标</h2><p>（<del>有待填坑</del>）</p>\n<p>有时，<strong>需要在检索出来的行中前进或后退一行或多行</strong>。这就是使用游标的原因。游标（cursor）是<strong>一个存储在MySQL服务器上的数据库查询</strong>， 它不是一条SELECT语句，<strong>而是被该语句检索出来的结果集</strong>。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。 </p>\n<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。 </p>\n<h3 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h3><ul>\n<li>在能够<strong>使用游标前，必须声明</strong>（定义）它</li>\n<li>一旦声明后，必须打开游标以供使用。</li>\n<li>对于填有数据的游标，根据需要取出（检索）各行。 </li>\n<li>在结束游标使用时，必须关闭游标。 </li>\n</ul>\n<h3 id=\"创建游标\"><a href=\"#创建游标\" class=\"headerlink\" title=\"创建游标\"></a>创建游标</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">PROCEDURE</span> processorders<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">BEGIN</span>\n    <span class=\"token keyword\">DECLARE</span> ordernumbers <span class=\"token keyword\">CURSOR</span>\n    <span class=\"token keyword\">FOR</span>\n    <span class=\"token keyword\">SELECT</span> order_num <span class=\"token keyword\">FROM</span> orders<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">END</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"打开和关闭游标\"><a href=\"#打开和关闭游标\" class=\"headerlink\" title=\"打开和关闭游标\"></a>打开和关闭游标</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--打开</span>\n<span class=\"token keyword\">OPEN</span> ordernumbers<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">--关闭</span>\n<span class=\"token keyword\">CLOSE</span> ordernumbers<span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>如果不明确关闭游标，MySql将会在到达END语句时自动关闭</p>\n</blockquote>\n<h3 id=\"使用游标\"><a href=\"#使用游标\" class=\"headerlink\" title=\"使用游标\"></a>使用游标</h3><p>在一个游标被打开后，可以使用<strong>FETCH语句</strong>分别访问它的每一行。 FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。 它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">PROCEDURE</span> processorders<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">BEGIN</span>\n    <span class=\"token comment\" spellcheck=\"true\">--声明一个变量</span>\n    <span class=\"token keyword\">DECLARE</span> o <span class=\"token keyword\">INT</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">--声明一个游标</span>\n    <span class=\"token keyword\">DECLARE</span> ordernumbers <span class=\"token keyword\">CURSOR</span>\n    <span class=\"token keyword\">FOR</span>\n    <span class=\"token keyword\">SELECT</span> order_num <span class=\"token keyword\">FROM</span> orders<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">--打开一个游标</span>\n    <span class=\"token keyword\">OPEN</span> ordernumbers<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">--获取数据</span>\n    <span class=\"token keyword\">FETCH</span> ordernumbers <span class=\"token keyword\">INTO</span> o<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">--关闭游标</span>\n    <span class=\"token keyword\">CLOSE</span> ordernumbers<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">END</span><span class=\"token punctuation\">;</span></code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><p>MySQL语句在需要时被执行，存储过程也是如此。但是，如果你想要<strong>某条语句（或某些语句）在事件发生时自动执行</strong>，怎么办呢？例如： </p>\n<ul>\n<li>每当增加一个顾客到某个数据库表时，都检查其电话号码格式是 否正确，州的缩写是否为大写； </li>\n<li>每当订购一个产品时，都从库存数量中减去订购的数量； </li>\n<li>无论何时删除一行，都在某个存档表中保留一个副本。 </li>\n</ul>\n<p>所有这些例子的共同之处是它们都需要在某个表发生更改时自动处理。这确切地说就是触发器。触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语 句） ： </p>\n<ul>\n<li>DELETE； </li>\n<li>INSERT； </li>\n<li>UPDATE。</li>\n</ul>\n<p><em>其他MySQL语句不支持触发器。</em> </p>\n<h3 id=\"创建触发器\"><a href=\"#创建触发器\" class=\"headerlink\" title=\"创建触发器\"></a>创建触发器</h3><p>在创建触发器时，需要给出4条信息： </p>\n<ul>\n<li>唯一的触发器名； </li>\n<li>触发器关联的表； (只有表支持触发器，视图不支持)</li>\n<li>触发器应该响应的活动（DELETE、INSERT或UPDATE）； </li>\n<li>触发器何时执行（处理之前或之后）。 </li>\n</ul>\n<blockquote>\n<p>每个表将最多支持6个触发器，DELETE、INSERT或UPDATE的处理之前或之后</p>\n</blockquote>\n<blockquote>\n<p>在MySQL 5中，触发器名必 须在每个表中唯一，但不是在每个数据库中唯一。这表示同一 数据库中的两个表可具有相同名字的触发器。这在其他每个数 据库触发器名必须唯一的DBMS中是不允许的，而且以后的 MySQL版本很可能会使命名规则更为严格。因此，现在最好 是在数据库范围内使用唯一的触发器名。 </p>\n</blockquote>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TRIGGER</span> newproduct <span class=\"token keyword\">AFTER</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">ON</span> products <span class=\"token keyword\">FOR EACH ROW</span> <span class=\"token keyword\">SELECT</span> <span class=\"token string\">'product added'</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>使用INSERT语句添加一行或多行到products表中时，将对每一行显示文本product added</p>\n</blockquote>\n<h3 id=\"删除触发器\"><a href=\"#删除触发器\" class=\"headerlink\" title=\"删除触发器\"></a>删除触发器</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TRIGGER</span> newproduct<span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。</p>\n</blockquote>\n<h3 id=\"使用触发器\"><a href=\"#使用触发器\" class=\"headerlink\" title=\"使用触发器\"></a>使用触发器</h3><h4 id=\"INSERT触发器\"><a href=\"#INSERT触发器\" class=\"headerlink\" title=\"INSERT触发器\"></a>INSERT触发器</h4><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点： </p>\n<ul>\n<li>在INSERT触发器代码内，可引用一个<strong>名为NEW的虚拟表，访问被插入的行</strong>； </li>\n<li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值） ； </li>\n<li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。 <pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TRIGGER</span> newproduct <span class=\"token keyword\">AFTER</span> <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">ON</span> products <span class=\"token keyword\">FOR EACH ROW</span> <span class=\"token keyword\">SELECT</span> NEW<span class=\"token punctuation\">.</span>order_num<span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从NEW. order_num取得这个值并返回它。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"DELETE触发器\"><a href=\"#DELETE触发器\" class=\"headerlink\" title=\"DELETE触发器\"></a>DELETE触发器</h4><p>DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两 点： </p>\n<ul>\n<li>在DELETE触发器代码内，你可以引用一个名为<strong>OLD的虚拟表，访问被删除的行</strong>；</li>\n<li>OLD中的值全都是只读的，不能更新。  <pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TRIGGER</span> deleteorder BEFORE <span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">ON</span> products <span class=\"token keyword\">FOR EACH ROW</span>\n<span class=\"token keyword\">BEGIN</span>\n  <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> archive_orders<span class=\"token punctuation\">(</span>order_num<span class=\"token punctuation\">,</span>order_date<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>OLD<span class=\"token punctuation\">.</span>order_num<span class=\"token punctuation\">,</span>OLD<span class=\"token punctuation\">.</span>order_num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">END</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>在任意订单被删除前将执行此触发器。它使用一条INSERT语句 将OLD中的值（要被删除的订单）保存到一个名为archive_ orders的存档表中</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"UPDATE触发器\"><a href=\"#UPDATE触发器\" class=\"headerlink\" title=\"UPDATE触发器\"></a>UPDATE触发器</h4><p>UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：</p>\n<ul>\n<li>在UPDATE触发器代码中，你可以引用一个名为<strong>OLD</strong>的虚拟表<strong>访问以前</strong>（UPDATE语句前）的值，引用一个名为<strong>NEW的虚拟表访问新更新的值</strong>； </li>\n<li>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改 将要用于UPDATE语句中的值）； </li>\n<li>OLD中的值全都是<strong>只读的，不能更新</strong>。 <pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TRIGGER</span> updateevendor BEFORE <span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">ON</span> vendors <span class=\"token keyword\">FOR EACH ROW</span> <span class=\"token keyword\">SET</span> NEW<span class=\"token punctuation\">.</span>vend_state <span class=\"token operator\">=</span> Upper<span class=\"token punctuation\">(</span>NEW<span class=\"token punctuation\">.</span>vend<span class=\"token operator\">-</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>下面的例子保证州名缩写总是大写（不管UPDATE语句中给出的是大 写还是小写）： </p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"进一步介绍\"><a href=\"#进一步介绍\" class=\"headerlink\" title=\"进一步介绍\"></a>进一步介绍</h3><p>在结束本章之前，我们再介绍一些使用触发器时需要记住的重点。</p>\n<ul>\n<li>与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来的 MySQL版本中有一些改进和增强触发器支持的计划。 </li>\n<li>创建触发器可能需要特殊的安全访问权限，但是，<strong>触发器的执行是自动的。如果INSERT、UPDATE或DELETE语句能够执行，则相关的触发器也能执行</strong>。 </li>\n<li>应该用触发器来<strong>保证数据的一致性</strong>（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。 </li>\n<li>触发器的一种非常有意义的使用是<strong>创建审计跟踪</strong>。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个 表非常容易。 </li>\n<li>遗憾的是，MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。</li>\n</ul>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"事务处理\"><a href=\"#事务处理\" class=\"headerlink\" title=\"事务处理\"></a>事务处理</h2><p>事务处理（transaction processing）可以用来维护数据库的完整性，它 保证成批的MySQL操作<strong>要么完全执行，要么完全不执行。</strong> </p>\n<p>利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）<strong>。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</strong></p>\n<blockquote>\n<ul>\n<li>事务（transaction）指一组SQL语句； </li>\n<li>回退（rollback）指撤销指定SQL语句的过程； </li>\n<li>提交（commit）指将未存储的SQL语句结果写入数据库表； </li>\n<li>保留点（savepoint）指事务处理中设置的临时占位符（place- holder），你可以对它发布回退（与回退整个事务处理不同</li>\n</ul>\n</blockquote>\n<h3 id=\"使用ROLLBACK\"><a href=\"#使用ROLLBACK\" class=\"headerlink\" title=\"使用ROLLBACK\"></a>使用ROLLBACK</h3><p>MySQL的ROLLBACK命令用来回退（撤销）MySQL语句。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> ordertotals <span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">--开始事物</span>\n<span class=\"token keyword\">START</span> <span class=\"token keyword\">TRANSACTION</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> ordertotals<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> ordertotals<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">--撤销</span>\n<span class=\"token keyword\">ROLLBACK</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> ordertotals<span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条 SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句<strong>回退 START TRANSACTION之后的所有语句</strong>，最后一条SELECT语句显示该表不为空。 </p>\n</blockquote>\n<h3 id=\"使用COMMIT\"><a href=\"#使用COMMIT\" class=\"headerlink\" title=\"使用COMMIT\"></a>使用COMMIT</h3><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。 </p>\n<p>但是，<strong>在事务处理块中，提交不会隐含地进行</strong>。为进行明确的提交，使用COMMIT语句，如下所示： </p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--开始事物</span>\n<span class=\"token keyword\">START</span> <span class=\"token keyword\">TRANSACTION</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> ordertotals <span class=\"token keyword\">WHERE</span> order_num <span class=\"token operator\">=</span> <span class=\"token number\">20010</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> orders <span class=\"token keyword\">WHERE</span> order_num <span class=\"token operator\">=</span> <span class=\"token number\">20010</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">--提交</span>\n<span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>从系统中完全删除订单20010。因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来<strong>保证订单不被部分删除</strong>。最后的COMMIT语句<strong>仅在不出错时写出更改</strong>。如 果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的） </p>\n</blockquote>\n<blockquote>\n<p><strong>隐含事务关闭</strong>  当COMMIT或ROLLBACK语句执行后，事务会自 动关闭（将来的更改会隐含提交）。 </p>\n</blockquote>\n<h3 id=\"使用保用点\"><a href=\"#使用保用点\" class=\"headerlink\" title=\"使用保用点\"></a>使用保用点</h3><p>简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但 是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要<strong>部分提交或回退</strong>。 </p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--创建保用点</span>\n<span class=\"token keyword\">SAVEPOINT</span> delete1<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">--回退</span>\n<span class=\"token keyword\">ROLLBACK</span> <span class=\"token keyword\">TO</span> delete1</code></pre>\n<blockquote>\n<p><strong>保留点越多越好</strong> .可以在MySQL代码中设置任意多的保留 点，越多越好。为什么呢？因为保留点越多，你就越能按自己的意愿<strong>灵活</strong>地进行回退。</p>\n</blockquote>\n<blockquote>\n<p>保留点在事务处理完成（执行一条<strong>ROLLBACK或 COMMIT）后</strong>自动释放**。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。 </p>\n</blockquote>\n<h3 id=\"更改默认提交方式\"><a href=\"#更改默认提交方式\" class=\"headerlink\" title=\"更改默认提交方式\"></a>更改默认提交方式</h3><p>正如所述，默认的MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句： </p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SET</span> autocommit<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"全球化和本地化\"><a href=\"#全球化和本地化\" class=\"headerlink\" title=\"全球化和本地化\"></a>全球化和本地化</h2><p><strong>不同的语言和字符集需要以不同的方式存储和检索</strong>。</p>\n<p>因此，MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法。</p>\n<ul>\n<li><strong>字符集</strong>：字母和符号的集合； </li>\n<li><strong>编码</strong>：某个字符集成员的内部表示； </li>\n<li><strong>校对</strong>：规定字符如何比较的指令。 <blockquote>\n<p>校对为什么重要  排序英文正文很容易，对吗？或许不。考 虑词APE、apex和Apple。它们处于正确的排序顺序吗？这有 赖于你是否想区分大小写。使用区分大小写的校对顺序，这 些词有一种排序方式，使用不区分大小写的校对顺序有另外 一种排序方式。这不仅影响排序（如用ORDER BY排序数据） ， 还影响搜索（例如，寻找apple的WHERE子句是否能找到 APPLE）。在使用诸如法文à或德文ö这样的字符时，情况更复 杂，在使用不基于拉丁文的字符集（日文、希伯来文、俄文 等）时，情况更为复杂</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"使用字符集和校对顺序\"><a href=\"#使用字符集和校对顺序\" class=\"headerlink\" title=\"使用字符集和校对顺序\"></a>使用字符集和校对顺序</h3><p>为查看所支持的字符集完整列表</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">CHARACTER SET</span><span class=\"token punctuation\">;</span></code></pre>\n<p>为了查看所支持校对的完整列</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> COLLATION<span class=\"token punctuation\">;</span></code></pre>\n<p>通常系统管理在安装时定义一个默认的字符集和校对。此外，也可 以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对可以使用以下语句： </p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'character%'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SHOW</span> VARIABLES <span class=\"token operator\">LIKE</span> <span class=\"token string\">'collation%'</span><span class=\"token punctuation\">;</span></code></pre>\n<p>为了给表指定字符集和校对，可使用带子句的CREATE TABLE       </p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> mytable\n<span class=\"token punctuation\">(</span>\n    column1 <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n    column2 <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARACTER SET</span> brew     <span class=\"token comment\" spellcheck=\"true\">--字符集</span>\n  <span class=\"token keyword\">COLLATE</span> hebrew_general_ci<span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">--校对顺序</span></code></pre>\n<p>对某个列设置单独的字符集和校对</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> mytable\n<span class=\"token punctuation\">(</span>\n    column1 <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n    column2 <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    column3 <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">CHARACTER SET</span> latin1 <span class=\"token keyword\">COLLATE</span> latin1_general_ci\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARACTER SET</span> brew     <span class=\"token comment\" spellcheck=\"true\">--字符集</span>\n  <span class=\"token keyword\">COLLATE</span> hebrew_general_ci<span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">--校对顺序</span></code></pre>\n<p>如前所述，校对在对用ORDER BY子句检索出来的数据排序时起重要 的作用。如果你<strong>需要用与创建表时不同的校对顺序排序特定的SELECT语句</strong>，可以在SELECT语句自身中进行：</p>\n<pre class=\" language-sql\"><code class=\"language-sql\">    <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span>  customer <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> lastname <span class=\"token keyword\">COLLATE</span> latin1_general_ci<span class=\"token punctuation\">;</span></code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"安全管理\"><a href=\"#安全管理\" class=\"headerlink\" title=\"安全管理\"></a>安全管理</h2><p>MySQL服务器的安全基础是：<strong>用户应该对他们需要的数据具有适当的访问权，既不能多也不能少</strong>。换句话说，用户不能对过多的数据具有过多的访问权。 </p>\n<blockquote>\n<p>应该严肃对待root登录的使用。仅在绝对需 要时使用它（或许在你不能登录其他管理账号时使用）。不应 该在日常的MySQL操作中使用root。 </p>\n</blockquote>\n<h3 id=\"管理用户\"><a href=\"#管理用户\" class=\"headerlink\" title=\"管理用户\"></a>管理用户</h3><p>MySQL用户账号和信息存储在名为mysql的MySQL数据库中。一般不需要直接访问mysql数据库和表（你稍后会明白这一点），但有时需要直接访问。需要直接访问它的时机之一是在需要获得所有用户账号列表时。</p>\n<p>mysql数据库有一个名为user的表，它包含所有用户账号。user 表有一个名为user的列，它存储用户登录名。</p>\n<h4 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h4><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--创建账户名为cc1,密码为123的账户</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">USER</span> <span class=\"token number\">cc1</span> IDENTIFIED <span class=\"token keyword\">BY</span> <span class=\"token string\">'123'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">--重命名</span>\n<span class=\"token keyword\">RENAME</span> <span class=\"token keyword\">USER</span> <span class=\"token number\">cc1</span> <span class=\"token keyword\">TO</span> <span class=\"token number\">cc2</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p><strong>使用GRANT或INSERT</strong> GRANT语句也可以创建用 户账号，但一般来说CREATE USER是最清楚和最简单的句子。 此外，也可以通过直接插入行到user表来增加用户，不过为安全起见，一般不建议这样做。MySQL用来存储用户账号信息 的表（以及表模式等）极为重要，对它们的任何毁坏都 可能严重地伤害到MySQL服务器。因此，相对于直接处理来 说，最好是用标记和函数来处理这些表。 </p>\n</blockquote>\n<h4 id=\"更改口令\"><a href=\"#更改口令\" class=\"headerlink\" title=\"更改口令\"></a>更改口令</h4><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SET</span> PASSWORD <span class=\"token keyword\">FOR</span>  <span class=\"token number\">cc2</span> <span class=\"token operator\">=</span> Password<span class=\"token punctuation\">(</span><span class=\"token string\">'456'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">--设置当前账户口令</span>\n<span class=\"token keyword\">SET</span> PASSWORD <span class=\"token operator\">=</span> Password<span class=\"token punctuation\">(</span><span class=\"token string\">'456'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"删除用户\"><a href=\"#删除用户\" class=\"headerlink\" title=\"删除用户\"></a>删除用户</h4><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">USER</span> <span class=\"token number\">cc2</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"设置访问权限\"><a href=\"#设置访问权限\" class=\"headerlink\" title=\"设置访问权限\"></a>设置访问权限</h3><p>在创建用户账号后，必须接着分配访问权限。<strong>新创建的用户账号没有访问权限</strong>。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--看到赋予用户账号的权限</span>\n<span class=\"token keyword\">SHOW</span> GRANTS <span class=\"token keyword\">FOR</span> <span class=\"token number\">cc2</span><span class=\"token punctuation\">;</span></code></pre>\n<p>为<strong>设置权限</strong>，使用GRANT语句。GRANT要求你至少给出以下信息： </p>\n<ul>\n<li>要授予的权限</li>\n<li>被授予访问权限的数据库或表；</li>\n<li>用户名</li>\n</ul>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。</span>\n<span class=\"token keyword\">GRANT</span> <span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">ON</span> crashcourse<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">TO</span> <span class=\"token number\">cc3</span><span class=\"token punctuation\">;</span></code></pre>\n<blockquote>\n<p>通过只授予SELECT访问权限，用户bforta对crashcourse数据库中的所有数据具有只读访问权限。 </p>\n</blockquote>\n<p>GRANT的反操作为REVOKE，用它来<strong>撤销特定的权限</strong>。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--取消刚赋予用户cc3的SELECT访问权限</span>\n<span class=\"token keyword\">REVOKE</span> <span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">ON</span> crashcourse<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token number\">cc3</span><span class=\"token punctuation\">;</span></code></pre>\n<p>GRANT和REVOKE可在几个层次上控制访问权限： </p>\n<ul>\n<li>整个服务器，使用GRANT ALL和REVOKE ALL； </li>\n<li>整个数据库，使用ON database.*； </li>\n<li>特定的表，使用ON database.table； </li>\n<li>特定的列； </li>\n<li>特定的存储过程。</li>\n</ul>\n<p>下标列出可以授予或撤销的每个权限。 </p>\n<table>\n<thead>\n<tr>\n<th>权限</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ALL</td>\n<td>除GRANT OPTION外的所有权限</td>\n</tr>\n<tr>\n<td>ALTER</td>\n<td>使用ALTER TABLE</td>\n</tr>\n<tr>\n<td>ALTER ROUTINE</td>\n<td>使用ALTER PROCEDURE和DROP PROCEDURE</td>\n</tr>\n<tr>\n<td>CREATE</td>\n<td>使用CREATE TABLE</td>\n</tr>\n<tr>\n<td>CREATE ROUTINE</td>\n<td>使用CREATE PROCEDURE</td>\n</tr>\n<tr>\n<td>CREATE TEMPORARY TABLES</td>\n<td>使用CREATE TEMPORARY TABLE</td>\n</tr>\n<tr>\n<td>CREATE USER</td>\n<td>使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES</td>\n</tr>\n<tr>\n<td>CREATE VIEW</td>\n<td>使用CREATE VIEW</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>使用DELETE</td>\n</tr>\n<tr>\n<td>DROP</td>\n<td>使用DROP TABLE</td>\n</tr>\n<tr>\n<td>EXECUTE</td>\n<td>使用CALL和存储过程</td>\n</tr>\n<tr>\n<td>FILE</td>\n<td>使用SELECT INTO OUTFILE和LOAD DATA INFILE</td>\n</tr>\n<tr>\n<td>GRANT OPTION</td>\n<td>使用GRANT和REVOKE</td>\n</tr>\n<tr>\n<td>INDEX</td>\n<td>使用CREATE INDEX和DROP INDEX</td>\n</tr>\n<tr>\n<td>INSERT</td>\n<td>使用INSERT</td>\n</tr>\n<tr>\n<td>LOCK TABLES</td>\n<td>使用LOCK TABLES</td>\n</tr>\n<tr>\n<td>PROCESS</td>\n<td>使用SHOW FULL PROCESSLIST</td>\n</tr>\n<tr>\n<td>RELOAD</td>\n<td>使用FLUSH</td>\n</tr>\n<tr>\n<td>REPLICATION CLIENT</td>\n<td>服务器位置的访问</td>\n</tr>\n<tr>\n<td>REPLICATION SLAVE</td>\n<td>由复制从属使用</td>\n</tr>\n<tr>\n<td>SELECT</td>\n<td>使用SELECT</td>\n</tr>\n<tr>\n<td>SHOW DATABASES</td>\n<td>使用SHOW DATABASES</td>\n</tr>\n<tr>\n<td>SHOW VIEW</td>\n<td>使用SHOW CREATE VIEW</td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>使用mysqladmin shutdown（用来关闭MySQL）</td>\n</tr>\n<tr>\n<td>SUPER</td>\n<td>使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER 和SET GLOBAL。还允许mysqladmin调试登录</td>\n</tr>\n<tr>\n<td>UPDATE</td>\n<td>使用UPDATE</td>\n</tr>\n<tr>\n<td>USAGE</td>\n<td>无访问权限</td>\n</tr>\n</tbody></table>\n<p>，当某个数据库或表被删除时（用DROP语 句），相关的访问权限仍然存在。而且，如果将来重新创建该 数据库或表，这些权限仍然起作用。 </p>\n<blockquote>\n<p>未来的授权  在使用GRANT和REVOKE时，用户账号必须存在， 但对所涉及的对象没有这个要求。这允许管理员在创建数据库 和表之前设计和实现安全措施。 这样做的副作用是，当某个数据库或表被删除时（用DROP语 句），相关的访问权限仍然存在。而且，如果将来重新创建该 数据库或表，这些权限仍然起作用。 </p>\n</blockquote>\n<blockquote>\n<p>简化多次授权  可通过列出各权限并用逗号分隔，将多条 GRANT语句串在一起，如下所示： <code>GRANT SELECT,INSERT ON crashcourse.* TO cc2;</code></p>\n</blockquote>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"数据库维护\"><a href=\"#数据库维护\" class=\"headerlink\" title=\"数据库维护\"></a>数据库维护</h2><h3 id=\"数据库备份\"><a href=\"#数据库备份\" class=\"headerlink\" title=\"数据库备份\"></a>数据库备份</h3><p>像所有数据一样，MySQL的数据也必须经常备份。由于MySQL数据 库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。 但是，<strong>由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效</strong>。<br>下面列出这个问题的可能解决方案。 </p>\n<ul>\n<li>使用<strong>命令行实用程序mysqldump</strong>转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正 确地备份转储文件。</li>\n<li>可用<strong>命令行实用程序mysqlhotcopy</strong>从一个数据库复制所有数据 （并非所有数据库引擎都支持这个实用程序）。 </li>\n<li>可以使用<strong>MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储</strong>所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原。 </li>\n</ul>\n<blockquote>\n<p>首先刷新未写数据 为<strong>了保证所有数据被写到磁盘（包括索引数据）</strong>，可能需要在进行备份前使用<strong>FLUSH TABLES</strong>语句。 </p>\n</blockquote>\n<h3 id=\"数据库维护-1\"><a href=\"#数据库维护-1\" class=\"headerlink\" title=\"数据库维护\"></a>数据库维护</h3><p><strong>ANALYZE TABLE</strong>，用来检查<strong>表键</strong>是否正确</p>\n<p>如果从一个表中删除大量数据，应该使用<strong>OPTIMIZE TABLE</strong>来收回所用的空间，从而优化表的性能。 </p>\n<h3 id=\"诊断启动问题\"><a href=\"#诊断启动问题\" class=\"headerlink\" title=\"诊断启动问题\"></a>诊断启动问题</h3><p>命令行mysqld手动启动</p>\n<h3 id=\"查看错误日志\"><a href=\"#查看错误日志\" class=\"headerlink\" title=\"查看错误日志\"></a>查看错误日志</h3><p>MySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下几种。 </p>\n<ul>\n<li><strong>错误日志</strong>。它包含启动和关闭问题以及任意关键错误的细节。此 日志通常名为hostname.err，位于data目录中。此日志名可用 –log-error命令行选项更改。 </li>\n<li><strong>查询日志</strong>。它记录所有MySQL活动，在诊断问题时非常有用。此 日志文件可能会很快地变得非常大，因此不应该长期使用它。此 日志通常名为hostname.log，位于data目录中。此名字可以用 –log命令行选项更改。 </li>\n<li><strong>二进制日志</strong>。它记录更新过数据（或者可能更新过数据）的所有 语句。此日志通常名为hostname-bin，位于data目录内。此名字 可以用–log-bin命令行选项更改。注意，这个日志文件是MySQL 5中添加的，以前的MySQL版本中使用的是更新日志。 </li>\n<li><strong>缓慢查询日志</strong>。顾名思义，此日志记录执行缓慢的任何查询。这 个日志在确定数据库何处需要优化很有用。此日志通常名为 hostname-slow.log ，位于data 目录中。此名字可以用 –log-slow-queries命令行选项更改。 在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文 件。 </li>\n</ul>\n<p>在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。 </p>\n<h2 id=\"改善性能\"><a href=\"#改善性能\" class=\"headerlink\" title=\"改善性能\"></a>改善性能</h2><ul>\n<li>首先，MySQL（与所有DBMS一样）具有<strong>特定的硬件建议</strong>。在学 习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但 对用于生产的服务器来说，应该坚持遵循这些硬件建议。</li>\n<li>一般来说，关键的生产DBMS应该运行在自己的<strong>专用服务器</strong>上。 </li>\n<li>MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你<strong>可能需要调整内存分配、缓冲区大小等。</strong>（为查看当前设置，可使用SHOW VARIABLES;和SHOW STATUS;。） </li>\n<li>MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。<strong>如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢</strong>。如果你遇到显著的性能不良，可使用SHOW PROCESSLIST 显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录） 。 </li>\n<li>总是有<strong>不止一种方法编写同一条SELECT语句</strong>。应该试验联结、并、 子查询等，找出最佳的方法。 </li>\n<li>使用<strong>EXPLAIN语句</strong>让MySQL<strong>解释它将如何执行一条SELECT语句</strong>。 </li>\n<li>一般来说，<strong>存储过程执行得比一条一条地执行其中的各条MySQL语句快</strong>。 </li>\n<li>应该总是使用正确的数据类型。 </li>\n<li>决<strong>不要检索比需求还要多的数据</strong>。换言之，不要用SELECT *（除 非你真正需要每个列）。 </li>\n<li>有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li>\n<li><strong>在导入数据时，应该关闭自动提交</strong>。你<strong>可能还想删除索引</strong>（包括 FULLTEXT索引），然后在导入完成后再重建它们。 </li>\n<li><strong>必须索引数据库表以改善数据检索的性能</strong>。确定索引什么不是一件微不足道的任务，需要分析使用的SELECT语句以找出重复的 WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。 </li>\n<li>你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的<strong>UNION语句</strong>，你能看到极大的性能改 进。 </li>\n<li><strong>索引改善数据检索的性能，但损害数据插入、删除和更新的性能</strong>。 如果你有一些表，它们收集数据且不经常被搜索，则在有必要之 前不要索引它们。（索引可根据需要添加和删除。） </li>\n<li>LIKE很慢。一般来说，<strong>最好是使用FULLTEXT而不是LIKE</strong>。 </li>\n<li>数据库是不断变化的实体。一组优化良好的表一会儿后可能就面 目全非了。由于表的使用和内容的更改，理想的优化和配置也会 改变。 </li>\n<li>最重要的规则就是，每条规则在某些条件下都会被打破。 </li>\n</ul>\n<p><br><br> </p>\n<p><br><br></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><div style=\"margin-left: 5px  font-size:16px;\">\n[1]Ben Forta, Mysql必知必会. 北京：人民邮电出版社，2019.\n</div>\n","site":{"data":{}},"excerpt":"<div style=\"width: 95%\">\n\n<p><img src=\"https://img2020.cnblogs.com/blog/2104937/202007/2104937-20200723232459669-218625272.png\" alt=\"《MySql必知必会》学习笔记\"></p>\n</div>\n\n\n<p>MySQL已经成为世界上最受欢迎的数据库管理系统之一。无论是用 在小型开发项目上，还是用来构建那些声名显赫的网站，MySQL都证明 了自己是个稳定、可靠、快速、可信的系统，足以胜任任何数据存储业 务的需要。</p>","more":"<h2 id=\"MySql的使用\"><a href=\"#MySql的使用\" class=\"headerlink\" title=\"MySql的使用\"></a>MySql的使用</h2><pre><code class=\"sql\">--选择数据库\nuse database; \n\n--返回可用数据库列表\nshow database; \n\n--返回一个数据库内表的列表\nshow tables; \n\n--对一个表的每个字段返回一行，行中包括字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息等\nshow columns from table;    \n--功能同上\ndescribe table;\n\n--用于显示广泛的服务器状态信息； \nshow status;    \n\n--显示创建创建数据库和表的MySql信息\nshow create database DBName; \nshow create table TName; \n\n--用于显示服务器错误或警告信息\nshow errors; \nshow warnings; </code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"检索数据\"><a href=\"#检索数据\" class=\"headerlink\" title=\"检索数据\"></a>检索数据</h2><pre><code class=\"sql\">--查询多个字段\nselect nickname,email from user;  \n\n--查询不同的姓名\nselect distinct nickname from user; \n\n--返回前几行\nselect nickname,email from user limit 1; \n\n--返回从第0行开始的2行\nselect nickname,email from user limit 0,2;  \n\n--功能同上\nselect nickname,email from user limit 0 offset 2;  </code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"排序和过滤检索数据\"><a href=\"#排序和过滤检索数据\" class=\"headerlink\" title=\"排序和过滤检索数据\"></a>排序和过滤检索数据</h2><pre><code class=\"sql\">--按照年龄从大到小排序，如果年龄相同则按照昵称从小到大排序\nselect nickname,email from user order by age desc , nickname;   \n\n--返回年龄不等于20的用户姓名 `&lt;&gt;`用法等同于`!=`\nselect nickename from user where age &lt;&gt; 20; \n\n--返回邮箱信息为空的用户名\nselect nickename from user where email is NULL; \n\n--返回邮箱信息为空的用户名\nselect nickename from user where email is NULL; \n\n--默认执行顺序为 `( age=10 ) or ( age=20 and eamil is NULL )`，`and`优先级更高\nselect * from user where age=10 or age=20 and eamil is NULL; //\n\n--对`IN`后圆括中的每一个元素进行匹配，等同于`OR`\nselect * from user where age in(10,20); \n\n--对其中条件进行否定\nselect * from user where age not in(10,20); \n\n--表示昵称包含字符e的所有用户，%表示通配符 表示任何字符出现的次数，0次、1次或多次。\nselect * from user where nickname like &#39;%e%&#39;;   \n\n--表示昵称第二个字符为e的所有用户，`_`表示匹配单个字符。 \nselect * from user where nickname like &#39;_e%&#39;;   \n</code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><pre><code class=\"sql\">--正则表达式，匹配年龄为10、20、30... 的用户，`.`表示匹配任意一个字符\nselect * from user where age REGEXP &#39;.0&#39;;   \n\n-- `BINARY`用于正则表达式中区分大小写\nselect * from user where age BINARY REGEXP &#39;JetPack.000&#39;;   \n\n--正则表达式进行OR匹配\nselect * from user where age BINARY REGEXP &#39;1000|1000&#39;;   \n\n--返回的是`1 Ton` `2 Ton` ,`[123]`为`[1|2|3]`的缩写，表示匹配1或2或3\nselect nickname from user where nickname BINARY REGEXP &#39;[123] Ton&#39;;   \n\n--返回的是匹配指定字符串以外的值\nselect nickname from user where nickname BINARY REGEXP &#39;[^123] Ton&#39;;   \n\n--nikename中包含`a Ton` `b Ton` `c Ton`，age中包含1,2,3\nselect nickname from user where nickname BINARY REGEXP &#39;[a-c] Ton&#39; and age REGEXP &#39;[1-3]&#39;;  </code></pre>\n<h3 id=\"匹配字符类\"><a href=\"#匹配字符类\" class=\"headerlink\" title=\"匹配字符类\"></a>匹配字符类</h3><table>\n<thead>\n<tr>\n<th>类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[:alnum:]</td>\n<td>任意字符和数字（同[a-zA-Z0-9]）</td>\n</tr>\n<tr>\n<td>[:alpha:]</td>\n<td>任意字符（同[a-zA-Z]）</td>\n</tr>\n<tr>\n<td>[:blank:]</td>\n<td>空格和制表（同[\\t]）</td>\n</tr>\n<tr>\n<td>[:cntrl:]</td>\n<td>ASCII控制字符（ASCII 0到31和127）</td>\n</tr>\n<tr>\n<td>[:digit:]</td>\n<td>任意数字（同[0-9]）</td>\n</tr>\n<tr>\n<td>[:graph:]</td>\n<td>与[:print:]相同，但不包括空格</td>\n</tr>\n<tr>\n<td>[:lower:]</td>\n<td>任意小写字母（同[a-z]）</td>\n</tr>\n<tr>\n<td>[:print:]</td>\n<td>任意可打印字符</td>\n</tr>\n<tr>\n<td>[:punct:]</td>\n<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>\n</tr>\n<tr>\n<td>[:space:]</td>\n<td>包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]）</td>\n</tr>\n<tr>\n<td>[:upper:]</td>\n<td>任意大写字母（同[A-Z]）</td>\n</tr>\n<tr>\n<td>[:xdigit:]</td>\n<td>任意十六进制数字（同[a-fA-F0-9]）</td>\n</tr>\n</tbody></table>\n<br>\n\n<h3 id=\"匹配多个实例\"><a href=\"#匹配多个实例\" class=\"headerlink\" title=\"匹配多个实例\"></a>匹配多个实例</h3><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>0个或多个匹配</td>\n</tr>\n<tr>\n<td>+</td>\n<td>1个或多个匹配（等于{1,}）</td>\n</tr>\n<tr>\n<td>?</td>\n<td>0个或1个匹配（等于{0,1}）</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>指定数目的匹配</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>不少于指定数目的匹配</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>匹配数目的范围（m不超过255）</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>‘\\\\([0-9]stick?\\\\)’</strong><br>A (1 stick)<br>B (1 sticks)<br><code>\\\\</code>为转移符 ，第一个\\是MySql自己解释一个，第二\\是正则表达式解释一个</p>\n</blockquote>\n<br>\n\n<h3 id=\"定位符\"><a href=\"#定位符\" class=\"headerlink\" title=\"定位符\"></a>定位符</h3><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>^</td>\n<td>文本的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td>文本的结尾</td>\n</tr>\n<tr>\n<td>[[:&lt;:]]</td>\n<td>词的开始</td>\n</tr>\n<tr>\n<td>[[:&gt;:]]</td>\n<td>词的结尾</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>‘^[0-9\\.]’<br><code>^</code>匹配串的开始，即以数字开头或者<code>.</code>开头的字符串</p>\n</blockquote>\n<h2 id=\"计算字段\"><a href=\"#计算字段\" class=\"headerlink\" title=\"计算字段\"></a>计算字段</h2><h3 id=\"拼接\"><a href=\"#拼接\" class=\"headerlink\" title=\"拼接\"></a>拼接</h3><pre><code class=\"sql\">-- 按照 `云卷云舒（20）`这样的昵称+年龄格式表示，`RTrim`去掉值右边的所有空格，\nselect Concat(RTrim(nick_name),&#39;(&#39;,RTrim(age),&#39;)&#39;) from user_info;</code></pre>\n<br>\n\n<h3 id=\"使用别名\"><a href=\"#使用别名\" class=\"headerlink\" title=\"使用别名\"></a>使用别名</h3><pre><code class=\"sql\">-- as info\nselect Concat(RTrim(nick_name),&#39;(&#39;,RTrim(age),&#39;)&#39;) as info from user_info;</code></pre>\n<br>\n\n<h3 id=\"算术运算\"><a href=\"#算术运算\" class=\"headerlink\" title=\"算术运算\"></a>算术运算</h3><pre><code class=\"sql\">select order_id,quantity,item_price,quantity*item_price as cost from order_items;</code></pre>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>加法</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减法</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法</td>\n</tr>\n</tbody></table>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"数据处理函数\"><a href=\"#数据处理函数\" class=\"headerlink\" title=\"数据处理函数\"></a>数据处理函数</h2><h3 id=\"文本处理函数\"><a href=\"#文本处理函数\" class=\"headerlink\" title=\"文本处理函数\"></a>文本处理函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Left()</td>\n<td>返回串左边的字符</td>\n</tr>\n<tr>\n<td>Length()</td>\n<td>返回串的长度</td>\n</tr>\n<tr>\n<td>Locate()</td>\n<td>找出串的一个子串</td>\n</tr>\n<tr>\n<td>Lower()</td>\n<td>将串转换为小写</td>\n</tr>\n<tr>\n<td>LTrim()</td>\n<td>去掉串左边的空格</td>\n</tr>\n<tr>\n<td>Right()</td>\n<td>返回串右边的字符</td>\n</tr>\n<tr>\n<td>RTrim()</td>\n<td>去掉串右边的空格</td>\n</tr>\n<tr>\n<td>Soundex()</td>\n<td>返回串的SOUNDEX值</td>\n</tr>\n<tr>\n<td>SubString()</td>\n<td>返回子串的字符</td>\n</tr>\n<tr>\n<td>Upper()</td>\n<td>将串转换为大写</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>SOUNDEX:将任何文本串转换为其语音表示的字母数字模式的算法。使得能<strong>对串进行发音比较而不是字母比较</strong></p>\n</blockquote>\n<pre><code class=\"sql\">-- nikename发音类似cc的所有nickname\nselect nickname from user_info where Soundex(nickname)=Soundex(&#39;cc&#39;);</code></pre>\n<br>\n\n<h3 id=\"时间处理函数\"><a href=\"#时间处理函数\" class=\"headerlink\" title=\"时间处理函数\"></a>时间处理函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AddDate()</td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td>AddTime()</td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td>CurDate()</td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td>CurTime()</td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td>Date()</td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td>DateDiff()</td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td>Date_Add()</td>\n<td>高度灵活的日期运算函数</td>\n</tr>\n<tr>\n<td>Date_Format()</td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td>Day()</td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td>DayOfWeek()</td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td>Hour()</td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td>Minute()</td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td>Month()</td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td>Now()</td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td>Second()</td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td>Time()</td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td>Year()</td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>日期格式最好为yyyy-mm-dd,可以排除多义性，这样MySql就不必做出任何假设，更加可靠</p>\n</blockquote>\n<blockquote>\n<p><code>select * from user where birthday=&#39;2000-01-01&#39;</code> 会和 birthday为’2000-01-01 01:01:01’的匹配失败<br>更好的解决方案是利用<code>Date()</code>函数直接匹配日期部分 <code>select * from user where Date(birthday)=&#39;2000-01-01&#39;</code></p>\n</blockquote>\n<h3 id=\"数值处理函数\"><a href=\"#数值处理函数\" class=\"headerlink\" title=\"数值处理函数\"></a>数值处理函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Abs()</td>\n<td>返回一个数的绝对值</td>\n</tr>\n<tr>\n<td>Cos()</td>\n<td>返回一个角度的余弦</td>\n</tr>\n<tr>\n<td>Exp()</td>\n<td>返回一个数的指数值</td>\n</tr>\n<tr>\n<td>Mod()</td>\n<td>返回除操作的余数</td>\n</tr>\n<tr>\n<td>Pi()</td>\n<td>返回圆周率</td>\n</tr>\n<tr>\n<td>Rand()</td>\n<td>返回一个随机数</td>\n</tr>\n<tr>\n<td>Sin()</td>\n<td>返回一个角度的正弦</td>\n</tr>\n<tr>\n<td>Sqrt()</td>\n<td>返回一个数的平方根</td>\n</tr>\n<tr>\n<td>Tan()</td>\n<td>返回一个角度的正切</td>\n</tr>\n</tbody></table>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"汇总数据\"><a href=\"#汇总数据\" class=\"headerlink\" title=\"汇总数据\"></a>汇总数据</h2><h3 id=\"聚集函数\"><a href=\"#聚集函数\" class=\"headerlink\" title=\"聚集函数\"></a>聚集函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AVG()</td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td>COUNT()</td>\n<td>返回某列的行数</td>\n</tr>\n<tr>\n<td>MAX()</td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td>MIN()</td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td>SUM()</td>\n<td>返回某列值之和</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>以上函数均忽略列值为NULL的行</p>\n</blockquote>\n<pre><code class=\"sql\">select AVG(age)    from user_info;\nselect COUNT(age)  from user_info;\nselect MAX(age)    from user_info;\nselect MIN(age)    from user_info;\nselect SUM(age)    from user_info;</code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"分组函数\"><a href=\"#分组函数\" class=\"headerlink\" title=\"分组函数\"></a>分组函数</h2><h3 id=\"创建分组\"><a href=\"#创建分组\" class=\"headerlink\" title=\"创建分组\"></a>创建分组</h3><ol>\n<li>先按照特定顺序分组</li>\n<li>再对<strong>每一组</strong>进行计算</li>\n</ol>\n<pre><code class=\"sql\">-- 先按照昵称分组，然后对每一组进行求和运算\nselect nick_name,SUM(age) from user_info group by nick_name;</code></pre>\n<blockquote>\n<p>select后的每一列都<strong>必须在GROUP BY字句中给出</strong></p>\n</blockquote>\n<blockquote>\n<p>如果在select中使用表达式，则必须在group by子句中指定相同的表达式</p>\n</blockquote>\n<h3 id=\"过滤分组\"><a href=\"#过滤分组\" class=\"headerlink\" title=\"过滤分组\"></a>过滤分组</h3><p>HAVING:</p>\n<ul>\n<li>基础功能和WHERE一样，在简单句式中可以替代WHERE</li>\n<li>区别：<ul>\n<li>WHERE过滤行，HAVING过滤分组</li>\n<li>WHERE在数据<strong>分组前</strong>过滤数据，HAVING在数据<strong>分组后</strong>对组进行分组。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"sql\">-- 先对过滤掉age&lt;=10的数据，再筛选出分组总年龄大于100的小组\nselect nick_name,SUM(age) from user_info where age&gt;10 group by nick_name having SUM(age)&gt;100;</code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><h3 id=\"利用子查询过滤\"><a href=\"#利用子查询过滤\" class=\"headerlink\" title=\"利用子查询过滤\"></a>利用子查询过滤</h3><blockquote>\n<p>现在有订单表orderitems，客户信息表customers，订单物品表orderitems<br>查询出订购物品cc2的所有客户姓名</p>\n</blockquote>\n<ul>\n<li>检索包含物品cc2的所有订单的编号。<pre><code class=\"sql\">select order_num from orderitems where prod_id=&#39;cc2&#39;;</code></pre>\n</li>\n<li>检索具有前一步骤列出的订单编号的所有客户的ID。<pre><code class=\"sql\">select cust_id from orders where order_num IN (2005,2006);</code></pre>\n</li>\n<li>检索前一步骤返回的所有客户ID的客户信息。 <strong>从内向外执行</strong><pre><code class=\"sql\">select cust_id from orders where order_num IN (select order_num from orderitems where prod_id=&#39;cc2&#39;);</code></pre>\n</li>\n<li>从客户ID中查询出信息<pre><code class=\"sql\">select \n  cust_name \nfrom \n  customers \nwhere \n  cust_id IN (select \n                  cust_id \n              from \n                  orders \n              where \n                  order_num IN (select \n                                  order_num \n                              from \n                                  orderitems \n                              where \n                                  prod_id=&#39;cc2&#39;));</code></pre>\n</li>\n</ul>\n<h3 id=\"作为计算手段使用子查询\"><a href=\"#作为计算手段使用子查询\" class=\"headerlink\" title=\"作为计算手段使用子查询\"></a>作为计算手段使用子查询</h3><blockquote>\n<p>现有订单表orderitems，客户信息表customers<br>查询每个用户的订单总数</p>\n</blockquote>\n<ul>\n<li>查询某个用户的所有订单数<pre><code class=\"sql\">select count(*) as orders from orders where cust_id=1001;</code></pre>\n</li>\n<li>查询在订单表中每个用户的订单总数及其信息<pre><code class=\"sql\">select cust_name,\n     (select count(*)\n      from orders \n      where oders.cust_id=customers.cust_id) as orders \nfrom customer \norder by cust_name;</code></pre>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"联结表\"><a href=\"#联结表\" class=\"headerlink\" title=\"联结表\"></a>联结表</h2><h3 id=\"使用where\"><a href=\"#使用where\" class=\"headerlink\" title=\"使用where\"></a>使用where</h3><pre><code class=\"sql\">select vend_name,prod_name,prod_price from vendors,products where vendors.vend_id=prodcts.vend_id order by vend_name,prod_name;</code></pre>\n<h3 id=\"内部联结\"><a href=\"#内部联结\" class=\"headerlink\" title=\"内部联结\"></a>内部联结</h3><p>使用 INNER JOIN 指定表，再使用 ON 执行特定条件的连接</p>\n<ul>\n<li>检索所有客户及其订单<pre><code class=\"sql\">SELECT customer.cust_id,orders.order_num FROM customer INNER JOIN orders ON customers.cust_id = orders.cust_id;</code></pre>\n</li>\n</ul>\n<h3 id=\"多表联结\"><a href=\"#多表联结\" class=\"headerlink\" title=\"多表联结\"></a>多表联结</h3><pre><code class=\"sql\">select cust_name \nfrom customer,orders,orderitems \nwhere customer.cust_id=oders.cust_id \nand orderitems.order_num=orders.order_num\nand prod_id=&#39;cc2&#39;;</code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"高级联结\"><a href=\"#高级联结\" class=\"headerlink\" title=\"高级联结\"></a>高级联结</h2><h3 id=\"使用表别名\"><a href=\"#使用表别名\" class=\"headerlink\" title=\"使用表别名\"></a>使用表别名</h3><pre><code class=\"sql\">select cust_name \nfrom customer as c,orders as o,orderitems as oi \nwhere c.cust_id=o.cust_id \nand oi.order_num=o.order_num\nand prod_id=&#39;cc2&#39;;</code></pre>\n<h3 id=\"自联结\"><a href=\"#自联结\" class=\"headerlink\" title=\"自联结\"></a>自联结</h3><blockquote>\n<p>在商品表中发一下一个不合格商品(id为cc3)，现在需要查找出生产这个商品的厂家的其他产品</p>\n</blockquote>\n<ul>\n<li><p>使用子查询</p>\n<pre><code class=\"sql\">SELECT prod_id,prod_name FROM products where vend_id = (SELECT vend_id FROM products WHERE prod_id = &#39;cc2&#39;);</code></pre>\n</li>\n<li><p>使用自联结</p>\n<pre><code class=\"sql\">SELECT p1.prod_id,p1.prod_name FROM products AS p1, products AS p2 WHERE p1.vend_id=p2.vend_id AND p2.prod_id = &#39;cc3&#39;;</code></pre>\n<blockquote>\n<p>p1,p2实际上是相同的一张表</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"自然联结\"><a href=\"#自然联结\" class=\"headerlink\" title=\"自然联结\"></a>自然联结</h3><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中，标准的联结(内部联结)返回所有的数据，<strong>甚至所有的列多次出现</strong>。</p>\n<p><strong>自然联结排除多次出现，使每个列只返回一次。</strong></p>\n<h3 id=\"外部联结\"><a href=\"#外部联结\" class=\"headerlink\" title=\"外部联结\"></a>外部联结</h3><p>许多联结将一个表中的行与另外一个表中的行相关联。但有时候需要<strong>包含没有关联行的那些行</strong>。</p>\n<ul>\n<li>列出所有产品以及订购数据，<strong>包括哪些没有人订购的产品</strong></li>\n<li>对每个客户下了多少订单进行计数，<strong>包括哪些至今尚未下订单的客户</strong></li>\n<li>检索所有客户及其订单(内部联结)</li>\n</ul>\n<pre><code class=\"sql\">SELECT customer.cust_id,orders.order_num FROM customer INNER JOIN orders ON customers.cust_id = orders.cust_id;</code></pre>\n<ul>\n<li>检索所有客户，包括那些没有下订单的客户(外部联结)<pre><code class=\"sql\">SELECT customer.cust_id,orders.order_num FROM customer LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id;</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>RIGHT表示OUTER JION右边的表的所有行（匹配或不匹配）都将被检索出来<br>LEFT 表示OUTER JION左边的表   </p>\n</blockquote>\n<h3 id=\"带聚集函数的联结\"><a href=\"#带聚集函数的联结\" class=\"headerlink\" title=\"带聚集函数的联结\"></a>带聚集函数的联结</h3><p>检索出所有客户及每个客户所下的订单数</p>\n<pre><code class=\"sql\">SELECT customers.cust_id,count(orders.ooder_num) FROM customer LEFT OUTER JOIN orders ON customer.cust_id = orders.cust_id ORDER BY customers.id;</code></pre>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"组合查询\"><a href=\"#组合查询\" class=\"headerlink\" title=\"组合查询\"></a>组合查询</h2><ul>\n<li>对于单个查询中从不同表汇总返回类似结构的数据</li>\n<li>对单个表执行多个查询，按单个查询返回数据</li>\n</ul>\n<h3 id=\"使用UNION\"><a href=\"#使用UNION\" class=\"headerlink\" title=\"使用UNION\"></a>使用UNION</h3><blockquote>\n<p>检索出所有价格小于5且来自2001,2002的供应商的所有商品</p>\n</blockquote>\n<pre><code class=\"sql\">SELECT prod_id,pro_name\nFROM products\nWHERE prod_price &lt; 5\nUNION\nSELECT prod_id,pro_name\nFROM productes\nWHERE vend_id in (2001,2003)\nORDER BY prod_name;</code></pre>\n<blockquote>\n<p>默认去除多个SELECT结果的重复行，但是可以使用UNION ALL来返回所有的改变行<br>排序语句放在最后一个SELECT的后面</p>\n</blockquote>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h2 id=\"全文本搜索\"><a href=\"#全文本搜索\" class=\"headerlink\" title=\"全文本搜索\"></a>全文本搜索</h2><h3 id=\"启用全文搜索\"><a href=\"#启用全文搜索\" class=\"headerlink\" title=\"启用全文搜索\"></a>启用全文搜索</h3><p>MySql指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySql可以快速有效地判断哪些行包含它们，哪些词不匹配，它们匹配的频率，等等<br><strong>FULLTEXT(列名称)</strong>    </p>\n<pre><code class=\"sql\">CREATE TABLE product(\n    note_id     int         NOT NULL,\n    pro_id      char(10)    NOT NULL,\n    note_text   text        NOT NULL,\n    PRIMARY KEY(pro_id),\n    FULLTEXT(note_text)\n)ENGINE=MyISAM;</code></pre>\n<blockquote>\n<p>InnoDB不支持全文本搜索引擎</p>\n</blockquote>\n<h3 id=\"进行全文本搜索\"><a href=\"#进行全文本搜索\" class=\"headerlink\" title=\"进行全文本搜索\"></a>进行全文本搜索</h3><p>Match()：指定被搜索的列<br>Against()：指定要使用的搜索表达式</p>\n<pre><code class=\"sql\">SELECT note_text FROM productnotes WHERE Match (note_text) Against(&#39;rabbit&#39;);</code></pre>\n<h3 id=\"使用扩展查询\"><a href=\"#使用扩展查询\" class=\"headerlink\" title=\"使用扩展查询\"></a>使用扩展查询</h3><p>考虑下面 的情况。你想找出所有提到anvils的注释。只有一个注释包含词anvils， 但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils。 这也是查询扩展的一项任务。在使用查询扩展时，MySQL对数据和 索引进行两遍扫描来完成搜索： </p>\n<ul>\n<li>首先，进行一个基本的全文本搜索，<strong>找出与搜索条件匹配的所有行</strong>；</li>\n<li>其次，MySQL检查这些匹配行并<strong>选择</strong>所有有用的词（我们将会简 要地解释MySQL如何断定什么有用，什么无用）。 </li>\n<li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件， 而且还使用所有有用的词。 <pre><code class=\"sql\">SELECT note_text FROM productnotes WHERE Match(note_text) Against (&#39;anvil&#39; WITH QUERY EXPANsION);</code></pre>\n<blockquote>\n<p>可能返回多行，但只有第一行含有关键字’anvil’，其他行因为含有第一行的相关字而有可能被检索出来</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"布尔文本搜索\"><a href=\"#布尔文本搜索\" class=\"headerlink\" title=\"布尔文本搜索\"></a>布尔文本搜索</h3><p>可以提供关于如下内容的细节：</p>\n<ul>\n<li>要匹配的词</li>\n<li>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含 其他指定的词也是如此） </li>\n<li>排列提示（指定某些词比其他词更重要，更重要的词等级更高）</li>\n<li>表达式分组</li>\n<li>另外一些内容</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>布尔操作符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>包含，词必须存在</td>\n</tr>\n<tr>\n<td>-</td>\n<td>排除，词必须不出现</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>包含，而且增加等级值</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>包含，且减少等级值</td>\n</tr>\n<tr>\n<td>()</td>\n<td>把词组成子表达式（允许这些子表达式作为一个组被包含、 排除、排列等）</td>\n</tr>\n<tr>\n<td>~</td>\n<td>取消一个词的排序值</td>\n</tr>\n<tr>\n<td>*</td>\n<td>词尾的通配符</td>\n</tr>\n<tr>\n<td>“”</td>\n<td>定义一个短语（与单个词的列表不一样，它匹配整个短语以 便包含或排除这个短语）</td>\n</tr>\n</tbody></table>\n<pre><code class=\"sql\">SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;heavy -rope*&#39; IN BOOLEAN MODE);</code></pre>\n<blockquote>\n<p>检索含有关键字<code>heavy</code><strong>但不含有以<code>rope</code>开头的行</strong></p>\n</blockquote>\n<h3 id=\"一些说明\"><a href=\"#一些说明\" class=\"headerlink\" title=\"一些说明\"></a>一些说明</h3><ul>\n<li>在索引全文本数据时，<strong>短词被忽略且从索引中排除</strong>。短词定义为 那些具有<em>3个或3个以下字符的词</em>（如果需要，这个数目可以更改）。</li>\n<li>MySQL带有一个<strong>内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略</strong>。如果需要，可以覆盖这个列表（请参 阅MySQL文档以了解如何完成此工作）。</li>\n<li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。 因此，MySQL规定了一条50%规则，<strong>如果一个词出现在50%以上的行中，则将它作为一个非用词忽略</strong>。<em>50%规则不用于IN BOOLEAN MODE。</em></li>\n<li>如果表中的<strong>行数少于3行，则全文本搜索不返回结果</strong>（因为每个词 或者不出现，或者至少出现在50%的行中）。 </li>\n<li><em>忽略词中的单引号</em>。例如，don’t索引为dont。 </li>\n<li><em>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文</em>本搜索结果。 </li>\n<li>如前所述，<strong>仅在MyISAM数据库引擎中支持全文本搜索。</strong> </li>\n</ul>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h2><h3 id=\"插入完整的行\"><a href=\"#插入完整的行\" class=\"headerlink\" title=\"插入完整的行\"></a>插入完整的行</h3><pre><code class=\"sql\">INSERT into customers VALUES (&quot;1&quot;,&quot;cc&quot;,&quot;cc@foxmail&quot;);</code></pre>\n<blockquote>\n<p>对每个列<strong>必须</strong>提供一个值。<strong>如果某个列没有值，应该使用NULL值</strong>（假定表允许对该列指定空值）。<br>对于自增的字段，也需要设为NULL</p>\n</blockquote>\n<blockquote>\n<p>种语法很简单，但并不安全，<strong>应该尽量避免使用</strong>。不能保证下一次表结构变动后各个列 保持完全相同的次序</p>\n</blockquote>\n<pre><code class=\"sql\">INSERT into customers(cust_id,cust_name,cust_email) VALUES (&quot;1&quot;,&quot;cc&quot;,&quot;cc@foxmail&quot;);</code></pre>\n<blockquote>\n<p>用VALUES 列表中的相应值填入列表中的对应项<br>对于自增字段，可以不出现</p>\n</blockquote>\n<blockquote>\n<p>如果数据检索是最重要的（通常是这样），则你可以通过在 INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL 降低INSERT语句的优先级，如下所示：<br><code>INSERT LOW_PRIORITY INTO</code><br>这也适用于UPDATE和DELETE语句      </p>\n</blockquote>\n<h3 id=\"插入多行\"><a href=\"#插入多行\" class=\"headerlink\" title=\"插入多行\"></a>插入多行</h3><pre><code class=\"sql\">INSERT into customers(cust_id,cust_name,cust_email) VALUES (&quot;1&quot;,&quot;cc&quot;,&quot;cc@foxmail&quot;),(&quot;2,cc2,cc2@foxmail&quot;);</code></pre>\n<h3 id=\"插入检索出来的数据\"><a href=\"#插入检索出来的数据\" class=\"headerlink\" title=\"插入检索出来的数据\"></a>插入检索出来的数据</h3><p>合并新旧表</p>\n<pre><code class=\"sql\">INSERT into cust_new(cust_id,\n                      cust_name,\n                      cust_email)\nSELECT  cust_id,\n        cust_name,   \n        cust_email                \nFROM cust_old;</code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"更新和删除数据\"><a href=\"#更新和删除数据\" class=\"headerlink\" title=\"更新和删除数据\"></a>更新和删除数据</h2><h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><pre><code class=\"sql\">UPDATE customers SET cust_email = &#39;newmail@foxmial.com&#39;, cust_name = &#39;newname&#39; WHERE cust_id = &#39;1&#39;;</code></pre>\n<blockquote>\n<p>如果没有<code>WHERE</code>语句，<strong>则将更新这张表中所有数据</strong></p>\n</blockquote>\n<blockquote>\n<p>IGNORE关键字，如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 （错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示： UPDATE IGNORE customers… </p>\n</blockquote>\n<blockquote>\n<p>为了删除某一行的某个列值，可以将它更新为NULL</p>\n</blockquote>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><ul>\n<li>删除一行<pre><code class=\"sql\">DELETE FROM customers WHERE cust_id = &#39;1231&#39;;</code></pre>\n<blockquote>\n<p>如果没有<code>WHERE</code>语句，<strong>则将删除这张表中所有数据</strong><br>如果更快的删除而且删除清零自增字段，可以使用<code>truncate tablename</code></p>\n</blockquote>\n</li>\n</ul>\n<p>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE 子句的UPDATE或DELETE语句。<br>保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能 像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。<br>在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进 行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。 </p>\n<h3 id=\"创建和删除表\"><a href=\"#创建和删除表\" class=\"headerlink\" title=\"创建和删除表\"></a>创建和删除表</h3><h4 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h4><pre><code class=\"sql\">CREATE TABLE product(\n    pro_id      char(10)    NOT NULL  AUTO_INCREMENT, --自增\n    note_id     int         NOT NULL,\n    note_text   text        NOT NULL,\n    pro_price   ine         NOT NULL DEFAULT 1, --默认值为1\n    PRIMARY KEY(pro_id)\n)ENGINE=InnoDB;</code></pre>\n<blockquote>\n<p>自增字段 AUTO_INCREMENT，（每个表<strong>只允许有一个自增字段</strong>，且<strong>必须被索引</strong>&lt;例如使它变为主键&gt;）<br>使用<code>SELECT last_insert_id()</code>语句<strong>返回最后一个AUTO_INCREMENT值</strong></p>\n</blockquote>\n<blockquote>\n<p>DEFAULT 设置默认值</p>\n</blockquote>\n<h4 id=\"引擎类型\"><a href=\"#引擎类型\" class=\"headerlink\" title=\"引擎类型\"></a>引擎类型</h4><p>与其他DBMS一样，MySQL有一个<strong>具体管理和处理数据</strong>的内部引擎。 在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT 语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候， 此引擎都隐藏在DBMS内，不需要过多关注它。   </p>\n<p>但MySQL与其他DBMS不一样，<strong>它具有多种引擎</strong>。它打包多个引擎， 这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT 等命令。 </p>\n<p>为什么要发行多种引擎呢？因为它们<strong>具有各自不同的功能和特性</strong>， 为不同的任务选择正确的引擎能获得<strong>良好的功能和灵活性</strong>。 </p>\n<p>当然，你完全可以忽略这些数据库引擎。如果省略ENGINE=语句，则 使用默认引擎（很可能是MyISAM），多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么ENGINE=语句很重要的原因 （也就是为什么本书的样列表中使用两种引擎的原因）。 </p>\n<ul>\n<li>InnoDB是一个<strong>可靠的事务处理引擎</strong>（参见第26章），它<strong>不支持全文本搜索</strong></li>\n<li>MEMORY在功能等同于MyISAM，但由于<strong>数据存储在内存</strong>（不是磁盘） 中，<strong>速度很快</strong>（特别适合于临时表）</li>\n<li>MyISAM是一个<strong>性能极高</strong>的引擎，它支持全文本搜索（参见第18章）， 但<strong>不支持事务处理</strong>。 </li>\n</ul>\n<h4 id=\"更新表\"><a href=\"#更新表\" class=\"headerlink\" title=\"更新表\"></a>更新表</h4><p>为更新表定义，可使用<strong>ALTER TABLE</strong>语句。但是，理想状态下，<em>当表中存储数据以后，该表就不应该再被更新</em>。在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。 </p>\n<pre><code class=\"sql\">--增加字段\nALTER TABLE products ADD prod_price;\n--删除字段\nALTER TABLE products DROP prod_price;\n--定义外键\nALTER TABLE products ADD CONSTRAINT orderitems FOREIGN KEY (order_num) REFERENCES (order_num);</code></pre>\n<p><strong>复杂的表结构更改</strong>一般需要手动删除过程，它涉及以下步骤： </p>\n<ul>\n<li>用新的列布局创建一个新表</li>\n<li>使用INSERT SELECT语句从旧表复制数据到新表</li>\n<li>检验包含所需数据的新表</li>\n<li>重命名旧表（如果确定，可以删除它）</li>\n<li>用旧表原来的名字重命名新表</li>\n<li>根据需要，重新创建触发器、存储过程、索引和外键</li>\n</ul>\n<h4 id=\"删除表\"><a href=\"#删除表\" class=\"headerlink\" title=\"删除表\"></a>删除表</h4><pre><code class=\"sql\">DROP TABLE customers;</code></pre>\n<h3 id=\"清除表数据\"><a href=\"#清除表数据\" class=\"headerlink\" title=\"清除表数据\"></a>清除表数据</h3><pre><code class=\"sql\">--删除数据\ndelete * from TName;\n--删除所有数据并重置自增序列\ntruncate table TName; </code></pre>\n<h4 id=\"重命名表\"><a href=\"#重命名表\" class=\"headerlink\" title=\"重命名表\"></a>重命名表</h4><pre><code class=\"sql\">RENAME TABLE customer1 TO customer2;</code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>视图是<strong>虚拟的表</strong>。与包含数据的表不一样，视图<strong>只包含使用时动态检索数据的查询</strong>。 </p>\n<blockquote>\n<p>它<strong>本身不包含</strong>表中应该有的<strong>任何列或数据</strong>，它<strong>包含的是一个SQL查询</strong></p>\n</blockquote>\n<h3 id=\"视图的应用\"><a href=\"#视图的应用\" class=\"headerlink\" title=\"视图的应用\"></a>视图的应用</h3><ul>\n<li><strong>重用SQL语句</strong></li>\n<li><strong>简化复杂的SQL操作</strong>。在编写查询后，可以方便地重用它而不必知道它的基本查询细节</li>\n<li><strong>使用表的组成部分</strong>而不是整个表。</li>\n<li><strong>保护数据</strong>。可以给用户授予表的特定部分的访问权限而不是整个 表的访问权限</li>\n<li><strong>更改数据格式和表示</strong>。视图可返回与底层表的表示和格式不同的数据</li>\n</ul>\n<p>在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图<strong>执行SELECT操作</strong>，<strong>过滤</strong>和<strong>排序</strong>数据，将视<strong>图联结到其他视图或表</strong>，甚至能<strong>添加</strong>和<strong>更新</strong>数据（添加和更新数据存在某些限制。关于这个内容稍 后还要做进一步的介绍）。 </p>\n<blockquote>\n<p>如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。</p>\n</blockquote>\n<h3 id=\"视图的规则和限制\"><a href=\"#视图的规则和限制\" class=\"headerlink\" title=\"视图的规则和限制\"></a>视图的规则和限制</h3><ul>\n<li>视图必须唯一命名</li>\n<li>创建的视图数目没有限制</li>\n<li><strong>必须具有足够的访问权限</strong></li>\n<li><strong>视图可以嵌套</strong>，即可以利用从其他视图中检索数据的查询来构造 一个视图</li>\n<li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖</li>\n<li><strong>视图不能索引</strong>，也不能有关联的触发器或默认值</li>\n<li>视图可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句。 </li>\n</ul>\n<h3 id=\"使用视图\"><a href=\"#使用视图\" class=\"headerlink\" title=\"使用视图\"></a>使用视图</h3><ul>\n<li>CREATE VIEW语句来创建</li>\n<li>SHOW CREATE VIEW viewname；来查看创建视图的语</li>\n<li>用DROP删除视图，其语法为DROP VIEW viewname</li>\n<li>更新视图时，可以先用DROP再用CREATE，也可以直接用<code>CREATE OR REPLACE VIEW</code>。如果要更新的视图不存在，则第2条更新语句会创 建一个视图；如果要更新的视图存在，则第2条更新语句会替换原 有视图</li>\n</ul>\n<h3 id=\"更新视图\"><a href=\"#更新视图\" class=\"headerlink\" title=\"更新视图\"></a>更新视图</h3><p>通常，视图是可更新的，但是，并非所有视图都是可更新的。基本上可以说，<strong>如果MySQL不能正确地确定被更新的基数据，则不允许更新</strong>（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新： </p>\n<ul>\n<li>分组</li>\n<li>联结</li>\n<li>子查询</li>\n<li>并</li>\n<li>聚集函数（Min()、Count()、Sum()等）</li>\n<li>DISTINCT</li>\n<li>导出（计算）列</li>\n</ul>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h2><p>迄今为止，使用的大多数SQL语句都是针对一个或多个表的单条语 句。并非所有操作都这么简单，经常会有一个完整的操作需要多条语句 才能完成。例如，考虑以下的情形</p>\n<ul>\n<li>为了处理订单，需要核对以保证库存中有相应的物品</li>\n<li>如果库存有物品，这些物品需要预定以便不将它们再卖给别的人，并且要减少可用的物品数量以反映正确的库存量</li>\n<li>库存中没有的物品需要订购，这需要与供应商进行某种交互 </li>\n<li>关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的客户</li>\n</ul>\n<p>执行这个<strong>处理需要针对许多表的多条MySQL语句</strong>。此外，需要执行的<strong>具体语句及其次序</strong>也不是固定的，它们可能会（和将）根据哪些物品在库存中哪些不在而变化。 </p>\n<p>存储过程简单来说，就是为以后的使用而保存的<strong>一条或多条MySQL语句的集合</strong>。</p>\n<blockquote>\n<p>可将其视为批文件，虽然它们的作用不仅限于批处理。 </p>\n</blockquote>\n<h3 id=\"使用存储过程的优缺点\"><a href=\"#使用存储过程的优缺点\" class=\"headerlink\" title=\"使用存储过程的优缺点\"></a>使用存储过程的优缺点</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p><strong>简单、安全、高性能</strong></p>\n<ul>\n<li>通过把处理封装在容易使用的单元中，<strong>简化复杂的操作</strong>（正如前 面例子所述）</li>\n<li>由于不要求反复建立一系列处理步骤，这<strong>保证了数据的完整性</strong>。<em>如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的</em>。 这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误<strong>保证了数据的一致性</strong></li>\n<li><strong>简化对变动的管理</strong>。如果表名、列名或业务逻辑（或别的内容） 有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化</li>\n<li><strong>提高性能</strong>。因为使用存储过程比使用单独的SQL语句要快 </li>\n<li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写<strong>功能更强更灵活</strong>的代码</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>存储过程的<strong>编写比基本SQL语句复杂</strong>，编写存储过程需要更高的技能，更丰富的经验。 </li>\n<li>你可能<strong>没有创建存储过程的安全访问权限</strong>。许多数据库管理员限 制存储过程的创建权限，允许用户使用存储过程，但不允许他们 创建存储过程。 </li>\n</ul>\n<h3 id=\"使用存储过程\"><a href=\"#使用存储过程\" class=\"headerlink\" title=\"使用存储过程\"></a>使用存储过程</h3><ul>\n<li>执行（call）<pre><code class=\"sql\">CALL productpricing(@pricelow,@pricehigh,@priceaverage);</code></pre>\n<h3 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h3>返回产品平均过程的存储过程<pre><code class=\"sql\">CREATE PROCEDURE productpricing()\nBEGIN\n  SELECT AVG(prod_price) AS priceaverage FROM products;\nEND</code></pre>\n<blockquote>\n<p>注意productpricing()的()</p>\n</blockquote>\n</li>\n</ul>\n<p>mysql命令行客户机的分隔符(命令行工具)</p>\n<pre><code class=\"sql\">DELIMITER//\n\n\nCREATE PROCEDURE productpricing()\nBEGIN\n    SELECT AVG(prod_price) AS priceaverage FROM products;\nEND//\n\nDELIMITER;\n</code></pre>\n<blockquote>\n<p>因为在存储过程存在<code>;</code>，所以在命令行程序中需使用特定的分隔符<br>DELIMITER+符号（分隔符）：表示告诉程序使用此分隔符作为新的语句结束分隔符,所以由<code>END</code>变为了<code>END//</code><br>除\\符号外，任何字符都可以用作语句分隔符。 </p>\n</blockquote>\n<h3 id=\"删除存储过程\"><a href=\"#删除存储过程\" class=\"headerlink\" title=\"删除存储过程\"></a>删除存储过程</h3><pre><code class=\"sql\">DROP PROCEDURE productpricing;</code></pre>\n<blockquote>\n<p>注意没有<code>()</code><br>如果该存储过程不存在，则会报错，所以建议使用<code>DROP PROCEDURE IF EXISTS</code></p>\n</blockquote>\n<h3 id=\"使用参数\"><a href=\"#使用参数\" class=\"headerlink\" title=\"使用参数\"></a>使用参数</h3><ul>\n<li>创建带参数的存储过程<pre><code class=\"sql\">CREATE PROCEDURE productpricing(\n  OUT pl DECIMAL(8,2),    --pl:存储产品最低价格\n  OUT ph DECIMAL(8,2),    --ph:存储产品最高价格\n)\nBEGIN\n  SELECT MIN(prod_price) INTO pl FROM products;\n  SELECT MAX(prod_price) INTO ph FROM products;\nEND</code></pre>\n<blockquote>\n<p>存储过程保存在BEGIN和END之间</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>OUT指出相应的参数用来<strong>从存储过程传出</strong> 一个值（返回给调用者）<br>IN,传递给存储过程<br>INOUT，对存储过程传入传出</p>\n</blockquote>\n<ul>\n<li>使用存储过程<br>```sql</li>\n</ul>\n<p>–指定变量名<br>CALL productpricing(@pricelow, @prichigh);</p>\n<p>–检索<br>SELECT @prcielow;</p>\n<p>SELECT @prcielow, @prichigh;</p>\n<pre><code>\n### 检查存储过程\n```sql\n-- 显示创建的语句\nSHOW CREATE PROCEDURE ordertotal;\n\n-- 显示更加详细，何时、由何人创建的信息\nSHOW CREATE PROCEDURE STATUS ordertotal;\n\n-- 过滤查看更多存储过程的信息\nSHOW CREATE PROCEDURE STATUS LIKE &#39;ordertotal&#39;;</code></pre><p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"游标\"><a href=\"#游标\" class=\"headerlink\" title=\"游标\"></a>游标</h2><p>（<del>有待填坑</del>）</p>\n<p>有时，<strong>需要在检索出来的行中前进或后退一行或多行</strong>。这就是使用游标的原因。游标（cursor）是<strong>一个存储在MySQL服务器上的数据库查询</strong>， 它不是一条SELECT语句，<strong>而是被该语句检索出来的结果集</strong>。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。 </p>\n<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。 </p>\n<h3 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h3><ul>\n<li>在能够<strong>使用游标前，必须声明</strong>（定义）它</li>\n<li>一旦声明后，必须打开游标以供使用。</li>\n<li>对于填有数据的游标，根据需要取出（检索）各行。 </li>\n<li>在结束游标使用时，必须关闭游标。 </li>\n</ul>\n<h3 id=\"创建游标\"><a href=\"#创建游标\" class=\"headerlink\" title=\"创建游标\"></a>创建游标</h3><pre><code class=\"sql\">CREATE PROCEDURE processorders()\nBEGIN\n    DECLARE ordernumbers CURSOR\n    FOR\n    SELECT order_num FROM orders;\nEND;</code></pre>\n<h3 id=\"打开和关闭游标\"><a href=\"#打开和关闭游标\" class=\"headerlink\" title=\"打开和关闭游标\"></a>打开和关闭游标</h3><pre><code class=\"sql\">--打开\nOPEN ordernumbers;\n\n--关闭\nCLOSE ordernumbers;</code></pre>\n<blockquote>\n<p>如果不明确关闭游标，MySql将会在到达END语句时自动关闭</p>\n</blockquote>\n<h3 id=\"使用游标\"><a href=\"#使用游标\" class=\"headerlink\" title=\"使用游标\"></a>使用游标</h3><p>在一个游标被打开后，可以使用<strong>FETCH语句</strong>分别访问它的每一行。 FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。 它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。</p>\n<pre><code class=\"sql\">CREATE PROCEDURE processorders()\nBEGIN\n    --声明一个变量\n    DECLARE o INT;\n    --声明一个游标\n    DECLARE ordernumbers CURSOR\n    FOR\n    SELECT order_num FROM orders;\n    --打开一个游标\n    OPEN ordernumbers;\n    --获取数据\n    FETCH ordernumbers INTO o;\n    --关闭游标\n    CLOSE ordernumbers;\nEND;</code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><p>MySQL语句在需要时被执行，存储过程也是如此。但是，如果你想要<strong>某条语句（或某些语句）在事件发生时自动执行</strong>，怎么办呢？例如： </p>\n<ul>\n<li>每当增加一个顾客到某个数据库表时，都检查其电话号码格式是 否正确，州的缩写是否为大写； </li>\n<li>每当订购一个产品时，都从库存数量中减去订购的数量； </li>\n<li>无论何时删除一行，都在某个存档表中保留一个副本。 </li>\n</ul>\n<p>所有这些例子的共同之处是它们都需要在某个表发生更改时自动处理。这确切地说就是触发器。触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语 句） ： </p>\n<ul>\n<li>DELETE； </li>\n<li>INSERT； </li>\n<li>UPDATE。</li>\n</ul>\n<p><em>其他MySQL语句不支持触发器。</em> </p>\n<h3 id=\"创建触发器\"><a href=\"#创建触发器\" class=\"headerlink\" title=\"创建触发器\"></a>创建触发器</h3><p>在创建触发器时，需要给出4条信息： </p>\n<ul>\n<li>唯一的触发器名； </li>\n<li>触发器关联的表； (只有表支持触发器，视图不支持)</li>\n<li>触发器应该响应的活动（DELETE、INSERT或UPDATE）； </li>\n<li>触发器何时执行（处理之前或之后）。 </li>\n</ul>\n<blockquote>\n<p>每个表将最多支持6个触发器，DELETE、INSERT或UPDATE的处理之前或之后</p>\n</blockquote>\n<blockquote>\n<p>在MySQL 5中，触发器名必 须在每个表中唯一，但不是在每个数据库中唯一。这表示同一 数据库中的两个表可具有相同名字的触发器。这在其他每个数 据库触发器名必须唯一的DBMS中是不允许的，而且以后的 MySQL版本很可能会使命名规则更为严格。因此，现在最好 是在数据库范围内使用唯一的触发器名。 </p>\n</blockquote>\n<pre><code class=\"sql\">CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT &#39;product added&#39;;</code></pre>\n<blockquote>\n<p>使用INSERT语句添加一行或多行到products表中时，将对每一行显示文本product added</p>\n</blockquote>\n<h3 id=\"删除触发器\"><a href=\"#删除触发器\" class=\"headerlink\" title=\"删除触发器\"></a>删除触发器</h3><pre><code class=\"sql\">DROP TRIGGER newproduct;</code></pre>\n<blockquote>\n<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。</p>\n</blockquote>\n<h3 id=\"使用触发器\"><a href=\"#使用触发器\" class=\"headerlink\" title=\"使用触发器\"></a>使用触发器</h3><h4 id=\"INSERT触发器\"><a href=\"#INSERT触发器\" class=\"headerlink\" title=\"INSERT触发器\"></a>INSERT触发器</h4><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点： </p>\n<ul>\n<li>在INSERT触发器代码内，可引用一个<strong>名为NEW的虚拟表，访问被插入的行</strong>； </li>\n<li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值） ； </li>\n<li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。 <pre><code class=\"sql\">CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT NEW.order_num;</code></pre>\n<blockquote>\n<p>在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从NEW. order_num取得这个值并返回它。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"DELETE触发器\"><a href=\"#DELETE触发器\" class=\"headerlink\" title=\"DELETE触发器\"></a>DELETE触发器</h4><p>DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两 点： </p>\n<ul>\n<li>在DELETE触发器代码内，你可以引用一个名为<strong>OLD的虚拟表，访问被删除的行</strong>；</li>\n<li>OLD中的值全都是只读的，不能更新。  <pre><code class=\"sql\">CREATE TRIGGER deleteorder BEFORE DELETE ON products FOR EACH ROW\nBEGIN\n  INSERT INTO archive_orders(order_num,order_date)\n  VALUES(OLD.order_num,OLD.order_num);\nEND;</code></pre>\n<blockquote>\n<p>在任意订单被删除前将执行此触发器。它使用一条INSERT语句 将OLD中的值（要被删除的订单）保存到一个名为archive_ orders的存档表中</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"UPDATE触发器\"><a href=\"#UPDATE触发器\" class=\"headerlink\" title=\"UPDATE触发器\"></a>UPDATE触发器</h4><p>UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：</p>\n<ul>\n<li>在UPDATE触发器代码中，你可以引用一个名为<strong>OLD</strong>的虚拟表<strong>访问以前</strong>（UPDATE语句前）的值，引用一个名为<strong>NEW的虚拟表访问新更新的值</strong>； </li>\n<li>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改 将要用于UPDATE语句中的值）； </li>\n<li>OLD中的值全都是<strong>只读的，不能更新</strong>。 <pre><code class=\"sql\">CREATE TRIGGER updateevendor BEFORE DELETE ON vendors FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend-state);</code></pre>\n<blockquote>\n<p>下面的例子保证州名缩写总是大写（不管UPDATE语句中给出的是大 写还是小写）： </p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"进一步介绍\"><a href=\"#进一步介绍\" class=\"headerlink\" title=\"进一步介绍\"></a>进一步介绍</h3><p>在结束本章之前，我们再介绍一些使用触发器时需要记住的重点。</p>\n<ul>\n<li>与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来的 MySQL版本中有一些改进和增强触发器支持的计划。 </li>\n<li>创建触发器可能需要特殊的安全访问权限，但是，<strong>触发器的执行是自动的。如果INSERT、UPDATE或DELETE语句能够执行，则相关的触发器也能执行</strong>。 </li>\n<li>应该用触发器来<strong>保证数据的一致性</strong>（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。 </li>\n<li>触发器的一种非常有意义的使用是<strong>创建审计跟踪</strong>。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个 表非常容易。 </li>\n<li>遗憾的是，MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。</li>\n</ul>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"事务处理\"><a href=\"#事务处理\" class=\"headerlink\" title=\"事务处理\"></a>事务处理</h2><p>事务处理（transaction processing）可以用来维护数据库的完整性，它 保证成批的MySQL操作<strong>要么完全执行，要么完全不执行。</strong> </p>\n<p>利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）<strong>。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</strong></p>\n<blockquote>\n<ul>\n<li>事务（transaction）指一组SQL语句； </li>\n<li>回退（rollback）指撤销指定SQL语句的过程； </li>\n<li>提交（commit）指将未存储的SQL语句结果写入数据库表； </li>\n<li>保留点（savepoint）指事务处理中设置的临时占位符（place- holder），你可以对它发布回退（与回退整个事务处理不同</li>\n</ul>\n</blockquote>\n<h3 id=\"使用ROLLBACK\"><a href=\"#使用ROLLBACK\" class=\"headerlink\" title=\"使用ROLLBACK\"></a>使用ROLLBACK</h3><p>MySQL的ROLLBACK命令用来回退（撤销）MySQL语句。</p>\n<pre><code class=\"sql\">SELECT * FROM ordertotals ;\n--开始事物\nSTART TRANSACTION; \nDELETE FROM ordertotals;\nSELECT * FROM ordertotals;\n--撤销\nROLLBACK;\nSELECT * FROM ordertotals;</code></pre>\n<blockquote>\n<p>首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条 SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句<strong>回退 START TRANSACTION之后的所有语句</strong>，最后一条SELECT语句显示该表不为空。 </p>\n</blockquote>\n<h3 id=\"使用COMMIT\"><a href=\"#使用COMMIT\" class=\"headerlink\" title=\"使用COMMIT\"></a>使用COMMIT</h3><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。 </p>\n<p>但是，<strong>在事务处理块中，提交不会隐含地进行</strong>。为进行明确的提交，使用COMMIT语句，如下所示： </p>\n<pre><code class=\"sql\">--开始事物\nSTART TRANSACTION; \nDELETE FROM ordertotals WHERE order_num = 20010;\nDELETE FROM orders WHERE order_num = 20010;\n--提交\nCOMMIT;</code></pre>\n<blockquote>\n<p>从系统中完全删除订单20010。因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来<strong>保证订单不被部分删除</strong>。最后的COMMIT语句<strong>仅在不出错时写出更改</strong>。如 果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的） </p>\n</blockquote>\n<blockquote>\n<p><strong>隐含事务关闭</strong>  当COMMIT或ROLLBACK语句执行后，事务会自 动关闭（将来的更改会隐含提交）。 </p>\n</blockquote>\n<h3 id=\"使用保用点\"><a href=\"#使用保用点\" class=\"headerlink\" title=\"使用保用点\"></a>使用保用点</h3><p>简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但 是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要<strong>部分提交或回退</strong>。 </p>\n<pre><code class=\"sql\">--创建保用点\nSAVEPOINT delete1;\n--回退\nROLLBACK TO delete1</code></pre>\n<blockquote>\n<p><strong>保留点越多越好</strong> .可以在MySQL代码中设置任意多的保留 点，越多越好。为什么呢？因为保留点越多，你就越能按自己的意愿<strong>灵活</strong>地进行回退。</p>\n</blockquote>\n<blockquote>\n<p>保留点在事务处理完成（执行一条<strong>ROLLBACK或 COMMIT）后</strong>自动释放**。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。 </p>\n</blockquote>\n<h3 id=\"更改默认提交方式\"><a href=\"#更改默认提交方式\" class=\"headerlink\" title=\"更改默认提交方式\"></a>更改默认提交方式</h3><p>正如所述，默认的MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句： </p>\n<pre><code class=\"sql\">SET autocommit=0;</code></pre>\n<h2 id=\"全球化和本地化\"><a href=\"#全球化和本地化\" class=\"headerlink\" title=\"全球化和本地化\"></a>全球化和本地化</h2><p><strong>不同的语言和字符集需要以不同的方式存储和检索</strong>。</p>\n<p>因此，MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法。</p>\n<ul>\n<li><strong>字符集</strong>：字母和符号的集合； </li>\n<li><strong>编码</strong>：某个字符集成员的内部表示； </li>\n<li><strong>校对</strong>：规定字符如何比较的指令。 <blockquote>\n<p>校对为什么重要  排序英文正文很容易，对吗？或许不。考 虑词APE、apex和Apple。它们处于正确的排序顺序吗？这有 赖于你是否想区分大小写。使用区分大小写的校对顺序，这 些词有一种排序方式，使用不区分大小写的校对顺序有另外 一种排序方式。这不仅影响排序（如用ORDER BY排序数据） ， 还影响搜索（例如，寻找apple的WHERE子句是否能找到 APPLE）。在使用诸如法文à或德文ö这样的字符时，情况更复 杂，在使用不基于拉丁文的字符集（日文、希伯来文、俄文 等）时，情况更为复杂</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"使用字符集和校对顺序\"><a href=\"#使用字符集和校对顺序\" class=\"headerlink\" title=\"使用字符集和校对顺序\"></a>使用字符集和校对顺序</h3><p>为查看所支持的字符集完整列表</p>\n<pre><code class=\"sql\">SHOW CHARACTER SET;</code></pre>\n<p>为了查看所支持校对的完整列</p>\n<pre><code class=\"sql\">SHOW COLLATION;</code></pre>\n<p>通常系统管理在安装时定义一个默认的字符集和校对。此外，也可 以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对可以使用以下语句： </p>\n<pre><code class=\"sql\">SHOW VARIABLES LIKE &#39;character%&#39;;\nSHOW VARIABLES LIKE &#39;collation%&#39;;</code></pre>\n<p>为了给表指定字符集和校对，可使用带子句的CREATE TABLE       </p>\n<pre><code class=\"sql\">CREATE TABLE mytable\n(\n    column1 INT,\n    column2 VARCHAR(10),\n) DEFAULT CHARACTER SET brew     --字符集\n  COLLATE hebrew_general_ci;     --校对顺序</code></pre>\n<p>对某个列设置单独的字符集和校对</p>\n<pre><code class=\"sql\">CREATE TABLE mytable\n(\n    column1 INT,\n    column2 VARCHAR(10),\n    column3 VARCHAR(20) CHARACTER SET latin1 COLLATE latin1_general_ci\n) DEFAULT CHARACTER SET brew     --字符集\n  COLLATE hebrew_general_ci;     --校对顺序</code></pre>\n<p>如前所述，校对在对用ORDER BY子句检索出来的数据排序时起重要 的作用。如果你<strong>需要用与创建表时不同的校对顺序排序特定的SELECT语句</strong>，可以在SELECT语句自身中进行：</p>\n<pre><code class=\"sql\">    SELECT * FROM  customer ORDER BY lastname COLLATE latin1_general_ci;</code></pre>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"安全管理\"><a href=\"#安全管理\" class=\"headerlink\" title=\"安全管理\"></a>安全管理</h2><p>MySQL服务器的安全基础是：<strong>用户应该对他们需要的数据具有适当的访问权，既不能多也不能少</strong>。换句话说，用户不能对过多的数据具有过多的访问权。 </p>\n<blockquote>\n<p>应该严肃对待root登录的使用。仅在绝对需 要时使用它（或许在你不能登录其他管理账号时使用）。不应 该在日常的MySQL操作中使用root。 </p>\n</blockquote>\n<h3 id=\"管理用户\"><a href=\"#管理用户\" class=\"headerlink\" title=\"管理用户\"></a>管理用户</h3><p>MySQL用户账号和信息存储在名为mysql的MySQL数据库中。一般不需要直接访问mysql数据库和表（你稍后会明白这一点），但有时需要直接访问。需要直接访问它的时机之一是在需要获得所有用户账号列表时。</p>\n<p>mysql数据库有一个名为user的表，它包含所有用户账号。user 表有一个名为user的列，它存储用户登录名。</p>\n<h4 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h4><pre><code class=\"sql\">--创建账户名为cc1,密码为123的账户\nCREATE USER cc1 IDENTIFIED BY &#39;123&#39;;\n--重命名\nRENAME USER cc1 TO cc2;</code></pre>\n<blockquote>\n<p><strong>使用GRANT或INSERT</strong> GRANT语句也可以创建用 户账号，但一般来说CREATE USER是最清楚和最简单的句子。 此外，也可以通过直接插入行到user表来增加用户，不过为安全起见，一般不建议这样做。MySQL用来存储用户账号信息 的表（以及表模式等）极为重要，对它们的任何毁坏都 可能严重地伤害到MySQL服务器。因此，相对于直接处理来 说，最好是用标记和函数来处理这些表。 </p>\n</blockquote>\n<h4 id=\"更改口令\"><a href=\"#更改口令\" class=\"headerlink\" title=\"更改口令\"></a>更改口令</h4><pre><code class=\"sql\">SET PASSWORD FOR  cc2 = Password(&#39;456&#39;);\n--设置当前账户口令\nSET PASSWORD = Password(&#39;456&#39;);</code></pre>\n<h4 id=\"删除用户\"><a href=\"#删除用户\" class=\"headerlink\" title=\"删除用户\"></a>删除用户</h4><pre><code class=\"sql\">DROP USER cc2;</code></pre>\n<h3 id=\"设置访问权限\"><a href=\"#设置访问权限\" class=\"headerlink\" title=\"设置访问权限\"></a>设置访问权限</h3><p>在创建用户账号后，必须接着分配访问权限。<strong>新创建的用户账号没有访问权限</strong>。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。</p>\n<pre><code class=\"sql\">--看到赋予用户账号的权限\nSHOW GRANTS FOR cc2;</code></pre>\n<p>为<strong>设置权限</strong>，使用GRANT语句。GRANT要求你至少给出以下信息： </p>\n<ul>\n<li>要授予的权限</li>\n<li>被授予访问权限的数据库或表；</li>\n<li>用户名</li>\n</ul>\n<pre><code class=\"sql\">--此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。\nGRANT SELECT ON crashcourse.* TO cc3;</code></pre>\n<blockquote>\n<p>通过只授予SELECT访问权限，用户bforta对crashcourse数据库中的所有数据具有只读访问权限。 </p>\n</blockquote>\n<p>GRANT的反操作为REVOKE，用它来<strong>撤销特定的权限</strong>。</p>\n<pre><code class=\"sql\">--取消刚赋予用户cc3的SELECT访问权限\nREVOKE SELECT ON crashcourse.* FROM cc3;</code></pre>\n<p>GRANT和REVOKE可在几个层次上控制访问权限： </p>\n<ul>\n<li>整个服务器，使用GRANT ALL和REVOKE ALL； </li>\n<li>整个数据库，使用ON database.*； </li>\n<li>特定的表，使用ON database.table； </li>\n<li>特定的列； </li>\n<li>特定的存储过程。</li>\n</ul>\n<p>下标列出可以授予或撤销的每个权限。 </p>\n<table>\n<thead>\n<tr>\n<th>权限</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ALL</td>\n<td>除GRANT OPTION外的所有权限</td>\n</tr>\n<tr>\n<td>ALTER</td>\n<td>使用ALTER TABLE</td>\n</tr>\n<tr>\n<td>ALTER ROUTINE</td>\n<td>使用ALTER PROCEDURE和DROP PROCEDURE</td>\n</tr>\n<tr>\n<td>CREATE</td>\n<td>使用CREATE TABLE</td>\n</tr>\n<tr>\n<td>CREATE ROUTINE</td>\n<td>使用CREATE PROCEDURE</td>\n</tr>\n<tr>\n<td>CREATE TEMPORARY TABLES</td>\n<td>使用CREATE TEMPORARY TABLE</td>\n</tr>\n<tr>\n<td>CREATE USER</td>\n<td>使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES</td>\n</tr>\n<tr>\n<td>CREATE VIEW</td>\n<td>使用CREATE VIEW</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>使用DELETE</td>\n</tr>\n<tr>\n<td>DROP</td>\n<td>使用DROP TABLE</td>\n</tr>\n<tr>\n<td>EXECUTE</td>\n<td>使用CALL和存储过程</td>\n</tr>\n<tr>\n<td>FILE</td>\n<td>使用SELECT INTO OUTFILE和LOAD DATA INFILE</td>\n</tr>\n<tr>\n<td>GRANT OPTION</td>\n<td>使用GRANT和REVOKE</td>\n</tr>\n<tr>\n<td>INDEX</td>\n<td>使用CREATE INDEX和DROP INDEX</td>\n</tr>\n<tr>\n<td>INSERT</td>\n<td>使用INSERT</td>\n</tr>\n<tr>\n<td>LOCK TABLES</td>\n<td>使用LOCK TABLES</td>\n</tr>\n<tr>\n<td>PROCESS</td>\n<td>使用SHOW FULL PROCESSLIST</td>\n</tr>\n<tr>\n<td>RELOAD</td>\n<td>使用FLUSH</td>\n</tr>\n<tr>\n<td>REPLICATION CLIENT</td>\n<td>服务器位置的访问</td>\n</tr>\n<tr>\n<td>REPLICATION SLAVE</td>\n<td>由复制从属使用</td>\n</tr>\n<tr>\n<td>SELECT</td>\n<td>使用SELECT</td>\n</tr>\n<tr>\n<td>SHOW DATABASES</td>\n<td>使用SHOW DATABASES</td>\n</tr>\n<tr>\n<td>SHOW VIEW</td>\n<td>使用SHOW CREATE VIEW</td>\n</tr>\n<tr>\n<td>SHUTDOWN</td>\n<td>使用mysqladmin shutdown（用来关闭MySQL）</td>\n</tr>\n<tr>\n<td>SUPER</td>\n<td>使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER 和SET GLOBAL。还允许mysqladmin调试登录</td>\n</tr>\n<tr>\n<td>UPDATE</td>\n<td>使用UPDATE</td>\n</tr>\n<tr>\n<td>USAGE</td>\n<td>无访问权限</td>\n</tr>\n</tbody></table>\n<p>，当某个数据库或表被删除时（用DROP语 句），相关的访问权限仍然存在。而且，如果将来重新创建该 数据库或表，这些权限仍然起作用。 </p>\n<blockquote>\n<p>未来的授权  在使用GRANT和REVOKE时，用户账号必须存在， 但对所涉及的对象没有这个要求。这允许管理员在创建数据库 和表之前设计和实现安全措施。 这样做的副作用是，当某个数据库或表被删除时（用DROP语 句），相关的访问权限仍然存在。而且，如果将来重新创建该 数据库或表，这些权限仍然起作用。 </p>\n</blockquote>\n<blockquote>\n<p>简化多次授权  可通过列出各权限并用逗号分隔，将多条 GRANT语句串在一起，如下所示： <code>GRANT SELECT,INSERT ON crashcourse.* TO cc2;</code></p>\n</blockquote>\n<p><br><br> </p>\n<hr>\n<p><br><br></p>\n<h2 id=\"数据库维护\"><a href=\"#数据库维护\" class=\"headerlink\" title=\"数据库维护\"></a>数据库维护</h2><h3 id=\"数据库备份\"><a href=\"#数据库备份\" class=\"headerlink\" title=\"数据库备份\"></a>数据库备份</h3><p>像所有数据一样，MySQL的数据也必须经常备份。由于MySQL数据 库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。 但是，<strong>由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效</strong>。<br>下面列出这个问题的可能解决方案。 </p>\n<ul>\n<li>使用<strong>命令行实用程序mysqldump</strong>转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正 确地备份转储文件。</li>\n<li>可用<strong>命令行实用程序mysqlhotcopy</strong>从一个数据库复制所有数据 （并非所有数据库引擎都支持这个实用程序）。 </li>\n<li>可以使用<strong>MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储</strong>所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原。 </li>\n</ul>\n<blockquote>\n<p>首先刷新未写数据 为<strong>了保证所有数据被写到磁盘（包括索引数据）</strong>，可能需要在进行备份前使用<strong>FLUSH TABLES</strong>语句。 </p>\n</blockquote>\n<h3 id=\"数据库维护-1\"><a href=\"#数据库维护-1\" class=\"headerlink\" title=\"数据库维护\"></a>数据库维护</h3><p><strong>ANALYZE TABLE</strong>，用来检查<strong>表键</strong>是否正确</p>\n<p>如果从一个表中删除大量数据，应该使用<strong>OPTIMIZE TABLE</strong>来收回所用的空间，从而优化表的性能。 </p>\n<h3 id=\"诊断启动问题\"><a href=\"#诊断启动问题\" class=\"headerlink\" title=\"诊断启动问题\"></a>诊断启动问题</h3><p>命令行mysqld手动启动</p>\n<h3 id=\"查看错误日志\"><a href=\"#查看错误日志\" class=\"headerlink\" title=\"查看错误日志\"></a>查看错误日志</h3><p>MySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下几种。 </p>\n<ul>\n<li><strong>错误日志</strong>。它包含启动和关闭问题以及任意关键错误的细节。此 日志通常名为hostname.err，位于data目录中。此日志名可用 –log-error命令行选项更改。 </li>\n<li><strong>查询日志</strong>。它记录所有MySQL活动，在诊断问题时非常有用。此 日志文件可能会很快地变得非常大，因此不应该长期使用它。此 日志通常名为hostname.log，位于data目录中。此名字可以用 –log命令行选项更改。 </li>\n<li><strong>二进制日志</strong>。它记录更新过数据（或者可能更新过数据）的所有 语句。此日志通常名为hostname-bin，位于data目录内。此名字 可以用–log-bin命令行选项更改。注意，这个日志文件是MySQL 5中添加的，以前的MySQL版本中使用的是更新日志。 </li>\n<li><strong>缓慢查询日志</strong>。顾名思义，此日志记录执行缓慢的任何查询。这 个日志在确定数据库何处需要优化很有用。此日志通常名为 hostname-slow.log ，位于data 目录中。此名字可以用 –log-slow-queries命令行选项更改。 在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文 件。 </li>\n</ul>\n<p>在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。 </p>\n<h2 id=\"改善性能\"><a href=\"#改善性能\" class=\"headerlink\" title=\"改善性能\"></a>改善性能</h2><ul>\n<li>首先，MySQL（与所有DBMS一样）具有<strong>特定的硬件建议</strong>。在学 习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但 对用于生产的服务器来说，应该坚持遵循这些硬件建议。</li>\n<li>一般来说，关键的生产DBMS应该运行在自己的<strong>专用服务器</strong>上。 </li>\n<li>MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你<strong>可能需要调整内存分配、缓冲区大小等。</strong>（为查看当前设置，可使用SHOW VARIABLES;和SHOW STATUS;。） </li>\n<li>MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。<strong>如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢</strong>。如果你遇到显著的性能不良，可使用SHOW PROCESSLIST 显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录） 。 </li>\n<li>总是有<strong>不止一种方法编写同一条SELECT语句</strong>。应该试验联结、并、 子查询等，找出最佳的方法。 </li>\n<li>使用<strong>EXPLAIN语句</strong>让MySQL<strong>解释它将如何执行一条SELECT语句</strong>。 </li>\n<li>一般来说，<strong>存储过程执行得比一条一条地执行其中的各条MySQL语句快</strong>。 </li>\n<li>应该总是使用正确的数据类型。 </li>\n<li>决<strong>不要检索比需求还要多的数据</strong>。换言之，不要用SELECT *（除 非你真正需要每个列）。 </li>\n<li>有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li>\n<li><strong>在导入数据时，应该关闭自动提交</strong>。你<strong>可能还想删除索引</strong>（包括 FULLTEXT索引），然后在导入完成后再重建它们。 </li>\n<li><strong>必须索引数据库表以改善数据检索的性能</strong>。确定索引什么不是一件微不足道的任务，需要分析使用的SELECT语句以找出重复的 WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。 </li>\n<li>你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的<strong>UNION语句</strong>，你能看到极大的性能改 进。 </li>\n<li><strong>索引改善数据检索的性能，但损害数据插入、删除和更新的性能</strong>。 如果你有一些表，它们收集数据且不经常被搜索，则在有必要之 前不要索引它们。（索引可根据需要添加和删除。） </li>\n<li>LIKE很慢。一般来说，<strong>最好是使用FULLTEXT而不是LIKE</strong>。 </li>\n<li>数据库是不断变化的实体。一组优化良好的表一会儿后可能就面 目全非了。由于表的使用和内容的更改，理想的优化和配置也会 改变。 </li>\n<li>最重要的规则就是，每条规则在某些条件下都会被打破。 </li>\n</ul>\n<p><br><br> </p>\n<p><br><br></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><div style=\"margin-left: 5px  font-size:16px;\">\n[1]Ben Forta, Mysql必知必会. 北京：人民邮电出版社，2019.\n</div>"},{"title":"网络","declare":true,"wordCount":true,"abbrlink":"50daec4","date":"2020-06-29T11:10:10.000Z","_content":"\n![NetWork](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200629181240.png)\n<!-- more -->\n\n[interview_1](https://blog.csdn.net/shuningzhang/article/details/90138425)\n## 一、TCP/IP网络模型\n<table>        \n    <tr>\n        <th>OSI</th>\n        <th>TCP/IP</th>\n        <th>功能</th>\n        <th>TCP/IP协议簇</th>\n    </tr>\n    <tr>\n        <td>\n            应用层<br>\n            表示层<br>\n            会话层<br>\n        </td>\n        <td>应用层</td>\n        <td>\n            文件传输，电子邮件，文件服务<br>\n            数据格式化，数据加密<br>\n            接触或建立与别的结点的连接<br>\n        </td>\n        <td>\n            TFTP，HHTP，SMTP,FTP,DNS\n        </td>\n    </tr>\n    <tr>\n        <td>传输层</td>\n        <td>传输层</td>\n        <td>提供端对端的接口</td>\n        <td>TCP,UDP</td>\n    </tr>\n    <tr>\n        <td>网络层</td>\n        <td>网络层</td>\n        <td>为数据包选择路由</td>\n        <td>IP,ICMP,RIP</td>\n    </tr>\n    <tr>\n        <td>\n            数据链路层<br>\n            物理层<br>\n        </td>\n        <td>链路层</td>\n        <td>\n            |传输有错误的帧以及错误检测功能<br>\n            以二进制数据格式在物理媒介上传输数据<br>\n        </td>\n        <td>\n            ARP,SLIP<br>\n            ISO2110,IEEE802<br>\n        </td>\n    </tr>\n</table>\n\n1. 物理层\n    * 该层为上层协议提供了一个传输数据的可靠物理媒介。简单的说，物理层确保原始数据可在各种物理媒介中传输。\n        * 中继器\n        * 集线器\n2. 数据链路层\n    * 将源自网络层的数据可靠地传输到相邻结点的目标网络层。主要功能有**将数据融合成数据块（帧），控制帧在物理信道上的传输，处理传输差错，调节发送速率以使与接收方匹配**。主要作用即：**物理地址寻址，数据成帧，流量控制，数据的检错，重发**\n        * 数据链路层为网络层提供可靠的数据传输\n        * 基本数据的数据单位为帧\n        * 主要的协议：以太网协议\n        * 网桥\n        * 交换机\n3. 网络层\n    * 该层的目的是**实现两个主机系统之间的数据传输透明**，具体功能包括**寻址和路由选择，连接的建立与终止等**，**它提供的服务使传输层不需要了解网络层的数据传输和交换技术**，可简单记为**路径选择，路由及逻辑寻址**\n        * TCP/IP的核心协议————IP协议\n            * 功能包括有：无线数据包传输，数据包路由选择，差错控制\n            * 与其配套的协议有：地址解析协议ARP,因特网报文协议ICMP等\n        * 网络层负责对子网间的数据包进行路由选择，还可以实现拥塞控制，网际互联\n        * 基本数据单位为IP数据报\n        * 路由器\n4. 传输层\n    * 负责**将上层数据分段并提供端对端的，可靠或不可靠的传输**。此外，传输层还要**处理端到端的差错控制和流量控制**，其任务是根据通信子网的特性，最佳的利用网络资源，**为两个端系统的会话层之间，建立，维护和取消阐述连接的功能，负责端对端的可靠信息传输**，在这一层，信息传送的协议称为**段**或者**报文**，作用：**为应用进程之间提供端到端的逻辑通信**\n        * 传输层负责**将上层数据分段并提供端到端，可靠或者不可靠的传输以及端到端的差错控制以及流量控制**\n        * **TCP协议**，**UDP协议**\n        * 网关\n5. 会话层\n    \n* 管理主机之间的**会话进程**，负责**建立、管理、终止进程之间的会话**，还可利用在数据中插入校验点**实现数据同步**，包括建立检查点和恢复方案。\n    \n6. 表示层\n\n* 对上层数据或信息进行**变换**以保证**一个主机的信息可以被另外一个主机的应用程序理解**，包括对数据的**加密，压缩，格式转换**等，数据描述使得应用程序不必担心计算机内部存储格式的问题。\n    \n7. 应用层\n    * 最靠近用户的层，**为用户的应用进程提供网络服务的接口，将用户的操作通过应用进程转换为服务，并匹配一个相应的服务协议发送给传输层**\n        >传输数据时可以只是使用（传输层）协议，但是没有应用层的话便无法识别数据内容。如果要使传输的数据有意义，则必须使用应用层协议。\n\n<br><br><br>\n\n***\n***\n\n<br><br><br>\n\n\n## 二、TCP和UDP\n\n### 2.1 TCP和UDP的区别\n||UDP|TCP|\n|--|--|--|\n|是否连接|无连接|有连接|\n|是否可靠|不可靠，不使用流量控制和拥塞控制|可靠传输，使用流量控制和拥塞控制|\n|是否有序|无序|有序|\n|是否有界|有界|无界|\n|重传机制|无|超时重传机制，快速重传机制|\n|连接对象个数|一对一，一对多，多对一，多对多|一对一|\n|传输方式|面向报文|面向数据流|\n|首部开销|小，仅8字节|最小20字节，最大60字节|\n|适用场景|实时应用（视频会议，直播）|适用于可靠的应用（文件传输）|\n\n* 是否有界\n    >**TCP通过字节流传输**，即TCP将应用程序看成是一连串的无结构的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。 而**UDP传输报文的方式是由应用程序**控制的，**应用层**交给UDP多长的报文，UDP照样发送，**既不拆分，也不合并，而是保留这些报文的边界**，即一次发送一个报文。有界与无界之分是根据接收报文来划分的，对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的,**UDP无缓存服务，信息确认由应用层完成**。\n* TCP黏包问题\n    >由于**TCP协议**本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会维持一个连接（Channel），数据在连接不断开的情况下，可以持续不断地将多个数据包发往服务器，但是如果发送的网络数据包太小，那么他本身会启用**Nagle算法**（可配置是否启用）**对较小的数据包进行合并**（基于此，TCP的网络延迟要UDP的高些）然后再发送（超时或者包大小足够）。**那么这样的话，服务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包**；服务器在接收到数据库后，放到缓冲区中，**如果消息没有被及时从缓存区取走**，下次在取数据的时候可能就会出现一次取出多个数据包的情况，造成粘包现象。\n\n    >* 发送定长的数据 **不能完全解决** 会出现不知道从哪里开始分离固定长度的数据的情况(没有被及时从缓存区取走)\n    >* **自定制协议** [定长结构体(标识该条数据长度)]12345[分隔符]\n\n* TCP分包问题：\n    >可能是**IP分片传输**导致的，也可能是**传输过程中丢失部分包导致出现的半包**，还有**可能就是一个包可能被分成了两次传输**，在取数据的时候，先取到了一部分（还可能与接收的缓冲区大小有关系），总之就是一个数据包被分成了多次接收。\n\n\n    \n* UDP无连接  \n首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。具体来说就是：\n    >在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了.在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作\n\n<br><br>\n\n***\n\n<br><br>\n\n### 2.2 TCP特性\n* [TCP的各种机制](https://blog.csdn.net/Cecilia3333/article/details/80358201)\n    * 可靠性\n        * **确认应答机制**（ACK）\n        * **超时重传机制**\n        * **校验和**\n    * 流量控制\n        * **滑动窗口机制**（ARQ)\n            >滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。\n    * 拥塞控制\n        * 防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载\n        * 具体实现\n            >**慢启动**（Slow Start）发送方维护拥塞窗口变量cwnd，先用小数据试探网络拥塞，没问题后来断加倍.\n            >**拥塞避免**（Congestion voidance）：拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1\n            >**快速重传**（Fast Retransmit）：快重传要求接收方收到失序报文段后立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n            >**快速恢复**（Fast Recovery）：当发送方连续收到三个重复确认时，就把慢开始门限ssthresh门限减半。接下来将cwnd设置为ssthresh的大小，然后执行拥塞避免算法\n            * **捎带应答**\n\n<br><br>\n\n***\n\n<br><br>\n\n### 2.3 TCP连接的建立与终止过程\n\n![TCP传输过程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/TCP传输过程.png)\n\n![TCP三次握手](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628132143.png)\n\n![TCP四次挥手](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628132341.png)\n\n* 三次握手\n    * 第一次握手：客户端将标志位SYN置为1，表示请求同步（建立连接）。随机产生一个值seq=x，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。\n    * 第二次握手：服务器端将标志位SYN置为1表示请求同步，ACK置为1表示收到请求。ack=x+1，用于给客户端和之前传送过来的seq校验。随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。\n    * 第三次握手：客户端收到确认后，检查ACK是否为1，ack是否为x+1，如果正确则将标志位ACK置为1，ack=y+1，seq=传过来的ack=x+1，并将该数据包发送给服务器端，并进入ESTABLISHED状态。服务器端检查ACK是否为1，ack是否为y+1，如果正确则连接建立成功服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。假如第三次握手没有到达服务器端呢？但是这时客户端已进入ESTABLISHED状态。但是其实这种情况下，只要客户端向服务器端写数据，就会收到服务器端的RST（复位）应答，这时客户端就能知道出现问题了。\n* 三次握手的漏洞\n但是在TCP三次握手中是有一个缺陷的。利用三次握手的缺陷可以进行**SYN洪泛攻击**。\n    * SYN洪泛攻击：通过网络服务所在的端口发送**大量伪造原地址的攻击报文**，发送到服务端，**造成服务端上的半开连接队列被占满**，从而阻止其他用户进行访问。\n    * 原理：攻击者客户端利用伪造的IP地址向服务端发出请求(第一次握手)，**而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(永远都不会有的)**，服务端在**等待这种半开的连接过程中消耗了资源**，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。\n    * 解决方案： \n        * 无效连接监视释放\n        >这种方法不停监视所有的连接，包括三次握手的，还有握手一次的，反正是所有的，当达到一定(与)阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，不管是正常的还是攻击的，所以这种方式不推荐。\n        * 延缓TCB分配方法\n        >一般的做完第一次握手之后，服务器就需要为该请求分配一个TCB（连接控制资源），通常这个资源需要200多个字节。延迟TCB的分配，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。\n        * 使用防火墙\n        >防火墙在确认了连接的有效性后，才向内部的服务器（Listener）发起SYN请求，\n\n* 四次挥手\n    * 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n    * 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于**半关闭状态**，即客户端已经没有数据要发送了，但是**服务器若发送数据，客户端依然要接受**。这个状态还要持续一段时间，也就是整个**CLOSE-WAIT状态**持续的时间。\n    * 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n    * 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n    * 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2 MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n\n\n* 四次挥手的原因\n    \n    **防止客户端失效的连接请求报文段突然又传到服务器**\n    *例如以下情况如果使用两次握手*：\n    \n    > 如果客户端向服务器发送第一次连接请求在网络节点上滞留了，没有收到服务器的确认，于是又重新发送了一次连接请求，服务器收到客户端的第二次请求发送确认，则连接建立完成，服务器客户端进行数据传输，传输完成断开连接。此时，**在网络上滞留的客户端第一次连接请求到达服务器，服务器发送确认连接但是客户端实际上并没有发送请求，因此不会理睬服务器发送的请求。但是服务器认为连接已完成，并等待客户端进行数据传输**。这样会造成资源的浪费\n    \n    *如果采用三次握手的话*：\n    \n    > 滞留在网络上的客户端第一次请求到达服务器之后，服务器发送确认，但实际上服务器并没有发送请求，因此不会理睬服务器的确认，故不会发送确认，服务器等不到客户端的确认则连接建立失败。这样就防止了客户端失效的连接请求报文段突然又传到服务器\n\n* TCP连接点的终止为啥是四次挥手而不是三次\n![TCP四次挥手原因](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/四次挥手原因.png)\n\n* TIME_WAIT状态：\n    >主动关闭放进入TIME_WAIT状态后，等待被动连接放发送FIN分节，如果直接关闭的话，系统可能会有一个与主动关闭方相同的新进程与被动连接方进行通讯，造成信息泄露。\n        \n<br><br><br>\n\n***\n***\n\n<br><br><br>\n\n\n\n## 三、IP Address\n\n![IP Address](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IP地址.png)\n\n### 3.1 IP地址的分类\n* A类地址：首位为0，1.0.0.1~127.255.255.254；主机号24位\n* B类地址：首位为10，128.0.0.1~191.255.255.254；主机号16位\n* C类地址：首位为110，192.0.0.1~223.255.255.254；主机号8位\n* D类地址（多播地址，也叫做组播地址）：首位为1110，224.0.0.1~239.255.255.254\n* E类地址：此类地址是保留地址，首位为11110，240.0.0.1~254.255.255.254\n\n\n* 广播地址\n    广播地址(Broadcast Address)是专门**用于同时向网络中所有工作站进行发送的一个地址**。\n\n    在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。\n\n    * 计算广播地址\n        广播地址：网络地址的主机位全部变成1 ，10011111 即159 即：202.112.14.159\n\n* 回环地址\n    127.0.0.1，通常被称为本地回环地址(Loop back address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在windows操作系统中也有相似的定义，所以通常在不安装网卡前就可以ping通这个本地回环地址。**一般都会用来检查本地网络协议、基本数据接口等是否正常的**\n\n<br><br>\n\n***\n\n<br><br>\n\n### 3.2 IP地址的主机ID与网络ID\n\n* **IP地址=网络地址+主机地址**\n    * 计算网络ID：只需要将**IP地址和子网掩码进行与运算**，所得结果即为该主机的网络ID\n    ```\n        有IP地址192.168.0.1，对应的子网掩码为255.255.255.0；\n\n        将IP地址和子网掩码全部转换成二进制的形式，即IP地址是：11000000.10101000.00000000.00000001 ，子网掩码是：11111111.11111111.11111111.00000000；\n\n        将二进制形式的IP地址和子网掩码进行与运算；\n\n        运算结果为11000000.10101000.00000000.00000000，转换为十进制就是192.168.0.0，所以这个主机的网络ID就是192.168.0.0。\n    ```\n    * 计算主机ID：只需要将**子网掩码进行二进制按位取反，再和IP地址进行与运算**，所得结果即为该主机的主机ID\n    ```\n        有IP地址192.168.0.1，对应的子网掩码为255.255.255.0；\n\n        将子网掩码转换成二进制的形式，即就是：11111111.11111111.11111111.00000000；\n\n        将子网掩码进行二进制按位取反，即就是：00000000.00000000.00000000.11111111;\n\n        将取反后的子网掩码和IP地址的二进制形式进行与运算；\n\n        结果为：00000000.00000000.00000000.00000001,转换为十进制就是0.0.0.1,所以这个主机的网络ID就是192.168.0.0。\n    ```\n    * 主机数\n    主机号有5位，那么这个地址中，就只能有25−2=3025−2=30个主机\n    因为其中全0作为网络地址，全1作为广播地址\n    \n<br><br>\n\n***\n\n<br><br>\n\n\n### 3.3 [子网划分](https://blog.csdn.net/gui951753/article/details/79412524)\n* 为什么进行子网划分\n    * **减少网络流量**\n    * **优化网络性能**，这是减少网络流量的结果。\n    * **简化管理**，与庞大的网络相比，在一系列相连的小网络中找出并隔离网络问题更容易。\n    * **有助于覆盖大型地理区域**，WAN链路比LAN链路的速度慢得多，且更昂贵;单个大跨度的大型网络在前面说的各个方面都可能出现问题（网络流量太大，广播风暴），而将多个小网络连接起来可提高系统的效率。\n\n\n* 子网掩码\n    子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。<br><br>\n\n    子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。**将IP地址和子网掩码换算为二进制，子网掩码连续全1的是网络地址，后面的是主机地址**。<br><br>\n\n    子网掩码——屏蔽一个IP地址的网络部分的“全1”比特模式。对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。<br><br>\n\n    * 通过子网掩码，就可以判断两个IP在不在一个局域网内部。<br>\n\n    * 子网掩码可以看出有多少位是网络号，有多少位是主机号<br><br>\n\n    * ip段/数字-如192.168.0.1/24是什么意思?\n    ```\n        后面这个数字标示了我们的网络号的位数，也就是子网掩码中前多少号为1\n\n        129.168.1.1 /24 这个24就是告诉我们网络号是24位\n\n        也就相当于告诉我们了\n\n        子网掩码是：11111111 11111111 11111111 00000000\n\n        即：255.255.255.0\n\n        172.16.10.33/27 中的/27\n\n        也就是说子网掩码是255.255.255.224 即27个全1\n    ```\n    \n\n* 网关\n    网关(Gateway)又称网间连接器、协议转换器。**默认网关在网络层上以实现网络互连**，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。可以是路由器、三层交换机等设备<br>\n    \n    **网关实质上是一个网络通向其他网络的IP地址**\n    \n\n* 三层交换机\n    组合了集线器、路由器和交换机的功能，具有网络管理的一类设备，可以实现在一个设备中对多个虚拟子网的管理的一类设备\n\n\n<br><br><br>\n\n***\n\n<br><br><br>\n\n\n## 四、HTTP和HTTPS\n\n### 4.1 HTTP版本\n\n#### 4.1.1 HTTP/0.9\n* HTTP协议的最初版本，功能简陋，仅支持请求方式GET，并且仅能请求访问HTML格式的资源。\n\n#### 4.1.2 HTTP/1.0\n* 请求行必须在尾部添加协议版本字段（http/1.0）\n\n* 必须包含头消息\n\n* 在0.9版本上做了进步，增加了请求方式POST和HEAD\n\n* 不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等\n\n* 开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即\n\n* HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据\n\n* 新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。\n\n* 1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive\n\n* TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。\n\n* HTTP/1.0与HTTP/1.1对比\n    * 可扩展性\n    * HTTP/1.1在消息中增加版本号，用于兼容性判断。\n    * 新增了请求方式PUT、PATCH、OPTIONS、DELETE等。\n    * 带宽优化\n        >HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。例如，客户端只需要显示一个文档的部分内容，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。\n\n        >HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。\n\n        >另外一种情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限）， 此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。HTTP/1.1 加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。\n\n        >注意，HTTP/1.0 的客户端不支持100响应码。但可以让客户端在请求消息中加入Expect头域，并将它的值设置为100-continue。节省带宽资源的一个非常有效的做法就是压缩要传送的数据。Content-Encoding是对消息进行端到端（end-to-end）的编码，它可能是资源在服务器上保存的固有格式（如 jpeg 图片格式）；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式。\n    * 长连接和短连接\n        > **HTTP1.1默认保持长连接**（HTTP persistent connection，也翻译为**持久连接**），**数据传输完成了保持TCP连接不断开**（不发RST包、不四次握手），**等待在同域名下继续用这个通道传输数据**；(**管道机制**)\n\n        >相反的就是短连接。**在 HTTP/1.0 中，默认使用的是短连接**。也就是说，**浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接**。\n\n#### 4.1.3 HTTP/2.0 （2015年5月以RFC 7540正式发表）\n为了解决1.1版本利用率不高的问题，基于SPDY协议提出了HTTP/2.0版本。\n* 增加双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题（HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级）\n* 之前HTTP版本请求和响应中，状态行和请求/响应头都是些信息字段，并没有真正的数据，因此在2.0版本中将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表，他们之间就以索引号来表示信息字段，这样就避免了1.0旧版本的重复繁琐的字段，并以压缩的方式传输，提高利用率\n\n* 另外也增加服务器推送的功能，即不经请求服务端主动向客户端发送数据。\n\n#### 4.1.4 HTTP3.0 \n* 基于QUIC协议传输\n* TTP的范例和概念没有改变。它含有头部（header）和正文（body），请求和回复，还有动词（verb）、Cookie和缓存。HTTP/3的**主要改变是将这些报文比特传送到另一端的方式**。\n为了使HTTP可以通过QUIC传输，协议的某些方面要进行修改，修改的结果便是HTTP/3。这些必要修改是因QUIC与TCP在某些性质上的不同所致，修改包括：     \n    * 在QUIC中，数据流由传输层本身提供，而在HTTP/2中，流由HTTP层完成。     \n    * 由于数据流互相独立，HTTP/2中使用的头部压缩算法如果不做改动，会造成队头阻塞。  \n    * QUIC流与HTTP/2略有不同。本书的HTTP/3章节会做详细介绍。\n\n\n<br><br>\n\n***\n\n<br><br>\n\n\n### 4.2 [HTTP请求与响应过程](https://zhuanlan.zhihu.com/p/102237039)\n![HTTP请求和响应过程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628170939.png)\n\n* forward和redirect \n    * forward（**转发**）:服务器请求资源，**服务器直接访问目标地址URL**，把那个URL的响应内容读取过来然后发送给浏览器浏览器不知道服务器发送的数据从哪里来的，所以**地址栏中的地址还是原来的地址**。\n    * redirect（**重定向**）:服务端根据逻辑发送一个状态码，告诉**浏览器去请求那个地址**，所以**地址栏中的地址是目标URL**。\n\n<br><br>\n\n***\n\n<br><br>\n\n### 4.3 在浏览器中输入url到显示页面的过程\n1. **输入地址**\n    >当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。\n2. **浏览器查找域名的 IP 地址**\n    >2.1 请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先**查看本地硬盘的 hosts** 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。\n\n    >2.2 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 **DNS请求到本地DNS服务器**。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。\n\n    >2.3 查询你输入的网址的DNS请求到达本地DNS服务器之后，**本地DNS服务器会首先查询它的缓存记录**，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要**向DNS根服务器进行查询**。\n\n    >2.4 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以**到域服务器上去继续查询**，并给出域服务器的地址。**这种过程是迭代的过程**。\n\n    >2.5本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。\n\n    >2.6 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。\n\n3. **浏览器向 web 服务器发送一个 HTTP 请求**\n    >拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024<端口<65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口**发起TCP的连接请求**。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。\n\n4. **服务器的永久重定向响应**\n    >服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访 http://www.google.com/ 而非 http://google.com/ 。为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像 http://www.yy.com/和http://yy.com/ ，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现\n    \n5. **浏览器跟踪重定向地址**\n    > 现在浏览器知道了 http://www.google.com/ 才是要访问的正确地址，所以它会发送另一个http请求。\n\n6. **服务器处理请求**\n    > 经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？\n\n    >后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。\n\n    >一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。\n\n    >此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。\n\n7. **服务器返回一个 HTTP 响应**　\n    >经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。\n\n    >HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：**状态行、响应头(Response Header)、响应正文**\n\n8. **浏览器显示 HTML**\n    >在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了\n\n\n<br><br>\n\n***\n\n<br><br>\n\n\n### 4.4 HTTP传输过程\n![HTTP传输过程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200629082216.png)\n\n### 4.5 [报文格式](https://blog.csdn.net/aomize/article/details/78609301)\n[报文格式](https://blog.csdn.net/lyn_00/article/details/84953763) \n\n\n|信息|说明|\n|-|-|\n|起始行|对报文进行描述|\n|头部|向报文中添加了一些附加信息，是一个名/只的列表，头部和协议配合工作，共同决定了客户端和服务器能做什么事情|\n|主体|包含数据的主体部分|\n\n\n#### 4.5.1 响应报文格式\n![请求报文格式](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628205247.png)\n\n* HTTP请求起始行\n\n|方法|说明|\n|-|-|\n|GET|请求URL所指的文档|\n|POST|从客户端向服务器端发送一些信息|\n|HEAD|只请求文档的信息，而不包含文档的内容|\n|PUT|从服务器向客户端发送文档|\n|TRACE|把到达的请求回送|\n|CONNECT|保留|\n|OPTION|询问关于可用的选项|\n\n* Get和Post的区别 \n    * GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同\n    * GET在浏览器回退时是无害的，而POST会再次提交请求。\n    * GET产生的URL地址可以被Bookmark，而POST不可以。\n    * GET请求会被浏览器主动cache，而POST不会，除非手动设置。\n    * GET请求只能进行url编码，而POST支持多种编码方式。\n    * GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\n    * GET请求在URL中传送的参数是有长度限制的，而POST么有。\n    * 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\n    * GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\n    * GET参数通过URL传递，POST放在Request body中。\n    * 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\n    * 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。\n\n\n* HTTP请求头部\n\n|信息|说明|\n|-|-|\n|Accept|指浏览器或其他客户可以接爱的MIME文件格式。可以根据它判断并返回适当的文件格式|\n|Accept-Charset|指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1|\n|Accept-Language|指出浏览器可以接受的语言种类，如en或en-us，指英语|\n|Accept-Encoding|指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式|\n|Cache-Control|设置关于请求被代理服务器存储的相关选项。一般用不到|\n|Connection|用来告诉服务器是否可以维持固定的HTTP连接。HTTP/1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接|\n|Content-Type|用来表名request的内容类型。可以用HttpServletRequest的getContentType()方法取得|\n|Cookie|浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能|\n\n#### 4.5.2 响应报文格式\n\n![响应报文格式](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628205343.png)\n\n* HTTP响应起始行\n\n|方法|说明|\n|-|-|\n|Server|给出服务器相关信息|\n|Accept-Ranges|服务器将接受请求的字节范围|\n|Content-Type|指明媒体类型|\n|Content-Encoding|指明编码方案|\n|Location|请求客户将请求发送到另一站点|\n|Set-Cookie|服务器请求客户保存Cookie|\n|Upgrade|指明优先使用的通信协议|\n|Public|给出可以支持的文档清单|\n|Retry-afer|指明的日期之后，服务器才能使用|\n\n\n* HTTP常见状态码\n    * 1开头状态码\n        **表示请求已被接收，继续处理**\n\n    * 2开头状态码\n        **表示成功处理请求的状态代码**\n        * 200:通常表示服务器成功处理的请求\n        \n    * 3开头状态码\n        **表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向**\n        * 301:代表永久性转移\n        * 302:代表暂时性转移\n    * 4开头状态代码 **通常表示请求可能出现错误，妨碍了服务器的处理**\n        * 400：服务器不理解请求的语法\n        * 403：服务器拒绝请求\n        * 404：服务器找不到请求的网页\n\n    * 5开头状态码 **通常表示服务器在处理中这些请求时发生内错误。这些错误可能是服务器本身错误或是请求出错**\n        * 500(服务器内部错误):服务器遇到错误，无法完成请求\n        * 501(无法实施):服务器不具备完成请求的功能。例如服务器无法识别方法。\n        * 502(错误网关)：服务器作为网关或代理，从上游服务器收到无效响应。\n        * 503(服务不可用):服务器目前无法使用(由于超载或者停机维护)，通常这只是暂时转态。\n        * 504(网关超时):服务器作为网关或者代理，但是没有及时从上游服务器收到请求。\n        * 505(HHTP版本不受支持):服务器不支持请求中所使用的HTTP协议版本\n        \n        >重点：***200,304,403,500***\n\n<br><br>\n\n***\n\n<br><br>\n\n### 4.6 HTTP与HTTPS的区别  \n* HTTPS协议需要ca申请证书，一般免费证书较少，所以需要一定费用\n* HTTP是超文本协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议\n    * 在HTTP通信中加入了SSL层，通信的数据被加密了，防止被窃取，具体的通信流程如下：\n        ![](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/HTTPS加密传输.png)\n* HTTP和HTTPS使用的是两种完全不同的连接方式，用的端口也不一样，前者是80，后者是443\n* HTTP的连接很简单，是无状态的；HTTPS是有SSl+HTTP协议构成的可加密除数，身份认证的网络协议，比HTTP更安全\n\n\n\n###  4.7 [HTTPS实现原理](https://blog.csdn.net/u011547347/article/details/83186514)\n\n\n\n\n###  4.8 HTTP代理服务器\n工作在**应用层**，比价耗费资源\n* **提高访问速度**：通常代理服务器都设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的 信息时，则直接由缓冲区中 取出信息，传给用户，以提高\n访问速度。\n* **控制对内部资源的访问**：如某大学FTP（前提是该代理地址在该资源的允许访问范围之 内），使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。\n* **过滤内容**：例如限制对特定计算机的访问，将一种语言的数据翻译成另一种语言，或是防御代理服务器两边的攻击性访问。\n* **隐藏真实IP**：上网者也可以通过代理服务器隐藏自己的IP，免受攻击。但是只一个代 理很难保证安全，更安全的方法是利用特定的工具创建代理链\n* **突破自身IP访问限制**：访问国外站点。中国教育网和169网等网络用户可以通过代理访 问国外网站。\n* **突破内容过滤机制限制，访问被过滤网站**。\n\n<br><br><br>\n\n***\n***\n\n<br><br><br>\n\n## 附录\n\n### 1. 常用网络测试命令及应用\n\n#### ping命令\n```ini\nPing [-t] [-a] [-n count] [-l length] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [-j HostList]| [-k HostList] [-w timeout] destination –list\n\nv-t，不间断地ping指定的主机，直到按“Ctrl+C” 组合键中断为止。\nv-a，指定对目的地IP地址进行反向名称解析。如 果解析成功，将显示相应的主机名。\nv-n count，发送count指定的ECHO数据包数，默认值为4。\n-l length，自定义发送数据包的大小，也就是发送由length指定大小的ECHO数据包，默认为32字节，最 大值是65527字节。\nv-f，指定发送的回响请求消息带有“不要拆分”标志（所在的IP标题设为1）\nv-i TTL，指定发送回响请求消息的IP标题中的TTL字段值。\nv-v TOS，指定发送回响请求消息的IP标题中的“服务 类型 (TOS)”字段值，默认值是0。TOS被指定为0到 255的十进制数。\nv-r count，指定IP标题中的“记录路由”选项用于记录由回响请求消息和相应的回响应答消息使用的路径\n```\n* 功能\n    * ping 127.0.0.1：检查TCP/IP是否被正确地安装。 \n    * ping本机IP：ping本地计算机的IP地址，本地计算 机对该ping命令作出应答。如果没有应答，则表示本地 配置或安装存在问题。出现此问题时，局域网用户可断开 网络电缆，然后重新发送该命令。如果网线断开后本命令 正确，则表示另一台计算机可能配置额相同的IP地址。\n    * ping局域网内其他主机IP：如果收到回送应答，表 明本地网络中的网卡和传输介质运行正确。但如果没有收 到回送应答，那么表示子网掩码不正确或网卡配置错误，或电缆线路有问题。\n    * ping网关IP：该命令如果应答正确，表示局域网中 的网关路由器正在运行以及能否与本地网络上的本地主机 通讯。\n    * ping远程主机IP：如果收到4个应答，表示成功地 使用了缺省网关。对于拨号上网用户则表示能够成功地访 问Internet。\n    * ping域名：ping域名，如 ping www.sina.com.cn ，通常是通过DNS服务器进行解析。 如果这里出现故障，则表示DNS服务器的IP地址配置不 正确或DNS服务器有故障。另外，利用该命令可以实现域名对IP地址的转换功能。\n\n####  \n```ini\n    nslookup www.*.com\n```\n\n* 功能\n    * nslookup是一个监测网络中DNS服务器是否能正确实现域名解析的命令行 工具。它在 UNIX/Windows NT/2000/XP中均可使用。nslookup必须要 安装了TCP/IP的网络环境中才能使用。\n    * 如果需要对DNS的故障进行排错就必须熟练使用工具nslookup。这个命令 可以指定查询的类型，可以查到DNS记录的生存时间，还可以指定使用哪个DNS服务器进行解释。\n\n#### ipconfig命令\n```ini\n    ipconfig [/all /renew [adapter] /release [adapter]] [/flushdns] [/displaydns] [/registerdns] [/showclassid Adapter] [/setclassid Adapter [ClassID]]\n```\n\n* 功能\n    * ipconfig用于显示当前的TCP/IP网络配置的设置值、刷 新动态主机配置协议（DHCP）和域名系统（DNS）设置。 使用不带参数的ipconfig可以显示所有适配器的IP地址、子网掩码和默认网关。\n    * ipconfig一般用来检验人工配置的TCP/IP设置是否正确。 如果计算机和所在的局域网使用了动态主机配置协议 （DHCP），这个程序所显示的信息可以让用户了解自己 的计算机是否成功的租用到一个IP地址，如果租用到则可 以了解它目前分配到的具体地址。了解计算机当前的IP地 址、子网掩码和缺省网关实际上是进行测试和故障分析的必要条件。\n\n* 范例\n    * 要显示所有适配器的完整TCP/IP配置，键入 `ipconfig/all。`\n    * 仅更新“本地连接”适配器的由DHCP分配IP地址 的配置，键入 `ipconfig /renew \"Local Area Connection\"`\n    * 要在排除DNS的名称解析故障期间清理DNS解析器 缓存，键入`ipconfig /flushdns`\n    * 要显示名称以Local开头的所有适配器的DHCP类别 ID，键入`ipconfig /showclassid Local`\n    * 要将“本地连接”适配器的DHCP类别ID设置为 TEST，键入`ipconfig /setclassid \"Local Area Connection\" TEST`\n\n<br><br>\n\n***\n\n<br><br>\n\n### 2. 网络流量监视命令\n|命令名称|适用的操作系统|功能说明|\n|-|-|-|\n|ping|UNIX/Windows|用于测量往返数据包丢失率|\n|bing|UNIX|测量线路的点到点带宽|\n|etherfind|UNIX|检查以太网数据包|\n|snoop|UNIX|捕获并检查网络数据包|\n|tcpdump|UNIX|网络的dumps流量|\n|getethers|UNIX|获取一个以太网局域网网段中所有主机的地址|\n|iptrace|UNIX|测量网关的性能|\n|netstat|UNIX/Windows|显示各种网络相关数据结构的内容|\n|arp|UNIX/Windows|显示并修改Internet到Ethernet地址转换表|\n|tracert|UNIX/Windows|追踪有路由延迟的目标机的路由|\n|route|UNIX/Windows|显示、人工添加和修改路由表项目|\n|pathping|UNIX/Windows|显示有关在源和目标主机之间的中间跃点处的网络 滞后和网络丢失的信息|\n\n* 其中一个是**ping**命令，重复执行大量的ping命令（ICMP回显 请求消息）可测算出接收的成功次数，就可以计算出数据包丢失的百分率。包丢失是一种吞吐量的测算。\n* 另一个常用的命令是点到点带宽**bing**命令，这个命令是以ping 为基础的，通过线路两端发送数据包的大小不同而产生的往返时间差进行计算，可以得出粗略的吞吐量数据。\n* 其他5个命令可以检查在网络中经过的数据包，分别提供不同的 输出。命令**etherfind**、**snoop**和**tcpdump**把网卡置于混杂模式中（在这种模式中，收集网络中未经处理的数据无需经过任 何过滤）并记录数据。命令**getethers**可以得到所有局域网网段 的主机名和以太网地址对。工具**iptrace**在UNIX内核中使用 NETMON程序，产生3类输出：IP流量、主机流量矩阵输出和预先定义数据包号的简短取样。\n* **netstat**命令可以帮助网络管理员了解网络的整体使用情 况。它可以显示当前正在活动的网络连接的详细信息，例 如，显示网络连接、路由表和网络接口信息，可以统计目前总共有哪些网络连接正在进行。命令格式语法： `netstat [-a] [-e] [-n] [-o] [-p Protocol] [-r] [-s] [Interval]`,\n* 使用**arp**命令，能够查看本地计算机或另一台计 算机的ARP高速缓存中的当前内容。此外，使用 arp命令，也可以用人工方式输入静态的网卡物 理和IP地址对，使用这种方式为缺省网关和本地 服务器等常用主机进行这项操作，有助于减少网络上的信息量。ARP命令格式：`arp [-a [InetAddr] [-N IfaceAddr]] [-g [InetAddr] [-N IfaceAddr]] [-d InetAddr [IfaceAddr]] [-s InetAddr EtherAddr [IfaceAddr]]`\n* **tracert**一般用来检测故障的位置，虽然还是不能确定 具体故障原因，但已经能显示问题所在的地方。另外， traceroute命令的功能与tracert相同，二者的差别仅 仅在于tracert命令是用在Windows平台上，而traceroute命令是用在Unix平台和路由器上。\n* **tracert**命令用来显示数据包到达目标主机所经过的路径，并 显示到达每个节点的时间。命令格式如下：`Tracert IP地址或主机名 [-d] [-h maximum_hops] [-j host_list] [-w timeout]`\n* **route**命令用来显示、人工添加和修改路由表项目的。 route命令格式：`route [-f] [-p] [[print] [add] [change] [delete] [Destination] [mask subnetmask] [Gateway] [metric Metric]] [if Interface]`\n\n<br><br>\n\n***\n\n<br><br>\n\n### 3. 专有名词\n* CDN\n    * CDN的全称是<code>Content Delivery Network</code>，即<code>内容分发网络</code>，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户<code>就近</code>获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有<code>内容存储</code>和<code>分发技术</code>。\n\n* DNS\n    * <p>你有没有想过为什么你可以通过键入 <code>www.google.com</code> 就能够获取你想要的网站？我们上面说到，计算机网络中的每个端系统都有一个 IP 地址存在，而把 IP 地址转换为便于人类记忆的协议就是 <code>DNS 协议</code>。</p><br><p>DNS 的全称是<code>域名系统（Domain Name System，缩写：DNS）</code>，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>\n    \n* URL   \n    * <p>我们上面提到，你可以通过输入 <code>www.google.com</code> 地址来访问谷歌的官网，那么这个地址有什么规定吗？我怎么输都可以？AAA.BBB.CCC 是不是也行？当然不是的，你输入的地址格式必须要满足 <code>URI</code> 的规范。</p><br>  <p><code>URI</code>的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>   <br><p><code>URL</code>的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的<code>网址</code>，它实际上是 URI 的一个子集。</p><p>URI 不仅包括 URL，还包括 URN（统一资源名称），它们之间的关系如下</p>\n\n    <img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/URI组成.png\" data-caption=\"URI组成\" />\n\n\n\n<br><br><br>\n\n* 推荐文章\n    * https://zhuanlan.zhihu.com/p/102237039\n    * https://blog.csdn.net/weixin_44367006/article/details/99768731\n\n\n* 参考    \n[1]https://blog.csdn.net/liuyanfeier/article/details/52787037\n[2]https://blog.csdn.net/qq_32374237/article/details/86242159\n[3]https://blog.csdn.net/gui951753/article/details/79412524\n[4]https://blog.csdn.net/lyn_00/article/details/84953763\n[5]https://blog.csdn.net/moge19/article/details/90050030\n[6]https://zhuanlan.zhihu.com/p/102237039\n[7]https://blog.csdn.net/weixin_44367006/article/details/99768731\n[8]https://blog.csdn.net/qq_33663020/article/details/79386252","source":"_posts/code/NetWork/网络.md","raw":"---\ntitle: 网络\ncategories: Code\ntags: NetWork\ndeclare: true\nwordCount: true\nabbrlink: 50daec4\ndate: 2020-06-29 19:10:10\n---\n\n![NetWork](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200629181240.png)\n<!-- more -->\n\n[interview_1](https://blog.csdn.net/shuningzhang/article/details/90138425)\n## 一、TCP/IP网络模型\n<table>        \n    <tr>\n        <th>OSI</th>\n        <th>TCP/IP</th>\n        <th>功能</th>\n        <th>TCP/IP协议簇</th>\n    </tr>\n    <tr>\n        <td>\n            应用层<br>\n            表示层<br>\n            会话层<br>\n        </td>\n        <td>应用层</td>\n        <td>\n            文件传输，电子邮件，文件服务<br>\n            数据格式化，数据加密<br>\n            接触或建立与别的结点的连接<br>\n        </td>\n        <td>\n            TFTP，HHTP，SMTP,FTP,DNS\n        </td>\n    </tr>\n    <tr>\n        <td>传输层</td>\n        <td>传输层</td>\n        <td>提供端对端的接口</td>\n        <td>TCP,UDP</td>\n    </tr>\n    <tr>\n        <td>网络层</td>\n        <td>网络层</td>\n        <td>为数据包选择路由</td>\n        <td>IP,ICMP,RIP</td>\n    </tr>\n    <tr>\n        <td>\n            数据链路层<br>\n            物理层<br>\n        </td>\n        <td>链路层</td>\n        <td>\n            |传输有错误的帧以及错误检测功能<br>\n            以二进制数据格式在物理媒介上传输数据<br>\n        </td>\n        <td>\n            ARP,SLIP<br>\n            ISO2110,IEEE802<br>\n        </td>\n    </tr>\n</table>\n\n1. 物理层\n    * 该层为上层协议提供了一个传输数据的可靠物理媒介。简单的说，物理层确保原始数据可在各种物理媒介中传输。\n        * 中继器\n        * 集线器\n2. 数据链路层\n    * 将源自网络层的数据可靠地传输到相邻结点的目标网络层。主要功能有**将数据融合成数据块（帧），控制帧在物理信道上的传输，处理传输差错，调节发送速率以使与接收方匹配**。主要作用即：**物理地址寻址，数据成帧，流量控制，数据的检错，重发**\n        * 数据链路层为网络层提供可靠的数据传输\n        * 基本数据的数据单位为帧\n        * 主要的协议：以太网协议\n        * 网桥\n        * 交换机\n3. 网络层\n    * 该层的目的是**实现两个主机系统之间的数据传输透明**，具体功能包括**寻址和路由选择，连接的建立与终止等**，**它提供的服务使传输层不需要了解网络层的数据传输和交换技术**，可简单记为**路径选择，路由及逻辑寻址**\n        * TCP/IP的核心协议————IP协议\n            * 功能包括有：无线数据包传输，数据包路由选择，差错控制\n            * 与其配套的协议有：地址解析协议ARP,因特网报文协议ICMP等\n        * 网络层负责对子网间的数据包进行路由选择，还可以实现拥塞控制，网际互联\n        * 基本数据单位为IP数据报\n        * 路由器\n4. 传输层\n    * 负责**将上层数据分段并提供端对端的，可靠或不可靠的传输**。此外，传输层还要**处理端到端的差错控制和流量控制**，其任务是根据通信子网的特性，最佳的利用网络资源，**为两个端系统的会话层之间，建立，维护和取消阐述连接的功能，负责端对端的可靠信息传输**，在这一层，信息传送的协议称为**段**或者**报文**，作用：**为应用进程之间提供端到端的逻辑通信**\n        * 传输层负责**将上层数据分段并提供端到端，可靠或者不可靠的传输以及端到端的差错控制以及流量控制**\n        * **TCP协议**，**UDP协议**\n        * 网关\n5. 会话层\n    \n* 管理主机之间的**会话进程**，负责**建立、管理、终止进程之间的会话**，还可利用在数据中插入校验点**实现数据同步**，包括建立检查点和恢复方案。\n    \n6. 表示层\n\n* 对上层数据或信息进行**变换**以保证**一个主机的信息可以被另外一个主机的应用程序理解**，包括对数据的**加密，压缩，格式转换**等，数据描述使得应用程序不必担心计算机内部存储格式的问题。\n    \n7. 应用层\n    * 最靠近用户的层，**为用户的应用进程提供网络服务的接口，将用户的操作通过应用进程转换为服务，并匹配一个相应的服务协议发送给传输层**\n        >传输数据时可以只是使用（传输层）协议，但是没有应用层的话便无法识别数据内容。如果要使传输的数据有意义，则必须使用应用层协议。\n\n<br><br><br>\n\n***\n***\n\n<br><br><br>\n\n\n## 二、TCP和UDP\n\n### 2.1 TCP和UDP的区别\n||UDP|TCP|\n|--|--|--|\n|是否连接|无连接|有连接|\n|是否可靠|不可靠，不使用流量控制和拥塞控制|可靠传输，使用流量控制和拥塞控制|\n|是否有序|无序|有序|\n|是否有界|有界|无界|\n|重传机制|无|超时重传机制，快速重传机制|\n|连接对象个数|一对一，一对多，多对一，多对多|一对一|\n|传输方式|面向报文|面向数据流|\n|首部开销|小，仅8字节|最小20字节，最大60字节|\n|适用场景|实时应用（视频会议，直播）|适用于可靠的应用（文件传输）|\n\n* 是否有界\n    >**TCP通过字节流传输**，即TCP将应用程序看成是一连串的无结构的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。 而**UDP传输报文的方式是由应用程序**控制的，**应用层**交给UDP多长的报文，UDP照样发送，**既不拆分，也不合并，而是保留这些报文的边界**，即一次发送一个报文。有界与无界之分是根据接收报文来划分的，对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的,**UDP无缓存服务，信息确认由应用层完成**。\n* TCP黏包问题\n    >由于**TCP协议**本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会维持一个连接（Channel），数据在连接不断开的情况下，可以持续不断地将多个数据包发往服务器，但是如果发送的网络数据包太小，那么他本身会启用**Nagle算法**（可配置是否启用）**对较小的数据包进行合并**（基于此，TCP的网络延迟要UDP的高些）然后再发送（超时或者包大小足够）。**那么这样的话，服务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包**；服务器在接收到数据库后，放到缓冲区中，**如果消息没有被及时从缓存区取走**，下次在取数据的时候可能就会出现一次取出多个数据包的情况，造成粘包现象。\n\n    >* 发送定长的数据 **不能完全解决** 会出现不知道从哪里开始分离固定长度的数据的情况(没有被及时从缓存区取走)\n    >* **自定制协议** [定长结构体(标识该条数据长度)]12345[分隔符]\n\n* TCP分包问题：\n    >可能是**IP分片传输**导致的，也可能是**传输过程中丢失部分包导致出现的半包**，还有**可能就是一个包可能被分成了两次传输**，在取数据的时候，先取到了一部分（还可能与接收的缓冲区大小有关系），总之就是一个数据包被分成了多次接收。\n\n\n    \n* UDP无连接  \n首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。具体来说就是：\n    >在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了.在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作\n\n<br><br>\n\n***\n\n<br><br>\n\n### 2.2 TCP特性\n* [TCP的各种机制](https://blog.csdn.net/Cecilia3333/article/details/80358201)\n    * 可靠性\n        * **确认应答机制**（ACK）\n        * **超时重传机制**\n        * **校验和**\n    * 流量控制\n        * **滑动窗口机制**（ARQ)\n            >滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。\n    * 拥塞控制\n        * 防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载\n        * 具体实现\n            >**慢启动**（Slow Start）发送方维护拥塞窗口变量cwnd，先用小数据试探网络拥塞，没问题后来断加倍.\n            >**拥塞避免**（Congestion voidance）：拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1\n            >**快速重传**（Fast Retransmit）：快重传要求接收方收到失序报文段后立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n            >**快速恢复**（Fast Recovery）：当发送方连续收到三个重复确认时，就把慢开始门限ssthresh门限减半。接下来将cwnd设置为ssthresh的大小，然后执行拥塞避免算法\n            * **捎带应答**\n\n<br><br>\n\n***\n\n<br><br>\n\n### 2.3 TCP连接的建立与终止过程\n\n![TCP传输过程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/TCP传输过程.png)\n\n![TCP三次握手](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628132143.png)\n\n![TCP四次挥手](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628132341.png)\n\n* 三次握手\n    * 第一次握手：客户端将标志位SYN置为1，表示请求同步（建立连接）。随机产生一个值seq=x，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。\n    * 第二次握手：服务器端将标志位SYN置为1表示请求同步，ACK置为1表示收到请求。ack=x+1，用于给客户端和之前传送过来的seq校验。随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。\n    * 第三次握手：客户端收到确认后，检查ACK是否为1，ack是否为x+1，如果正确则将标志位ACK置为1，ack=y+1，seq=传过来的ack=x+1，并将该数据包发送给服务器端，并进入ESTABLISHED状态。服务器端检查ACK是否为1，ack是否为y+1，如果正确则连接建立成功服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。假如第三次握手没有到达服务器端呢？但是这时客户端已进入ESTABLISHED状态。但是其实这种情况下，只要客户端向服务器端写数据，就会收到服务器端的RST（复位）应答，这时客户端就能知道出现问题了。\n* 三次握手的漏洞\n但是在TCP三次握手中是有一个缺陷的。利用三次握手的缺陷可以进行**SYN洪泛攻击**。\n    * SYN洪泛攻击：通过网络服务所在的端口发送**大量伪造原地址的攻击报文**，发送到服务端，**造成服务端上的半开连接队列被占满**，从而阻止其他用户进行访问。\n    * 原理：攻击者客户端利用伪造的IP地址向服务端发出请求(第一次握手)，**而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(永远都不会有的)**，服务端在**等待这种半开的连接过程中消耗了资源**，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。\n    * 解决方案： \n        * 无效连接监视释放\n        >这种方法不停监视所有的连接，包括三次握手的，还有握手一次的，反正是所有的，当达到一定(与)阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，不管是正常的还是攻击的，所以这种方式不推荐。\n        * 延缓TCB分配方法\n        >一般的做完第一次握手之后，服务器就需要为该请求分配一个TCB（连接控制资源），通常这个资源需要200多个字节。延迟TCB的分配，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。\n        * 使用防火墙\n        >防火墙在确认了连接的有效性后，才向内部的服务器（Listener）发起SYN请求，\n\n* 四次挥手\n    * 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n    * 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于**半关闭状态**，即客户端已经没有数据要发送了，但是**服务器若发送数据，客户端依然要接受**。这个状态还要持续一段时间，也就是整个**CLOSE-WAIT状态**持续的时间。\n    * 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n    * 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n    * 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2 MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n\n\n* 四次挥手的原因\n    \n    **防止客户端失效的连接请求报文段突然又传到服务器**\n    *例如以下情况如果使用两次握手*：\n    \n    > 如果客户端向服务器发送第一次连接请求在网络节点上滞留了，没有收到服务器的确认，于是又重新发送了一次连接请求，服务器收到客户端的第二次请求发送确认，则连接建立完成，服务器客户端进行数据传输，传输完成断开连接。此时，**在网络上滞留的客户端第一次连接请求到达服务器，服务器发送确认连接但是客户端实际上并没有发送请求，因此不会理睬服务器发送的请求。但是服务器认为连接已完成，并等待客户端进行数据传输**。这样会造成资源的浪费\n    \n    *如果采用三次握手的话*：\n    \n    > 滞留在网络上的客户端第一次请求到达服务器之后，服务器发送确认，但实际上服务器并没有发送请求，因此不会理睬服务器的确认，故不会发送确认，服务器等不到客户端的确认则连接建立失败。这样就防止了客户端失效的连接请求报文段突然又传到服务器\n\n* TCP连接点的终止为啥是四次挥手而不是三次\n![TCP四次挥手原因](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/四次挥手原因.png)\n\n* TIME_WAIT状态：\n    >主动关闭放进入TIME_WAIT状态后，等待被动连接放发送FIN分节，如果直接关闭的话，系统可能会有一个与主动关闭方相同的新进程与被动连接方进行通讯，造成信息泄露。\n        \n<br><br><br>\n\n***\n***\n\n<br><br><br>\n\n\n\n## 三、IP Address\n\n![IP Address](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IP地址.png)\n\n### 3.1 IP地址的分类\n* A类地址：首位为0，1.0.0.1~127.255.255.254；主机号24位\n* B类地址：首位为10，128.0.0.1~191.255.255.254；主机号16位\n* C类地址：首位为110，192.0.0.1~223.255.255.254；主机号8位\n* D类地址（多播地址，也叫做组播地址）：首位为1110，224.0.0.1~239.255.255.254\n* E类地址：此类地址是保留地址，首位为11110，240.0.0.1~254.255.255.254\n\n\n* 广播地址\n    广播地址(Broadcast Address)是专门**用于同时向网络中所有工作站进行发送的一个地址**。\n\n    在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。\n\n    * 计算广播地址\n        广播地址：网络地址的主机位全部变成1 ，10011111 即159 即：202.112.14.159\n\n* 回环地址\n    127.0.0.1，通常被称为本地回环地址(Loop back address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在windows操作系统中也有相似的定义，所以通常在不安装网卡前就可以ping通这个本地回环地址。**一般都会用来检查本地网络协议、基本数据接口等是否正常的**\n\n<br><br>\n\n***\n\n<br><br>\n\n### 3.2 IP地址的主机ID与网络ID\n\n* **IP地址=网络地址+主机地址**\n    * 计算网络ID：只需要将**IP地址和子网掩码进行与运算**，所得结果即为该主机的网络ID\n    ```\n        有IP地址192.168.0.1，对应的子网掩码为255.255.255.0；\n\n        将IP地址和子网掩码全部转换成二进制的形式，即IP地址是：11000000.10101000.00000000.00000001 ，子网掩码是：11111111.11111111.11111111.00000000；\n\n        将二进制形式的IP地址和子网掩码进行与运算；\n\n        运算结果为11000000.10101000.00000000.00000000，转换为十进制就是192.168.0.0，所以这个主机的网络ID就是192.168.0.0。\n    ```\n    * 计算主机ID：只需要将**子网掩码进行二进制按位取反，再和IP地址进行与运算**，所得结果即为该主机的主机ID\n    ```\n        有IP地址192.168.0.1，对应的子网掩码为255.255.255.0；\n\n        将子网掩码转换成二进制的形式，即就是：11111111.11111111.11111111.00000000；\n\n        将子网掩码进行二进制按位取反，即就是：00000000.00000000.00000000.11111111;\n\n        将取反后的子网掩码和IP地址的二进制形式进行与运算；\n\n        结果为：00000000.00000000.00000000.00000001,转换为十进制就是0.0.0.1,所以这个主机的网络ID就是192.168.0.0。\n    ```\n    * 主机数\n    主机号有5位，那么这个地址中，就只能有25−2=3025−2=30个主机\n    因为其中全0作为网络地址，全1作为广播地址\n    \n<br><br>\n\n***\n\n<br><br>\n\n\n### 3.3 [子网划分](https://blog.csdn.net/gui951753/article/details/79412524)\n* 为什么进行子网划分\n    * **减少网络流量**\n    * **优化网络性能**，这是减少网络流量的结果。\n    * **简化管理**，与庞大的网络相比，在一系列相连的小网络中找出并隔离网络问题更容易。\n    * **有助于覆盖大型地理区域**，WAN链路比LAN链路的速度慢得多，且更昂贵;单个大跨度的大型网络在前面说的各个方面都可能出现问题（网络流量太大，广播风暴），而将多个小网络连接起来可提高系统的效率。\n\n\n* 子网掩码\n    子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。<br><br>\n\n    子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。**将IP地址和子网掩码换算为二进制，子网掩码连续全1的是网络地址，后面的是主机地址**。<br><br>\n\n    子网掩码——屏蔽一个IP地址的网络部分的“全1”比特模式。对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。<br><br>\n\n    * 通过子网掩码，就可以判断两个IP在不在一个局域网内部。<br>\n\n    * 子网掩码可以看出有多少位是网络号，有多少位是主机号<br><br>\n\n    * ip段/数字-如192.168.0.1/24是什么意思?\n    ```\n        后面这个数字标示了我们的网络号的位数，也就是子网掩码中前多少号为1\n\n        129.168.1.1 /24 这个24就是告诉我们网络号是24位\n\n        也就相当于告诉我们了\n\n        子网掩码是：11111111 11111111 11111111 00000000\n\n        即：255.255.255.0\n\n        172.16.10.33/27 中的/27\n\n        也就是说子网掩码是255.255.255.224 即27个全1\n    ```\n    \n\n* 网关\n    网关(Gateway)又称网间连接器、协议转换器。**默认网关在网络层上以实现网络互连**，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。可以是路由器、三层交换机等设备<br>\n    \n    **网关实质上是一个网络通向其他网络的IP地址**\n    \n\n* 三层交换机\n    组合了集线器、路由器和交换机的功能，具有网络管理的一类设备，可以实现在一个设备中对多个虚拟子网的管理的一类设备\n\n\n<br><br><br>\n\n***\n\n<br><br><br>\n\n\n## 四、HTTP和HTTPS\n\n### 4.1 HTTP版本\n\n#### 4.1.1 HTTP/0.9\n* HTTP协议的最初版本，功能简陋，仅支持请求方式GET，并且仅能请求访问HTML格式的资源。\n\n#### 4.1.2 HTTP/1.0\n* 请求行必须在尾部添加协议版本字段（http/1.0）\n\n* 必须包含头消息\n\n* 在0.9版本上做了进步，增加了请求方式POST和HEAD\n\n* 不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等\n\n* 开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即\n\n* HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据\n\n* 新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。\n\n* 1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive\n\n* TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。\n\n* HTTP/1.0与HTTP/1.1对比\n    * 可扩展性\n    * HTTP/1.1在消息中增加版本号，用于兼容性判断。\n    * 新增了请求方式PUT、PATCH、OPTIONS、DELETE等。\n    * 带宽优化\n        >HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。例如，客户端只需要显示一个文档的部分内容，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。\n\n        >HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。\n\n        >另外一种情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限）， 此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。HTTP/1.1 加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。\n\n        >注意，HTTP/1.0 的客户端不支持100响应码。但可以让客户端在请求消息中加入Expect头域，并将它的值设置为100-continue。节省带宽资源的一个非常有效的做法就是压缩要传送的数据。Content-Encoding是对消息进行端到端（end-to-end）的编码，它可能是资源在服务器上保存的固有格式（如 jpeg 图片格式）；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式。\n    * 长连接和短连接\n        > **HTTP1.1默认保持长连接**（HTTP persistent connection，也翻译为**持久连接**），**数据传输完成了保持TCP连接不断开**（不发RST包、不四次握手），**等待在同域名下继续用这个通道传输数据**；(**管道机制**)\n\n        >相反的就是短连接。**在 HTTP/1.0 中，默认使用的是短连接**。也就是说，**浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接**。\n\n#### 4.1.3 HTTP/2.0 （2015年5月以RFC 7540正式发表）\n为了解决1.1版本利用率不高的问题，基于SPDY协议提出了HTTP/2.0版本。\n* 增加双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题（HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级）\n* 之前HTTP版本请求和响应中，状态行和请求/响应头都是些信息字段，并没有真正的数据，因此在2.0版本中将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表，他们之间就以索引号来表示信息字段，这样就避免了1.0旧版本的重复繁琐的字段，并以压缩的方式传输，提高利用率\n\n* 另外也增加服务器推送的功能，即不经请求服务端主动向客户端发送数据。\n\n#### 4.1.4 HTTP3.0 \n* 基于QUIC协议传输\n* TTP的范例和概念没有改变。它含有头部（header）和正文（body），请求和回复，还有动词（verb）、Cookie和缓存。HTTP/3的**主要改变是将这些报文比特传送到另一端的方式**。\n为了使HTTP可以通过QUIC传输，协议的某些方面要进行修改，修改的结果便是HTTP/3。这些必要修改是因QUIC与TCP在某些性质上的不同所致，修改包括：     \n    * 在QUIC中，数据流由传输层本身提供，而在HTTP/2中，流由HTTP层完成。     \n    * 由于数据流互相独立，HTTP/2中使用的头部压缩算法如果不做改动，会造成队头阻塞。  \n    * QUIC流与HTTP/2略有不同。本书的HTTP/3章节会做详细介绍。\n\n\n<br><br>\n\n***\n\n<br><br>\n\n\n### 4.2 [HTTP请求与响应过程](https://zhuanlan.zhihu.com/p/102237039)\n![HTTP请求和响应过程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628170939.png)\n\n* forward和redirect \n    * forward（**转发**）:服务器请求资源，**服务器直接访问目标地址URL**，把那个URL的响应内容读取过来然后发送给浏览器浏览器不知道服务器发送的数据从哪里来的，所以**地址栏中的地址还是原来的地址**。\n    * redirect（**重定向**）:服务端根据逻辑发送一个状态码，告诉**浏览器去请求那个地址**，所以**地址栏中的地址是目标URL**。\n\n<br><br>\n\n***\n\n<br><br>\n\n### 4.3 在浏览器中输入url到显示页面的过程\n1. **输入地址**\n    >当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。\n2. **浏览器查找域名的 IP 地址**\n    >2.1 请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先**查看本地硬盘的 hosts** 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。\n\n    >2.2 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 **DNS请求到本地DNS服务器**。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。\n\n    >2.3 查询你输入的网址的DNS请求到达本地DNS服务器之后，**本地DNS服务器会首先查询它的缓存记录**，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要**向DNS根服务器进行查询**。\n\n    >2.4 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以**到域服务器上去继续查询**，并给出域服务器的地址。**这种过程是迭代的过程**。\n\n    >2.5本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。\n\n    >2.6 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。\n\n3. **浏览器向 web 服务器发送一个 HTTP 请求**\n    >拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024<端口<65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口**发起TCP的连接请求**。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。\n\n4. **服务器的永久重定向响应**\n    >服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访 http://www.google.com/ 而非 http://google.com/ 。为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像 http://www.yy.com/和http://yy.com/ ，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现\n    \n5. **浏览器跟踪重定向地址**\n    > 现在浏览器知道了 http://www.google.com/ 才是要访问的正确地址，所以它会发送另一个http请求。\n\n6. **服务器处理请求**\n    > 经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？\n\n    >后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。\n\n    >一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。\n\n    >此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。\n\n7. **服务器返回一个 HTTP 响应**　\n    >经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。\n\n    >HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：**状态行、响应头(Response Header)、响应正文**\n\n8. **浏览器显示 HTML**\n    >在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了\n\n\n<br><br>\n\n***\n\n<br><br>\n\n\n### 4.4 HTTP传输过程\n![HTTP传输过程](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200629082216.png)\n\n### 4.5 [报文格式](https://blog.csdn.net/aomize/article/details/78609301)\n[报文格式](https://blog.csdn.net/lyn_00/article/details/84953763) \n\n\n|信息|说明|\n|-|-|\n|起始行|对报文进行描述|\n|头部|向报文中添加了一些附加信息，是一个名/只的列表，头部和协议配合工作，共同决定了客户端和服务器能做什么事情|\n|主体|包含数据的主体部分|\n\n\n#### 4.5.1 响应报文格式\n![请求报文格式](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628205247.png)\n\n* HTTP请求起始行\n\n|方法|说明|\n|-|-|\n|GET|请求URL所指的文档|\n|POST|从客户端向服务器端发送一些信息|\n|HEAD|只请求文档的信息，而不包含文档的内容|\n|PUT|从服务器向客户端发送文档|\n|TRACE|把到达的请求回送|\n|CONNECT|保留|\n|OPTION|询问关于可用的选项|\n\n* Get和Post的区别 \n    * GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同\n    * GET在浏览器回退时是无害的，而POST会再次提交请求。\n    * GET产生的URL地址可以被Bookmark，而POST不可以。\n    * GET请求会被浏览器主动cache，而POST不会，除非手动设置。\n    * GET请求只能进行url编码，而POST支持多种编码方式。\n    * GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\n    * GET请求在URL中传送的参数是有长度限制的，而POST么有。\n    * 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\n    * GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\n    * GET参数通过URL传递，POST放在Request body中。\n    * 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\n    * 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。\n\n\n* HTTP请求头部\n\n|信息|说明|\n|-|-|\n|Accept|指浏览器或其他客户可以接爱的MIME文件格式。可以根据它判断并返回适当的文件格式|\n|Accept-Charset|指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1|\n|Accept-Language|指出浏览器可以接受的语言种类，如en或en-us，指英语|\n|Accept-Encoding|指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式|\n|Cache-Control|设置关于请求被代理服务器存储的相关选项。一般用不到|\n|Connection|用来告诉服务器是否可以维持固定的HTTP连接。HTTP/1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接|\n|Content-Type|用来表名request的内容类型。可以用HttpServletRequest的getContentType()方法取得|\n|Cookie|浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能|\n\n#### 4.5.2 响应报文格式\n\n![响应报文格式](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628205343.png)\n\n* HTTP响应起始行\n\n|方法|说明|\n|-|-|\n|Server|给出服务器相关信息|\n|Accept-Ranges|服务器将接受请求的字节范围|\n|Content-Type|指明媒体类型|\n|Content-Encoding|指明编码方案|\n|Location|请求客户将请求发送到另一站点|\n|Set-Cookie|服务器请求客户保存Cookie|\n|Upgrade|指明优先使用的通信协议|\n|Public|给出可以支持的文档清单|\n|Retry-afer|指明的日期之后，服务器才能使用|\n\n\n* HTTP常见状态码\n    * 1开头状态码\n        **表示请求已被接收，继续处理**\n\n    * 2开头状态码\n        **表示成功处理请求的状态代码**\n        * 200:通常表示服务器成功处理的请求\n        \n    * 3开头状态码\n        **表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向**\n        * 301:代表永久性转移\n        * 302:代表暂时性转移\n    * 4开头状态代码 **通常表示请求可能出现错误，妨碍了服务器的处理**\n        * 400：服务器不理解请求的语法\n        * 403：服务器拒绝请求\n        * 404：服务器找不到请求的网页\n\n    * 5开头状态码 **通常表示服务器在处理中这些请求时发生内错误。这些错误可能是服务器本身错误或是请求出错**\n        * 500(服务器内部错误):服务器遇到错误，无法完成请求\n        * 501(无法实施):服务器不具备完成请求的功能。例如服务器无法识别方法。\n        * 502(错误网关)：服务器作为网关或代理，从上游服务器收到无效响应。\n        * 503(服务不可用):服务器目前无法使用(由于超载或者停机维护)，通常这只是暂时转态。\n        * 504(网关超时):服务器作为网关或者代理，但是没有及时从上游服务器收到请求。\n        * 505(HHTP版本不受支持):服务器不支持请求中所使用的HTTP协议版本\n        \n        >重点：***200,304,403,500***\n\n<br><br>\n\n***\n\n<br><br>\n\n### 4.6 HTTP与HTTPS的区别  \n* HTTPS协议需要ca申请证书，一般免费证书较少，所以需要一定费用\n* HTTP是超文本协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议\n    * 在HTTP通信中加入了SSL层，通信的数据被加密了，防止被窃取，具体的通信流程如下：\n        ![](https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/HTTPS加密传输.png)\n* HTTP和HTTPS使用的是两种完全不同的连接方式，用的端口也不一样，前者是80，后者是443\n* HTTP的连接很简单，是无状态的；HTTPS是有SSl+HTTP协议构成的可加密除数，身份认证的网络协议，比HTTP更安全\n\n\n\n###  4.7 [HTTPS实现原理](https://blog.csdn.net/u011547347/article/details/83186514)\n\n\n\n\n###  4.8 HTTP代理服务器\n工作在**应用层**，比价耗费资源\n* **提高访问速度**：通常代理服务器都设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的 信息时，则直接由缓冲区中 取出信息，传给用户，以提高\n访问速度。\n* **控制对内部资源的访问**：如某大学FTP（前提是该代理地址在该资源的允许访问范围之 内），使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。\n* **过滤内容**：例如限制对特定计算机的访问，将一种语言的数据翻译成另一种语言，或是防御代理服务器两边的攻击性访问。\n* **隐藏真实IP**：上网者也可以通过代理服务器隐藏自己的IP，免受攻击。但是只一个代 理很难保证安全，更安全的方法是利用特定的工具创建代理链\n* **突破自身IP访问限制**：访问国外站点。中国教育网和169网等网络用户可以通过代理访 问国外网站。\n* **突破内容过滤机制限制，访问被过滤网站**。\n\n<br><br><br>\n\n***\n***\n\n<br><br><br>\n\n## 附录\n\n### 1. 常用网络测试命令及应用\n\n#### ping命令\n```ini\nPing [-t] [-a] [-n count] [-l length] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [-j HostList]| [-k HostList] [-w timeout] destination –list\n\nv-t，不间断地ping指定的主机，直到按“Ctrl+C” 组合键中断为止。\nv-a，指定对目的地IP地址进行反向名称解析。如 果解析成功，将显示相应的主机名。\nv-n count，发送count指定的ECHO数据包数，默认值为4。\n-l length，自定义发送数据包的大小，也就是发送由length指定大小的ECHO数据包，默认为32字节，最 大值是65527字节。\nv-f，指定发送的回响请求消息带有“不要拆分”标志（所在的IP标题设为1）\nv-i TTL，指定发送回响请求消息的IP标题中的TTL字段值。\nv-v TOS，指定发送回响请求消息的IP标题中的“服务 类型 (TOS)”字段值，默认值是0。TOS被指定为0到 255的十进制数。\nv-r count，指定IP标题中的“记录路由”选项用于记录由回响请求消息和相应的回响应答消息使用的路径\n```\n* 功能\n    * ping 127.0.0.1：检查TCP/IP是否被正确地安装。 \n    * ping本机IP：ping本地计算机的IP地址，本地计算 机对该ping命令作出应答。如果没有应答，则表示本地 配置或安装存在问题。出现此问题时，局域网用户可断开 网络电缆，然后重新发送该命令。如果网线断开后本命令 正确，则表示另一台计算机可能配置额相同的IP地址。\n    * ping局域网内其他主机IP：如果收到回送应答，表 明本地网络中的网卡和传输介质运行正确。但如果没有收 到回送应答，那么表示子网掩码不正确或网卡配置错误，或电缆线路有问题。\n    * ping网关IP：该命令如果应答正确，表示局域网中 的网关路由器正在运行以及能否与本地网络上的本地主机 通讯。\n    * ping远程主机IP：如果收到4个应答，表示成功地 使用了缺省网关。对于拨号上网用户则表示能够成功地访 问Internet。\n    * ping域名：ping域名，如 ping www.sina.com.cn ，通常是通过DNS服务器进行解析。 如果这里出现故障，则表示DNS服务器的IP地址配置不 正确或DNS服务器有故障。另外，利用该命令可以实现域名对IP地址的转换功能。\n\n####  \n```ini\n    nslookup www.*.com\n```\n\n* 功能\n    * nslookup是一个监测网络中DNS服务器是否能正确实现域名解析的命令行 工具。它在 UNIX/Windows NT/2000/XP中均可使用。nslookup必须要 安装了TCP/IP的网络环境中才能使用。\n    * 如果需要对DNS的故障进行排错就必须熟练使用工具nslookup。这个命令 可以指定查询的类型，可以查到DNS记录的生存时间，还可以指定使用哪个DNS服务器进行解释。\n\n#### ipconfig命令\n```ini\n    ipconfig [/all /renew [adapter] /release [adapter]] [/flushdns] [/displaydns] [/registerdns] [/showclassid Adapter] [/setclassid Adapter [ClassID]]\n```\n\n* 功能\n    * ipconfig用于显示当前的TCP/IP网络配置的设置值、刷 新动态主机配置协议（DHCP）和域名系统（DNS）设置。 使用不带参数的ipconfig可以显示所有适配器的IP地址、子网掩码和默认网关。\n    * ipconfig一般用来检验人工配置的TCP/IP设置是否正确。 如果计算机和所在的局域网使用了动态主机配置协议 （DHCP），这个程序所显示的信息可以让用户了解自己 的计算机是否成功的租用到一个IP地址，如果租用到则可 以了解它目前分配到的具体地址。了解计算机当前的IP地 址、子网掩码和缺省网关实际上是进行测试和故障分析的必要条件。\n\n* 范例\n    * 要显示所有适配器的完整TCP/IP配置，键入 `ipconfig/all。`\n    * 仅更新“本地连接”适配器的由DHCP分配IP地址 的配置，键入 `ipconfig /renew \"Local Area Connection\"`\n    * 要在排除DNS的名称解析故障期间清理DNS解析器 缓存，键入`ipconfig /flushdns`\n    * 要显示名称以Local开头的所有适配器的DHCP类别 ID，键入`ipconfig /showclassid Local`\n    * 要将“本地连接”适配器的DHCP类别ID设置为 TEST，键入`ipconfig /setclassid \"Local Area Connection\" TEST`\n\n<br><br>\n\n***\n\n<br><br>\n\n### 2. 网络流量监视命令\n|命令名称|适用的操作系统|功能说明|\n|-|-|-|\n|ping|UNIX/Windows|用于测量往返数据包丢失率|\n|bing|UNIX|测量线路的点到点带宽|\n|etherfind|UNIX|检查以太网数据包|\n|snoop|UNIX|捕获并检查网络数据包|\n|tcpdump|UNIX|网络的dumps流量|\n|getethers|UNIX|获取一个以太网局域网网段中所有主机的地址|\n|iptrace|UNIX|测量网关的性能|\n|netstat|UNIX/Windows|显示各种网络相关数据结构的内容|\n|arp|UNIX/Windows|显示并修改Internet到Ethernet地址转换表|\n|tracert|UNIX/Windows|追踪有路由延迟的目标机的路由|\n|route|UNIX/Windows|显示、人工添加和修改路由表项目|\n|pathping|UNIX/Windows|显示有关在源和目标主机之间的中间跃点处的网络 滞后和网络丢失的信息|\n\n* 其中一个是**ping**命令，重复执行大量的ping命令（ICMP回显 请求消息）可测算出接收的成功次数，就可以计算出数据包丢失的百分率。包丢失是一种吞吐量的测算。\n* 另一个常用的命令是点到点带宽**bing**命令，这个命令是以ping 为基础的，通过线路两端发送数据包的大小不同而产生的往返时间差进行计算，可以得出粗略的吞吐量数据。\n* 其他5个命令可以检查在网络中经过的数据包，分别提供不同的 输出。命令**etherfind**、**snoop**和**tcpdump**把网卡置于混杂模式中（在这种模式中，收集网络中未经处理的数据无需经过任 何过滤）并记录数据。命令**getethers**可以得到所有局域网网段 的主机名和以太网地址对。工具**iptrace**在UNIX内核中使用 NETMON程序，产生3类输出：IP流量、主机流量矩阵输出和预先定义数据包号的简短取样。\n* **netstat**命令可以帮助网络管理员了解网络的整体使用情 况。它可以显示当前正在活动的网络连接的详细信息，例 如，显示网络连接、路由表和网络接口信息，可以统计目前总共有哪些网络连接正在进行。命令格式语法： `netstat [-a] [-e] [-n] [-o] [-p Protocol] [-r] [-s] [Interval]`,\n* 使用**arp**命令，能够查看本地计算机或另一台计 算机的ARP高速缓存中的当前内容。此外，使用 arp命令，也可以用人工方式输入静态的网卡物 理和IP地址对，使用这种方式为缺省网关和本地 服务器等常用主机进行这项操作，有助于减少网络上的信息量。ARP命令格式：`arp [-a [InetAddr] [-N IfaceAddr]] [-g [InetAddr] [-N IfaceAddr]] [-d InetAddr [IfaceAddr]] [-s InetAddr EtherAddr [IfaceAddr]]`\n* **tracert**一般用来检测故障的位置，虽然还是不能确定 具体故障原因，但已经能显示问题所在的地方。另外， traceroute命令的功能与tracert相同，二者的差别仅 仅在于tracert命令是用在Windows平台上，而traceroute命令是用在Unix平台和路由器上。\n* **tracert**命令用来显示数据包到达目标主机所经过的路径，并 显示到达每个节点的时间。命令格式如下：`Tracert IP地址或主机名 [-d] [-h maximum_hops] [-j host_list] [-w timeout]`\n* **route**命令用来显示、人工添加和修改路由表项目的。 route命令格式：`route [-f] [-p] [[print] [add] [change] [delete] [Destination] [mask subnetmask] [Gateway] [metric Metric]] [if Interface]`\n\n<br><br>\n\n***\n\n<br><br>\n\n### 3. 专有名词\n* CDN\n    * CDN的全称是<code>Content Delivery Network</code>，即<code>内容分发网络</code>，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户<code>就近</code>获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有<code>内容存储</code>和<code>分发技术</code>。\n\n* DNS\n    * <p>你有没有想过为什么你可以通过键入 <code>www.google.com</code> 就能够获取你想要的网站？我们上面说到，计算机网络中的每个端系统都有一个 IP 地址存在，而把 IP 地址转换为便于人类记忆的协议就是 <code>DNS 协议</code>。</p><br><p>DNS 的全称是<code>域名系统（Domain Name System，缩写：DNS）</code>，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>\n    \n* URL   \n    * <p>我们上面提到，你可以通过输入 <code>www.google.com</code> 地址来访问谷歌的官网，那么这个地址有什么规定吗？我怎么输都可以？AAA.BBB.CCC 是不是也行？当然不是的，你输入的地址格式必须要满足 <code>URI</code> 的规范。</p><br>  <p><code>URI</code>的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>   <br><p><code>URL</code>的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的<code>网址</code>，它实际上是 URI 的一个子集。</p><p>URI 不仅包括 URL，还包括 URN（统一资源名称），它们之间的关系如下</p>\n\n    <img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/URI组成.png\" data-caption=\"URI组成\" />\n\n\n\n<br><br><br>\n\n* 推荐文章\n    * https://zhuanlan.zhihu.com/p/102237039\n    * https://blog.csdn.net/weixin_44367006/article/details/99768731\n\n\n* 参考    \n[1]https://blog.csdn.net/liuyanfeier/article/details/52787037\n[2]https://blog.csdn.net/qq_32374237/article/details/86242159\n[3]https://blog.csdn.net/gui951753/article/details/79412524\n[4]https://blog.csdn.net/lyn_00/article/details/84953763\n[5]https://blog.csdn.net/moge19/article/details/90050030\n[6]https://zhuanlan.zhihu.com/p/102237039\n[7]https://blog.csdn.net/weixin_44367006/article/details/99768731\n[8]https://blog.csdn.net/qq_33663020/article/details/79386252","slug":"code/NetWork/网络","published":1,"updated":"2020-08-01T14:53:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5dy1gu00650w7t5qjnc3c1","content":"<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200629181240.png\" alt=\"NetWork\"></p>\n<a id=\"more\"></a>\n\n<p><a href=\"https://blog.csdn.net/shuningzhang/article/details/90138425\" target=\"_blank\" rel=\"noopener\">interview_1</a></p>\n<h2 id=\"一、TCP-IP网络模型\"><a href=\"#一、TCP-IP网络模型\" class=\"headerlink\" title=\"一、TCP/IP网络模型\"></a>一、TCP/IP网络模型</h2><table>        \n    <tr>\n        <th>OSI</th>\n        <th>TCP/IP</th>\n        <th>功能</th>\n        <th>TCP/IP协议簇</th>\n    </tr>\n    <tr>\n        <td>\n            应用层<br>\n            表示层<br>\n            会话层<br>\n        </td>\n        <td>应用层</td>\n        <td>\n            文件传输，电子邮件，文件服务<br>\n            数据格式化，数据加密<br>\n            接触或建立与别的结点的连接<br>\n        </td>\n        <td>\n            TFTP，HHTP，SMTP,FTP,DNS\n        </td>\n    </tr>\n    <tr>\n        <td>传输层</td>\n        <td>传输层</td>\n        <td>提供端对端的接口</td>\n        <td>TCP,UDP</td>\n    </tr>\n    <tr>\n        <td>网络层</td>\n        <td>网络层</td>\n        <td>为数据包选择路由</td>\n        <td>IP,ICMP,RIP</td>\n    </tr>\n    <tr>\n        <td>\n            数据链路层<br>\n            物理层<br>\n        </td>\n        <td>链路层</td>\n        <td>\n            |传输有错误的帧以及错误检测功能<br>\n            以二进制数据格式在物理媒介上传输数据<br>\n        </td>\n        <td>\n            ARP,SLIP<br>\n            ISO2110,IEEE802<br>\n        </td>\n    </tr>\n</table>\n\n<ol>\n<li>物理层<ul>\n<li>该层为上层协议提供了一个传输数据的可靠物理媒介。简单的说，物理层确保原始数据可在各种物理媒介中传输。<ul>\n<li>中继器</li>\n<li>集线器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据链路层<ul>\n<li>将源自网络层的数据可靠地传输到相邻结点的目标网络层。主要功能有<strong>将数据融合成数据块（帧），控制帧在物理信道上的传输，处理传输差错，调节发送速率以使与接收方匹配</strong>。主要作用即：<strong>物理地址寻址，数据成帧，流量控制，数据的检错，重发</strong><ul>\n<li>数据链路层为网络层提供可靠的数据传输</li>\n<li>基本数据的数据单位为帧</li>\n<li>主要的协议：以太网协议</li>\n<li>网桥</li>\n<li>交换机</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络层<ul>\n<li>该层的目的是<strong>实现两个主机系统之间的数据传输透明</strong>，具体功能包括<strong>寻址和路由选择，连接的建立与终止等</strong>，<strong>它提供的服务使传输层不需要了解网络层的数据传输和交换技术</strong>，可简单记为<strong>路径选择，路由及逻辑寻址</strong><ul>\n<li>TCP/IP的核心协议————IP协议<ul>\n<li>功能包括有：无线数据包传输，数据包路由选择，差错控制</li>\n<li>与其配套的协议有：地址解析协议ARP,因特网报文协议ICMP等</li>\n</ul>\n</li>\n<li>网络层负责对子网间的数据包进行路由选择，还可以实现拥塞控制，网际互联</li>\n<li>基本数据单位为IP数据报</li>\n<li>路由器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>传输层<ul>\n<li>负责<strong>将上层数据分段并提供端对端的，可靠或不可靠的传输</strong>。此外，传输层还要<strong>处理端到端的差错控制和流量控制</strong>，其任务是根据通信子网的特性，最佳的利用网络资源，<strong>为两个端系统的会话层之间，建立，维护和取消阐述连接的功能，负责端对端的可靠信息传输</strong>，在这一层，信息传送的协议称为<strong>段</strong>或者<strong>报文</strong>，作用：<strong>为应用进程之间提供端到端的逻辑通信</strong><ul>\n<li>传输层负责<strong>将上层数据分段并提供端到端，可靠或者不可靠的传输以及端到端的差错控制以及流量控制</strong></li>\n<li><strong>TCP协议</strong>，<strong>UDP协议</strong></li>\n<li>网关</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>会话层</li>\n</ol>\n<ul>\n<li>管理主机之间的<strong>会话进程</strong>，负责<strong>建立、管理、终止进程之间的会话</strong>，还可利用在数据中插入校验点<strong>实现数据同步</strong>，包括建立检查点和恢复方案。</li>\n</ul>\n<ol start=\"6\">\n<li>表示层</li>\n</ol>\n<ul>\n<li>对上层数据或信息进行<strong>变换</strong>以保证<strong>一个主机的信息可以被另外一个主机的应用程序理解</strong>，包括对数据的<strong>加密，压缩，格式转换</strong>等，数据描述使得应用程序不必担心计算机内部存储格式的问题。</li>\n</ul>\n<ol start=\"7\">\n<li>应用层<ul>\n<li>最靠近用户的层，<strong>为用户的应用进程提供网络服务的接口，将用户的操作通过应用进程转换为服务，并匹配一个相应的服务协议发送给传输层</strong><blockquote>\n<p>传输数据时可以只是使用（传输层）协议，但是没有应用层的话便无法识别数据内容。如果要使传输的数据有意义，则必须使用应用层协议。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<p><br><br><br></p>\n<hr>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"二、TCP和UDP\"><a href=\"#二、TCP和UDP\" class=\"headerlink\" title=\"二、TCP和UDP\"></a>二、TCP和UDP</h2><h3 id=\"2-1-TCP和UDP的区别\"><a href=\"#2-1-TCP和UDP的区别\" class=\"headerlink\" title=\"2.1 TCP和UDP的区别\"></a>2.1 TCP和UDP的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>UDP</th>\n<th>TCP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否连接</td>\n<td>无连接</td>\n<td>有连接</td>\n</tr>\n<tr>\n<td>是否可靠</td>\n<td>不可靠，不使用流量控制和拥塞控制</td>\n<td>可靠传输，使用流量控制和拥塞控制</td>\n</tr>\n<tr>\n<td>是否有序</td>\n<td>无序</td>\n<td>有序</td>\n</tr>\n<tr>\n<td>是否有界</td>\n<td>有界</td>\n<td>无界</td>\n</tr>\n<tr>\n<td>重传机制</td>\n<td>无</td>\n<td>超时重传机制，快速重传机制</td>\n</tr>\n<tr>\n<td>连接对象个数</td>\n<td>一对一，一对多，多对一，多对多</td>\n<td>一对一</td>\n</tr>\n<tr>\n<td>传输方式</td>\n<td>面向报文</td>\n<td>面向数据流</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>小，仅8字节</td>\n<td>最小20字节，最大60字节</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>实时应用（视频会议，直播）</td>\n<td>适用于可靠的应用（文件传输）</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>是否有界</p>\n<blockquote>\n<p><strong>TCP通过字节流传输</strong>，即TCP将应用程序看成是一连串的无结构的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。 而<strong>UDP传输报文的方式是由应用程序</strong>控制的，<strong>应用层</strong>交给UDP多长的报文，UDP照样发送，<strong>既不拆分，也不合并，而是保留这些报文的边界</strong>，即一次发送一个报文。有界与无界之分是根据接收报文来划分的，对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的,<strong>UDP无缓存服务，信息确认由应用层完成</strong>。</p>\n</blockquote>\n</li>\n<li><p>TCP黏包问题</p>\n<blockquote>\n<p>由于<strong>TCP协议</strong>本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会维持一个连接（Channel），数据在连接不断开的情况下，可以持续不断地将多个数据包发往服务器，但是如果发送的网络数据包太小，那么他本身会启用<strong>Nagle算法</strong>（可配置是否启用）<strong>对较小的数据包进行合并</strong>（基于此，TCP的网络延迟要UDP的高些）然后再发送（超时或者包大小足够）。<strong>那么这样的话，服务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包</strong>；服务器在接收到数据库后，放到缓冲区中，<strong>如果消息没有被及时从缓存区取走</strong>，下次在取数据的时候可能就会出现一次取出多个数据包的情况，造成粘包现象。</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>发送定长的数据 <strong>不能完全解决</strong> 会出现不知道从哪里开始分离固定长度的数据的情况(没有被及时从缓存区取走)</li>\n<li><strong>自定制协议</strong> [定长结构体(标识该条数据长度)]12345[分隔符]</li>\n</ul>\n</blockquote>\n</li>\n<li><p>TCP分包问题：</p>\n<blockquote>\n<p>可能是<strong>IP分片传输</strong>导致的，也可能是<strong>传输过程中丢失部分包导致出现的半包</strong>，还有<strong>可能就是一个包可能被分成了两次传输</strong>，在取数据的时候，先取到了一部分（还可能与接收的缓冲区大小有关系），总之就是一个数据包被分成了多次接收。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>UDP无连接<br>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。具体来说就是：<blockquote>\n<p>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了.在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"2-2-TCP特性\"><a href=\"#2-2-TCP特性\" class=\"headerlink\" title=\"2.2 TCP特性\"></a>2.2 TCP特性</h3><ul>\n<li><a href=\"https://blog.csdn.net/Cecilia3333/article/details/80358201\" target=\"_blank\" rel=\"noopener\">TCP的各种机制</a><ul>\n<li>可靠性<ul>\n<li><strong>确认应答机制</strong>（ACK）</li>\n<li><strong>超时重传机制</strong></li>\n<li><strong>校验和</strong></li>\n</ul>\n</li>\n<li>流量控制<ul>\n<li><strong>滑动窗口机制</strong>（ARQ)<blockquote>\n<p>滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>拥塞控制<ul>\n<li>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载</li>\n<li>具体实现<blockquote>\n<p><strong>慢启动</strong>（Slow Start）发送方维护拥塞窗口变量cwnd，先用小数据试探网络拥塞，没问题后来断加倍.<br><strong>拥塞避免</strong>（Congestion voidance）：拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1<br><strong>快速重传</strong>（Fast Retransmit）：快重传要求接收方收到失序报文段后立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br><strong>快速恢复</strong>（Fast Recovery）：当发送方连续收到三个重复确认时，就把慢开始门限ssthresh门限减半。接下来将cwnd设置为ssthresh的大小，然后执行拥塞避免算法</p>\n</blockquote>\n<ul>\n<li><strong>捎带应答</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"2-3-TCP连接的建立与终止过程\"><a href=\"#2-3-TCP连接的建立与终止过程\" class=\"headerlink\" title=\"2.3 TCP连接的建立与终止过程\"></a>2.3 TCP连接的建立与终止过程</h3><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/TCP%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png\" alt=\"TCP传输过程\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628132143.png\" alt=\"TCP三次握手\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628132341.png\" alt=\"TCP四次挥手\"></p>\n<ul>\n<li><p>三次握手</p>\n<ul>\n<li>第一次握手：客户端将标志位SYN置为1，表示请求同步（建立连接）。随机产生一个值seq=x，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li>\n<li>第二次握手：服务器端将标志位SYN置为1表示请求同步，ACK置为1表示收到请求。ack=x+1，用于给客户端和之前传送过来的seq校验。随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li>\n<li>第三次握手：客户端收到确认后，检查ACK是否为1，ack是否为x+1，如果正确则将标志位ACK置为1，ack=y+1，seq=传过来的ack=x+1，并将该数据包发送给服务器端，并进入ESTABLISHED状态。服务器端检查ACK是否为1，ack是否为y+1，如果正确则连接建立成功服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。假如第三次握手没有到达服务器端呢？但是这时客户端已进入ESTABLISHED状态。但是其实这种情况下，只要客户端向服务器端写数据，就会收到服务器端的RST（复位）应答，这时客户端就能知道出现问题了。</li>\n</ul>\n</li>\n<li><p>三次握手的漏洞<br>但是在TCP三次握手中是有一个缺陷的。利用三次握手的缺陷可以进行<strong>SYN洪泛攻击</strong>。</p>\n<ul>\n<li>SYN洪泛攻击：通过网络服务所在的端口发送<strong>大量伪造原地址的攻击报文</strong>，发送到服务端，<strong>造成服务端上的半开连接队列被占满</strong>，从而阻止其他用户进行访问。</li>\n<li>原理：攻击者客户端利用伪造的IP地址向服务端发出请求(第一次握手)，<strong>而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(永远都不会有的)</strong>，服务端在<strong>等待这种半开的连接过程中消耗了资源</strong>，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。</li>\n<li>解决方案： <ul>\n<li>无效连接监视释放<blockquote>\n<p>这种方法不停监视所有的连接，包括三次握手的，还有握手一次的，反正是所有的，当达到一定(与)阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，不管是正常的还是攻击的，所以这种方式不推荐。</p>\n</blockquote>\n</li>\n<li>延缓TCB分配方法<blockquote>\n<p>一般的做完第一次握手之后，服务器就需要为该请求分配一个TCB（连接控制资源），通常这个资源需要200多个字节。延迟TCB的分配，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。</p>\n</blockquote>\n</li>\n<li>使用防火墙<blockquote>\n<p>防火墙在确认了连接的有效性后，才向内部的服务器（Listener）发起SYN请求，</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>四次挥手</p>\n<ul>\n<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>\n<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于<strong>半关闭状态</strong>，即客户端已经没有数据要发送了，但是<strong>服务器若发送数据，客户端依然要接受</strong>。这个状态还要持续一段时间，也就是整个<strong>CLOSE-WAIT状态</strong>持续的时间。</li>\n<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>\n<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>\n<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2 MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>四次挥手的原因</p>\n<p>  <strong>防止客户端失效的连接请求报文段突然又传到服务器</strong><br>  <em>例如以下情况如果使用两次握手</em>：</p>\n<blockquote>\n<p>如果客户端向服务器发送第一次连接请求在网络节点上滞留了，没有收到服务器的确认，于是又重新发送了一次连接请求，服务器收到客户端的第二次请求发送确认，则连接建立完成，服务器客户端进行数据传输，传输完成断开连接。此时，<strong>在网络上滞留的客户端第一次连接请求到达服务器，服务器发送确认连接但是客户端实际上并没有发送请求，因此不会理睬服务器发送的请求。但是服务器认为连接已完成，并等待客户端进行数据传输</strong>。这样会造成资源的浪费</p>\n</blockquote>\n<p>  <em>如果采用三次握手的话</em>：</p>\n<blockquote>\n<p>滞留在网络上的客户端第一次请求到达服务器之后，服务器发送确认，但实际上服务器并没有发送请求，因此不会理睬服务器的确认，故不会发送确认，服务器等不到客户端的确认则连接建立失败。这样就防止了客户端失效的连接请求报文段突然又传到服务器</p>\n</blockquote>\n</li>\n<li><p>TCP连接点的终止为啥是四次挥手而不是三次<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%8E%9F%E5%9B%A0.png\" alt=\"TCP四次挥手原因\"></p>\n</li>\n<li><p>TIME_WAIT状态：</p>\n<blockquote>\n<p>主动关闭放进入TIME_WAIT状态后，等待被动连接放发送FIN分节，如果直接关闭的话，系统可能会有一个与主动关闭方相同的新进程与被动连接方进行通讯，造成信息泄露。</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br><br></p>\n<hr>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"三、IP-Address\"><a href=\"#三、IP-Address\" class=\"headerlink\" title=\"三、IP Address\"></a>三、IP Address</h2><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IP%E5%9C%B0%E5%9D%80.png\" alt=\"IP Address\"></p>\n<h3 id=\"3-1-IP地址的分类\"><a href=\"#3-1-IP地址的分类\" class=\"headerlink\" title=\"3.1 IP地址的分类\"></a>3.1 IP地址的分类</h3><ul>\n<li>A类地址：首位为0，1.0.0.1~127.255.255.254；主机号24位</li>\n<li>B类地址：首位为10，128.0.0.1~191.255.255.254；主机号16位</li>\n<li>C类地址：首位为110，192.0.0.1~223.255.255.254；主机号8位</li>\n<li>D类地址（多播地址，也叫做组播地址）：首位为1110，224.0.0.1~239.255.255.254</li>\n<li>E类地址：此类地址是保留地址，首位为11110，240.0.0.1~254.255.255.254</li>\n</ul>\n<ul>\n<li><p>广播地址<br>  广播地址(Broadcast Address)是专门<strong>用于同时向网络中所有工作站进行发送的一个地址</strong>。</p>\n<p>  在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>\n<ul>\n<li>计算广播地址<br>  广播地址：网络地址的主机位全部变成1 ，10011111 即159 即：202.112.14.159</li>\n</ul>\n</li>\n<li><p>回环地址<br>  127.0.0.1，通常被称为本地回环地址(Loop back address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在windows操作系统中也有相似的定义，所以通常在不安装网卡前就可以ping通这个本地回环地址。<strong>一般都会用来检查本地网络协议、基本数据接口等是否正常的</strong></p>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"3-2-IP地址的主机ID与网络ID\"><a href=\"#3-2-IP地址的主机ID与网络ID\" class=\"headerlink\" title=\"3.2 IP地址的主机ID与网络ID\"></a>3.2 IP地址的主机ID与网络ID</h3><ul>\n<li><p><strong>IP地址=网络地址+主机地址</strong></p>\n<ul>\n<li><p>计算网络ID：只需要将<strong>IP地址和子网掩码进行与运算</strong>，所得结果即为该主机的网络ID</p>\n<pre><code>  有IP地址192.168.0.1，对应的子网掩码为255.255.255.0；\n\n  将IP地址和子网掩码全部转换成二进制的形式，即IP地址是：11000000.10101000.00000000.00000001 ，子网掩码是：11111111.11111111.11111111.00000000；\n\n  将二进制形式的IP地址和子网掩码进行与运算；\n\n  运算结果为11000000.10101000.00000000.00000000，转换为十进制就是192.168.0.0，所以这个主机的网络ID就是192.168.0.0。</code></pre></li>\n<li><p>计算主机ID：只需要将<strong>子网掩码进行二进制按位取反，再和IP地址进行与运算</strong>，所得结果即为该主机的主机ID</p>\n<pre><code>  有IP地址192.168.0.1，对应的子网掩码为255.255.255.0；\n\n  将子网掩码转换成二进制的形式，即就是：11111111.11111111.11111111.00000000；\n\n  将子网掩码进行二进制按位取反，即就是：00000000.00000000.00000000.11111111;\n\n  将取反后的子网掩码和IP地址的二进制形式进行与运算；\n\n  结果为：00000000.00000000.00000000.00000001,转换为十进制就是0.0.0.1,所以这个主机的网络ID就是192.168.0.0。</code></pre></li>\n<li><p>主机数<br>主机号有5位，那么这个地址中，就只能有25−2=3025−2=30个主机<br>因为其中全0作为网络地址，全1作为广播地址</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"3-3-子网划分\"><a href=\"#3-3-子网划分\" class=\"headerlink\" title=\"3.3 子网划分\"></a>3.3 <a href=\"https://blog.csdn.net/gui951753/article/details/79412524\" target=\"_blank\" rel=\"noopener\">子网划分</a></h3><ul>\n<li>为什么进行子网划分<ul>\n<li><strong>减少网络流量</strong></li>\n<li><strong>优化网络性能</strong>，这是减少网络流量的结果。</li>\n<li><strong>简化管理</strong>，与庞大的网络相比，在一系列相连的小网络中找出并隔离网络问题更容易。</li>\n<li><strong>有助于覆盖大型地理区域</strong>，WAN链路比LAN链路的速度慢得多，且更昂贵;单个大跨度的大型网络在前面说的各个方面都可能出现问题（网络流量太大，广播风暴），而将多个小网络连接起来可提高系统的效率。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>子网掩码<br>  子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。<br><br></p>\n<p>  子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。<strong>将IP地址和子网掩码换算为二进制，子网掩码连续全1的是网络地址，后面的是主机地址</strong>。<br><br></p>\n<p>  子网掩码——屏蔽一个IP地址的网络部分的“全1”比特模式。对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。<br><br></p>\n<ul>\n<li><p>通过子网掩码，就可以判断两个IP在不在一个局域网内部。<br></p>\n</li>\n<li><p>子网掩码可以看出有多少位是网络号，有多少位是主机号<br><br></p>\n</li>\n<li><p>ip段/数字-如192.168.0.1/24是什么意思?</p>\n<pre><code>  后面这个数字标示了我们的网络号的位数，也就是子网掩码中前多少号为1\n\n  129.168.1.1 /24 这个24就是告诉我们网络号是24位\n\n  也就相当于告诉我们了\n\n  子网掩码是：11111111 11111111 11111111 00000000\n\n  即：255.255.255.0\n\n  172.16.10.33/27 中的/27\n\n  也就是说子网掩码是255.255.255.224 即27个全1</code></pre></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>网关<br>  网关(Gateway)又称网间连接器、协议转换器。<strong>默认网关在网络层上以实现网络互连</strong>，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。可以是路由器、三层交换机等设备<br></p>\n<p>  <strong>网关实质上是一个网络通向其他网络的IP地址</strong></p>\n</li>\n</ul>\n<ul>\n<li>三层交换机<br>  组合了集线器、路由器和交换机的功能，具有网络管理的一类设备，可以实现在一个设备中对多个虚拟子网的管理的一类设备</li>\n</ul>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"四、HTTP和HTTPS\"><a href=\"#四、HTTP和HTTPS\" class=\"headerlink\" title=\"四、HTTP和HTTPS\"></a>四、HTTP和HTTPS</h2><h3 id=\"4-1-HTTP版本\"><a href=\"#4-1-HTTP版本\" class=\"headerlink\" title=\"4.1 HTTP版本\"></a>4.1 HTTP版本</h3><h4 id=\"4-1-1-HTTP-0-9\"><a href=\"#4-1-1-HTTP-0-9\" class=\"headerlink\" title=\"4.1.1 HTTP/0.9\"></a>4.1.1 HTTP/0.9</h4><ul>\n<li>HTTP协议的最初版本，功能简陋，仅支持请求方式GET，并且仅能请求访问HTML格式的资源。</li>\n</ul>\n<h4 id=\"4-1-2-HTTP-1-0\"><a href=\"#4-1-2-HTTP-1-0\" class=\"headerlink\" title=\"4.1.2 HTTP/1.0\"></a>4.1.2 HTTP/1.0</h4><ul>\n<li><p>请求行必须在尾部添加协议版本字段（http/1.0）</p>\n</li>\n<li><p>必须包含头消息</p>\n</li>\n<li><p>在0.9版本上做了进步，增加了请求方式POST和HEAD</p>\n</li>\n<li><p>不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等</p>\n</li>\n<li><p>开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即</p>\n</li>\n<li><p>HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据</p>\n</li>\n<li><p>新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>\n</li>\n<li><p>1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive</p>\n</li>\n<li><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。</p>\n</li>\n<li><p>HTTP/1.0与HTTP/1.1对比</p>\n<ul>\n<li><p>可扩展性</p>\n</li>\n<li><p>HTTP/1.1在消息中增加版本号，用于兼容性判断。</p>\n</li>\n<li><p>新增了请求方式PUT、PATCH、OPTIONS、DELETE等。</p>\n</li>\n<li><p>带宽优化</p>\n<blockquote>\n<p>HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。例如，客户端只需要显示一个文档的部分内容，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。</p>\n</blockquote>\n<blockquote>\n<p>HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。</p>\n</blockquote>\n<blockquote>\n<p>另外一种情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限）， 此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。HTTP/1.1 加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。</p>\n</blockquote>\n<blockquote>\n<p>注意，HTTP/1.0 的客户端不支持100响应码。但可以让客户端在请求消息中加入Expect头域，并将它的值设置为100-continue。节省带宽资源的一个非常有效的做法就是压缩要传送的数据。Content-Encoding是对消息进行端到端（end-to-end）的编码，它可能是资源在服务器上保存的固有格式（如 jpeg 图片格式）；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式。</p>\n</blockquote>\n</li>\n<li><p>长连接和短连接</p>\n<blockquote>\n<p><strong>HTTP1.1默认保持长连接</strong>（HTTP persistent connection，也翻译为<strong>持久连接</strong>），<strong>数据传输完成了保持TCP连接不断开</strong>（不发RST包、不四次握手），<strong>等待在同域名下继续用这个通道传输数据</strong>；(<strong>管道机制</strong>)</p>\n</blockquote>\n<blockquote>\n<p>相反的就是短连接。<strong>在 HTTP/1.0 中，默认使用的是短连接</strong>。也就是说，<strong>浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接</strong>。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-1-3-HTTP-2-0-（2015年5月以RFC-7540正式发表）\"><a href=\"#4-1-3-HTTP-2-0-（2015年5月以RFC-7540正式发表）\" class=\"headerlink\" title=\"4.1.3 HTTP/2.0 （2015年5月以RFC 7540正式发表）\"></a>4.1.3 HTTP/2.0 （2015年5月以RFC 7540正式发表）</h4><p>为了解决1.1版本利用率不高的问题，基于SPDY协议提出了HTTP/2.0版本。</p>\n<ul>\n<li><p>增加双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题（HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级）</p>\n</li>\n<li><p>之前HTTP版本请求和响应中，状态行和请求/响应头都是些信息字段，并没有真正的数据，因此在2.0版本中将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表，他们之间就以索引号来表示信息字段，这样就避免了1.0旧版本的重复繁琐的字段，并以压缩的方式传输，提高利用率</p>\n</li>\n<li><p>另外也增加服务器推送的功能，即不经请求服务端主动向客户端发送数据。</p>\n</li>\n</ul>\n<h4 id=\"4-1-4-HTTP3-0\"><a href=\"#4-1-4-HTTP3-0\" class=\"headerlink\" title=\"4.1.4 HTTP3.0\"></a>4.1.4 HTTP3.0</h4><ul>\n<li>基于QUIC协议传输</li>\n<li>TTP的范例和概念没有改变。它含有头部（header）和正文（body），请求和回复，还有动词（verb）、Cookie和缓存。HTTP/3的<strong>主要改变是将这些报文比特传送到另一端的方式</strong>。<br>为了使HTTP可以通过QUIC传输，协议的某些方面要进行修改，修改的结果便是HTTP/3。这些必要修改是因QUIC与TCP在某些性质上的不同所致，修改包括：     <ul>\n<li>在QUIC中，数据流由传输层本身提供，而在HTTP/2中，流由HTTP层完成。     </li>\n<li>由于数据流互相独立，HTTP/2中使用的头部压缩算法如果不做改动，会造成队头阻塞。  </li>\n<li>QUIC流与HTTP/2略有不同。本书的HTTP/3章节会做详细介绍。</li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"4-2-HTTP请求与响应过程\"><a href=\"#4-2-HTTP请求与响应过程\" class=\"headerlink\" title=\"4.2 HTTP请求与响应过程\"></a>4.2 <a href=\"https://zhuanlan.zhihu.com/p/102237039\" target=\"_blank\" rel=\"noopener\">HTTP请求与响应过程</a></h3><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628170939.png\" alt=\"HTTP请求和响应过程\"></p>\n<ul>\n<li>forward和redirect <ul>\n<li>forward（<strong>转发</strong>）:服务器请求资源，<strong>服务器直接访问目标地址URL</strong>，把那个URL的响应内容读取过来然后发送给浏览器浏览器不知道服务器发送的数据从哪里来的，所以<strong>地址栏中的地址还是原来的地址</strong>。</li>\n<li>redirect（<strong>重定向</strong>）:服务端根据逻辑发送一个状态码，告诉<strong>浏览器去请求那个地址</strong>，所以<strong>地址栏中的地址是目标URL</strong>。</li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"4-3-在浏览器中输入url到显示页面的过程\"><a href=\"#4-3-在浏览器中输入url到显示页面的过程\" class=\"headerlink\" title=\"4.3 在浏览器中输入url到显示页面的过程\"></a>4.3 在浏览器中输入url到显示页面的过程</h3><ol>\n<li><p><strong>输入地址</strong></p>\n<blockquote>\n<p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>\n</blockquote>\n</li>\n<li><p><strong>浏览器查找域名的 IP 地址</strong></p>\n<blockquote>\n<p>2.1 请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先<strong>查看本地硬盘的 hosts</strong> 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>\n</blockquote>\n<blockquote>\n<p>2.2 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 <strong>DNS请求到本地DNS服务器</strong>。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p>\n</blockquote>\n<blockquote>\n<p>2.3 查询你输入的网址的DNS请求到达本地DNS服务器之后，<strong>本地DNS服务器会首先查询它的缓存记录</strong>，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要<strong>向DNS根服务器进行查询</strong>。</p>\n</blockquote>\n<blockquote>\n<p>2.4 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以<strong>到域服务器上去继续查询</strong>，并给出域服务器的地址。<strong>这种过程是迭代的过程</strong>。</p>\n</blockquote>\n<blockquote>\n<p>2.5本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</p>\n</blockquote>\n<blockquote>\n<p>2.6 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>\n</blockquote>\n</li>\n<li><p><strong>浏览器向 web 服务器发送一个 HTTP 请求</strong></p>\n<blockquote>\n<p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口<strong>发起TCP的连接请求</strong>。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p>\n</blockquote>\n</li>\n<li><p><strong>服务器的永久重定向响应</strong></p>\n<blockquote>\n<p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访 <a href=\"http://www.google.com/\" target=\"_blank\" rel=\"noopener\">http://www.google.com/</a> 而非 <a href=\"http://google.com/\" target=\"_blank\" rel=\"noopener\">http://google.com/</a> 。为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像 <a href=\"http://www.yy.com/和http://yy.com/\" target=\"_blank\" rel=\"noopener\">http://www.yy.com/和http://yy.com/</a> ，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现</p>\n</blockquote>\n</li>\n<li><p><strong>浏览器跟踪重定向地址</strong></p>\n<blockquote>\n<p>现在浏览器知道了 <a href=\"http://www.google.com/\" target=\"_blank\" rel=\"noopener\">http://www.google.com/</a> 才是要访问的正确地址，所以它会发送另一个http请求。</p>\n</blockquote>\n</li>\n<li><p><strong>服务器处理请求</strong></p>\n<blockquote>\n<p>经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？</p>\n</blockquote>\n<blockquote>\n<p>后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。</p>\n</blockquote>\n<blockquote>\n<p>一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。</p>\n</blockquote>\n<blockquote>\n<p>此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>\n</blockquote>\n</li>\n<li><p><strong>服务器返回一个 HTTP 响应</strong>　</p>\n<blockquote>\n<p>经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。</p>\n</blockquote>\n<blockquote>\n<p>HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：<strong>状态行、响应头(Response Header)、响应正文</strong></p>\n</blockquote>\n</li>\n<li><p><strong>浏览器显示 HTML</strong></p>\n<blockquote>\n<p>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了</p>\n</blockquote>\n</li>\n</ol>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"4-4-HTTP传输过程\"><a href=\"#4-4-HTTP传输过程\" class=\"headerlink\" title=\"4.4 HTTP传输过程\"></a>4.4 HTTP传输过程</h3><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200629082216.png\" alt=\"HTTP传输过程\"></p>\n<h3 id=\"4-5-报文格式\"><a href=\"#4-5-报文格式\" class=\"headerlink\" title=\"4.5 报文格式\"></a>4.5 <a href=\"https://blog.csdn.net/aomize/article/details/78609301\" target=\"_blank\" rel=\"noopener\">报文格式</a></h3><p><a href=\"https://blog.csdn.net/lyn_00/article/details/84953763\" target=\"_blank\" rel=\"noopener\">报文格式</a> </p>\n<table>\n<thead>\n<tr>\n<th>信息</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>起始行</td>\n<td>对报文进行描述</td>\n</tr>\n<tr>\n<td>头部</td>\n<td>向报文中添加了一些附加信息，是一个名/只的列表，头部和协议配合工作，共同决定了客户端和服务器能做什么事情</td>\n</tr>\n<tr>\n<td>主体</td>\n<td>包含数据的主体部分</td>\n</tr>\n</tbody></table>\n<h4 id=\"4-5-1-响应报文格式\"><a href=\"#4-5-1-响应报文格式\" class=\"headerlink\" title=\"4.5.1 响应报文格式\"></a>4.5.1 响应报文格式</h4><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628205247.png\" alt=\"请求报文格式\"></p>\n<ul>\n<li>HTTP请求起始行</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>请求URL所指的文档</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>从客户端向服务器端发送一些信息</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>只请求文档的信息，而不包含文档的内容</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>从服务器向客户端发送文档</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>把到达的请求回送</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>保留</td>\n</tr>\n<tr>\n<td>OPTION</td>\n<td>询问关于可用的选项</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Get和Post的区别 <ul>\n<li>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同</li>\n<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>\n<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>\n<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>\n<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>\n<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>\n<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>\n<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>\n<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>\n<li>GET参数通过URL传递，POST放在Request body中。</li>\n<li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</li>\n<li>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>HTTP请求头部</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>信息</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept</td>\n<td>指浏览器或其他客户可以接爱的MIME文件格式。可以根据它判断并返回适当的文件格式</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>指出浏览器可以接受的语言种类，如en或en-us，指英语</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>设置关于请求被代理服务器存储的相关选项。一般用不到</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>用来告诉服务器是否可以维持固定的HTTP连接。HTTP/1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>用来表名request的内容类型。可以用HttpServletRequest的getContentType()方法取得</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能</td>\n</tr>\n</tbody></table>\n<h4 id=\"4-5-2-响应报文格式\"><a href=\"#4-5-2-响应报文格式\" class=\"headerlink\" title=\"4.5.2 响应报文格式\"></a>4.5.2 响应报文格式</h4><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628205343.png\" alt=\"响应报文格式\"></p>\n<ul>\n<li>HTTP响应起始行</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server</td>\n<td>给出服务器相关信息</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>服务器将接受请求的字节范围</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>指明媒体类型</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>指明编码方案</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>请求客户将请求发送到另一站点</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>服务器请求客户保存Cookie</td>\n</tr>\n<tr>\n<td>Upgrade</td>\n<td>指明优先使用的通信协议</td>\n</tr>\n<tr>\n<td>Public</td>\n<td>给出可以支持的文档清单</td>\n</tr>\n<tr>\n<td>Retry-afer</td>\n<td>指明的日期之后，服务器才能使用</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>HTTP常见状态码</p>\n<ul>\n<li><p>1开头状态码<br>  <strong>表示请求已被接收，继续处理</strong></p>\n</li>\n<li><p>2开头状态码<br>  <strong>表示成功处理请求的状态代码</strong></p>\n<ul>\n<li>200:通常表示服务器成功处理的请求</li>\n</ul>\n</li>\n<li><p>3开头状态码<br>  <strong>表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向</strong></p>\n<ul>\n<li>301:代表永久性转移</li>\n<li>302:代表暂时性转移</li>\n</ul>\n</li>\n<li><p>4开头状态代码 <strong>通常表示请求可能出现错误，妨碍了服务器的处理</strong></p>\n<ul>\n<li>400：服务器不理解请求的语法</li>\n<li>403：服务器拒绝请求</li>\n<li>404：服务器找不到请求的网页</li>\n</ul>\n</li>\n<li><p>5开头状态码 <strong>通常表示服务器在处理中这些请求时发生内错误。这些错误可能是服务器本身错误或是请求出错</strong></p>\n<ul>\n<li><p>500(服务器内部错误):服务器遇到错误，无法完成请求</p>\n</li>\n<li><p>501(无法实施):服务器不具备完成请求的功能。例如服务器无法识别方法。</p>\n</li>\n<li><p>502(错误网关)：服务器作为网关或代理，从上游服务器收到无效响应。</p>\n</li>\n<li><p>503(服务不可用):服务器目前无法使用(由于超载或者停机维护)，通常这只是暂时转态。</p>\n</li>\n<li><p>504(网关超时):服务器作为网关或者代理，但是没有及时从上游服务器收到请求。</p>\n</li>\n<li><p>505(HHTP版本不受支持):服务器不支持请求中所使用的HTTP协议版本</p>\n<blockquote>\n<p>重点：<strong><em>200,304,403,500</em></strong></p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"4-6-HTTP与HTTPS的区别\"><a href=\"#4-6-HTTP与HTTPS的区别\" class=\"headerlink\" title=\"4.6 HTTP与HTTPS的区别\"></a>4.6 HTTP与HTTPS的区别</h3><ul>\n<li>HTTPS协议需要ca申请证书，一般免费证书较少，所以需要一定费用</li>\n<li>HTTP是超文本协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议<ul>\n<li>在HTTP通信中加入了SSL层，通信的数据被加密了，防止被窃取，具体的通信流程如下：<br>  <img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/HTTPS%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93.png\" alt=\"\"></li>\n</ul>\n</li>\n<li>HTTP和HTTPS使用的是两种完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li>\n<li>HTTP的连接很简单，是无状态的；HTTPS是有SSl+HTTP协议构成的可加密除数，身份认证的网络协议，比HTTP更安全</li>\n</ul>\n<h3 id=\"4-7-HTTPS实现原理\"><a href=\"#4-7-HTTPS实现原理\" class=\"headerlink\" title=\"4.7 HTTPS实现原理\"></a>4.7 <a href=\"https://blog.csdn.net/u011547347/article/details/83186514\" target=\"_blank\" rel=\"noopener\">HTTPS实现原理</a></h3><h3 id=\"4-8-HTTP代理服务器\"><a href=\"#4-8-HTTP代理服务器\" class=\"headerlink\" title=\"4.8 HTTP代理服务器\"></a>4.8 HTTP代理服务器</h3><p>工作在<strong>应用层</strong>，比价耗费资源</p>\n<ul>\n<li><strong>提高访问速度</strong>：通常代理服务器都设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的 信息时，则直接由缓冲区中 取出信息，传给用户，以提高<br>访问速度。</li>\n<li><strong>控制对内部资源的访问</strong>：如某大学FTP（前提是该代理地址在该资源的允许访问范围之 内），使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</li>\n<li><strong>过滤内容</strong>：例如限制对特定计算机的访问，将一种语言的数据翻译成另一种语言，或是防御代理服务器两边的攻击性访问。</li>\n<li><strong>隐藏真实IP</strong>：上网者也可以通过代理服务器隐藏自己的IP，免受攻击。但是只一个代 理很难保证安全，更安全的方法是利用特定的工具创建代理链</li>\n<li><strong>突破自身IP访问限制</strong>：访问国外站点。中国教育网和169网等网络用户可以通过代理访 问国外网站。</li>\n<li><strong>突破内容过滤机制限制，访问被过滤网站</strong>。</li>\n</ul>\n<p><br><br><br></p>\n<hr>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"1-常用网络测试命令及应用\"><a href=\"#1-常用网络测试命令及应用\" class=\"headerlink\" title=\"1. 常用网络测试命令及应用\"></a>1. 常用网络测试命令及应用</h3><h4 id=\"ping命令\"><a href=\"#ping命令\" class=\"headerlink\" title=\"ping命令\"></a>ping命令</h4><pre class=\" language-ini\"><code class=\"language-ini\">Ping [-t] [-a] [-n count] [-l length] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [-j HostList]| [-k HostList] [-w timeout] destination –list\n\nv-t，不间断地ping指定的主机，直到按“Ctrl+C” 组合键中断为止。\nv-a，指定对目的地IP地址进行反向名称解析。如 果解析成功，将显示相应的主机名。\nv-n count，发送count指定的ECHO数据包数，默认值为4。\n-l length，自定义发送数据包的大小，也就是发送由length指定大小的ECHO数据包，默认为32字节，最 大值是65527字节。\nv-f，指定发送的回响请求消息带有“不要拆分”标志（所在的IP标题设为1）\nv-i TTL，指定发送回响请求消息的IP标题中的TTL字段值。\nv-v TOS，指定发送回响请求消息的IP标题中的“服务 类型 (TOS)”字段值，默认值是0。TOS被指定为0到 255的十进制数。\nv-r count，指定IP标题中的“记录路由”选项用于记录由回响请求消息和相应的回响应答消息使用的路径</code></pre>\n<ul>\n<li>功能<ul>\n<li>ping 127.0.0.1：检查TCP/IP是否被正确地安装。 </li>\n<li>ping本机IP：ping本地计算机的IP地址，本地计算 机对该ping命令作出应答。如果没有应答，则表示本地 配置或安装存在问题。出现此问题时，局域网用户可断开 网络电缆，然后重新发送该命令。如果网线断开后本命令 正确，则表示另一台计算机可能配置额相同的IP地址。</li>\n<li>ping局域网内其他主机IP：如果收到回送应答，表 明本地网络中的网卡和传输介质运行正确。但如果没有收 到回送应答，那么表示子网掩码不正确或网卡配置错误，或电缆线路有问题。</li>\n<li>ping网关IP：该命令如果应答正确，表示局域网中 的网关路由器正在运行以及能否与本地网络上的本地主机 通讯。</li>\n<li>ping远程主机IP：如果收到4个应答，表示成功地 使用了缺省网关。对于拨号上网用户则表示能够成功地访 问Internet。</li>\n<li>ping域名：ping域名，如 ping <a href=\"http://www.sina.com.cn\" target=\"_blank\" rel=\"noopener\">www.sina.com.cn</a> ，通常是通过DNS服务器进行解析。 如果这里出现故障，则表示DNS服务器的IP地址配置不 正确或DNS服务器有故障。另外，利用该命令可以实现域名对IP地址的转换功能。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><pre class=\" language-ini\"><code class=\"language-ini\">    nslookup www.*.com</code></pre>\n<ul>\n<li>功能<ul>\n<li>nslookup是一个监测网络中DNS服务器是否能正确实现域名解析的命令行 工具。它在 UNIX/Windows NT/2000/XP中均可使用。nslookup必须要 安装了TCP/IP的网络环境中才能使用。</li>\n<li>如果需要对DNS的故障进行排错就必须熟练使用工具nslookup。这个命令 可以指定查询的类型，可以查到DNS记录的生存时间，还可以指定使用哪个DNS服务器进行解释。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ipconfig命令\"><a href=\"#ipconfig命令\" class=\"headerlink\" title=\"ipconfig命令\"></a>ipconfig命令</h4><pre class=\" language-ini\"><code class=\"language-ini\">    ipconfig [/all /renew [adapter] /release [adapter]] [/flushdns] [/displaydns] [/registerdns] [/showclassid Adapter] [/setclassid Adapter [ClassID]]</code></pre>\n<ul>\n<li><p>功能</p>\n<ul>\n<li>ipconfig用于显示当前的TCP/IP网络配置的设置值、刷 新动态主机配置协议（DHCP）和域名系统（DNS）设置。 使用不带参数的ipconfig可以显示所有适配器的IP地址、子网掩码和默认网关。</li>\n<li>ipconfig一般用来检验人工配置的TCP/IP设置是否正确。 如果计算机和所在的局域网使用了动态主机配置协议 （DHCP），这个程序所显示的信息可以让用户了解自己 的计算机是否成功的租用到一个IP地址，如果租用到则可 以了解它目前分配到的具体地址。了解计算机当前的IP地 址、子网掩码和缺省网关实际上是进行测试和故障分析的必要条件。</li>\n</ul>\n</li>\n<li><p>范例</p>\n<ul>\n<li>要显示所有适配器的完整TCP/IP配置，键入 <code>ipconfig/all。</code></li>\n<li>仅更新“本地连接”适配器的由DHCP分配IP地址 的配置，键入 <code>ipconfig /renew &quot;Local Area Connection&quot;</code></li>\n<li>要在排除DNS的名称解析故障期间清理DNS解析器 缓存，键入<code>ipconfig /flushdns</code></li>\n<li>要显示名称以Local开头的所有适配器的DHCP类别 ID，键入<code>ipconfig /showclassid Local</code></li>\n<li>要将“本地连接”适配器的DHCP类别ID设置为 TEST，键入<code>ipconfig /setclassid &quot;Local Area Connection&quot; TEST</code></li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"2-网络流量监视命令\"><a href=\"#2-网络流量监视命令\" class=\"headerlink\" title=\"2. 网络流量监视命令\"></a>2. 网络流量监视命令</h3><table>\n<thead>\n<tr>\n<th>命令名称</th>\n<th>适用的操作系统</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ping</td>\n<td>UNIX/Windows</td>\n<td>用于测量往返数据包丢失率</td>\n</tr>\n<tr>\n<td>bing</td>\n<td>UNIX</td>\n<td>测量线路的点到点带宽</td>\n</tr>\n<tr>\n<td>etherfind</td>\n<td>UNIX</td>\n<td>检查以太网数据包</td>\n</tr>\n<tr>\n<td>snoop</td>\n<td>UNIX</td>\n<td>捕获并检查网络数据包</td>\n</tr>\n<tr>\n<td>tcpdump</td>\n<td>UNIX</td>\n<td>网络的dumps流量</td>\n</tr>\n<tr>\n<td>getethers</td>\n<td>UNIX</td>\n<td>获取一个以太网局域网网段中所有主机的地址</td>\n</tr>\n<tr>\n<td>iptrace</td>\n<td>UNIX</td>\n<td>测量网关的性能</td>\n</tr>\n<tr>\n<td>netstat</td>\n<td>UNIX/Windows</td>\n<td>显示各种网络相关数据结构的内容</td>\n</tr>\n<tr>\n<td>arp</td>\n<td>UNIX/Windows</td>\n<td>显示并修改Internet到Ethernet地址转换表</td>\n</tr>\n<tr>\n<td>tracert</td>\n<td>UNIX/Windows</td>\n<td>追踪有路由延迟的目标机的路由</td>\n</tr>\n<tr>\n<td>route</td>\n<td>UNIX/Windows</td>\n<td>显示、人工添加和修改路由表项目</td>\n</tr>\n<tr>\n<td>pathping</td>\n<td>UNIX/Windows</td>\n<td>显示有关在源和目标主机之间的中间跃点处的网络 滞后和网络丢失的信息</td>\n</tr>\n</tbody></table>\n<ul>\n<li>其中一个是<strong>ping</strong>命令，重复执行大量的ping命令（ICMP回显 请求消息）可测算出接收的成功次数，就可以计算出数据包丢失的百分率。包丢失是一种吞吐量的测算。</li>\n<li>另一个常用的命令是点到点带宽<strong>bing</strong>命令，这个命令是以ping 为基础的，通过线路两端发送数据包的大小不同而产生的往返时间差进行计算，可以得出粗略的吞吐量数据。</li>\n<li>其他5个命令可以检查在网络中经过的数据包，分别提供不同的 输出。命令<strong>etherfind</strong>、<strong>snoop</strong>和<strong>tcpdump</strong>把网卡置于混杂模式中（在这种模式中，收集网络中未经处理的数据无需经过任 何过滤）并记录数据。命令<strong>getethers</strong>可以得到所有局域网网段 的主机名和以太网地址对。工具<strong>iptrace</strong>在UNIX内核中使用 NETMON程序，产生3类输出：IP流量、主机流量矩阵输出和预先定义数据包号的简短取样。</li>\n<li><strong>netstat</strong>命令可以帮助网络管理员了解网络的整体使用情 况。它可以显示当前正在活动的网络连接的详细信息，例 如，显示网络连接、路由表和网络接口信息，可以统计目前总共有哪些网络连接正在进行。命令格式语法： <code>netstat [-a] [-e] [-n] [-o] [-p Protocol] [-r] [-s] [Interval]</code>,</li>\n<li>使用<strong>arp</strong>命令，能够查看本地计算机或另一台计 算机的ARP高速缓存中的当前内容。此外，使用 arp命令，也可以用人工方式输入静态的网卡物 理和IP地址对，使用这种方式为缺省网关和本地 服务器等常用主机进行这项操作，有助于减少网络上的信息量。ARP命令格式：<code>arp [-a [InetAddr] [-N IfaceAddr]] [-g [InetAddr] [-N IfaceAddr]] [-d InetAddr [IfaceAddr]] [-s InetAddr EtherAddr [IfaceAddr]]</code></li>\n<li><strong>tracert</strong>一般用来检测故障的位置，虽然还是不能确定 具体故障原因，但已经能显示问题所在的地方。另外， traceroute命令的功能与tracert相同，二者的差别仅 仅在于tracert命令是用在Windows平台上，而traceroute命令是用在Unix平台和路由器上。</li>\n<li><strong>tracert</strong>命令用来显示数据包到达目标主机所经过的路径，并 显示到达每个节点的时间。命令格式如下：<code>Tracert IP地址或主机名 [-d] [-h maximum_hops] [-j host_list] [-w timeout]</code></li>\n<li><strong>route</strong>命令用来显示、人工添加和修改路由表项目的。 route命令格式：<code>route [-f] [-p] [[print] [add] [change] [delete] [Destination] [mask subnetmask] [Gateway] [metric Metric]] [if Interface]</code></li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"3-专有名词\"><a href=\"#3-专有名词\" class=\"headerlink\" title=\"3. 专有名词\"></a>3. 专有名词</h3><ul>\n<li><p>CDN</p>\n<ul>\n<li>CDN的全称是<code>Content Delivery Network</code>，即<code>内容分发网络</code>，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户<code>就近</code>获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有<code>内容存储</code>和<code>分发技术</code>。</li>\n</ul>\n</li>\n<li><p>DNS</p>\n<ul>\n<li><p>你有没有想过为什么你可以通过键入 <code>www.google.com</code> 就能够获取你想要的网站？我们上面说到，计算机网络中的每个端系统都有一个 IP 地址存在，而把 IP 地址转换为便于人类记忆的协议就是 <code>DNS 协议</code>。</p><br><p>DNS 的全称是<code>域名系统（Domain Name System，缩写：DNS）</code>，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>\n</li>\n</ul>\n</li>\n<li><p>URL   </p>\n<ul>\n<li><p>我们上面提到，你可以通过输入 <code>www.google.com</code> 地址来访问谷歌的官网，那么这个地址有什么规定吗？我怎么输都可以？AAA.BBB.CCC 是不是也行？当然不是的，你输入的地址格式必须要满足 <code>URI</code> 的规范。</p><br>  <p><code>URI</code>的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>   <br><p><code>URL</code>的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的<code>网址</code>，它实际上是 URI 的一个子集。</p><p>URI 不仅包括 URL，还包括 URN（统一资源名称），它们之间的关系如下</p>\n\n<img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/URI组成.png\" data-caption=\"URI组成\" />\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<p><br><br><br></p>\n<ul>\n<li>推荐文章<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/102237039\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/102237039</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_44367006/article/details/99768731\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_44367006/article/details/99768731</a></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>参考<br>[1]<a href=\"https://blog.csdn.net/liuyanfeier/article/details/52787037\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liuyanfeier/article/details/52787037</a><br>[2]<a href=\"https://blog.csdn.net/qq_32374237/article/details/86242159\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_32374237/article/details/86242159</a><br>[3]<a href=\"https://blog.csdn.net/gui951753/article/details/79412524\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gui951753/article/details/79412524</a><br>[4]<a href=\"https://blog.csdn.net/lyn_00/article/details/84953763\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lyn_00/article/details/84953763</a><br>[5]<a href=\"https://blog.csdn.net/moge19/article/details/90050030\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/moge19/article/details/90050030</a><br>[6]<a href=\"https://zhuanlan.zhihu.com/p/102237039\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/102237039</a><br>[7]<a href=\"https://blog.csdn.net/weixin_44367006/article/details/99768731\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_44367006/article/details/99768731</a><br>[8]<a href=\"https://blog.csdn.net/qq_33663020/article/details/79386252\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_33663020/article/details/79386252</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200629181240.png\" alt=\"NetWork\"></p>","more":"<p><a href=\"https://blog.csdn.net/shuningzhang/article/details/90138425\" target=\"_blank\" rel=\"noopener\">interview_1</a></p>\n<h2 id=\"一、TCP-IP网络模型\"><a href=\"#一、TCP-IP网络模型\" class=\"headerlink\" title=\"一、TCP/IP网络模型\"></a>一、TCP/IP网络模型</h2><table>        \n    <tr>\n        <th>OSI</th>\n        <th>TCP/IP</th>\n        <th>功能</th>\n        <th>TCP/IP协议簇</th>\n    </tr>\n    <tr>\n        <td>\n            应用层<br>\n            表示层<br>\n            会话层<br>\n        </td>\n        <td>应用层</td>\n        <td>\n            文件传输，电子邮件，文件服务<br>\n            数据格式化，数据加密<br>\n            接触或建立与别的结点的连接<br>\n        </td>\n        <td>\n            TFTP，HHTP，SMTP,FTP,DNS\n        </td>\n    </tr>\n    <tr>\n        <td>传输层</td>\n        <td>传输层</td>\n        <td>提供端对端的接口</td>\n        <td>TCP,UDP</td>\n    </tr>\n    <tr>\n        <td>网络层</td>\n        <td>网络层</td>\n        <td>为数据包选择路由</td>\n        <td>IP,ICMP,RIP</td>\n    </tr>\n    <tr>\n        <td>\n            数据链路层<br>\n            物理层<br>\n        </td>\n        <td>链路层</td>\n        <td>\n            |传输有错误的帧以及错误检测功能<br>\n            以二进制数据格式在物理媒介上传输数据<br>\n        </td>\n        <td>\n            ARP,SLIP<br>\n            ISO2110,IEEE802<br>\n        </td>\n    </tr>\n</table>\n\n<ol>\n<li>物理层<ul>\n<li>该层为上层协议提供了一个传输数据的可靠物理媒介。简单的说，物理层确保原始数据可在各种物理媒介中传输。<ul>\n<li>中继器</li>\n<li>集线器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据链路层<ul>\n<li>将源自网络层的数据可靠地传输到相邻结点的目标网络层。主要功能有<strong>将数据融合成数据块（帧），控制帧在物理信道上的传输，处理传输差错，调节发送速率以使与接收方匹配</strong>。主要作用即：<strong>物理地址寻址，数据成帧，流量控制，数据的检错，重发</strong><ul>\n<li>数据链路层为网络层提供可靠的数据传输</li>\n<li>基本数据的数据单位为帧</li>\n<li>主要的协议：以太网协议</li>\n<li>网桥</li>\n<li>交换机</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络层<ul>\n<li>该层的目的是<strong>实现两个主机系统之间的数据传输透明</strong>，具体功能包括<strong>寻址和路由选择，连接的建立与终止等</strong>，<strong>它提供的服务使传输层不需要了解网络层的数据传输和交换技术</strong>，可简单记为<strong>路径选择，路由及逻辑寻址</strong><ul>\n<li>TCP/IP的核心协议————IP协议<ul>\n<li>功能包括有：无线数据包传输，数据包路由选择，差错控制</li>\n<li>与其配套的协议有：地址解析协议ARP,因特网报文协议ICMP等</li>\n</ul>\n</li>\n<li>网络层负责对子网间的数据包进行路由选择，还可以实现拥塞控制，网际互联</li>\n<li>基本数据单位为IP数据报</li>\n<li>路由器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>传输层<ul>\n<li>负责<strong>将上层数据分段并提供端对端的，可靠或不可靠的传输</strong>。此外，传输层还要<strong>处理端到端的差错控制和流量控制</strong>，其任务是根据通信子网的特性，最佳的利用网络资源，<strong>为两个端系统的会话层之间，建立，维护和取消阐述连接的功能，负责端对端的可靠信息传输</strong>，在这一层，信息传送的协议称为<strong>段</strong>或者<strong>报文</strong>，作用：<strong>为应用进程之间提供端到端的逻辑通信</strong><ul>\n<li>传输层负责<strong>将上层数据分段并提供端到端，可靠或者不可靠的传输以及端到端的差错控制以及流量控制</strong></li>\n<li><strong>TCP协议</strong>，<strong>UDP协议</strong></li>\n<li>网关</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>会话层</li>\n</ol>\n<ul>\n<li>管理主机之间的<strong>会话进程</strong>，负责<strong>建立、管理、终止进程之间的会话</strong>，还可利用在数据中插入校验点<strong>实现数据同步</strong>，包括建立检查点和恢复方案。</li>\n</ul>\n<ol start=\"6\">\n<li>表示层</li>\n</ol>\n<ul>\n<li>对上层数据或信息进行<strong>变换</strong>以保证<strong>一个主机的信息可以被另外一个主机的应用程序理解</strong>，包括对数据的<strong>加密，压缩，格式转换</strong>等，数据描述使得应用程序不必担心计算机内部存储格式的问题。</li>\n</ul>\n<ol start=\"7\">\n<li>应用层<ul>\n<li>最靠近用户的层，<strong>为用户的应用进程提供网络服务的接口，将用户的操作通过应用进程转换为服务，并匹配一个相应的服务协议发送给传输层</strong><blockquote>\n<p>传输数据时可以只是使用（传输层）协议，但是没有应用层的话便无法识别数据内容。如果要使传输的数据有意义，则必须使用应用层协议。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<p><br><br><br></p>\n<hr>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"二、TCP和UDP\"><a href=\"#二、TCP和UDP\" class=\"headerlink\" title=\"二、TCP和UDP\"></a>二、TCP和UDP</h2><h3 id=\"2-1-TCP和UDP的区别\"><a href=\"#2-1-TCP和UDP的区别\" class=\"headerlink\" title=\"2.1 TCP和UDP的区别\"></a>2.1 TCP和UDP的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>UDP</th>\n<th>TCP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否连接</td>\n<td>无连接</td>\n<td>有连接</td>\n</tr>\n<tr>\n<td>是否可靠</td>\n<td>不可靠，不使用流量控制和拥塞控制</td>\n<td>可靠传输，使用流量控制和拥塞控制</td>\n</tr>\n<tr>\n<td>是否有序</td>\n<td>无序</td>\n<td>有序</td>\n</tr>\n<tr>\n<td>是否有界</td>\n<td>有界</td>\n<td>无界</td>\n</tr>\n<tr>\n<td>重传机制</td>\n<td>无</td>\n<td>超时重传机制，快速重传机制</td>\n</tr>\n<tr>\n<td>连接对象个数</td>\n<td>一对一，一对多，多对一，多对多</td>\n<td>一对一</td>\n</tr>\n<tr>\n<td>传输方式</td>\n<td>面向报文</td>\n<td>面向数据流</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>小，仅8字节</td>\n<td>最小20字节，最大60字节</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>实时应用（视频会议，直播）</td>\n<td>适用于可靠的应用（文件传输）</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>是否有界</p>\n<blockquote>\n<p><strong>TCP通过字节流传输</strong>，即TCP将应用程序看成是一连串的无结构的字节流。每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。 而<strong>UDP传输报文的方式是由应用程序</strong>控制的，<strong>应用层</strong>交给UDP多长的报文，UDP照样发送，<strong>既不拆分，也不合并，而是保留这些报文的边界</strong>，即一次发送一个报文。有界与无界之分是根据接收报文来划分的，对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的,<strong>UDP无缓存服务，信息确认由应用层完成</strong>。</p>\n</blockquote>\n</li>\n<li><p>TCP黏包问题</p>\n<blockquote>\n<p>由于<strong>TCP协议</strong>本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会维持一个连接（Channel），数据在连接不断开的情况下，可以持续不断地将多个数据包发往服务器，但是如果发送的网络数据包太小，那么他本身会启用<strong>Nagle算法</strong>（可配置是否启用）<strong>对较小的数据包进行合并</strong>（基于此，TCP的网络延迟要UDP的高些）然后再发送（超时或者包大小足够）。<strong>那么这样的话，服务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包</strong>；服务器在接收到数据库后，放到缓冲区中，<strong>如果消息没有被及时从缓存区取走</strong>，下次在取数据的时候可能就会出现一次取出多个数据包的情况，造成粘包现象。</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>发送定长的数据 <strong>不能完全解决</strong> 会出现不知道从哪里开始分离固定长度的数据的情况(没有被及时从缓存区取走)</li>\n<li><strong>自定制协议</strong> [定长结构体(标识该条数据长度)]12345[分隔符]</li>\n</ul>\n</blockquote>\n</li>\n<li><p>TCP分包问题：</p>\n<blockquote>\n<p>可能是<strong>IP分片传输</strong>导致的，也可能是<strong>传输过程中丢失部分包导致出现的半包</strong>，还有<strong>可能就是一个包可能被分成了两次传输</strong>，在取数据的时候，先取到了一部分（还可能与接收的缓冲区大小有关系），总之就是一个数据包被分成了多次接收。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>UDP无连接<br>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。具体来说就是：<blockquote>\n<p>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了.在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"2-2-TCP特性\"><a href=\"#2-2-TCP特性\" class=\"headerlink\" title=\"2.2 TCP特性\"></a>2.2 TCP特性</h3><ul>\n<li><a href=\"https://blog.csdn.net/Cecilia3333/article/details/80358201\" target=\"_blank\" rel=\"noopener\">TCP的各种机制</a><ul>\n<li>可靠性<ul>\n<li><strong>确认应答机制</strong>（ACK）</li>\n<li><strong>超时重传机制</strong></li>\n<li><strong>校验和</strong></li>\n</ul>\n</li>\n<li>流量控制<ul>\n<li><strong>滑动窗口机制</strong>（ARQ)<blockquote>\n<p>滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>拥塞控制<ul>\n<li>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载</li>\n<li>具体实现<blockquote>\n<p><strong>慢启动</strong>（Slow Start）发送方维护拥塞窗口变量cwnd，先用小数据试探网络拥塞，没问题后来断加倍.<br><strong>拥塞避免</strong>（Congestion voidance）：拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1<br><strong>快速重传</strong>（Fast Retransmit）：快重传要求接收方收到失序报文段后立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br><strong>快速恢复</strong>（Fast Recovery）：当发送方连续收到三个重复确认时，就把慢开始门限ssthresh门限减半。接下来将cwnd设置为ssthresh的大小，然后执行拥塞避免算法</p>\n</blockquote>\n<ul>\n<li><strong>捎带应答</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"2-3-TCP连接的建立与终止过程\"><a href=\"#2-3-TCP连接的建立与终止过程\" class=\"headerlink\" title=\"2.3 TCP连接的建立与终止过程\"></a>2.3 TCP连接的建立与终止过程</h3><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/TCP%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png\" alt=\"TCP传输过程\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628132143.png\" alt=\"TCP三次握手\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628132341.png\" alt=\"TCP四次挥手\"></p>\n<ul>\n<li><p>三次握手</p>\n<ul>\n<li>第一次握手：客户端将标志位SYN置为1，表示请求同步（建立连接）。随机产生一个值seq=x，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li>\n<li>第二次握手：服务器端将标志位SYN置为1表示请求同步，ACK置为1表示收到请求。ack=x+1，用于给客户端和之前传送过来的seq校验。随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li>\n<li>第三次握手：客户端收到确认后，检查ACK是否为1，ack是否为x+1，如果正确则将标志位ACK置为1，ack=y+1，seq=传过来的ack=x+1，并将该数据包发送给服务器端，并进入ESTABLISHED状态。服务器端检查ACK是否为1，ack是否为y+1，如果正确则连接建立成功服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。假如第三次握手没有到达服务器端呢？但是这时客户端已进入ESTABLISHED状态。但是其实这种情况下，只要客户端向服务器端写数据，就会收到服务器端的RST（复位）应答，这时客户端就能知道出现问题了。</li>\n</ul>\n</li>\n<li><p>三次握手的漏洞<br>但是在TCP三次握手中是有一个缺陷的。利用三次握手的缺陷可以进行<strong>SYN洪泛攻击</strong>。</p>\n<ul>\n<li>SYN洪泛攻击：通过网络服务所在的端口发送<strong>大量伪造原地址的攻击报文</strong>，发送到服务端，<strong>造成服务端上的半开连接队列被占满</strong>，从而阻止其他用户进行访问。</li>\n<li>原理：攻击者客户端利用伪造的IP地址向服务端发出请求(第一次握手)，<strong>而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(永远都不会有的)</strong>，服务端在<strong>等待这种半开的连接过程中消耗了资源</strong>，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。</li>\n<li>解决方案： <ul>\n<li>无效连接监视释放<blockquote>\n<p>这种方法不停监视所有的连接，包括三次握手的，还有握手一次的，反正是所有的，当达到一定(与)阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，不管是正常的还是攻击的，所以这种方式不推荐。</p>\n</blockquote>\n</li>\n<li>延缓TCB分配方法<blockquote>\n<p>一般的做完第一次握手之后，服务器就需要为该请求分配一个TCB（连接控制资源），通常这个资源需要200多个字节。延迟TCB的分配，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。</p>\n</blockquote>\n</li>\n<li>使用防火墙<blockquote>\n<p>防火墙在确认了连接的有效性后，才向内部的服务器（Listener）发起SYN请求，</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>四次挥手</p>\n<ul>\n<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>\n<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于<strong>半关闭状态</strong>，即客户端已经没有数据要发送了，但是<strong>服务器若发送数据，客户端依然要接受</strong>。这个状态还要持续一段时间，也就是整个<strong>CLOSE-WAIT状态</strong>持续的时间。</li>\n<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>\n<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>\n<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2 MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>四次挥手的原因</p>\n<p>  <strong>防止客户端失效的连接请求报文段突然又传到服务器</strong><br>  <em>例如以下情况如果使用两次握手</em>：</p>\n<blockquote>\n<p>如果客户端向服务器发送第一次连接请求在网络节点上滞留了，没有收到服务器的确认，于是又重新发送了一次连接请求，服务器收到客户端的第二次请求发送确认，则连接建立完成，服务器客户端进行数据传输，传输完成断开连接。此时，<strong>在网络上滞留的客户端第一次连接请求到达服务器，服务器发送确认连接但是客户端实际上并没有发送请求，因此不会理睬服务器发送的请求。但是服务器认为连接已完成，并等待客户端进行数据传输</strong>。这样会造成资源的浪费</p>\n</blockquote>\n<p>  <em>如果采用三次握手的话</em>：</p>\n<blockquote>\n<p>滞留在网络上的客户端第一次请求到达服务器之后，服务器发送确认，但实际上服务器并没有发送请求，因此不会理睬服务器的确认，故不会发送确认，服务器等不到客户端的确认则连接建立失败。这样就防止了客户端失效的连接请求报文段突然又传到服务器</p>\n</blockquote>\n</li>\n<li><p>TCP连接点的终止为啥是四次挥手而不是三次<br><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%8E%9F%E5%9B%A0.png\" alt=\"TCP四次挥手原因\"></p>\n</li>\n<li><p>TIME_WAIT状态：</p>\n<blockquote>\n<p>主动关闭放进入TIME_WAIT状态后，等待被动连接放发送FIN分节，如果直接关闭的话，系统可能会有一个与主动关闭方相同的新进程与被动连接方进行通讯，造成信息泄露。</p>\n</blockquote>\n</li>\n</ul>\n<p><br><br><br></p>\n<hr>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"三、IP-Address\"><a href=\"#三、IP-Address\" class=\"headerlink\" title=\"三、IP Address\"></a>三、IP Address</h2><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/IP%E5%9C%B0%E5%9D%80.png\" alt=\"IP Address\"></p>\n<h3 id=\"3-1-IP地址的分类\"><a href=\"#3-1-IP地址的分类\" class=\"headerlink\" title=\"3.1 IP地址的分类\"></a>3.1 IP地址的分类</h3><ul>\n<li>A类地址：首位为0，1.0.0.1~127.255.255.254；主机号24位</li>\n<li>B类地址：首位为10，128.0.0.1~191.255.255.254；主机号16位</li>\n<li>C类地址：首位为110，192.0.0.1~223.255.255.254；主机号8位</li>\n<li>D类地址（多播地址，也叫做组播地址）：首位为1110，224.0.0.1~239.255.255.254</li>\n<li>E类地址：此类地址是保留地址，首位为11110，240.0.0.1~254.255.255.254</li>\n</ul>\n<ul>\n<li><p>广播地址<br>  广播地址(Broadcast Address)是专门<strong>用于同时向网络中所有工作站进行发送的一个地址</strong>。</p>\n<p>  在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>\n<ul>\n<li>计算广播地址<br>  广播地址：网络地址的主机位全部变成1 ，10011111 即159 即：202.112.14.159</li>\n</ul>\n</li>\n<li><p>回环地址<br>  127.0.0.1，通常被称为本地回环地址(Loop back address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在windows操作系统中也有相似的定义，所以通常在不安装网卡前就可以ping通这个本地回环地址。<strong>一般都会用来检查本地网络协议、基本数据接口等是否正常的</strong></p>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"3-2-IP地址的主机ID与网络ID\"><a href=\"#3-2-IP地址的主机ID与网络ID\" class=\"headerlink\" title=\"3.2 IP地址的主机ID与网络ID\"></a>3.2 IP地址的主机ID与网络ID</h3><ul>\n<li><p><strong>IP地址=网络地址+主机地址</strong></p>\n<ul>\n<li><p>计算网络ID：只需要将<strong>IP地址和子网掩码进行与运算</strong>，所得结果即为该主机的网络ID</p>\n<pre><code>  有IP地址192.168.0.1，对应的子网掩码为255.255.255.0；\n\n  将IP地址和子网掩码全部转换成二进制的形式，即IP地址是：11000000.10101000.00000000.00000001 ，子网掩码是：11111111.11111111.11111111.00000000；\n\n  将二进制形式的IP地址和子网掩码进行与运算；\n\n  运算结果为11000000.10101000.00000000.00000000，转换为十进制就是192.168.0.0，所以这个主机的网络ID就是192.168.0.0。</code></pre></li>\n<li><p>计算主机ID：只需要将<strong>子网掩码进行二进制按位取反，再和IP地址进行与运算</strong>，所得结果即为该主机的主机ID</p>\n<pre><code>  有IP地址192.168.0.1，对应的子网掩码为255.255.255.0；\n\n  将子网掩码转换成二进制的形式，即就是：11111111.11111111.11111111.00000000；\n\n  将子网掩码进行二进制按位取反，即就是：00000000.00000000.00000000.11111111;\n\n  将取反后的子网掩码和IP地址的二进制形式进行与运算；\n\n  结果为：00000000.00000000.00000000.00000001,转换为十进制就是0.0.0.1,所以这个主机的网络ID就是192.168.0.0。</code></pre></li>\n<li><p>主机数<br>主机号有5位，那么这个地址中，就只能有25−2=3025−2=30个主机<br>因为其中全0作为网络地址，全1作为广播地址</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"3-3-子网划分\"><a href=\"#3-3-子网划分\" class=\"headerlink\" title=\"3.3 子网划分\"></a>3.3 <a href=\"https://blog.csdn.net/gui951753/article/details/79412524\" target=\"_blank\" rel=\"noopener\">子网划分</a></h3><ul>\n<li>为什么进行子网划分<ul>\n<li><strong>减少网络流量</strong></li>\n<li><strong>优化网络性能</strong>，这是减少网络流量的结果。</li>\n<li><strong>简化管理</strong>，与庞大的网络相比，在一系列相连的小网络中找出并隔离网络问题更容易。</li>\n<li><strong>有助于覆盖大型地理区域</strong>，WAN链路比LAN链路的速度慢得多，且更昂贵;单个大跨度的大型网络在前面说的各个方面都可能出现问题（网络流量太大，广播风暴），而将多个小网络连接起来可提高系统的效率。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>子网掩码<br>  子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。<br><br></p>\n<p>  子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。<strong>将IP地址和子网掩码换算为二进制，子网掩码连续全1的是网络地址，后面的是主机地址</strong>。<br><br></p>\n<p>  子网掩码——屏蔽一个IP地址的网络部分的“全1”比特模式。对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。<br><br></p>\n<ul>\n<li><p>通过子网掩码，就可以判断两个IP在不在一个局域网内部。<br></p>\n</li>\n<li><p>子网掩码可以看出有多少位是网络号，有多少位是主机号<br><br></p>\n</li>\n<li><p>ip段/数字-如192.168.0.1/24是什么意思?</p>\n<pre><code>  后面这个数字标示了我们的网络号的位数，也就是子网掩码中前多少号为1\n\n  129.168.1.1 /24 这个24就是告诉我们网络号是24位\n\n  也就相当于告诉我们了\n\n  子网掩码是：11111111 11111111 11111111 00000000\n\n  即：255.255.255.0\n\n  172.16.10.33/27 中的/27\n\n  也就是说子网掩码是255.255.255.224 即27个全1</code></pre></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>网关<br>  网关(Gateway)又称网间连接器、协议转换器。<strong>默认网关在网络层上以实现网络互连</strong>，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。可以是路由器、三层交换机等设备<br></p>\n<p>  <strong>网关实质上是一个网络通向其他网络的IP地址</strong></p>\n</li>\n</ul>\n<ul>\n<li>三层交换机<br>  组合了集线器、路由器和交换机的功能，具有网络管理的一类设备，可以实现在一个设备中对多个虚拟子网的管理的一类设备</li>\n</ul>\n<p><br><br><br></p>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"四、HTTP和HTTPS\"><a href=\"#四、HTTP和HTTPS\" class=\"headerlink\" title=\"四、HTTP和HTTPS\"></a>四、HTTP和HTTPS</h2><h3 id=\"4-1-HTTP版本\"><a href=\"#4-1-HTTP版本\" class=\"headerlink\" title=\"4.1 HTTP版本\"></a>4.1 HTTP版本</h3><h4 id=\"4-1-1-HTTP-0-9\"><a href=\"#4-1-1-HTTP-0-9\" class=\"headerlink\" title=\"4.1.1 HTTP/0.9\"></a>4.1.1 HTTP/0.9</h4><ul>\n<li>HTTP协议的最初版本，功能简陋，仅支持请求方式GET，并且仅能请求访问HTML格式的资源。</li>\n</ul>\n<h4 id=\"4-1-2-HTTP-1-0\"><a href=\"#4-1-2-HTTP-1-0\" class=\"headerlink\" title=\"4.1.2 HTTP/1.0\"></a>4.1.2 HTTP/1.0</h4><ul>\n<li><p>请求行必须在尾部添加协议版本字段（http/1.0）</p>\n</li>\n<li><p>必须包含头消息</p>\n</li>\n<li><p>在0.9版本上做了进步，增加了请求方式POST和HEAD</p>\n</li>\n<li><p>不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等</p>\n</li>\n<li><p>开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即</p>\n</li>\n<li><p>HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据</p>\n</li>\n<li><p>新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>\n</li>\n<li><p>1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive</p>\n</li>\n<li><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。</p>\n</li>\n<li><p>HTTP/1.0与HTTP/1.1对比</p>\n<ul>\n<li><p>可扩展性</p>\n</li>\n<li><p>HTTP/1.1在消息中增加版本号，用于兼容性判断。</p>\n</li>\n<li><p>新增了请求方式PUT、PATCH、OPTIONS、DELETE等。</p>\n</li>\n<li><p>带宽优化</p>\n<blockquote>\n<p>HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。例如，客户端只需要显示一个文档的部分内容，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。</p>\n</blockquote>\n<blockquote>\n<p>HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。</p>\n</blockquote>\n<blockquote>\n<p>另外一种情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限）， 此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。HTTP/1.1 加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。</p>\n</blockquote>\n<blockquote>\n<p>注意，HTTP/1.0 的客户端不支持100响应码。但可以让客户端在请求消息中加入Expect头域，并将它的值设置为100-continue。节省带宽资源的一个非常有效的做法就是压缩要传送的数据。Content-Encoding是对消息进行端到端（end-to-end）的编码，它可能是资源在服务器上保存的固有格式（如 jpeg 图片格式）；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式。</p>\n</blockquote>\n</li>\n<li><p>长连接和短连接</p>\n<blockquote>\n<p><strong>HTTP1.1默认保持长连接</strong>（HTTP persistent connection，也翻译为<strong>持久连接</strong>），<strong>数据传输完成了保持TCP连接不断开</strong>（不发RST包、不四次握手），<strong>等待在同域名下继续用这个通道传输数据</strong>；(<strong>管道机制</strong>)</p>\n</blockquote>\n<blockquote>\n<p>相反的就是短连接。<strong>在 HTTP/1.0 中，默认使用的是短连接</strong>。也就是说，<strong>浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接</strong>。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-1-3-HTTP-2-0-（2015年5月以RFC-7540正式发表）\"><a href=\"#4-1-3-HTTP-2-0-（2015年5月以RFC-7540正式发表）\" class=\"headerlink\" title=\"4.1.3 HTTP/2.0 （2015年5月以RFC 7540正式发表）\"></a>4.1.3 HTTP/2.0 （2015年5月以RFC 7540正式发表）</h4><p>为了解决1.1版本利用率不高的问题，基于SPDY协议提出了HTTP/2.0版本。</p>\n<ul>\n<li><p>增加双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题（HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级）</p>\n</li>\n<li><p>之前HTTP版本请求和响应中，状态行和请求/响应头都是些信息字段，并没有真正的数据，因此在2.0版本中将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表，他们之间就以索引号来表示信息字段，这样就避免了1.0旧版本的重复繁琐的字段，并以压缩的方式传输，提高利用率</p>\n</li>\n<li><p>另外也增加服务器推送的功能，即不经请求服务端主动向客户端发送数据。</p>\n</li>\n</ul>\n<h4 id=\"4-1-4-HTTP3-0\"><a href=\"#4-1-4-HTTP3-0\" class=\"headerlink\" title=\"4.1.4 HTTP3.0\"></a>4.1.4 HTTP3.0</h4><ul>\n<li>基于QUIC协议传输</li>\n<li>TTP的范例和概念没有改变。它含有头部（header）和正文（body），请求和回复，还有动词（verb）、Cookie和缓存。HTTP/3的<strong>主要改变是将这些报文比特传送到另一端的方式</strong>。<br>为了使HTTP可以通过QUIC传输，协议的某些方面要进行修改，修改的结果便是HTTP/3。这些必要修改是因QUIC与TCP在某些性质上的不同所致，修改包括：     <ul>\n<li>在QUIC中，数据流由传输层本身提供，而在HTTP/2中，流由HTTP层完成。     </li>\n<li>由于数据流互相独立，HTTP/2中使用的头部压缩算法如果不做改动，会造成队头阻塞。  </li>\n<li>QUIC流与HTTP/2略有不同。本书的HTTP/3章节会做详细介绍。</li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"4-2-HTTP请求与响应过程\"><a href=\"#4-2-HTTP请求与响应过程\" class=\"headerlink\" title=\"4.2 HTTP请求与响应过程\"></a>4.2 <a href=\"https://zhuanlan.zhihu.com/p/102237039\" target=\"_blank\" rel=\"noopener\">HTTP请求与响应过程</a></h3><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628170939.png\" alt=\"HTTP请求和响应过程\"></p>\n<ul>\n<li>forward和redirect <ul>\n<li>forward（<strong>转发</strong>）:服务器请求资源，<strong>服务器直接访问目标地址URL</strong>，把那个URL的响应内容读取过来然后发送给浏览器浏览器不知道服务器发送的数据从哪里来的，所以<strong>地址栏中的地址还是原来的地址</strong>。</li>\n<li>redirect（<strong>重定向</strong>）:服务端根据逻辑发送一个状态码，告诉<strong>浏览器去请求那个地址</strong>，所以<strong>地址栏中的地址是目标URL</strong>。</li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"4-3-在浏览器中输入url到显示页面的过程\"><a href=\"#4-3-在浏览器中输入url到显示页面的过程\" class=\"headerlink\" title=\"4.3 在浏览器中输入url到显示页面的过程\"></a>4.3 在浏览器中输入url到显示页面的过程</h3><ol>\n<li><p><strong>输入地址</strong></p>\n<blockquote>\n<p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>\n</blockquote>\n</li>\n<li><p><strong>浏览器查找域名的 IP 地址</strong></p>\n<blockquote>\n<p>2.1 请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先<strong>查看本地硬盘的 hosts</strong> 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>\n</blockquote>\n<blockquote>\n<p>2.2 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 <strong>DNS请求到本地DNS服务器</strong>。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p>\n</blockquote>\n<blockquote>\n<p>2.3 查询你输入的网址的DNS请求到达本地DNS服务器之后，<strong>本地DNS服务器会首先查询它的缓存记录</strong>，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要<strong>向DNS根服务器进行查询</strong>。</p>\n</blockquote>\n<blockquote>\n<p>2.4 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以<strong>到域服务器上去继续查询</strong>，并给出域服务器的地址。<strong>这种过程是迭代的过程</strong>。</p>\n</blockquote>\n<blockquote>\n<p>2.5本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</p>\n</blockquote>\n<blockquote>\n<p>2.6 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>\n</blockquote>\n</li>\n<li><p><strong>浏览器向 web 服务器发送一个 HTTP 请求</strong></p>\n<blockquote>\n<p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口<strong>发起TCP的连接请求</strong>。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p>\n</blockquote>\n</li>\n<li><p><strong>服务器的永久重定向响应</strong></p>\n<blockquote>\n<p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访 <a href=\"http://www.google.com/\" target=\"_blank\" rel=\"noopener\">http://www.google.com/</a> 而非 <a href=\"http://google.com/\" target=\"_blank\" rel=\"noopener\">http://google.com/</a> 。为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像 <a href=\"http://www.yy.com/和http://yy.com/\" target=\"_blank\" rel=\"noopener\">http://www.yy.com/和http://yy.com/</a> ，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现</p>\n</blockquote>\n</li>\n<li><p><strong>浏览器跟踪重定向地址</strong></p>\n<blockquote>\n<p>现在浏览器知道了 <a href=\"http://www.google.com/\" target=\"_blank\" rel=\"noopener\">http://www.google.com/</a> 才是要访问的正确地址，所以它会发送另一个http请求。</p>\n</blockquote>\n</li>\n<li><p><strong>服务器处理请求</strong></p>\n<blockquote>\n<p>经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？</p>\n</blockquote>\n<blockquote>\n<p>后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。</p>\n</blockquote>\n<blockquote>\n<p>一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。</p>\n</blockquote>\n<blockquote>\n<p>此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>\n</blockquote>\n</li>\n<li><p><strong>服务器返回一个 HTTP 响应</strong>　</p>\n<blockquote>\n<p>经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。</p>\n</blockquote>\n<blockquote>\n<p>HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：<strong>状态行、响应头(Response Header)、响应正文</strong></p>\n</blockquote>\n</li>\n<li><p><strong>浏览器显示 HTML</strong></p>\n<blockquote>\n<p>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了</p>\n</blockquote>\n</li>\n</ol>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"4-4-HTTP传输过程\"><a href=\"#4-4-HTTP传输过程\" class=\"headerlink\" title=\"4.4 HTTP传输过程\"></a>4.4 HTTP传输过程</h3><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200629082216.png\" alt=\"HTTP传输过程\"></p>\n<h3 id=\"4-5-报文格式\"><a href=\"#4-5-报文格式\" class=\"headerlink\" title=\"4.5 报文格式\"></a>4.5 <a href=\"https://blog.csdn.net/aomize/article/details/78609301\" target=\"_blank\" rel=\"noopener\">报文格式</a></h3><p><a href=\"https://blog.csdn.net/lyn_00/article/details/84953763\" target=\"_blank\" rel=\"noopener\">报文格式</a> </p>\n<table>\n<thead>\n<tr>\n<th>信息</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>起始行</td>\n<td>对报文进行描述</td>\n</tr>\n<tr>\n<td>头部</td>\n<td>向报文中添加了一些附加信息，是一个名/只的列表，头部和协议配合工作，共同决定了客户端和服务器能做什么事情</td>\n</tr>\n<tr>\n<td>主体</td>\n<td>包含数据的主体部分</td>\n</tr>\n</tbody></table>\n<h4 id=\"4-5-1-响应报文格式\"><a href=\"#4-5-1-响应报文格式\" class=\"headerlink\" title=\"4.5.1 响应报文格式\"></a>4.5.1 响应报文格式</h4><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628205247.png\" alt=\"请求报文格式\"></p>\n<ul>\n<li>HTTP请求起始行</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>请求URL所指的文档</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>从客户端向服务器端发送一些信息</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>只请求文档的信息，而不包含文档的内容</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>从服务器向客户端发送文档</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>把到达的请求回送</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>保留</td>\n</tr>\n<tr>\n<td>OPTION</td>\n<td>询问关于可用的选项</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Get和Post的区别 <ul>\n<li>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同</li>\n<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>\n<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>\n<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>\n<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>\n<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>\n<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>\n<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>\n<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>\n<li>GET参数通过URL传递，POST放在Request body中。</li>\n<li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</li>\n<li>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>HTTP请求头部</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>信息</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept</td>\n<td>指浏览器或其他客户可以接爱的MIME文件格式。可以根据它判断并返回适当的文件格式</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>指出浏览器可以接受的语言种类，如en或en-us，指英语</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>设置关于请求被代理服务器存储的相关选项。一般用不到</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>用来告诉服务器是否可以维持固定的HTTP连接。HTTP/1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>用来表名request的内容类型。可以用HttpServletRequest的getContentType()方法取得</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能</td>\n</tr>\n</tbody></table>\n<h4 id=\"4-5-2-响应报文格式\"><a href=\"#4-5-2-响应报文格式\" class=\"headerlink\" title=\"4.5.2 响应报文格式\"></a>4.5.2 响应报文格式</h4><p><img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/20200628205343.png\" alt=\"响应报文格式\"></p>\n<ul>\n<li>HTTP响应起始行</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server</td>\n<td>给出服务器相关信息</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>服务器将接受请求的字节范围</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>指明媒体类型</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>指明编码方案</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>请求客户将请求发送到另一站点</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>服务器请求客户保存Cookie</td>\n</tr>\n<tr>\n<td>Upgrade</td>\n<td>指明优先使用的通信协议</td>\n</tr>\n<tr>\n<td>Public</td>\n<td>给出可以支持的文档清单</td>\n</tr>\n<tr>\n<td>Retry-afer</td>\n<td>指明的日期之后，服务器才能使用</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>HTTP常见状态码</p>\n<ul>\n<li><p>1开头状态码<br>  <strong>表示请求已被接收，继续处理</strong></p>\n</li>\n<li><p>2开头状态码<br>  <strong>表示成功处理请求的状态代码</strong></p>\n<ul>\n<li>200:通常表示服务器成功处理的请求</li>\n</ul>\n</li>\n<li><p>3开头状态码<br>  <strong>表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向</strong></p>\n<ul>\n<li>301:代表永久性转移</li>\n<li>302:代表暂时性转移</li>\n</ul>\n</li>\n<li><p>4开头状态代码 <strong>通常表示请求可能出现错误，妨碍了服务器的处理</strong></p>\n<ul>\n<li>400：服务器不理解请求的语法</li>\n<li>403：服务器拒绝请求</li>\n<li>404：服务器找不到请求的网页</li>\n</ul>\n</li>\n<li><p>5开头状态码 <strong>通常表示服务器在处理中这些请求时发生内错误。这些错误可能是服务器本身错误或是请求出错</strong></p>\n<ul>\n<li><p>500(服务器内部错误):服务器遇到错误，无法完成请求</p>\n</li>\n<li><p>501(无法实施):服务器不具备完成请求的功能。例如服务器无法识别方法。</p>\n</li>\n<li><p>502(错误网关)：服务器作为网关或代理，从上游服务器收到无效响应。</p>\n</li>\n<li><p>503(服务不可用):服务器目前无法使用(由于超载或者停机维护)，通常这只是暂时转态。</p>\n</li>\n<li><p>504(网关超时):服务器作为网关或者代理，但是没有及时从上游服务器收到请求。</p>\n</li>\n<li><p>505(HHTP版本不受支持):服务器不支持请求中所使用的HTTP协议版本</p>\n<blockquote>\n<p>重点：<strong><em>200,304,403,500</em></strong></p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"4-6-HTTP与HTTPS的区别\"><a href=\"#4-6-HTTP与HTTPS的区别\" class=\"headerlink\" title=\"4.6 HTTP与HTTPS的区别\"></a>4.6 HTTP与HTTPS的区别</h3><ul>\n<li>HTTPS协议需要ca申请证书，一般免费证书较少，所以需要一定费用</li>\n<li>HTTP是超文本协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议<ul>\n<li>在HTTP通信中加入了SSL层，通信的数据被加密了，防止被窃取，具体的通信流程如下：<br>  <img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/HTTPS%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93.png\" alt=\"\"></li>\n</ul>\n</li>\n<li>HTTP和HTTPS使用的是两种完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li>\n<li>HTTP的连接很简单，是无状态的；HTTPS是有SSl+HTTP协议构成的可加密除数，身份认证的网络协议，比HTTP更安全</li>\n</ul>\n<h3 id=\"4-7-HTTPS实现原理\"><a href=\"#4-7-HTTPS实现原理\" class=\"headerlink\" title=\"4.7 HTTPS实现原理\"></a>4.7 <a href=\"https://blog.csdn.net/u011547347/article/details/83186514\" target=\"_blank\" rel=\"noopener\">HTTPS实现原理</a></h3><h3 id=\"4-8-HTTP代理服务器\"><a href=\"#4-8-HTTP代理服务器\" class=\"headerlink\" title=\"4.8 HTTP代理服务器\"></a>4.8 HTTP代理服务器</h3><p>工作在<strong>应用层</strong>，比价耗费资源</p>\n<ul>\n<li><strong>提高访问速度</strong>：通常代理服务器都设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的 信息时，则直接由缓冲区中 取出信息，传给用户，以提高<br>访问速度。</li>\n<li><strong>控制对内部资源的访问</strong>：如某大学FTP（前提是该代理地址在该资源的允许访问范围之 内），使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</li>\n<li><strong>过滤内容</strong>：例如限制对特定计算机的访问，将一种语言的数据翻译成另一种语言，或是防御代理服务器两边的攻击性访问。</li>\n<li><strong>隐藏真实IP</strong>：上网者也可以通过代理服务器隐藏自己的IP，免受攻击。但是只一个代 理很难保证安全，更安全的方法是利用特定的工具创建代理链</li>\n<li><strong>突破自身IP访问限制</strong>：访问国外站点。中国教育网和169网等网络用户可以通过代理访 问国外网站。</li>\n<li><strong>突破内容过滤机制限制，访问被过滤网站</strong>。</li>\n</ul>\n<p><br><br><br></p>\n<hr>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"1-常用网络测试命令及应用\"><a href=\"#1-常用网络测试命令及应用\" class=\"headerlink\" title=\"1. 常用网络测试命令及应用\"></a>1. 常用网络测试命令及应用</h3><h4 id=\"ping命令\"><a href=\"#ping命令\" class=\"headerlink\" title=\"ping命令\"></a>ping命令</h4><pre><code class=\"ini\">Ping [-t] [-a] [-n count] [-l length] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [-j HostList]| [-k HostList] [-w timeout] destination –list\n\nv-t，不间断地ping指定的主机，直到按“Ctrl+C” 组合键中断为止。\nv-a，指定对目的地IP地址进行反向名称解析。如 果解析成功，将显示相应的主机名。\nv-n count，发送count指定的ECHO数据包数，默认值为4。\n-l length，自定义发送数据包的大小，也就是发送由length指定大小的ECHO数据包，默认为32字节，最 大值是65527字节。\nv-f，指定发送的回响请求消息带有“不要拆分”标志（所在的IP标题设为1）\nv-i TTL，指定发送回响请求消息的IP标题中的TTL字段值。\nv-v TOS，指定发送回响请求消息的IP标题中的“服务 类型 (TOS)”字段值，默认值是0。TOS被指定为0到 255的十进制数。\nv-r count，指定IP标题中的“记录路由”选项用于记录由回响请求消息和相应的回响应答消息使用的路径</code></pre>\n<ul>\n<li>功能<ul>\n<li>ping 127.0.0.1：检查TCP/IP是否被正确地安装。 </li>\n<li>ping本机IP：ping本地计算机的IP地址，本地计算 机对该ping命令作出应答。如果没有应答，则表示本地 配置或安装存在问题。出现此问题时，局域网用户可断开 网络电缆，然后重新发送该命令。如果网线断开后本命令 正确，则表示另一台计算机可能配置额相同的IP地址。</li>\n<li>ping局域网内其他主机IP：如果收到回送应答，表 明本地网络中的网卡和传输介质运行正确。但如果没有收 到回送应答，那么表示子网掩码不正确或网卡配置错误，或电缆线路有问题。</li>\n<li>ping网关IP：该命令如果应答正确，表示局域网中 的网关路由器正在运行以及能否与本地网络上的本地主机 通讯。</li>\n<li>ping远程主机IP：如果收到4个应答，表示成功地 使用了缺省网关。对于拨号上网用户则表示能够成功地访 问Internet。</li>\n<li>ping域名：ping域名，如 ping <a href=\"http://www.sina.com.cn\" target=\"_blank\" rel=\"noopener\">www.sina.com.cn</a> ，通常是通过DNS服务器进行解析。 如果这里出现故障，则表示DNS服务器的IP地址配置不 正确或DNS服务器有故障。另外，利用该命令可以实现域名对IP地址的转换功能。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><pre><code class=\"ini\">    nslookup www.*.com</code></pre>\n<ul>\n<li>功能<ul>\n<li>nslookup是一个监测网络中DNS服务器是否能正确实现域名解析的命令行 工具。它在 UNIX/Windows NT/2000/XP中均可使用。nslookup必须要 安装了TCP/IP的网络环境中才能使用。</li>\n<li>如果需要对DNS的故障进行排错就必须熟练使用工具nslookup。这个命令 可以指定查询的类型，可以查到DNS记录的生存时间，还可以指定使用哪个DNS服务器进行解释。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ipconfig命令\"><a href=\"#ipconfig命令\" class=\"headerlink\" title=\"ipconfig命令\"></a>ipconfig命令</h4><pre><code class=\"ini\">    ipconfig [/all /renew [adapter] /release [adapter]] [/flushdns] [/displaydns] [/registerdns] [/showclassid Adapter] [/setclassid Adapter [ClassID]]</code></pre>\n<ul>\n<li><p>功能</p>\n<ul>\n<li>ipconfig用于显示当前的TCP/IP网络配置的设置值、刷 新动态主机配置协议（DHCP）和域名系统（DNS）设置。 使用不带参数的ipconfig可以显示所有适配器的IP地址、子网掩码和默认网关。</li>\n<li>ipconfig一般用来检验人工配置的TCP/IP设置是否正确。 如果计算机和所在的局域网使用了动态主机配置协议 （DHCP），这个程序所显示的信息可以让用户了解自己 的计算机是否成功的租用到一个IP地址，如果租用到则可 以了解它目前分配到的具体地址。了解计算机当前的IP地 址、子网掩码和缺省网关实际上是进行测试和故障分析的必要条件。</li>\n</ul>\n</li>\n<li><p>范例</p>\n<ul>\n<li>要显示所有适配器的完整TCP/IP配置，键入 <code>ipconfig/all。</code></li>\n<li>仅更新“本地连接”适配器的由DHCP分配IP地址 的配置，键入 <code>ipconfig /renew &quot;Local Area Connection&quot;</code></li>\n<li>要在排除DNS的名称解析故障期间清理DNS解析器 缓存，键入<code>ipconfig /flushdns</code></li>\n<li>要显示名称以Local开头的所有适配器的DHCP类别 ID，键入<code>ipconfig /showclassid Local</code></li>\n<li>要将“本地连接”适配器的DHCP类别ID设置为 TEST，键入<code>ipconfig /setclassid &quot;Local Area Connection&quot; TEST</code></li>\n</ul>\n</li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"2-网络流量监视命令\"><a href=\"#2-网络流量监视命令\" class=\"headerlink\" title=\"2. 网络流量监视命令\"></a>2. 网络流量监视命令</h3><table>\n<thead>\n<tr>\n<th>命令名称</th>\n<th>适用的操作系统</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ping</td>\n<td>UNIX/Windows</td>\n<td>用于测量往返数据包丢失率</td>\n</tr>\n<tr>\n<td>bing</td>\n<td>UNIX</td>\n<td>测量线路的点到点带宽</td>\n</tr>\n<tr>\n<td>etherfind</td>\n<td>UNIX</td>\n<td>检查以太网数据包</td>\n</tr>\n<tr>\n<td>snoop</td>\n<td>UNIX</td>\n<td>捕获并检查网络数据包</td>\n</tr>\n<tr>\n<td>tcpdump</td>\n<td>UNIX</td>\n<td>网络的dumps流量</td>\n</tr>\n<tr>\n<td>getethers</td>\n<td>UNIX</td>\n<td>获取一个以太网局域网网段中所有主机的地址</td>\n</tr>\n<tr>\n<td>iptrace</td>\n<td>UNIX</td>\n<td>测量网关的性能</td>\n</tr>\n<tr>\n<td>netstat</td>\n<td>UNIX/Windows</td>\n<td>显示各种网络相关数据结构的内容</td>\n</tr>\n<tr>\n<td>arp</td>\n<td>UNIX/Windows</td>\n<td>显示并修改Internet到Ethernet地址转换表</td>\n</tr>\n<tr>\n<td>tracert</td>\n<td>UNIX/Windows</td>\n<td>追踪有路由延迟的目标机的路由</td>\n</tr>\n<tr>\n<td>route</td>\n<td>UNIX/Windows</td>\n<td>显示、人工添加和修改路由表项目</td>\n</tr>\n<tr>\n<td>pathping</td>\n<td>UNIX/Windows</td>\n<td>显示有关在源和目标主机之间的中间跃点处的网络 滞后和网络丢失的信息</td>\n</tr>\n</tbody></table>\n<ul>\n<li>其中一个是<strong>ping</strong>命令，重复执行大量的ping命令（ICMP回显 请求消息）可测算出接收的成功次数，就可以计算出数据包丢失的百分率。包丢失是一种吞吐量的测算。</li>\n<li>另一个常用的命令是点到点带宽<strong>bing</strong>命令，这个命令是以ping 为基础的，通过线路两端发送数据包的大小不同而产生的往返时间差进行计算，可以得出粗略的吞吐量数据。</li>\n<li>其他5个命令可以检查在网络中经过的数据包，分别提供不同的 输出。命令<strong>etherfind</strong>、<strong>snoop</strong>和<strong>tcpdump</strong>把网卡置于混杂模式中（在这种模式中，收集网络中未经处理的数据无需经过任 何过滤）并记录数据。命令<strong>getethers</strong>可以得到所有局域网网段 的主机名和以太网地址对。工具<strong>iptrace</strong>在UNIX内核中使用 NETMON程序，产生3类输出：IP流量、主机流量矩阵输出和预先定义数据包号的简短取样。</li>\n<li><strong>netstat</strong>命令可以帮助网络管理员了解网络的整体使用情 况。它可以显示当前正在活动的网络连接的详细信息，例 如，显示网络连接、路由表和网络接口信息，可以统计目前总共有哪些网络连接正在进行。命令格式语法： <code>netstat [-a] [-e] [-n] [-o] [-p Protocol] [-r] [-s] [Interval]</code>,</li>\n<li>使用<strong>arp</strong>命令，能够查看本地计算机或另一台计 算机的ARP高速缓存中的当前内容。此外，使用 arp命令，也可以用人工方式输入静态的网卡物 理和IP地址对，使用这种方式为缺省网关和本地 服务器等常用主机进行这项操作，有助于减少网络上的信息量。ARP命令格式：<code>arp [-a [InetAddr] [-N IfaceAddr]] [-g [InetAddr] [-N IfaceAddr]] [-d InetAddr [IfaceAddr]] [-s InetAddr EtherAddr [IfaceAddr]]</code></li>\n<li><strong>tracert</strong>一般用来检测故障的位置，虽然还是不能确定 具体故障原因，但已经能显示问题所在的地方。另外， traceroute命令的功能与tracert相同，二者的差别仅 仅在于tracert命令是用在Windows平台上，而traceroute命令是用在Unix平台和路由器上。</li>\n<li><strong>tracert</strong>命令用来显示数据包到达目标主机所经过的路径，并 显示到达每个节点的时间。命令格式如下：<code>Tracert IP地址或主机名 [-d] [-h maximum_hops] [-j host_list] [-w timeout]</code></li>\n<li><strong>route</strong>命令用来显示、人工添加和修改路由表项目的。 route命令格式：<code>route [-f] [-p] [[print] [add] [change] [delete] [Destination] [mask subnetmask] [Gateway] [metric Metric]] [if Interface]</code></li>\n</ul>\n<p><br><br></p>\n<hr>\n<p><br><br></p>\n<h3 id=\"3-专有名词\"><a href=\"#3-专有名词\" class=\"headerlink\" title=\"3. 专有名词\"></a>3. 专有名词</h3><ul>\n<li><p>CDN</p>\n<ul>\n<li>CDN的全称是<code>Content Delivery Network</code>，即<code>内容分发网络</code>，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户<code>就近</code>获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有<code>内容存储</code>和<code>分发技术</code>。</li>\n</ul>\n</li>\n<li><p>DNS</p>\n<ul>\n<li><p>你有没有想过为什么你可以通过键入 <code>www.google.com</code> 就能够获取你想要的网站？我们上面说到，计算机网络中的每个端系统都有一个 IP 地址存在，而把 IP 地址转换为便于人类记忆的协议就是 <code>DNS 协议</code>。</p><br><p>DNS 的全称是<code>域名系统（Domain Name System，缩写：DNS）</code>，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>\n</li>\n</ul>\n</li>\n<li><p>URL   </p>\n<ul>\n<li><p>我们上面提到，你可以通过输入 <code>www.google.com</code> 地址来访问谷歌的官网，那么这个地址有什么规定吗？我怎么输都可以？AAA.BBB.CCC 是不是也行？当然不是的，你输入的地址格式必须要满足 <code>URI</code> 的规范。</p><br>  <p><code>URI</code>的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>   <br><p><code>URL</code>的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的<code>网址</code>，它实际上是 URI 的一个子集。</p><p>URI 不仅包括 URL，还包括 URN（统一资源名称），它们之间的关系如下</p>\n\n<img src=\"https://cdn.jsdelivr.net/gh/cloud-r/GitakRepository/static_files/blog/img/URI组成.png\" data-caption=\"URI组成\" />\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<p><br><br><br></p>\n<ul>\n<li>推荐文章<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/102237039\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/102237039</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_44367006/article/details/99768731\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_44367006/article/details/99768731</a></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>参考<br>[1]<a href=\"https://blog.csdn.net/liuyanfeier/article/details/52787037\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liuyanfeier/article/details/52787037</a><br>[2]<a href=\"https://blog.csdn.net/qq_32374237/article/details/86242159\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_32374237/article/details/86242159</a><br>[3]<a href=\"https://blog.csdn.net/gui951753/article/details/79412524\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gui951753/article/details/79412524</a><br>[4]<a href=\"https://blog.csdn.net/lyn_00/article/details/84953763\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lyn_00/article/details/84953763</a><br>[5]<a href=\"https://blog.csdn.net/moge19/article/details/90050030\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/moge19/article/details/90050030</a><br>[6]<a href=\"https://zhuanlan.zhihu.com/p/102237039\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/102237039</a><br>[7]<a href=\"https://blog.csdn.net/weixin_44367006/article/details/99768731\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_44367006/article/details/99768731</a><br>[8]<a href=\"https://blog.csdn.net/qq_33663020/article/details/79386252\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_33663020/article/details/79386252</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cks5dy1en000a0w7t4e17bcw1","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1eq000i0w7te3mchd44"},{"post_id":"cks5dy1eh00050w7t3sy37ehu","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1es000n0w7t76c4hmjt"},{"post_id":"cks5dy1eo000b0w7t4epwh35g","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1et000q0w7t0prn4i2x"},{"post_id":"cks5dy1ep000f0w7t0pmg26ee","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1et000u0w7tdje0abn5"},{"post_id":"cks5dy1ek00060w7tcvz72s45","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1eu000x0w7t8c5yfutc"},{"post_id":"cks5dy1eq000h0w7tegiz1ew5","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1ev00110w7t859qe7m2"},{"post_id":"cks5dy1er000m0w7t7xskgj49","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1ew00140w7t9jup7s0c"},{"post_id":"cks5dy1em00090w7tbzb0damr","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1ex00170w7t9kzrhtq7"},{"post_id":"cks5dy1es000p0w7t2a7lardg","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1ex001a0w7t3xubgfyn"},{"post_id":"cks5dy1et000t0w7tcslf5jv6","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1ey001d0w7t1gez19wc"},{"post_id":"cks5dy1eu000w0w7t0kx7a1xq","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1ez001g0w7t1adc9jhp"},{"post_id":"cks5dy1eu000z0w7thz0h6qmo","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1f2001j0w7t7uxmhj18"},{"post_id":"cks5dy1ew00130w7t570k15k7","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1f3001l0w7t518wfboy"},{"post_id":"cks5dy1ew00160w7t4tztdkeg","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1f4001p0w7t35rl3sm9"},{"post_id":"cks5dy1ex00190w7t3f5c05bl","category_id":"cks5dy1el00070w7t6s8f4ez0","_id":"cks5dy1f4001r0w7t1wxh1ktc"},{"post_id":"cks5dy1ey001c0w7t8n4b2psk","category_id":"cks5dy1ez001h0w7tagno0kuj","_id":"cks5dy1f5001u0w7t16m0fex8"},{"post_id":"cks5dy1ey001f0w7tb4zz4n0o","category_id":"cks5dy1ez001h0w7tagno0kuj","_id":"cks5dy1f7001y0w7t754yg8ko"},{"post_id":"cks5dy1f2001i0w7t4tt92rva","category_id":"cks5dy1ez001h0w7tagno0kuj","_id":"cks5dy1f800220w7tb94s978t"},{"post_id":"cks5dy1f2001k0w7tbvu2hads","category_id":"cks5dy1f6001x0w7th3s41aoo","_id":"cks5dy1fb00270w7t4ann1gyh"},{"post_id":"cks5dy1f6001v0w7tc76b0jqa","category_id":"cks5dy1f800230w7tf2fq1qmv","_id":"cks5dy1fc002d0w7t4jp54wrl"},{"post_id":"cks5dy1f6001w0w7t0jk1828w","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1ff002k0w7tdqd5dm1z"},{"post_id":"cks5dy1f7001z0w7t9afc9otq","category_id":"cks5dy1f800230w7tf2fq1qmv","_id":"cks5dy1fg002p0w7t06jd00o4"},{"post_id":"cks5dy1f700210w7t5y52f03a","category_id":"cks5dy1fe002j0w7t8x4jahiu","_id":"cks5dy1fg002t0w7te6fd3w1k"},{"post_id":"cks5dy1f800240w7t4x9tdexq","category_id":"cks5dy1fg002q0w7tgv7sdv1v","_id":"cks5dy1fh002y0w7tbk7614v5"},{"post_id":"cks5dy1fb002a0w7t9hygghpn","category_id":"cks5dy1fg002q0w7tgv7sdv1v","_id":"cks5dy1fi00310w7td31d9l23"},{"post_id":"cks5dy1fb002b0w7t5krj6c9a","category_id":"cks5dy1fg002q0w7tgv7sdv1v","_id":"cks5dy1fj00340w7t5uw1bi0w"},{"post_id":"cks5dy1fc002f0w7t5doneoxu","category_id":"cks5dy1fe002j0w7t8x4jahiu","_id":"cks5dy1fj00360w7tcrxx6fra"},{"post_id":"cks5dy1fd002h0w7t6j6pefup","category_id":"cks5dy1fg002q0w7tgv7sdv1v","_id":"cks5dy1fj00380w7t84t3hf0v"},{"post_id":"cks5dy1ff002l0w7tdig8gz5y","category_id":"cks5dy1fg002q0w7tgv7sdv1v","_id":"cks5dy1fk00390w7tfw7qhwyr"},{"post_id":"cks5dy1ff002n0w7t9gkp1era","category_id":"cks5dy1fg002q0w7tgv7sdv1v","_id":"cks5dy1fk003a0w7tho5v4kog"},{"post_id":"cks5dy1fz003b0w7t0nd17tjj","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1g1003g0w7t99eufbdt"},{"post_id":"cks5dy1g0003c0w7tewk6fvrp","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1g2003i0w7t5x908g66"},{"post_id":"cks5dy1g0003e0w7t2ctb3cqp","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1g3003m0w7th66acv0p"},{"post_id":"cks5dy1g1003f0w7tcbym2oqt","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1g4003p0w7teiw51kba"},{"post_id":"cks5dy1g2003h0w7tfi132ozf","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1g5003t0w7t8xmib01u"},{"post_id":"cks5dy1g3003l0w7t6m6080yq","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1g6003v0w7t05i87luz"},{"post_id":"cks5dy1g3003o0w7t7j1x0p5s","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1g7003z0w7t0f12e1dv"},{"post_id":"cks5dy1g6003u0w7t5f5u3yun","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1g900440w7t60t429zd"},{"post_id":"cks5dy1g7003y0w7tbmtc2t1k","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1ga00470w7tcs0jh6zo"},{"post_id":"cks5dy1g700400w7tdpfrbw0y","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gb004b0w7t1x910pow"},{"post_id":"cks5dy1g800430w7tgf1ac9t3","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gc004e0w7t6kmdh7be"},{"post_id":"cks5dy1g900460w7td20t3ace","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gd004h0w7t000d5d4j"},{"post_id":"cks5dy1gb004a0w7t035odcpg","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1ge004k0w7texy2afkt"},{"post_id":"cks5dy1gc004d0w7tad7gcw4w","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gf004o0w7t9nwl70hi"},{"post_id":"cks5dy1gd004g0w7tdi3150d5","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gg004r0w7t0k6q6z53"},{"post_id":"cks5dy1gd004j0w7tepk61d4r","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gi004v0w7t8bgt0lli"},{"post_id":"cks5dy1gf004n0w7t1keh49wy","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gj004y0w7thteyauzy"},{"post_id":"cks5dy1gf004q0w7t0wjo0r0c","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gl00520w7thncf1wrv"},{"post_id":"cks5dy1gh004u0w7t1ct77zun","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gm00550w7t9751fxa7"},{"post_id":"cks5dy1gj004x0w7td6ck2txs","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gm00590w7t0gu48gp0"},{"post_id":"cks5dy1gk00510w7tegzm2trr","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gn005c0w7t0fh6bnhw"},{"post_id":"cks5dy1gl00540w7t9ngia1gp","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1go005g0w7t8gef8bii"},{"post_id":"cks5dy1gm00580w7t62cs75ns","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gp005j0w7tayf7fbdv"},{"post_id":"cks5dy1gn005b0w7t4v6vdvt5","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gq005m0w7tdlse1mk2"},{"post_id":"cks5dy1go005f0w7teudmf09k","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gr005q0w7tbd7wcnmz"},{"post_id":"cks5dy1gp005i0w7t98xm5aew","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gs005s0w7t9pnr2u1e"},{"post_id":"cks5dy1gq005l0w7tfios906p","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gs005v0w7t2u85ci70"},{"post_id":"cks5dy1gr005p0w7t5q540r5u","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gt005y0w7t9h9qbmq7"},{"post_id":"cks5dy1gr005r0w7t8mcnd8uq","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gt00610w7t9i8n8xv0"},{"post_id":"cks5dy1gs005u0w7t7amfay6p","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gu00630w7tbeqd1ass"},{"post_id":"cks5dy1gs005x0w7tfozj01iw","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gv00660w7t23ya65xw"},{"post_id":"cks5dy1gt00600w7t8k9w2yw0","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gv00680w7taqyi08e2"},{"post_id":"cks5dy1gu00620w7teaeu9c6s","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gv006b0w7t1les4iee"},{"post_id":"cks5dy1gu00650w7t5qjnc3c1","category_id":"cks5dy1fb00280w7tgklvc4vu","_id":"cks5dy1gw006d0w7t2w61ekit"}],"PostTag":[{"post_id":"cks5dy1en000a0w7t4e17bcw1","tag_id":"cks5dy1em00080w7tep755xvk","_id":"cks5dy1ep000e0w7teepr228j"},{"post_id":"cks5dy1eh00050w7t3sy37ehu","tag_id":"cks5dy1em00080w7tep755xvk","_id":"cks5dy1eq000g0w7thonw5wgu"},{"post_id":"cks5dy1eo000b0w7t4epwh35g","tag_id":"cks5dy1em00080w7tep755xvk","_id":"cks5dy1er000l0w7tdrxpaxqj"},{"post_id":"cks5dy1ep000f0w7t0pmg26ee","tag_id":"cks5dy1em00080w7tep755xvk","_id":"cks5dy1es000o0w7t6v9r8q5x"},{"post_id":"cks5dy1ek00060w7tcvz72s45","tag_id":"cks5dy1em00080w7tep755xvk","_id":"cks5dy1et000s0w7tgnbg9o7f"},{"post_id":"cks5dy1eq000h0w7tegiz1ew5","tag_id":"cks5dy1em00080w7tep755xvk","_id":"cks5dy1eu000v0w7tbr2w6urm"},{"post_id":"cks5dy1em00090w7tbzb0damr","tag_id":"cks5dy1em00080w7tep755xvk","_id":"cks5dy1eu000y0w7tazpv0258"},{"post_id":"cks5dy1es000p0w7t2a7lardg","tag_id":"cks5dy1em00080w7tep755xvk","_id":"cks5dy1ew00120w7td5xng3hf"},{"post_id":"cks5dy1er000m0w7t7xskgj49","tag_id":"cks5dy1et000r0w7t9n627w5e","_id":"cks5dy1ew00150w7t0prvdycl"},{"post_id":"cks5dy1eu000z0w7thz0h6qmo","tag_id":"cks5dy1et000r0w7t9n627w5e","_id":"cks5dy1ex00180w7t7u4icij4"},{"post_id":"cks5dy1et000t0w7tcslf5jv6","tag_id":"cks5dy1et000r0w7t9n627w5e","_id":"cks5dy1ey001b0w7t9yy6510v"},{"post_id":"cks5dy1ex00190w7t3f5c05bl","tag_id":"cks5dy1ey001e0w7t5o6y1i85","_id":"cks5dy1f3001m0w7thfwr5w25"},{"post_id":"cks5dy1f6001w0w7t0jk1828w","tag_id":"cks5dy1f700200w7t2eoe8uao","_id":"cks5dy1fb00290w7tdxf6bu95"},{"post_id":"cks5dy1f700210w7t5y52f03a","tag_id":"cks5dy1fa00260w7td4aqbd6x","_id":"cks5dy1fd002g0w7t8i966ly1"},{"post_id":"cks5dy1f800240w7t4x9tdexq","tag_id":"cks5dy1fc002c0w7t8c57afto","_id":"cks5dy1ff002m0w7t53c9dcrj"},{"post_id":"cks5dy1fb002a0w7t9hygghpn","tag_id":"cks5dy1fe002i0w7tbna21dc8","_id":"cks5dy1fg002r0w7t1agqhtul"},{"post_id":"cks5dy1fb002b0w7t5krj6c9a","tag_id":"cks5dy1fg002o0w7t2j2xchk0","_id":"cks5dy1fh002v0w7t0d2m7smh"},{"post_id":"cks5dy1fc002f0w7t5doneoxu","tag_id":"cks5dy1fg002s0w7t22kb6h9p","_id":"cks5dy1fh002z0w7t1mze8f5k"},{"post_id":"cks5dy1fd002h0w7t6j6pefup","tag_id":"cks5dy1fh002w0w7tf5m948zr","_id":"cks5dy1fi00320w7t94k524jr"},{"post_id":"cks5dy1g1003f0w7tcbym2oqt","tag_id":"cks5dy1g0003d0w7tby87f5j1","_id":"cks5dy1g2003k0w7t5feqaolw"},{"post_id":"cks5dy1fz003b0w7t0nd17tjj","tag_id":"cks5dy1g0003d0w7tby87f5j1","_id":"cks5dy1g3003n0w7t591h4wh9"},{"post_id":"cks5dy1g0003c0w7tewk6fvrp","tag_id":"cks5dy1g0003d0w7tby87f5j1","_id":"cks5dy1g4003r0w7t63otd1mt"},{"post_id":"cks5dy1g0003e0w7t2ctb3cqp","tag_id":"cks5dy1g0003d0w7tby87f5j1","_id":"cks5dy1g7003x0w7tbd9fbpyv"},{"post_id":"cks5dy1g7003y0w7tbmtc2t1k","tag_id":"cks5dy1g6003w0w7t2nbre3u7","_id":"cks5dy1g800420w7tdqvq94qy"},{"post_id":"cks5dy1g2003h0w7tfi132ozf","tag_id":"cks5dy1g6003w0w7t2nbre3u7","_id":"cks5dy1g900450w7tde605vzu"},{"post_id":"cks5dy1g700400w7tdpfrbw0y","tag_id":"cks5dy1g6003w0w7t2nbre3u7","_id":"cks5dy1gb00490w7t2lbh7axf"},{"post_id":"cks5dy1g3003l0w7t6m6080yq","tag_id":"cks5dy1g6003w0w7t2nbre3u7","_id":"cks5dy1gb004c0w7tbajkbpsq"},{"post_id":"cks5dy1g3003o0w7t7j1x0p5s","tag_id":"cks5dy1g6003w0w7t2nbre3u7","_id":"cks5dy1gd004i0w7t06etd86h"},{"post_id":"cks5dy1gd004g0w7tdi3150d5","tag_id":"cks5dy1gc004f0w7t0pe45kz9","_id":"cks5dy1ge004m0w7tgvhuha79"},{"post_id":"cks5dy1g6003u0w7t5f5u3yun","tag_id":"cks5dy1gc004f0w7t0pe45kz9","_id":"cks5dy1gf004p0w7t628o5dfr"},{"post_id":"cks5dy1gd004j0w7tepk61d4r","tag_id":"cks5dy1gc004f0w7t0pe45kz9","_id":"cks5dy1gg004t0w7tc7235t0c"},{"post_id":"cks5dy1gf004n0w7t1keh49wy","tag_id":"cks5dy1gc004f0w7t0pe45kz9","_id":"cks5dy1gj004w0w7t6gbid6mx"},{"post_id":"cks5dy1g800430w7tgf1ac9t3","tag_id":"cks5dy1gc004f0w7t0pe45kz9","_id":"cks5dy1gk00500w7tb3wzd8ds"},{"post_id":"cks5dy1gf004q0w7t0wjo0r0c","tag_id":"cks5dy1gc004f0w7t0pe45kz9","_id":"cks5dy1gl00530w7t6hew6d8s"},{"post_id":"cks5dy1gh004u0w7t1ct77zun","tag_id":"cks5dy1gc004f0w7t0pe45kz9","_id":"cks5dy1gm00560w7t4ab2bulv"},{"post_id":"cks5dy1g900460w7td20t3ace","tag_id":"cks5dy1gc004f0w7t0pe45kz9","_id":"cks5dy1gn005a0w7t0c4yfzkn"},{"post_id":"cks5dy1gj004x0w7td6ck2txs","tag_id":"cks5dy1gc004f0w7t0pe45kz9","_id":"cks5dy1gn005d0w7tdgqz8z8l"},{"post_id":"cks5dy1gb004a0w7t035odcpg","tag_id":"cks5dy1gj004z0w7t6nwpe11v","_id":"cks5dy1go005h0w7tec6j6p47"},{"post_id":"cks5dy1gc004d0w7tad7gcw4w","tag_id":"cks5dy1gj004z0w7t6nwpe11v","_id":"cks5dy1gq005k0w7t93ui1lb9"},{"post_id":"cks5dy1gk00510w7tegzm2trr","tag_id":"cks5dy1gn005e0w7t8rgn6680","_id":"cks5dy1gr005o0w7t9jhsffih"},{"post_id":"cks5dy1gr005r0w7t8mcnd8uq","tag_id":"cks5dy1gq005n0w7t2nlpb2k2","_id":"cks5dy1gs005w0w7t5wyo1th6"},{"post_id":"cks5dy1gl00540w7t9ngia1gp","tag_id":"cks5dy1gq005n0w7t2nlpb2k2","_id":"cks5dy1gv00670w7tfzu81z6t"},{"post_id":"cks5dy1gl00540w7t9ngia1gp","tag_id":"cks5dy1gs005t0w7tc22z6vby","_id":"cks5dy1gv00690w7t0miufuph"},{"post_id":"cks5dy1gl00540w7t9ngia1gp","tag_id":"cks5dy1gt005z0w7t5dgacear","_id":"cks5dy1gw006c0w7t2d1mc577"},{"post_id":"cks5dy1gm00580w7t62cs75ns","tag_id":"cks5dy1gq005n0w7t2nlpb2k2","_id":"cks5dy1gw006g0w7tbsmmbc3m"},{"post_id":"cks5dy1gm00580w7t62cs75ns","tag_id":"cks5dy1gs005t0w7tc22z6vby","_id":"cks5dy1gw006h0w7t4t497jlq"},{"post_id":"cks5dy1gm00580w7t62cs75ns","tag_id":"cks5dy1gt005z0w7t5dgacear","_id":"cks5dy1gx006j0w7t9fgea7et"},{"post_id":"cks5dy1gn005b0w7t4v6vdvt5","tag_id":"cks5dy1gq005n0w7t2nlpb2k2","_id":"cks5dy1gx006k0w7ta3bxdz8b"},{"post_id":"cks5dy1go005f0w7teudmf09k","tag_id":"cks5dy1gq005n0w7t2nlpb2k2","_id":"cks5dy1gx006m0w7t0akz7nlw"},{"post_id":"cks5dy1gp005i0w7t98xm5aew","tag_id":"cks5dy1gq005n0w7t2nlpb2k2","_id":"cks5dy1gy006p0w7t0y0x57ha"},{"post_id":"cks5dy1gp005i0w7t98xm5aew","tag_id":"cks5dy1gs005t0w7tc22z6vby","_id":"cks5dy1gy006q0w7tg3uf317w"},{"post_id":"cks5dy1gq005l0w7tfios906p","tag_id":"cks5dy1gq005n0w7t2nlpb2k2","_id":"cks5dy1gy006s0w7t2ebh6ss1"},{"post_id":"cks5dy1gr005p0w7t5q540r5u","tag_id":"cks5dy1gy006r0w7t11i8a1pi","_id":"cks5dy1gy006u0w7t1ce1gq4e"},{"post_id":"cks5dy1gs005u0w7t7amfay6p","tag_id":"cks5dy1gy006r0w7t11i8a1pi","_id":"cks5dy1gz006w0w7tf6bablby"},{"post_id":"cks5dy1gs005x0w7tfozj01iw","tag_id":"cks5dy1gz006v0w7thlk400w2","_id":"cks5dy1gz006y0w7t3tt11xkr"},{"post_id":"cks5dy1gt00600w7t8k9w2yw0","tag_id":"cks5dy1gz006v0w7thlk400w2","_id":"cks5dy1gz00700w7tedgqa9oy"},{"post_id":"cks5dy1gu00620w7teaeu9c6s","tag_id":"cks5dy1gz006z0w7t7vf23pfm","_id":"cks5dy1gz00720w7t48yn8i2s"},{"post_id":"cks5dy1gu00650w7t5qjnc3c1","tag_id":"cks5dy1gz00710w7ta531hjzz","_id":"cks5dy1h000730w7t5hvmfft0"}],"Tag":[{"name":"Array","_id":"cks5dy1em00080w7tep755xvk"},{"name":"String","_id":"cks5dy1et000r0w7t9n627w5e"},{"name":"数据结构","_id":"cks5dy1ey001e0w7t5o6y1i85"},{"name":"Linux","_id":"cks5dy1f700200w7t2eoe8uao"},{"name":"环境配置","_id":"cks5dy1fa00260w7td4aqbd6x"},{"name":"windows","_id":"cks5dy1fc002c0w7t8c57afto"},{"name":"SCM","_id":"cks5dy1fe002i0w7tbna21dc8"},{"name":"Cloud","_id":"cks5dy1fg002o0w7t2j2xchk0"},{"name":"linux工具","_id":"cks5dy1fg002s0w7t22kb6h9p"},{"name":"git","_id":"cks5dy1fh002w0w7tf5m948zr"},{"name":"DesignMode","_id":"cks5dy1g0003d0w7tby87f5j1"},{"name":"JVM","_id":"cks5dy1g6003w0w7t2nbre3u7"},{"name":"JavaSE","_id":"cks5dy1gc004f0w7t0pe45kz9"},{"name":"工具类","_id":"cks5dy1gj004z0w7t6nwpe11v"},{"name":"JavaWeb Exception","_id":"cks5dy1gn005e0w7t8rgn6680"},{"name":"JavaWeb","_id":"cks5dy1gq005n0w7t2nlpb2k2"},{"name":"ORM","_id":"cks5dy1gs005t0w7tc22z6vby"},{"name":"JPA","_id":"cks5dy1gt005z0w7t5dgacear"},{"name":"Multi-Thread","_id":"cks5dy1gy006r0w7t11i8a1pi"},{"name":"OS","_id":"cks5dy1gz006v0w7thlk400w2"},{"name":"Mysql","_id":"cks5dy1gz006z0w7t7vf23pfm"},{"name":"NetWork","_id":"cks5dy1gz00710w7ta531hjzz"}]}}