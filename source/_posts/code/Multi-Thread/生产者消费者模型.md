---
title: 生产者消费者模型
categories: Code
tags: Multi-Thread
declare: true
wordCount: true
abbrlink: 161dcf21
date: 2020-11-23 01:03:24
---

生产者消费者模型是线程模型中一个经典问题：生产者和消费者在同一时间内共享同一个容器，生产者向容器添加产品，消费者从容器中取走产品，**当容器满时，生产者阻塞，当容器为空时，消费者阻塞**。

<div align = "center">
    <img src="https://i.loli.net/2020/11/22/DzeAYk3SVMHQ4ZG.png" alt="生产者消费者模型示意图" width="60%"/>
</div>

<!-- more -->

## 一、Code
### 1.1 synchronized实现
#### 1.1.1 容器
```java
public class Container {
    private Queue<Integer> container = new LinkedList<>();
    private int containerSize = 5;  //容器的大小

    /**
    * @Description: 生产者生产内容
    * @Param: [val] 添加的内容
    * @return: void
    * @Author: cloudr
    * @Date: 2020/11/22
    */
    public synchronized void add(int val) throws InterruptedException {
        if (container.size() > containerSize) {
            wait(); //阻塞生产者，不让其继续生产
        }
        container.add(val);
        notify();   //通知消费者继续消费
    }

    /**
    * @Description: 消费者消费内容
    * @Param: []
    * @return: int 返回生产者所生产的
    * @Author: cloudr
    * @Date: 2020/11/22
    */
    public synchronized int get() throws InterruptedException {
        if (container.size() == 0) {
            wait(); //阻塞生消费者，不让其继续消费
        }
        int returnRes = container.poll();
        notify();   //通知生产者继续生产
        return returnRes;
    }
}
```
 
#### 1.1.2 生产者
```java
public class Producer extends Thread{
    private Container container;

    public Producer(Container container) {
        this.container = container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            try {
                container.add(i);   //生产内容添加进容器中
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```
#### 1.1.3 消费者
```java
public class Consumer extends Thread {
    private Container container;

    public Consumer(Container container) {
        this.container = container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            int val = 0;
            try {
                val = container.get();  //从容器中获取产品消费
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(val);
        }
    }
}
```
#### 1.1.4 Demo
```java
public class ProducerAndConsumerDemo {
    public static void main(String[] args) {
        Container container = new Container();
        Producer producer = new Producer(container);
        Consumer consumer = new Consumer(container);
        producer.start();
        consumer.start();
    }
}
```

### 1.2 BlockingQueue实现

使用BlockingQueue时，我们再也不必关心什么时候应该阻塞线程，什么时候应该唤醒线程。

```java
package com.cc.step1.ProducerAndConsumerModel;

import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * @author shangjing
 * @date 2018/11/22 4:05 PM
 * @describe32
 */
public class PCByBlockingQueue {
    private static int count = 0;

    private final BlockingQueue blockingQueue = new LinkedBlockingQueue(10);    //容器

    class Producer implements Runnable {

        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(new Random().nextInt(1000));   //模拟生产者和消费者效率不一致
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    int val = new Random().nextInt(1000);
                    blockingQueue.put(val);  //生产内容进入容器
                    count++;
                    System.out.println(Thread.currentThread().getName() + "-生产者生产" + val + "，容器中数量为:" + count);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    class Consumer implements Runnable {

        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(new Random().nextInt(500));    //模拟生产者和消费者效率不一致
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    int val = (int) blockingQueue.take();   //消费者从容器消费产品
                    count--;
                    System.out.println(Thread.currentThread().getName() + "-消费者消费" + val + "，容器中数量为：" + count);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        PCByBlockingQueue blockingQueueTest = new PCByBlockingQueue();
        new Thread(blockingQueueTest.new Producer()).start();
        new Thread(blockingQueueTest.new Consumer()).start();
        // 模拟多个生产者和消费者
//        new Thread(blockingQueueTest.new Producer()).start();     
//        new Thread(blockingQueueTest.new Consumer()).start();
//        new Thread(blockingQueueTest.new Producer()).start();
//        new Thread(blockingQueueTest.new Consumer()).start();
    }
}
```

### 参考    
[1]https://www.jianshu.com/p/f53fb95b5820    

